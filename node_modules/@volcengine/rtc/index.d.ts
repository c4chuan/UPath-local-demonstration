// Generated by dts-bundle-generator v8.1.2

import { EventArgs, EventEmitter, EventNames, ValidEventTypes } from 'eventemitter3';

declare class EnhancedEventEmitter<EventTypes extends ValidEventTypes = string | symbol> extends EventEmitter<EventTypes> {
	safeEmit<T extends EventNames<EventTypes>>(event: T, ...args: EventArgs<EventTypes, T>): boolean;
	asyncEmit<T extends EventNames<EventTypes>>(event: T, ...args: EventArgs<EventTypes, T>): Promise<void>;
}
declare class VERTC implements IVERTC {
	getSdkVersion: () => string;
	createEngine: (appId: string, config?: EngineConfig | undefined) => IRTCEngine;
	createBLWEngine: (appId: string, config?: EngineConfig | undefined) => IBLWRTCEngine;
	destroyEngine: (engine: IRTCEngine) => void;
	enumerateDevices: () => Promise<MediaDeviceInfo[]>;
	enableDevices: (options?: {
		video: boolean;
		audio: boolean;
	}) => Promise<{
		video: boolean;
		audio: boolean;
		videoExceptionError?: DOMException | undefined;
		audioExceptionError?: DOMException | undefined;
	}>;
	enumerateAudioCaptureDevices: () => Promise<MediaDeviceInfo[]>;
	enumerateVideoCaptureDevices: () => Promise<MediaDeviceInfo[]>;
	enumerateAudioPlaybackDevices: () => Promise<MediaDeviceInfo[]>;
	getParameter: typeof getParameter;
	setParameter: typeof setParameter;
	isSupported: () => Promise<boolean>;
	getSupportedCodecs: () => Promise<string[]>;
	getElectronScreenSources: typeof getElectronScreenSources;
	events: typeof EngineEventsTypes;
	ErrorCode: typeof ErrorCode;
	platform: string;
	commitInfo: string;
	downloadLog: (key?: string | undefined) => void;
	setLogConfig: ({ logLevel, LogfileSize, }: {
		logLevel?: "none" | "error" | "warning" | "info" | "trace" | undefined;
		LogfileSize?: number | undefined;
	}) => void;
}
declare const Config: SetParamInterface;
declare const _default: VERTC;
declare enum AudioMixingError {
	/** 
	 * @brief 混音正常。
	 */
	
	AUDIO_MIXING_ERROR_OK = 0,
	/** 
	 * @brief 预加载失败，找不到混音文件或者文件长度超出 20s。
	 */
	
	AUDIO_MIXING_ERROR_PRELOAD_FAILED = 1,
	/** 
	 * @brief 混音开启失败，找不到混音文件或者混音文件打开失败。
	 */
	
	AUDIO_MIXING_ERROR_START_FAILED = 2,
	/** 
	 * @brief 混音 ID 异常。
	 */
	
	AUDIO_MIXING_ERROR_ID_NOT_FOUND = 3,
	/** 
	 * @brief 设置混音文件的播放位置出错。
	 */
	
	AUDIO_MIXING_ERROR_SET_POSITION_FAILED = 4,
	/** 
	 * @brief 音量参数不合法，音量值区间应为[0, 400]。
	 */
	
	AUDIO_MIXING_ERROR_INVALID_VOLUME = 5,
	/** 
	 * @brief 播放的文件与预加载的文件不一致，请先使用 `unloadAudioMixing` 卸载文件。
	 */
	
	AUDIO_MIXING_ERROR_LOAD_CONFLICT = 6,
	/** 
	 * @brief 混音 ID 类型不匹配，当前操作接口不支持该 ID 代表的音频流类型。
	 */
	
	AUDIO_MIXING_ERROR_ID_TYPE_NOT_MATCH = 7,
	/** 
	 * @brief 设置混音文件的音调不合法。
	 */
	
	AUDIO_MIXING_ERROR_ID_TYPE_INVALID_PITCH = 8,
	/** 
	 * @brief 设置混音文件的音轨不合法。
	 */
	
	AUDIO_MIXING_ERROR_INVALID_AUDIO_TRACK = 9
}
declare enum AudioMixingState {
	/** 
	 * @brief 混音已加载
	 */
	
	AUDIO_MIXING_STATE_PRELOADED = 0,
	/** 
	 * @brief 混音正在播放
	 */
	
	AUDIO_MIXING_STATE_PLAYING = 1,
	/** 
	 * @brief 混音暂停
	 */
	
	AUDIO_MIXING_STATE_PAUSED = 2,
	/** 
	 * @brief 混音停止
	 */
	
	AUDIO_MIXING_STATE_STOPPED = 3,
	/** 
	 * @brief 混音播放失败
	 */
	
	AUDIO_MIXING_STATE_FAILED = 4,
	/** 
	 * @brief 混音播放结束
	 */
	
	AUDIO_MIXING_STATE_FINISHED = 5,
	/** 
	 * @brief 准备 PCM 混音
	 */
	
	AUDIO_MIXING_STATE_PCM_ENABLED = 6,
	/** 
	 * @brief PCM 混音播放结束
	 */
	
	AUDIO_MIXING_STATE_PCM_DISABLED = 7
}
declare enum EngineEventsTypes {
	/** 
	 * @brief 轨道关闭
	 */
	
	onTrackEnded = "onTrackEnded",
	onTrackMute = "onTrackMute",
	onTrackUnmute = "onTrackUnmute",
	/** 
	 * @brief 播放器事件
	 */
	
	onPlayerEvent = "onPlayerEvent",
	/** 
	 * @brief 自动播放失败
	 */
	
	onAutoplayFailed = "onAutoplayFailed",
	/** 
	 * @brief 用户加入房间
	 */
	
	onUserJoined = "onUserJoined",
	/** 
	 * @brief 用户离开房间
	 */
	
	onUserLeave = "onUserLeave",
	/** 
	 * @brief 连接状态改变
	 */
	
	onConnectionStateChanged = "onConnectionStateChanged",
	onUserPublishStream = "onUserPublishStream",
	onUserUnpublishStream = "onUserUnpublishStream",
	onUserPublishScreen = "onUserPublishScreen",
	onUserUnpublishScreen = "onUserUnpublishScreen",
	/** 
	 * @brief 收到房间内的广播消息
	 */
	
	onRoomMessageReceived = "onRoomMessageReceived",
	/** 
	 * @brief 收到房间内的二进制广播消息
	 */
	
	onRoomBinaryMessageReceived = "onRoomBinaryMessageReceived",
	/** 
	 * @brief 收到点对点文本消息
	 */
	
	onUserMessageReceived = "onUserMessageReceived",
	/** 
	 * @brief 收到点对点二进制消息
	 */
	
	onUserBinaryMessageReceived = "onUserBinaryMessageReceived",
	/** 
	 * @brief 首帧视频渲染成功
	 * @deprecated  since 4.47, use on onRemoteVideoFirstFrame instead.
	 */
	
	onVideoFirstFrameRendered = "onVideoFirstFrameRendered",
	/** 
	 * @brief 首帧视频解码成功
	 * @deprecated  since 4.47, use on onRemoteVideoFirstFrame instead.
	 */
	
	onVideoFirstFrameDecoded = "onVideoFirstFrameDecoded",
	/** 
	 * @brief 远端视频首帧渲染成功
	 */
	
	onRemoteVideoFirstFrame = "onRemoteVideoFirstFrame",
	/** 
	 * @deprecated since 4.47, use on onRemoteAudioFirstFrame instead.
	 * @brief 首帧音频解码成功
	 */
	
	onAudioFirstFrameDecoded = "onAudioFirstFrameDecoded",
	/** 
	 * @brief 远端首帧音频解码成功
	 */
	
	onRemoteAudioFirstFrame = "onRemoteAudioFirstFrame",
	/** 
	 * 首帧视频渲染成功
	 */
	
	onFirstPublicStreamVideoFrameRendered = "onFirstPublicStreamVideoFrameRendered",
	/** 
	 * 首帧视频解码成功
	 */
	
	onFirstPublicStreamVideoFrameDecoded = "onFirstPublicStreamVideoFrameDecoded",
	/** 
	 * 首帧音频解码成功
	 */
	
	onFirstPublicStreamAudioFrameDecoded = "onFirstPublicStreamAudioFrameDecoded",
	/** 
	 * @brief 视频媒体设备状态改变
	 */
	
	onVideoDeviceStateChanged = "onVideoDeviceStateChanged",
	/** 
	 * @brief 音频媒体设备状态改变
	 */
	
	onAudioDeviceStateChanged = "onAudioDeviceStateChanged",
	/** 
	 * @brief 远端媒体流信息回调
	 */
	
	onRemoteStreamStats = "onRemoteStreamStats",
	/** 
	 * 远端公共媒体流信息回调
	 */
	
	onPublicStreamStats = "onPublicStreamStats",
	/** 
	 * 本地媒体流信息回调
	 * @brief 本地媒体流信息回调
	 */
	
	onLocalStreamStats = "onLocalStreamStats",
	/** 
	 * @brief 音量提示回调
	 */
	
	onAudioVolumeIndication = "onAudioVolumeIndication",
	onLocalAudioPropertiesReport = "onLocalAudioPropertiesReport",
	onRemoteAudioPropertiesReport = "onRemoteAudioPropertiesReport",
	onActiveSpeaker = "onActiveSpeaker",
	/** 
	 * @brief 音频播放设备状态回调
	 */
	
	onAudioPlaybackDeviceChanged = "onAudioPlaybackDeviceChanged",
	/** 
	 * @brief 用户开启视频采集
	 */
	
	onUserStartVideoCapture = "onUserStartVideoCapture",
	/** 
	 * @brief 用户关闭视频采集
	 */
	
	onUserStopVideoCapture = "onUserStopVideoCapture",
	/** 
	 * @brief 用户开启音频采集
	 */
	
	onUserStartAudioCapture = "onUserStartAudioCapture",
	/** 
	 * @brief 用户关闭音频采集
	 */
	
	onUserStopAudioCapture = "onUserStopAudioCapture",
	onAutoPublishResult = "onAutoPublishResult",
	onAutoSubscribeResult = "onAutoSubscribeResult",
	/** 
	 * @brief 转推直播状态
	 */
	
	onLiveTranscodingResult = "onLiveTranscodingResult",
	onStreamMixingEvent = "onStreamMixingEvent",
	onAudioPlaybackDeviceTestVolume = "onAudioPlaybackDeviceTestVolume",
	onSEIMessageReceived = "onSEIMessageReceived",
	onError = "onError",
	onAudioMixingStateChanged = "onAudioMixingStateChanged",
	onUserMessageReceivedOutsideRoom = "onUserMessageReceivedOutsideRoom",
	onUserBinaryMessageReceivedOutsideRoom = "onUserBinaryMessageReceivedOutsideRoom",
	onTokenWillExpire = "onTokenWillExpire",
	onTokenPublishPrivilegeWillExpire = "onTokenPublishPrivilegeWillExpire",
	onTokenPublishPrivilegeDidExpired = "onTokenPublishPrivilegeDidExpired",
	onTokenSubscribePrivilegeWillExpire = "onTokenSubscribePrivilegeWillExpire",
	onTokenSubscribePrivilegeDidExpired = "onTokenSubscribePrivilegeDidExpired",
	onCloudProxyConnected = "onCloudProxyConnected",
	onPushPublicStreamResult = "onPushPublicStreamResult",
	onPublicStreamSEIMessageReceived = "onPublicStreamSEIMessageReceived",
	onNetworkQuality = "onNetworkQuality",
	onSimulcastSubscribeFallback = "onSimulcastSubscribeFallback",
	onRemoteVideoSizeChanged = "onRemoteVideoSizeChanged",
	onVideoStreamBanned = "onVideoStreamBanned",
	onAudioStreamBanned = "onAudioStreamBanned",
	onLocalVideoSizeChanged = "onLocalVideoSizeChanged",
	onSubtitleStateChanged = "onSubtitleStateChanged",
	onSubtitleMessageReceived = "onSubtitleMessageReceived",
	onServerParamsSetResult = "onServerParamsSetResult",
	onLocalStreamTrackChangedByExtension = "onLocalStreamTrackChangedByExtension",
	onVendorConnectionStateChanged = "onVendorConnectionStateChanged",
	onForwardStreamError = "onForwardStreamError",
	onRejoinWithTcp = "onRejoinWithTcp",
	onIceConnectWithTcp = "onIceConnectWithTcp",
	onPublishRetry = "onPublishRetry",
	onSubscribeRetry = "onSubscribeRetry",
	onPublishResult = "onPublishResult",
	onSubscribeResult = "onSubscribeResult",
	onSEIStreamUpdate = "onSEIStreamUpdate"
}
declare enum ErrorCode {
	/** 
	 * @brief 调用 `destroyEngine` 时，传入的参数不是合法的 engine 对象。
	 */
	
	INVALID_ENGINE = "INVALID_ENGINE",
	/** 
	 * @brief 通用错误码。调用方法时，传入的参数不合法。请根据各方法说明传入正确的参数。
	 */
	
	INVALID_PARAMS = "INVALID_PARAMS",
	/** 
	 * @hidden no use
	 * @brief 尝试发布/取消发布或订阅/取消订阅流时不在房间内
	 */
	
	INVOKED_BEFORE_JOIN_ROOM = "INVOKED_BEFORE_JOIN_ROOM",
	/** 
	 * @brief 调用 `joinRoom` 进房时使用了已过期的 Token 或使用的 Token 无效。请重新获取 Token 后再次调用 `joinRoom` 进房。
	 */
	
	INVALID_TOKEN = "INVALID_TOKEN",
	/** 
	 * @brief 调用 `joinRoom` 进房失败，具体错误原因查看 message。
	 */
	
	JOIN_ROOM_FAILED = "JOIN_ROOM_FAILED",
	/** 
	 * @brief 调用 `updateToken` 时传入的 Token 无效。请使用有效的 Token。
	 */
	
	UPDATE_TOKEN_WITH_INVALID_TOKEN = "UPDATE_TOKEN_WITH_INVALID_TOKEN",
	/** 
	 * @brief 调用 `updateToken` 时不在房间内，请先调用 `joinRoom` 加入房间。
	 */
	
	UPDATE_TOKEN_BEFORE_JOIN = "UPDATE_TOKEN_BEFORE_JOIN",
	/** 
	 * @brief 重复进房。已加入房间后，又再次调用 `joinRoom` 时触发。
	 */
	
	REPEAT_JOIN = "REPEAT_JOIN",
	/** 
	 * @hidden no use
	 * @brief 重复发布流
	 */
	
	REPEAT_PUBLISH = "REPEAT_PUBLISH",
	/** 
	 * @brief 重复发布公共流。已发布公共流后，又再次调用 `startPushPublicStream` 时触发。
	 */
	
	REPEAT_PUSH = "REPEAT_PUSH",
	/** 
	 * @brief 调用 `startPlayPublicStream` 重复订阅同一条公共流。
	 */
	
	REPEAT_PLAY = "REPEAT_PLAY",
	/** 
	 * @hidden no use
	 * @brief 在加入房间之前就执行发布操作
	 */
	
	PUBLISH_BEFORE_JOIN = "PUBLISH_BEFORE_JOIN",
	/** 
	 * @hidden no use
	 * @brief 在加入房间之前就执行取消发布操作
	 */
	
	UNPUBLISH_BEFORE_JOIN = "UNPUBLISH_BEFORE_JOIN",
	/** 
	 * @hidden no use
	 * @brief 在加入房间之前就执行订阅操作
	 */
	
	SUBSCRIBE_BEFORE_JOIN = "SUBSCRIBE_BEFORE_JOIN",
	/** 
	 * @hidden no use
	 * @brief 在加入房间之前就执行取消订阅操作
	 */
	
	UNSUBSCRIBE_BEFORE_JOIN = "UNSUBSCRIBE_BEFORE_JOIN",
	/** 
	 * @brief 无发布权限。调用 `setUserVisibility` 将自身设置为对当前房间内其他用户不可见后，调用 `publishStream` 或 `publishScreen` 发布流。请先将自身切换至可见后再发布流。
	 */
	
	NO_PUBLISH_PERMISSION = "NO_PUBLISH_PERMISSION",
	/** 
	 * @brief 目标流不存在。触发时机包括：调用 `subscribeStream`/`unsubscribeStream` 订阅/取消订阅一路不存在的流；调用 `takeRemoteSnapshot` 截取远端画面时指定的流不存在。请输入正确的 ID，或确认目标流在房间内。
	 */
	
	STREAM_NOT_EXIST = "STREAM_NOT_EXIST",
	/** 
	 * @hidden no use
	 * @brief 发布时，没有采集任何音视频流
	 */
	
	EMPTY_STREAM = "EMPTY_STREAM",
	/** 
	 * @brief 非法操作。SDK 尚未与服务器建连，在此状态下不能进行该操作。请确认调用方法时是否已加入房间，或网络状态是否正常。
	 */
	
	NOT_CONNECTED_YET = "NOT_CONNECTED_YET",
	/** 
	 * @hidden no use
	 * @brief 在加入房间之前就发布 IM 消息
	 */
	
	IM_BEFORE_JOIN = "IM_BEFORE_JOIN",
	/** 
	 * @hidden no use
	 * @brief 用户不存在
	 */
	
	USER_NOT_EXIST = "USER_NOT_EXIST",
	/** 
	 * @hidden no use
	 * @brief 用户已经在房间中
	 */
	
	ALREADY_IN_ROOM = "ALREADY_IN_ROOM",
	/** 
	 * @brief 服务端调用 OpenAPI 将当前用户踢出房间。通过 `onError` 回调。
	 */
	
	KICKED_OUT = "KICKED_OUT",
	/** 
	 * @brief 服务端调用 OpenAPI 解散房间，所有用户被移出房间。通过 `onError` 回调。
	 */
	
	ROOM_DISMISS = "ROOM_DISMISS",
	/** 
	 * @brief 加入房间后，Token 过期。通过 `onError` 回调。请获取新的 Token 后，调用 `joinRoom` 重新加入房间。
	 */
	
	TOKEN_EXPIRED = "TOKEN_EXPIRED",
	/** 
	 * @brief Token 发布权限过期，通过 `onTokenPublishPrivilegeDidExpired` 回调。调用 `updateToken` 更新 Token 发布权限。
	 */
	
	TOKEN_NO_PUBLISH_PERMISSION = "TOKEN_NO_PUBLISH_PERMISSION",
	/** 
	 * @brief Token 订阅权限过期，通过 `onTokenSubscribePrivilegeDidExpired` 回调。调用 `updateToken` 更新 Token 订阅权限。
	 */
	
	TOKEN_NO_SUBSCRIBE_PERMISSION = "TOKEN_NO_SUBSCRIBE_PERMISSION",
	/** 
	 * @brief 有相同用户 ID 的用户加入本房间，当前用户被踢出房间。通过 `onError` 回调。
	 */
	
	DUPLICATE_LOGIN = "DUPLICATE_LOGIN",
	/** 
	 * @brief 调用 `takeLocalSnapshot` 截取本地画面时指定的视频流不存在。请确保指定的流已发布。
	 */
	
	INVOKED_BEFORE_CAPTURE = "INVOKED_BEFORE_CAPTURE",
	/** 
	 * @brief 重复采集。调用 `startAudioCapture`、`startVideoCapture` 或 `startAudioAndVideoCapture` 重复采集同一条音频/视频流时触发。
	 */
	
	REPEAT_CAPTURE = "REPEAT_CAPTURE",
	/** 
	 * @brief 调用 `startVideoCapture` 或 `startAudioAndVideoCapture` 开启视频采集失败。请确认是否有可用的采集设备，或是否被其他 App 占用。
	 */
	
	GET_VIDEO_TRACK_FAILED = "GET_VIDEO_TRACK_FAILED",
	/** 
	 * @brief 调用 `startAudioCapture` 或 `startAudioAndVideoCapture` 开启音频采集失败。请确认是否有可用的采集设备，或是否被其他 App 占用。
	 */
	
	GET_AUDIO_TRACK_FAILED = "GET_AUDIO_TRACK_FAILED",
	/** 
	 * @brief 调用 `startScreenCapture` 开启屏幕采集共享失败。
	 */
	
	GET_SCREEN_TRACK_FAILED = "GET_SCREEN_TRACK_FAILED",
	/** 
	 * @brief 流类型不匹配。调用 `setVideoSourceType` 设置了自定义视频源后，又调用 `startAudioCapture`、`stopAudioCapture`、`startVideoCapture`、`stopVideoCapture` 或 `startAudioAndVideoCapture` 等内部采集相关的接口。
	 */
	
	STREAM_TYPE_NOT_MATCH = "STREAM_TYPE_NOT_MATCH",
	/** 
	 * @brief 调用 `setLocalVideoPlayer`/`setRemoteVideoPlayer` 传入的播放容器不存在。
	 */
	
	CANT_FIND_DOM = "CANT_FIND_DOM",
	/** 
	 * @brief 调用 `setAudioPlaybackDevice` 设置音频播放设备时，输入的设备 ID 无效。
	 */
	
	INVALID_DEVICE_ID = "INVALID_DEVICE_ID",
	/** 
	 * @hidden no use
	 * @brief 没有采集权限
	 */
	
	NO_PERMISSION = "NO_PERMISSION",
	/** 
	 * @brief 调用 `startAudioDeviceRecordTest`/`setAudioPlaybackDevice` 失败，浏览器不支持设置音频播放设备或测试音频采集/播放设备。
	 */
	
	NOT_SUPPORTED = "NOT_SUPPORTED",
	/** 
	 * @hidden no use
	 */
	
	INTERRUPT = "INTERRUPT",
	/** 
	 * @brief 调用 `joinRoom` 时请求分配 ICE 节点时失败。
	 */
	
	ICE_SERVER_WRONG = "ICE_SERVER_WRONG",
	/** 
	 * @hidden no use
	 * @brief 跟服务器建立 datachannel 连接失败
	 */
	
	ESTABLISH_DATACHANNEL_FAILED = "ESTABLISH_DATACHANNEL_FAILED",
	/** 
	 * @brief 调用 `startAudioMixing` 或 `preloadAudioMixing` 时资源加载失败。请传入正确的资源路径。
	 */
	
	LOAD_RESOURCES_FAILED = "LOAD_RESOURCES_FAILED",
	/** 
	 * @hidden no use
	 * @brief 信令通道没有建立
	 */
	
	SIGNALING_CHANNEL_NOT_OPEN = "SIGNALING_CHANNEL_NOT_OPEN",
	/** 
	 * @brief 通用错误码，60s 内没有收到信令回复。
	 */
	
	TIME_OUT = "TIME_OUT",
	/** 
	 * @hidden no use
	 * @brief 网络未连接拒绝操作
	 */
	
	REFUSE_OPERATION_IN_DISCONNECT = "REFUSE_OPERATION_IN_DISCONNECT",
	/** 
	 * @brief 创建 TRANSCEIVER 失败
	 */
	
	ADD_TRANSCEIVER_FAILED = "ADD_TRANSCEIVER_FAILED",
	/** 
	 * @hidden no use
	 * @brief 更新发送流失败
	 */
	
	UPDATE_TRACK_FAILED = "UPDATE_TRACK_FAILED",
	/** 
	 * @brief 调用 `publishStream` 或 `publishScreen` 发布流失败，具体原因查看 message。
	 */
	
	PUBLISH_FAILED = "PUBLISH_FAILED",
	/** 
	 * @hidden no use
	 * @brief 取消发布流失败
	 */
	
	UNPUBLISH_FAILED = "UNPUBLISH_FAILED",
	/** 
	 * @hidden no use
	 * @brief 订阅失败
	 */
	
	SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED",
	/** 
	 * @hidden no use
	 * @brief 取消订阅失败
	 */
	
	UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED",
	/** 
	 * @brief 通用错误码。发布/订阅等操作执行到一半时离开房间，会触发该错误回调，表示操作中断，无需处理。
	 */
	
	OPERATION_CANCEL = "OPERATION_CANCEL",
	/** 
	 * @brief 调用 `startCloudProxy` 开启云代理功能失败，原因为进房后调用。你需要在进房前调用该方法。
	 */
	
	START_CLOUD_PROXY_AFTER_JOIN = "START_CLOUD_PROXY_AFTER_JOIN",
	/** 
	 * @brief 调用 `stopCloudProxy` 关闭云代理功能失败，原因为离开房间前调用。你需要在退房后调用该方法。
	 */
	
	STOP_CLOUD_PROXY_BEFORE_LEAVE = "STOP_CLOUD_PROXY_BEFORE_LEAVE",
	/** 
	 * @brief 通用错误码。具体错误原因查看 message。
	 */
	
	UNEXPECTED_ERROR = "UNEXPECTED_ERROR",
	/** 
	 * @brief 检测已开启。已经开启音频设备检测后，重复调用 `startAudioPlaybackDeviceTest` 或 `startAudioDeviceRecordTest` 时触发。
	 */
	
	REPEAT_DEVICE_TEST = "REPEAT_DEVICE_TEST",
	/** 
	 * @brief 调用 `startAudioDeviceRecordTest` 开启音频设备测试失败，请重试。
	 */
	
	AUDIO_DEVICE_TEST_FAILED = "AUDIO_DEVICE_RECORD_FAILED",
	/** 
	 * @brief 调用 `login` 失败，已有相同 userId 的用户登录了实时信令服务器，请勿重复登录或使用不同的 userId 登录。
	 */
	
	ALREADY_LOGIN = "ALREADY_LOGIN",
	/** 
	 * @brief 调用 `login` 登录实时信令服务器失败，具体原因查看 message。
	 */
	
	LOGIN_FAILED = "LOGIN_FAILED",
	/** 
	 * @brief 消息功能通用错误码。尚未调用 `login` 成功登录实时信令服务器前调用消息相关 API 时触发。请先登录。
	 */
	
	NOT_LOGIN = "NOT_LOGIN",
	/** 
	 * @brief 相同用户 ID 的用户登录，导致本地已登录用户被顶出。通过 `onError` 回调。
	 */
	
	RTM_DUPLICATE_LOGIN = "RTM_DUPLICATE_LOGIN",
	/** 
	 * @brief 重连实时信令服务器时使用的 Token 异常。通过 `onError` 回调。请使用新的 Token 重新登录。
	 */
	
	RTM_TOKEN_ERROR = "RTM_TOKEN_ERROR",
	/** 
	 * @brief 调用 `sendUserMessage`、`sendUserBinaryMessage`、`sendUserMessageOutsideRoom`、`sendUserBinaryMessageOutsideRoom`、`sendServerMessage` 或 `sendServerBinaryMessage` 发送点对点消息超时。
	 */
	
	USER_MESSAGE_TIMEOUT = "USER_MESSAGE_TIMEOUT",
	/** 
	 * @brief 调用 `sendUserMessage`、`sendUserBinaryMessage`、`sendUserMessageOutsideRoom`、`sendUserBinaryMessageOutsideRoom`、`sendServerMessage` 或 `sendServerBinaryMessage` 发送点对点消息时，通道断开，发送失败。
	 */
	
	USER_MESSAGE_BROKEN = "USER_MESSAGE_BROKEN",
	/** 
	 * @brief 调用 `sendUserMessage`、`sendUserBinaryMessage`、`sendUserMessageOutsideRoom`、`sendUserBinaryMessageOutsideRoom`、`sendServerMessage` 或 `sendServerBinaryMessage` 发送点对点消息时找不到接收者，请检查传入的 userId 是否正确。
	 */
	
	USER_MESSAGE_NO_RECEIVER = "USER_MESSAGE_NO_RECEIVER",
	/** 
	 * @hidden
	 * @deprecated since 4.49, use USER_MESSAGE_NO_RECEIVER instead.
	 * @brief 获取级联路径失败
	 */
	
	USER_MESSAGE_NO_RELAYPATH = "USER_MESSAGE_NO_RELAYPATH",
	/** 
	 * @hidden no use
	 * @brief 超过 QPS 限制
	 */
	
	USER_MESSAGE_EXCEED_QPS = "USER_MESSAGE_EXCEED_QPS",
	/** 
	 * @brief 调用 `sendServerMessage` 或 `sendServerBinaryMessage` 发送点对点消息到业务服务器无应答，可能是 Http 不通。
	 */
	
	USER_MESSAGE_SEND_TO_SERVER_ERROR = "USER_MESSAGE_SEND_TO_SERVER_ERROR",
	/** 
	 * @brief 调用 `sendServerMessage` 或 `sendServerBinaryMessage` 发送点对点消息到业务服务器失败，业务服务器 Http 响应状态码不是 200。
	 */
	
	USER_MESSAGE_SERVER_RESPONSE_ERROR = "USER_MESSAGE_SERVER_RESPONSE_ERROR",
	/** 
	 * @brief 调用 `sendUserMessage` 或 `sendUserBinaryMessage` 发送点对点消息失败，原因是尚未进房。请加入房间后调用。
	 */
	
	USER_MESSAGE_NOT_JOIN = "USER_MESSAGE_NOT_JOIN",
	/** 
	 * @hidden
	 * @deprecated
	 * @brief 连接未完成初始化
	 */
	
	USER_MESSAGE_INIT = "USER_MESSAGE_INIT",
	/** 
	 * @hidden
	 * @deprecated since 4.49, use USER_MESSAGE_UNKNOWN instead.
	 * @brief 没有可用的数据传输通道连接
	 */
	
	USER_MESSAGE_NO_CONNECTION = "USER_MESSAGE_NO_CONNECTION",
	/** 
	 * @brief 调用 `sendUserMessageOutsideRoom`/`sendUserBinaryMessageOutsideRoom` 发送房间外点对点消息，或调用 `sendServerMessage`/`sendServerBinaryMessage` 向业务服务器发送消息时尚未登录实时信令服务器，请先调用 `login` 登录。
	 */
	
	USER_MESSAGE_NOT_LOGIN = "USER_MESSAGE_NOT_LOGIN",
	/** 
	 * @brief 调用 `sendServerMessage`/`sendServerBinaryMessage` 向业务服务器发送消息之前，尚未设置参数，请先调用 `setServerParam` 设置业务服务器参数。
	 */
	
	USER_MESSAGE_SERVER_PARAMS_NOTSET = "USER_MESSAGE_SERVER_PARAMS_NOTSET",
	/** 
	 * @brief 调用 `sendUserMessage`、`sendUserBinaryMessage`、`sendUserMessageOutsideRoom`、`sendUserBinaryMessageOutsideRoom`、`sendServerMessage` 或 `sendServerBinaryMessage` 发送点对点消息时发生未知错误。
	 */
	
	USER_MESSAGE_UNKNOWN = "USER_MESSAGE_UNKNOWN",
	/** 
	 * @hidden no use
	 * @brief 推流用户没有进入房间。
	 */
	
	START_PUBLIC_STREAM_BEFORE_JOIN = "START_PUBLIC_STREAM_BEFORE_JOIN",
	/** 
	 * @brief SDK 与服务端重连失败，并不再自动重试。通过 `onError` 回调。你需退房后重新进房，或联系技术支持。
	 */
	
	RECONNECT_FAILED = "RECONNECT_FAILED",
	/** 
	 * @brief 字幕已开启。已开启字幕功能后，再次调用 `startSubtitle` 时触发。请勿重复开启字幕功能。
	 */
	
	SUBTITLE_ALREADY_ON = "SUBTITLE_ALREADY_ON",
	/** 
	 * @hidden currently not available
	 * @brief 未开启字幕任务或没开启字幕就调用更新字幕API时报错。
	 */
	
	SUBTITLE_NOT_TURNED_ON = "SUBTITLE_NOT_TURNED_ON",
	/** 
	 * @brief 云端媒体处理内部出现错误。通过 `onSubtitleStateChanged` 回调。请联系技术支持。
	 */
	
	SUBTITLE_ERR_POSTPROCESS = "SUBTITLE_ERR_POSTPROCESS",
	/** 
	 * @brief 第三方服务连接失败。通过 `onSubtitleStateChanged` 回调。请联系技术支持。
	 */
	
	SUBTITLE_ERR_CONNECTION_ERROR = "SUBTITLE_ERR_CONNECTION_ERROR",
	/** 
	 * @brief 云端媒体处理超时未响应。通过 `onSubtitleStateChanged` 回调。请联系技术支持。
	 */
	
	SUBTITLE_ERR_PROCESS_ERROR = "SUBTITLE_ERR_PROCESS_ERROR",
	/** 
	 * @brief 客户端无法识别云端媒体处理发送的错误码。通过 `onSubtitleStateChanged` 回调。请联系技术支持。
	 */
	
	SUBTITLE_ERR_UNKNOWN = "SUBTITLE_ERR_UNKNOWN",
	/** 
	 * @brief 跨房间转发媒体流相关 API 的调用时机不正确，请参考各接口说明确认调用的先后顺序。
	 */
	
	UNEXPECTED_INVOKE_FORWARD_STREAM = "UNEXPECTED_INVOKE_FORWARD_STREAM",
	/** 
	 * @brief 调用 `joinRoom` 进房失败，原因是房间被封禁。
	 */
	
	ROOM_FORBIDDEN = "ROOM_FORBIDDEN",
	/** 
	 * @brief 调用 `joinRoom` 进房失败，原因是本地用户被封禁。
	 */
	
	USER_FORBIDDEN = "USER_FORBIDDEN",
	/** 
	 * @brief 获取 Electron 实例失败。确认当前满足 Electron 开发环境要求，参考 [Electron 架构下通过 Web SDK 实现屏幕共享](https://www.volcengine.com/docs/6348/1340581)。
	 */
	
	ERR_ELECTRON_IS_NULL = "ERR_ELECTRON_IS_NULL",
	/** 
	 * @brief 在 Electron 环境中获取桌面共享源失败。
	 */
	
	ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR",
	/** 
	 * @brief Simulcast 功能设置失败。确认调用时机是否满足 [`setLocalSimulcastMode`](104478#rtcengine-setlocalsimulcastmode) 要求。
	 * 开始发布后可以更改分辨率，但不能更改路数。
	 */
	
	SET_SIMULCAST_FAILED = "SET_SIMULCAST_FAILED",
	/** 
	 * @brief 混用了 Simulcast 功能的废弃接口和当前接口。后续版本将不再维护废弃接口，并预计在多个版本后删除，建议尽快替换为当前接口。
	 * + `setRemoteVideoConfig` 已废弃，请使用 [`setRemoteSimulcastStreamType`](104478#rtcengine-setremotesimulcaststreamtype)。
	 * + `enableSimulcastMode` 已废弃，请使用 [`setLocalSimulcastMode`](104478#rtcengine-setlocalsimulcastmode)。
	 */
	
	MIXING_OLD_AND_NEW_APIS = "MIXING_OLD_AND_NEW_APIS",
	/** 
	 * @brief 通过 [`startPushWTN`](104478#wtnstream-startpushwtn) 发布 WTN 流失败。
	 */
	
	WTN_PUSH_FAILED = "WTN_PUSH_FAILED",
	/** 
	 * @brief 通过 [`startPlayWTN`](104478#wtnstream-startplaywtn) 订阅 WTN 流失败。
	 */
	
	WTN_PLAY_FAILED = "WTN_PLAY_FAILED",
	NOT_ALLOWED_IN_RTS_ROOM = "NOT_ALLOWED_IN_RTS_ROOM",
	NOT_ALLOWED_IN_RESTRICTED_MODE = "NOT_ALLOWED_IN_RESTRICTED_MODE"
}
declare enum ExtendMediaType {
	NONE = 0
}
declare enum SEIStreamEventType {
	/** 
	 * @brief 远端用户发布黑帧视频流。
	 *        语音通话场景下，远端用户调用 [sendSEIMessage](104478#sendseimessage) 发送 SEI 数据时，SDK 会自动发布一路黑帧视频流，并触发该回调。
	 */
	
	BLACK = 0,
	/** 
	 * @brief 远端黑帧视频流移除。该回调的触发时机包括：
	 *        <ul><li> 远端用户开启摄像头采集，由语音通话切换至视频通话，黑帧视频流停止发布；</li><li> 远端用户调用 [setVideoSourceType](104478#setvideosourcetype) 切换至自定义视频采集时，黑帧视频流停止发布；</li><li> 远端用户调用 [sendSEIMessage](104478#sendseimessage) 后 1 分钟内未有 SEI 数据发送，黑帧视频流停止发布。</li></ul>
	 */
	
	NORMAL = 1
}
declare enum StreamMixingEventErrorCode {
	/** 
	 * @brief 推流成功
	 */
	
	ERR_OK = 0,
	/** 
	 * @brief 推流参数错误。
	 */
	
	ERR_PARAM_INVALID = 1,
	/** 
	 * @brief 和 RTC 服务端建立连接失败，会自动重连。
	 */
	
	ERR_FRAME_TIMEOUT = 2,
	/** 
	 * @brief 合流服务中间过程存在错误，建议重试。
	 */
	
	ERR_POSTPROCESS = 3,
	/** 
	 * @brief 推流失败，等待服务端重推。
	 */
	
	ERR_PUSH_CDN = 4,
	/** 
	 * @brief 其他异常。
	 */
	
	ERR_UNKNOWN = 9999
}
declare enum StreamMixingEventType {
	/** 
	 * @brief 已发起开始转推请求。
	 */
	
	START = 1,
	/** 
	 * @brief 转推至 CDN 成功。
	 */
	
	START_SUCCESS = 2,
	/** 
	 * @brief 推流 CDN 失败。
	 */
	
	START_FAILED = 3,
	/** 
	 * @brief 已发起更新转推请求。
	 */
	
	UPDATE = 4,
	/** 
	 * @brief 成功应用新配置进行推流。
	 */
	
	UPDATE_SUCCESS = 5,
	/** 
	 * @brief 更新合流失败，新配置参数校验失败或配置未生效。
	 */
	
	UPDATE_FAILED = 6,
	/** 
	 * @brief 已发起停止转推请求。
	 */
	
	STOP = 7,
	/** 
	 * @brief 成功停止推流至CDN。
	 */
	
	STOP_SUCCESS = 8,
	/** 
	 * @brief 停止推流失败。
	 */
	
	STOP_FAILED = 9
}
declare function getElectronScreenSources(type?: ScreenSourceType): Promise<ElectronDesktopCapturerSource[]>;
declare function getParameter(key: keyof typeof Config): {} | undefined;
declare function setParameter<T extends SetParamKey>(key: T, value: (SetParamInterface & CoreSetParamterInterface)[T]): IJoinRoomConfig | undefined;
/** 
 * @brief AAC 编码规格。
 */

export declare enum AAC_PROFILE {
	/** 
	 * @brief AAC-LC 规格，默认值。
	 */
	
	LC = "LC",
	/** 
	 * @brief HE-AAC v1 规格。
	 */
	
	HEv1 = "HEv1",
	/** 
	 * @brief HE-AAC v2 规格。
	 */
	
	HEv2 = "HEv2"
}
/** 
 * @brief 混音播放声道类型
 */

export declare enum AudioMixingDualMonoMode {
	/** 
	 * @brief 和音频文件一致
	 */
	
	AUTO = 0,
	/** 
	 * @brief 只能听到音频文件中左声道的音频
	 */
	
	MODE_L = 1,
	/** 
	 * @brief 只能听到音频文件中右声道的音频
	 */
	
	MODE_R = 2,
	/** 
	 * @brief 能同时听到音频文件中左右声道的音频
	 */
	
	MODE_MIX = 3
}
/** 
 * @brief 混音播放类型
 */

export declare enum AudioMixingType {
	/** 
	 * @brief 仅本地播放
	 */
	
	PLAYOUT = 0,
	/** 
	 * @brief 仅发送到远端
	 */
	
	PUBLISH = 1,
	/** 
	 * @brief 在本地播放并发送到远端
	 */
	
	PLAYOUT_AND_PUBLISH = 2
}
/** 
 * @brief 音质档位
 *        调用 [setAudioProfile](104478#setaudioprofile) 设置的音质档位
 */

export declare enum AudioProfileType {
	/** 
	 * @brief 默认音质
	 *        服务器下发的音质配置
	 */
	
	default = 0,
	/** 
	 * @brief 流畅音质。
	 *        单声道，采样率为 16kHz，编码码率为 24kbps。
	 *        流畅优先、低功耗、低流量消耗，适用于大部分游戏场景，如小队语音、组队语音、国战语音等。
	 */
	
	fluent = 1,
	/** 
	 * @brief 单声道标准音质。
	 *        采样率为 48kHz，编码码率为 48kbps。
	 *        适用于对音质有一定要求的场景，同时延时、功耗和流量消耗相对适中，适合教育场景和狼人杀等游戏。
	 */
	
	standard = 2,
	/** 
	 * @brief 双声道音乐音质
	 *        采样率为 48kHz，编码码率为 128kbps。
	 *        超高音质，同时延时、功耗和流量消耗相对较大，适用于连麦 PK 等音乐场景。
	 *        游戏场景不建议使用。
	 */
	
	hd = 3,
	/** 
	 * @brief 双声道标准音质。采样率为 48 KHz，编码码率最大值为 80 Kbps
	 */
	
	standardStereo = 4,
	/** 
	 * @brief 单声道音乐音质。采样率为 48 kHz，编码码率最大值为 128 Kbps
	 */
	
	hdMono = 5
}
/** 
 * @brief 本地主流音量回调的数据范围，控制回调中是否包含混音。
 *        该功能影响 [onActiveSpeaker](104479#onactivespeaker) 回调。例如，[AudioReportMode](#audioreportmode) 为 `AUDIOMIXING`，即使麦克风音量为 0，该回调中也可能回调本端用户主流音频。
 */

export declare enum AudioReportMode {
	/** 
	 * @brief （默认值）麦克风音量，即混音前的音量。
	 */
	
	MICROPHONE = 0,
	/** 
	 * @brief 混音后的音量。
	 */
	
	AUDIOMIXING = 1
}
/** 
 * @brief 音频选路优先级设置。
 */

export declare enum AudioSelectionPriority {
	/** 
	 * @brief 正常，参加音频选路。
	 */
	
	DEFAULT = 0,
	/** 
	 * @brief 高优先级，跳过音频选路
	 */
	
	HIGH = 1
}
/** 
 * @brief 音频采集方式
 */

export declare enum AudioSourceType {
	/** 
	 * @brief 自定义采集模块
	 */
	
	AUDIO_SOURCE_TYPE_EXTERNAL = 0,
	/** 
	 * @brief 内部采集，使用由 SDK 提供的音频采集模块
	 */
	
	AUDIO_SOURCE_TYPE_INTERNAL = 1
}
/** 
 * @private
 * 房间模式
 * web 目前用不到这个字段，先保留，不上文档。
 */

export declare enum ChannelProfile {
	CHANNEL_PROFILE_COMMUNICATION = 0,
	CHANNEL_PROFILE_LIVE_BROADCASTING = 1
}
/** 
 * @brief SDK 与信令服务器连接状态。
 */

export declare enum ConnectionState {
	/** 
	 * @brief 进行连接前准备，锁定相关资源。
	 */
	
	CONNECTION_START = 0,
	/** 
	 * @brief 连接断开。
	 */
	
	CONNECTION_STATE_DISCONNECTED = 1,
	/** 
	 * @brief 首次连接，正在连接中。
	 */
	
	CONNECTION_STATE_CONNECTING = 2,
	/** 
	 * @brief 首次连接成功。
	 */
	
	CONNECTION_STATE_CONNECTED = 3,
	/** 
	 * @brief 连接断开后重新连接中。
	 */
	
	CONNECTION_STATE_RECONNECTING = 4,
	/** 
	 * @brief 连接断开后重连成功。
	 */
	
	CONNECTION_STATE_RECONNECTED = 5,
	/** 
	 * @brief 处于 `CONNECTION_STATE_DISCONNECTED` 状态超过 10 秒，且期间重连未成功。SDK将继续尝试重连。
	 */
	
	CONNECTION_STATE_LOST = 6
}
/** 
 * @brief 是否开启耳返音频
 */

export declare enum EarMonitorPosition {
	/** 
	 * @brief 不开启耳返
	 */
	
	NONE = 0,
	/** 
	 * @brief 未经混音和前处理的本地音频
	 */
	
	AFTER_CAPTURE = 1,
	/** 
	 * @brief 经过前处理的本地音频，未经混音
	 */
	
	AFTER_PROCESS = 2
}
/** 
 * @brief 触发流回退或恢复的原因
 */

export declare enum FallbackOrRecoverReason {
	/** 
	 * @brief 其他原因，非带宽原因引起的回退或恢复。默认值
	 */
	
	Unknown = -1,
	/** 
	 * @brief 由带宽不足导致的流回退。
	 */
	
	SubscribeFallbackByBandwidth = 0,
	/** 
	 * @brief 由带宽恢复导致的流恢复。
	 */
	
	SubscribeRecoverByBandwidth = 2
}
/** 
 * @detail errorcode
 * @brief 跨房间转发媒体流错误码，通过 [onForwardStreamError]({{callback}}#onForwardStreamError) 回调。
 */

export declare enum ForwardStreamError {
	/** 
	 * @brief 成功。
	 */
	
	FORWARD_STREAM_ERROR_OK = 0,
	/** 
	 * @brief 目标房间 Token 错误。
	 */
	
	FORWARD_STREAM_ERROR_INVALID_TOKEN = 1202,
	/** 
	 * @brief 服务端未知错误。
	 */
	
	FORWARD_STREAM_ERROR_RESPONSE = 1203,
	/** 
	 * @brief 将源房间设置为目标房间时返回该错误。
	 */
	
	FORWARD_STREAM_ERROR_REMOTE_KICKED = 1204,
	/** 
	 * @hidden
	 */
	
	FORWARD_STREAM_ERROR_NOT_SUPPORT = 1205
}
/** 
 * @brief 跨房间转发媒体流状态。
 */

export declare enum ForwardStreamState {
	/** 
	 * @brief 成功。
	 */
	
	FORWARD_STREAM_STATE_SUCCESS = 0,
	/** 
	 * @brief 失败。
	 */
	
	FORWARD_STREAM_STATE_FAILURE = 1
}
/** 
 * @brief 本地主流音量回调模式。
 *        该功能影响 [onActiveSpeaker](104479#onactivespeaker) 回调。例如，进入房间但未发布主流音频，[LocalMainReportMode](#localmainreportmode) 为 `RESET`，则该回调永远不会包含本端用户主流音频。
 */

export declare enum LocalMainReportMode {
	/** 
	 * @brief （默认值）本地主流存在时，始终开启音量回调。
	 */
	
	NORMAL = 0,
	/** 
	 * @brief 未发布时，不回调对应音量。发布时回调真实音量。
	 */
	
	DISCONNECT = 1,
	/** 
	 * @brief 未发布时，始终回调 0。发布时正常回调真实音量。
	 */
	
	RESET = 2
}
export declare enum LogChannel {
	/** 
	 * @brief 国内
	 */
	
	domestic = 0,
	/** 
	 * @brief 海外
	 */
	
	overseas = 1
}
/** 
 * @brief 媒体流类型
 */

export declare enum MediaType {
	/** 
	 * @brief 只控制音频
	 */
	
	AUDIO = 1,
	/** 
	 * @brief 只控制视频
	 */
	
	VIDEO = 2,
	/** 
	 * @brief 同时控制音频和视频
	 */
	
	AUDIO_AND_VIDEO = 3
}
/** 
 * @brief 镜像状态
 */

export declare enum MirrorMode {
	/** 
	 * @brief 关闭
	 */
	
	MIRROR_MODE_OFF = 0,
	/** 
	 * @brief 开启
	 */
	
	MIRROR_MODE_ON = 1
}
/** 
 * @brief 是否开启视频流渲染镜像。
 * 因浏览器限制，不支持编码传输镜像。
 */

export declare enum MirrorType {
	/** 
	 * @brief 无镜像效果
	 */
	
	MIRROR_TYPE_NONE = 0,
	/** 
	 * @brief 开启镜像效果
	 */
	
	MIRROR_TYPE_RENDER = 1
}
/** 
 * @brief 网络质量
 */

export declare enum NetworkQuality {
	/** 
	 * @brief 网络质量未知
	 */
	
	UNKNOWN = 0,
	/** 
	 * @brief 网络质量极好
	 */
	
	EXCELLENT = 1,
	/** 
	 * @brief 主观感觉和 Excellent 差不多，但码率可能略低
	 */
	
	GOOD = 2,
	/** 
	 * @brief 主观感受有瑕疵但不影响沟通
	 */
	
	POOR = 3,
	/** 
	 * @brief 勉强能沟通但不顺畅。建议降低采样率、码率或通过 UI 提示用户是否切换为纯语音通话。
	 */
	
	BAD = 4,
	/** 
	 * @brief 网络质量非常差，基本不能沟通。建议通过 UI 给出弱网提示。
	 */
	
	VBAD = 5,
	/** 
	 * @brief 网络连接断开，无法通话。
	 */
	
	DOWN = 6
}
/** 
 * @brief 补帧模式
 */

export declare enum PublicInterpolationMode {
	/** 
	 * @brief 补最后一帧。
	 */
	
	PREV_FRAME = 0,
	/** 
	 * @brief 补背景图片或者黑帧。
	 */
	
	OTHER_FRAME = 1
}
/** 
 * @brief WTN 流是否包含音视频。
 */

export declare enum PublicStreamType {
	/** 
	 * @brief 包含音视频。
	 */
	
	AUDIO_AND_VIDEO = 0,
	/** 
	 * @brief 仅包含音频。
	 */
	
	AUDIO_ONLY = 1,
	/** 
	 * @brief 仅包含视频。
	 */
	
	VIDEO_ONLY = 2
}
/** 
 * @brief 音视频流发布结果
 */

export declare enum PublishState {
	/** 
	 * @brief 发布成功
	 */
	
	PUBLISH_SUCC = 0,
	/** 
	 * @brief 发布失败
	 */
	
	PUBLISH_FAIL = 1
}
/** 
 * @brief 自动播放策略。参考[自动播放策略](https://www.volcengine.com/docs/6348/130302)，获取更多相关信息。
 */

export declare enum RTCAutoPlayPolicy {
	/** 
	 * @brief 默认值，自动播放音频和视频
	 */
	
	AUTO_PLAY = 0,
	/** 
	 * @brief 自动播放视频，不自动播放音频
	 */
	
	VIDEO_ONLY = 1,
	/** 
	 * @brief 不自动播放，引导用户通过交互，手动播放
	 */
	
	PLAY_MANUALLY = 2
}
/**
 * @hidden
 * 发生重连的原因
 */
export declare enum ReconnectReason {
	ICE_FAILED = "iceFailed",
	NODE_CHANGE = "nodeChange",
	JOIN_TIMEOUT = "joinTimeout",
	NOTIFY_RECONNECT = "notifyReconnect"
}
/** 
 * @brief 远端用户优先级
 */

export declare enum RemoteUserPriority {
	/** 
	 * @brief 用户优先级为低（默认值）
	 */
	
	LOW = 0,
	/** 
	 * @brief 用户优先级为正常
	 */
	
	MEDIUM = 100,
	/** 
	 * @brief 用户优先级为高
	 */
	
	HIGH = 200
}
/** 
 * @brief 房间的创建模式。
 */

export declare enum RoomMode {
	/** 
	 * @brief 同时创建 RTC 房间和 RTS 房间。
	 * 在该模式下，即使用户仅使用 RTS 功能，未使用音视频功能，也会收取 RTC 音视频通话费。因为一旦进入 RTC 房间，计费即开始（至少收取纯音频通话费）。具体计费规则，请参见[音视频通话费](69871)。
	 */
	
	ROOM_MODE_RTC = 0,
	/** 
	 * @brief 仅创建 RTS 房间。
	 * 该模式下，以下接口会被禁止调用：`setUserVisibility`、`setAudioSelectionConfig`、`publishStream`、`unpublishStream`、`subscribeStream`、`unsubscribeStream`、`pauseAllSubscribedStream`、`resumeAllSubscribedStream`、`startForwardStreamToRooms`、`updateForwardStreamToRooms`、`stopForwardStreamToRooms`、`pauseForwardStreamToAllRooms`、`resumeForwardStreamToAllRooms`、`publishScreen`、`unpublishScreen`、`subscribeScreen`、`unsubscribeScreen`、`startLiveTranscoding`、`updateLiveTranscoding`、`stopLiveTranscoding`、`sendSEIMessage`、`startSubtitle`、`stopSubtitle`、`updateSubtitleConfig`。
	 * 如果你只需要 RTS 功能，推荐通过集成 [RTS SDK](1162275) 创建应用。目前已支持 Android、iOS 以及 Web 端。
	 */
	
	ROOM_MODE_RTS_ONLY = 1
}
/** 
 * @brief 房间模式
 *        调用 [joinRoom](104478#joinroom) 时，根据所需场景，选择合适的房间模式，应用不同的音视频算法、视频参数和网络配置
 *        如果需要设置音频参数，应调用 [setAudioProfile](104478#setaudioprofile) 进行配置
 */

export declare enum RoomProfileType {
	/** 
	 * @brief 默认场景，普通音视频通话模式，例如，语音聊天室
	 */
	
	communication = 0,
	/** 
	 * @brief 适用于 1 vs 1 音视频通话
	 */
	
	chat = 5,
	/** 
	 * @brief 适用于 2 人以上纯语音通话
	 */
	
	chatRoom = 6,
	/** 
	 * @brief 适用于直播中主播之间连麦的业务场景
	 */
	
	coHost = 9,
	/** 
	 * @brief 适用于云端会议中的个人设备
	 */
	
	meeting = 16,
	/** 
	 * @brief 适用于课堂互动，房间内同时进行音视频互动的人数大于 9 人
	 */
	
	classRoom = 18
}
/** 
 * @brief 字幕模式。
 */

export declare enum SUBTITLE_MODE {
	/** 
	 * @brief 识别模式。在此模式下，房间内用户语音会被转为文字。
	 */
	
	ASR_ONLY = 0,
	/** 
	 * @brief 翻译模式。在此模式下，房间内用户语音会先被转为文字，再被翻译为目标语言。
	 */
	
	ASR_AND_TRANSLATION = 1
}
/** 
 * @brief 订阅大小流偏好
 */

export declare enum SimulcastStreamType {
	/** 
	 * @brief 大流
	 */
	
	VIDEO_STREAM_HIGH = "high",
	/** 
	 * @brief 中流
	 */
	
	VIDEO_STREAM_MID = "mid",
	/** 
	 * @brief 小流
	 */
	
	VIDEO_STREAM_LOW = "low"
}
/** 
 * @brief 流属性
 */

export declare enum StreamIndex {
	/** 
	 * @brief 主流。包括：通过默认摄像头/麦克风采集到的视频/音频;
	 */
	
	STREAM_INDEX_MAIN = 0,
	/** 
	 * @brief 屏幕流。共享的视频流，或来自声卡的本地播放音频流。
	 */
	
	STREAM_INDEX_SCREEN = 1
}
/** 
 * @brief 房间内远端流移除原因。
 */

export declare enum StreamRemoveReason {
	/** 
	 * @brief 远端用户停止发布流。
	 */
	
	STREAM_REMOVE_REASON_UNPUBLISH = 0,
	/** 
	 * @brief 远端用户发布流失败。
	 */
	
	STREAM_REMOVE_REASON_PUBLISH_FAILED = 1,
	/** 
	 * @brief 保活失败。
	 */
	
	STREAM_REMOVE_REASON_KEEP_LIVE_FAILED = 2,
	/** 
	 * @brief 远端用户断网。
	 */
	
	STREAM_REMOVE_REASON_CLIENT_DISCONNECTED = 3,
	/** 
	 * @brief 远端用户重新发布流。
	 */
	
	STREAM_REMOVE_REASON_REPUBLISH = 4,
	/** 
	 * @brief 其他原因。
	 */
	
	STREAM_REMOVE_REASON_OTHER = 5,
	/** 
	 * @brief Token 发布权限过期。
	 */
	
	STREAM_REMOVE_REASON_TOKEN_PRIVILEGE_EXPIRED = 6
}
/** 
 * @brief 订阅端音视频流回退选项。
 */

export declare enum SubscribeFallbackOption {
	/** 
	 * @brief 不开启回退功能。默认设置。
	 */
	
	DISABLE = 0,
	/** 
	 * @brief 下行网络不佳时，对视频流做降级处理。
	 * 该设置仅对发布端开启 Simulcast 功能时生效。参见[使用 Simulcast 功能](https://www.volcengine.com/docs/6348/1359024)。
	 */
	
	VIDEO_STREAM_LOW = 1,
	/** 
	 * @brief 下行网络不佳时，取消接收视频，仅接收音频。
	 *        当发布端开启发送多路流功能时，设置此选项不利于提升用户体验，因此不建议设置此选项。
	 */
	
	AUDIO_ONLY = 2
}
/** 
 * @brief 订阅模式选项。业务方在加入房间前，调用 enableAutoSubscribe 接口（已废弃）设置订阅模式。
 */

export declare enum SubscribeMode {
	/** 
	 * @brief 自动订阅模式。SDK 会自动为用户订阅房间中的每一路流。默认值。
	 */
	
	AUTO_SUBSCRIBE_MODE = 0,
	/** 
	 * @brief 手动订阅模式。SDK 不为自动订阅流。调用 [subscribeUserStream](104478#subscribeuserstream) 手动订阅。
	 */
	
	MANUAL_SUBSCRIBE_MODE = 1
}
/** 
 * @brief 音视频流订阅结果
 */

export declare enum SubscribeState {
	/** 
	 * @brief 更新订阅状态成功
	 */
	
	SUBSCRIBE_SUCC = 0,
	/** 
	 * @brief 更新订阅状态失败
	 */
	
	SUBSCRIBE_FAIL = 1
}
/** 
 * @brief 字幕任务状态类型。
 */

export declare enum SubtitleEventType {
	/** 
	 * @brief 字幕已开启。
	 */
	
	STARTED = 0,
	/** 
	 * @brief 字幕已关闭。
	 */
	
	STOPPED = 1,
	/** 
	 * @brief 字幕任务出现错误。
	 */
	
	ERROR = 2,
	/** 
	 * @brief 字幕翻译配置已更新。
	 */
	
	UPDATED = 3
}
/** 
 * @brief <span id="transcoding_video_codec"></span>
 *        视频编码格式。
 */

export declare enum TRANSCODING_VIDEO_CODEC {
	/** 
	 * @brief H.264 格式，默认值。
	 */
	
	H264 = "H264",
	/** 
	 * @brief ByteVC1 格式。
	 */
	
	H265 = "H265"
}
/** 
 * @brief <span id="user_online_status"></span>
 *        登录状态
 */

export declare enum USER_ONLINE_STATUS {
	/** 
	 * @brief 离线。无法收发点对点消息。
	 */
	
	OFFLINE = 0,
	/** 
	 * @brief 在线
	 */
	
	ONLINE = 1,
	/** 
	 * @brief 未知。无法收发点对点消息。
	 */
	
	UNREACHABLE = 2
}
export declare enum UserDisconnectionTag {
	/** 用户正常离房 */
	userLeave = "userLeave",
	/** 用户因为断网离房 */
	connectionLost = "connectionLost",
	/** 因同userId重复登录房间导致被挤出 */
	userDuplicateLogin = "userDuplicateLogin",
	/** 因openAPI接口实现踢人将用户踢出房间 */
	kickedByAdmin = "kickedByAdmin",
	roleChanged = "roleChanged",
	/** 由于token过期离开房间 */
	onUserTokenDidExpire = "onUserTokenDidExpire"
}
/** 
 * @brief 远端用户离开房间的原因
 */

export declare enum UserOfflineReason {
	/** 
	 * @brief 远端用户调用 `leaveRoom` 主动退出房间。
	 */
	
	QUIT = 0,
	/** 
	 * @brief 远端用户因 Token 过期或网络原因等掉线。
	 */
	
	DROPPED = 1,
	/** 
	 * @brief 远端用户调用 `setUserVisibility` 切换至不可见状态。
	 */
	
	SWITCH_TO_INVISIBLE = 2,
	/** 
	 * @brief 服务端调用 OpenAPI 将远端用户踢出房间。
	 */
	
	KICKED_BY_ADMIN = 3
}
/** 
 * @hidden for internal use only
 * @brief 编码优先级。
 */

export declare enum VideoCodecType {
	/** 
	 * @brief 不指定编解码格式。SDK 会根据当前视频流的分辨率、设备性能自动匹配适合的编解码格式。
	 */
	
	AUTO = "auto",
	/** 
	 * @brief H.264
	 */
	
	H264 = "h264",
	/** 
	 * @brief VP8
	 */
	
	VP8 = "vp8",
	/**
	 * @hidden
	 */
	ByteVC1 = "ByteVC1"
}
/** 
 * @brief 渲染模式
 */

export declare enum VideoRenderMode {
	/** 
	 * @brief （主流默认值）视窗填满优先。
	 *        视频帧等比缩放，直至视窗被视频填满。如果视频帧长宽比例与视窗不同，视频帧的多出部分将无法显示。
	 */
	
	RENDER_MODE_HIDDEN = 0,
	/** 
	 * @brief （屏幕流默认值）视频帧内容全部显示优先。
	 *        视频帧等比缩放，直至视频帧能够在视窗上全部显示。如果视频帧长宽比例与视窗不同，视窗上会出现未被填满的透明区域。
	 */
	
	RENDER_MODE_FIT = 1,
	/** 
	 * @brief 视窗填满并显示视频全部内容。
	 *        视频帧非等比缩放，拉伸至填满视窗区域。
	 */
	
	RENDER_MODE_FILL = 2
}
/** 
 * @brief 发布大小流模式
 */

export declare enum VideoSimulcastMode {
	/** 
	 * @brief 单流模式。始终只有 1 路分辨率的流。
	 */
	
	VIDEO_ONLY_ONE = 0,
	/** 
	 * @brief 按需订阅模式。发送端会根据订阅端的状态，按需发布。无订阅偏好设置默认发送 2 路。
	 */
	
	VIDEO_ON_DEMAND = 1,
	/** 
	 * @brief 多流模式。发送端始终按照设置的参数发布所有大小流。默认发送 2 路。
	 */
	
	VIDEO_ALWAYS_SIMULCAST = 2
}
/** 
 * @brief 视频采集方式
 */

export declare enum VideoSourceType {
	/** 
	 * @brief 自定义采集
	 */
	
	VIDEO_SOURCE_TYPE_EXTERNAL = 0,
	/** 
	 * @brief 内部采集，使用由 SDK 提供的视频采集模块（默认）
	 */
	
	VIDEO_SOURCE_TYPE_INTERNAL = 1
}
/** 
 * @brief WTN 流播放事件
 */

export declare enum WTNPlayState {
	/** 
	 * @brief 初始，调用 startPlayWtn 后，状态由 INIT 变为 START。
	 */
	
	INIT = 0,
	/** 
	 * @brief 开始。
	 */
	
	START = 1,
	/** 
	 * @brief 成功。
	 */
	
	SUCCESS = 2,
	/** 
	 * @brief 停止。
	 */
	
	STOP = 3,
	/** 
	 * @brief 推流失败。
	 */
	
	FAIL = 4
}
/** 
 * @brief 播放 WTN 流状态变化原因
 */

export declare enum WTNPlayStateChangedReason {
	/** 
	 * @brief 成功。
	 */
	
	PLAY_SUCCESS = 0,
	/** 
	 * @brief 主动调用 startPlayWtn。
	 */
	
	START_PLAY = 1,
	/** 
	 * @brief 主动调用 stopPlayWtn。
	 */
	
	STOP_PLAY = 2,
	/** 
	 * @brief 发布端主动停止。
	 */
	
	REMOTE_STOP = 3,
	/** 
	 * @brief 发布端主动停止。
	 */
	
	REMOTE_FAILURE = 4,
	/** 
	 * @brief 流被封禁。
	 */
	
	STREAM_BANNED = 5,
	/** 
	 * @brief token 无订阅权限。
	 */
	
	NO_PLAY_PERMISSION = 6,
	/** 
	 * @brief 远端流不存在。
	 */
	
	STREAM_NOT_EXIST = 7,
	/** 
	 * @brief 网络错误重试
	 */
	
	IN_RETRY = 8,
	/** 
	 * @brief 重试失败，重试三次后报此错误。
	 */
	
	RETRY_FAIL = 9,
	/** 
	 * @brief 内部原因（目前包含服务端三个上限错误）
	 */
	
	INTERNAL = 10,
	/** 
	 * @brief 超出单端订阅上限，一个引擎实例最多拉5路流
	 */
	
	OVER_CLIENT_SUBSCRIBE_STREAM_LIMIT = 1310,
	/** 
	 * @brief 超出单流订阅人数上限，当前未配置限制
	 */
	
	OVER_STREAM_SUBSCRIBE_USER_LIMIT = 1311,
	/** 
	 * @brief 超出单流订阅请求 QPS 上限，当前未配置限制
	 */
	
	OVER_STREAM_SUBSCRIBE_REQUES_TLIMIT = 1312
}
/** 
 * @brief 客户端发布 WTN 流任务状态
 */

export declare enum WTNPushState {
	/** 
	 * @brief 初始，调用 startPushWtn 后，状态由 init 变为 start。
	 */
	
	INIT = 0,
	/** 
	 * @brief 开始。
	 */
	
	START = 1,
	/** 
	 * @brief 成功。
	 */
	
	SUCCESS = 2,
	/** 
	 * @brief 停止。
	 */
	
	STOP = 3,
	/** 
	 * @brief 推流失败。
	 */
	
	FAIL = 4
}
/** 
 * @brief 客户端发布 WTN 流任务状态变化原因
 */

export declare enum WTNPushStateChangedReason {
	/** 
	 * @brief 成功。
	 */
	
	PUSH_SUCCESS = 0,
	/** 
	 * @brief 主动调用 [startPushWTN](104478#wtnstream-startpushwtn)。
	 */
	
	START_PUSH = 1,
	/** 
	 * @brief 主动调用 [stopPushWTN](104478#wtnstream-stoppushwtn)。
	 */
	
	STOP_PUSH = 2,
	/** 
	 * @brief 网络错误重试
	 */
	
	IN_RETRY = 3,
	/** 
	 * @brief 重试失败，重试三次后报此错误。
	 */
	
	RETRY_FAIL = 4,
	/** 
	 * @brief token 无发布权限
	 */
	
	NO_PUSH_PERMISSION = 5,
	/** 
	 * @brief 相同 stream_id 流被挤占
	 */
	
	STREAM_PUSH_BY_OTHER = 6
}
/** 
 * @brief 远端 WTN 流音频状态
 */

export declare enum WTNRemoteAudioState {
	/** 
	 * @brief 初始状态。在 ReasonMute 和 ReasonRemotestop 情况下，报告该状态。
	 */
	
	STOPED = 0,
	/** 
	 * @brief 本地用户已接收远端视频首包
	 */
	
	STARTING = 1,
	/** 
	 * @brief 远端视频流正在解码，正常播放
	 */
	
	DECODING = 2,
	/** 
	 * @brief 远端视频流卡顿
	 */
	
	FROZEN = 3,
	/** 
	 * @brief 拉流发生error，reason=internal，不对外
	 */
	
	FAILED = 4
}
/** 
 * @brief 远端 WTN 流音频状态变化原因
 */

export declare enum WTNRemoteAudioStateChangeReason {
	/** 
	 * @brief 内部原因。
	 */
	
	INTERNAL = 0,
	/** 
	 * @brief 网络阻塞。
	 */
	
	NETWORK_CONGESTION = 1,
	/** 
	 * @brief 网络恢复正常。
	 */
	
	NETWORK_RECOVERY = 2,
	/** 
	 * @brief 本地订阅远端流。
	 */
	
	UNMUTE = 3,
	/** 
	 * @brief 本地取消订阅远端流。
	 */
	
	MUTE = 4,
	/** 
	 * @brief 远端流发布。
	 */
	
	REMOTE_START = 5,
	/** 
	 * @brief 远端流停止发布。
	 */
	
	REMOTE_STOP = 6
}
/** 
 * @brief 远端 WTN 流视频状态
 */

export declare enum WTNRemoteVideoState {
	/** 
	 * @brief 初始状态。在 ReasonMute 和 ReasonRemotestop 情况下，报告该状态。
	 */
	
	STOPED = 0,
	/** 
	 * @brief 本地用户已接收远端视频首包
	 */
	
	STARTING = 1,
	/** 
	 * @brief 远端视频流正在解码，正常播放
	 */
	
	DECODING = 2,
	/** 
	 * @brief 远端视频流卡顿
	 */
	
	FROZEN = 3,
	/** 
	 * @brief 拉流发生error，reason=internal，不对外
	 */
	
	FAILED = 4
}
/** 
 * @brief 远端 WTN 流视频状态变化原因
 */

export declare enum WTNRemoteVideoStateChangeReason {
	/** 
	 * @brief 内部原因。
	 */
	
	INTERNAL = 0,
	/** 
	 * @brief 网络阻塞。
	 */
	
	NETWORK_CONGESTION = 1,
	/** 
	 * @brief 网络恢复正常。
	 */
	
	NETWORK_RECOVERY = 2,
	/** 
	 * @brief 本地订阅远端流。
	 */
	
	UNMUTE = 3,
	/** 
	 * @brief 本地取消订阅远端流。
	 */
	
	MUTE = 4,
	/** 
	 * @brief 远端流发布。
	 */
	
	REMOTE_START = 5,
	/** 
	 * @brief 远端流停止发布。
	 */
	
	REMOTE_STOP = 6
}
/** 
 * @brief WTN 流事件
 */

export declare enum WTNStreamEventsTypes {
	onWTNPushStateChanged = "onWTNPushStateChanged",
	onWTNPlayStateChanged = "onWTNPlayStateChanged",
	onWTNRemoteAudioStateChanged = "onWTNRemoteAudioStateChanged",
	onWTNRemoteVideoStateChanged = "onWTNRemoteVideoStateChanged",
	onWTNRemoteVideoStats = "onWTNRemoteVideoStats",
	onWTNRemoteAudioStats = "onWTNRemoteAudioStats",
	onWTNFirstRemoteVideoFrameDecoded = "onWTNFirstRemoteVideoFrameDecoded",
	onWTNSEIMessageReceived = "onWTNSEIMessageReceived"
}
/** 
 * @brief Electron 框架下屏幕共享源对象。
 */

export declare interface ElectronDesktopCapturerSource {
	/** 
	 * @brief 唯一标识。
	 */
	
	id: string;
	/** 
	 * @brief 共享源名称。
	 */
	
	name: string;
	/** 
	 * @brief 缩略图。
	 */
	
	thumbnail: IElectronNativeImage;
}
export declare type RTCExtension = any;
/** 
 * @brief 音频帧数据结构体
 */

export interface AudioFrameData {
	/** 
	 * @brief 音频帧 PCM 数据
	 */
	
	channels: Float32Array[];
	/** 
	 * @brief 声道数
	 */
	
	channelCount: number;
	/** 
	 * @brief 采样率，单位为 Hz。
	 */
	
	sampleRate: number;
}
/** 
 * 音频混音文件播放状态改变事件
 */

export interface AudioMixingStateChangedEvent {
	/** 
	 * @brief 混音 ID
	 */
	
	mixId: number;
	/** 
	 * @brief 混音状态
	 */
	
	state: AudioMixingState;
	/** 
	 * @brief 混音错误
	 */
	
	error: AudioMixingError;
}
/** 
 * @brief 音频播放器信息
 */

export interface AudioPlayerOption {
	/** 
	 * @brief 用户 ID
	 */
	
	userId: string;
	/** 
	 * @brief DOM
	 */
	
	renderDom?: string;
}
/** 
 * @brief 音频信息提示的相关配置
 */

export interface AudioPropertiesConfig {
	/** 
	 * @brief 信息提示间隔，单位：ms，默认为 100ms </br>
	 *     &ensp;  + `≤0`: 关闭信息提示
	 *     &ensp;  + `(0,100)`: 不合法的interval 值，SDK 自动设置为 100ms
	 *     &ensp;  + `≥100`: 开启信息提示，并将信息提示间隔设置为此值
	 */
	
	interval?: number;
	/** 
	 * @brief 是否在页面隐藏时保持开启获取音量回调，默认保持开启。
	 *        + true: 保持开启
	 *        + false：关闭
	 */
	
	enableInBackground?: boolean;
	/** 
	 * @brief 本地主流音量回调模式。
	 */
	
	localMainReportMode?: LocalMainReportMode;
	/** 
	 * @brief 本地主流音量回调的数据范围，控制回调中是否包含混音。
	 */
	
	audioReportMode?: AudioReportMode;
}
/** 
 * @brief 音频属性信息
 */

export interface AudioPropertiesInfo {
	/** 
	 * @brief 线性音量，与原始音量呈线性关系，数值越大，音量越大。取值范围是：[0,255]。<br>
	 *        - [0, 25]：近似无声 <br>
	 *        - [26, 75]: 低音量 <br>
	 *        - [76, 204]: 中音量 <br>
	 *        - [205, 255]: 高音量 <br>
	 */
	
	linearVolume: number;
	/** 
	 * @brief 非线性音量。由原始音量的对数值转化而来，因此在中低音量时更灵敏，可以用作 Active Speaker（房间内最活跃用户）的识别。取值范围是：[-127，0]，单位 dB。 <br>
	 *        - [-127, -60]：近似无声 <br>
	 *        - [-59, -40]: 低音量 <br>
	 *        - [-39, -20]: 中音量 <br>
	 *        - [-19, 0]: 高音量 <br>
	 */
	
	nonlinearVolume: number;
}
/** 
 * @brief 音频流发布封禁/解禁事件
 */

export interface AudioStreamBannedEvent {
	/** 
	 * @brief 被禁用/解禁的音频流用户 ID
	 */
	
	uid: string;
	/** 
	 * @brief 音频流发布状态
	 *        true：音频流发布被禁止
	 *        false: 音频流发布被解禁
	 */
	
	banned: boolean;
}
/** 
 * @brief 声音音量信息。包含每个说话者的用户 id 和音量信息
 */

export interface AudioVolumeInfo {
	/** 
	 * @brief 说话者的用户 id
	 */
	
	userId: string;
	/** 
	 * @brief 说话者的音量，范围为 0（最低）- 255（最高）
	 */
	
	volume: number;
}
/** 
 * @brief 自动播放失败事件
 */

export interface AutoPlayFailedEvent {
	/** 
	 * @brief 自动播放失败的流所属的用户 ID。不带此参数时表示本地流播放失败。
	 */
	
	userId: string;
	/** 
	 * @brief 自动播放失败的媒体类型
	 *        例如，当同一用户的视频流和音频流自动播放都失败时，将触发两次 `onAutoPlayFailed` 回调，分别包含 `audio` 和 `video` 参数。
	 */
	
	kind: "audio" | "video";
	/** 
	 * @brief 视频流属性。
	 */
	
	streamIndex: StreamIndex;
	/** 
	 * @brief 远端媒体流的类型
	 */
	
	mediaType: MediaType.AUDIO | MediaType.VIDEO;
	/** 
	 * @brief 播放器 ID。空值为默认播放器。
	 */
	
	playerId?: string;
	/** 
	 * @brief 是否开启耳返音频。耳返的音频是否经过前处理。
	 */
	
	position?: EarMonitorPosition;
}
/** 
 * @brief SDK 成功连接云代理服务器事件。
 */

export interface CloudProxyConnectedEvent {
	/** 
	 * @brief SDK 开启云代理后，加入频道的耗时。
	 */
	
	interval: number;
}
/** 
 * @brief 云代理服务器信息
 */

export interface CloudProxyInfo {
	/** 
	 * @brief 埋点日志上报的的代理地址
	 */
	
	logProxy: string;
	/** 
	 * @brief 统一接入的代理地址
	 */
	
	accessProxy: string | string[];
	/** 
	 * @brief RTC 配置下发的代理地址
	 */
	
	configProxy: string;
}
/** 
 * @brief 连接状态改变
 */

export interface ConnectionStateChangeEvent {
	/** 
	 * @brief 内部连接状态
	 */
	
	state: ConnectionState;
	/** 
	 * @hidden
	 * @brief 重连原因
	 */
	
	reason?: ReconnectReason;
}
export interface CoreConfigType {
	UPLOAD_CONSOLE_ON: boolean;
	UPLOAD_CONSOLE_LENGTH_CUT: number;
	UPLOAD_REPORT_LIMIT: number;
	ENABLE_REPORT_IDB_BUFFER: boolean;
}
/** 
 * @brief 音频或视频媒体设备（例如摄像头、麦克风、扬声器）的信息及连接状态。
 */

export interface DeviceInfo {
	/** 
	 * @brief 设备信息，包括设备ID、类型等。具体请参见 [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo)。
	 */
	
	mediaDeviceInfo: MediaDeviceInfo;
	/** 
	 * @brief 设备状态:
	 *        - active：设备已连接。
	 *        - inactive：设备已断开连接。
	 */
	
	deviceState: "active" | "inactive";
}
/** 
 * @brief 引擎级别配置项
 */

export interface EngineConfig {
	/** 
	 * @brief 自动播放策略
	 */
	
	autoPlayPolicy?: RTCAutoPlayPolicy;
	/** 
	 * @hidden
	 * @brief 私有参数，用于指定服务器节点
	 */
	
	expectedIDC?: string;
}
export interface ExtraJoinRoomParams {
	serviceType?: string;
	tenantId?: string;
	[key: string]: any;
}
/** 
 * @brief 跨房间转发媒体流信息。
 */

export interface ForwardStreamInfo {
	/** 
	 * @brief 跨房间转发媒体流的目标房间 ID。
	 */
	
	roomId: string;
	/** 
	 * @brief 使用目标房间 roomId 和 userId 生成的 Token。
	 *        测试时可使用[控制台](https://console.volcengine.com/rtc/listRTC)生成的临时 Token，正式上线需要使用密钥 SDK 在你的服务端生成并下发 Token。
	 */
	
	token: string;
}
/** 
 * @brief 跨房间转发媒体流状态信息。
 */

export interface ForwardStreamStateInfo {
	/** 
	 * @brief 跨房间转发媒体流的目标房间 ID。
	 */
	
	roomId: string;
	/** 
	 * @brief 跨房间转发媒体流状态。
	 */
	
	state: ForwardStreamState;
	/** 
	 * @brief 跨房间转发媒体流错误码。
	 */
	
	error: ForwardStreamError;
}
/**
 * @id AudioMixingManager
 * @list overview
 * @detail api
 */

export interface IAudioMixingManager {
	/** 
	 * @brief 开启混音
	 * @param id  混音 ID。
	 *     混音 ID 用于标识混音，请保证混音 ID 唯一性。
	 * @param filePath 指定需要混音的音频文件的绝对路径，支持音频文件格式有: mp3，aac等
	 * @param options 混音配置
	 *        可以设置混音的播放次数、是否本地播放混音、以及是否将混音发送至远端
	 * @return `LOAD_RESOURCES_FAILED`: 资源加载失败。请传入正确的资源路径。
	 * @notes + 如果已经通过 [preloadAudioMixing](#preloadaudiomixing) 加载音效，确保此处的 `ID` 与上次调用 [preloadAudioMixing](#preloadaudiomixing) 设置的 `ID` 相同。
	 *       + 如果使用相同的 `ID` 重复调用本方法，前一次混音会停止，后一次混音开始
	 *       + 开始播放音频文件后，可以调用 [stopAudioMixing](#stopaudiomixing) 方法停止播放音频文件。
	 *       + 本方法的混音数据来源于外部文件，而 [enableAudioMixingBuffer](#enableaudiomixingbuffer) 的混音数据来源于外部缓存且音频格式为 PCM，这两种混音方式可以共存。
	 * @group Audio Mixing
	 * @order 5
	 */
	
	startAudioMixing: (id: number, filePath: string, options: MixOption) => Promise<void>;
	/** 
	 * @brief 停止播放音频文件
	 * @param id 混音 ID
	 * @notes + 调用 [startAudioMixing](#startaudiomixing) 方法开始播放音频文件后，可以调用本方法停止播放音频文件。
	 *        + 调用本方法停止播放音频文件后，该音频文件会被自动卸载。
	 * @group Audio Mixing
	 * @order 6
	 */
	
	stopAudioMixing: (id: number) => void;
	/** 
	 * @brief 暂停播放音频文件
	 * @param id 混音 ID
	 * @notes + 调用 [startAudioMixing](#startaudiomixing) 方法开始播放音频文件后，可以通过调用本方法暂停播放音频文件。
	 *       + 调用本方法暂停播放音频文件后，可调用 [resumeAudioMixing](#resumeaudiomixing) 方法恢复播放及混音。
	 * @group Audio Mixing
	 * @order 7
	 */
	
	pauseAudioMixing: (id: number) => void;
	/** 
	 * @brief 恢复播放音频文件
	 * @param id 混音 ID
	 * @notes 调用 [pauseAudioMixing](#pauseaudiomixing) 方法暂停播放音频文件后，可以通过调用本方法恢复播放及混音。
	 * @group Audio Mixing
	 * @order 8
	 */
	
	resumeAudioMixing: (id: number) => void;
	/** 
	 * @brief 预加载指定音频文件到内存中
	 * @param id 混音 ID。用于标识混音，请保证混音 ID 唯一性。
	 *        如果使用相同的 ID 重复调用本方法，后一次会覆盖前一次。
	 *        如果先调用 [startAudioMixing](#startaudiomixing)，再使用相同的 ID 调用本方法 ，会上一个混音停止，然后加载后一个混音。
	 *        使用一个 ID 调用本方法预加载 A.mp3 后，如果需要使用相同的 ID 调用 [startAudioMixing](#startaudiomixing) 播放 B.mp3，请先调用 [unloadAudioMixing](#unloadaudiomixing) 卸载 A.mp3 ，否则会报错 AUDIO_MIXING_ERROR_LOAD_CONFLICT。
	 * @param filePath 用于混音文件路径。可以是本地文件的绝对路径，支持音频文件格式有: mp3，aac等
	 * @return `LOAD_RESOURCES_FAILED`: 资源加载失败。请传入正确的资源路径。
	 * @notes + 需要频繁播放某个音频文件的时候，调用本方法预加载该文件，在播放的时候可以只加载一次该文件，减少 CPU 占用。
	 *       + 本方法只是预加载指定音频文件，只有调用 [startAudioMixing](#startaudiomixing) 方法才开始播放指定音频文件。
	 *       + 调用本方法预加载的指定音频文件可以通过 [unloadAudioMixing](#unloadaudiomixing) 卸载。
	 * @group Audio Mixing
	 * @order 9
	 */
	
	preloadAudioMixing: (id: number, filePath: string) => Promise<void>;
	/** 
	 * @brief 卸载指定音频文件
	 * @param id 混音 ID
	 * @group Audio Mixing
	 * @order 10
	 */
	
	unloadAudioMixing: (id: number) => void;
	/** 
	 * @brief 调节音频文件混音的音量大小。
	 * @param id 混音 ID
	 * @param volume 混音音量相对原音量的比值。范围为 `[0, 400]`，建议范围是 `[0, 100]`。
	 *        + 0：静音
	 *        + 100：原始音量（默认值）
	 *        + 400: 最大可调音量 (自带溢出保护)
	 * @group Audio Mixing
	 * @order 16
	 */
	
	setAudioMixingVolume: (id: number, volume: number) => void;
	/** 
	 * @brief 获取音频文件的音量
	 * @param id 混音 ID
	 * @return + `0`: 获取失败
	 *         + `>0`: 成功，音量值
	 * @group Audio Mixing
	 * @order 15
	 */
	
	getAudioMixingVolume: (id: number) => number;
	/** 
	 * @brief 获取音频文件时长
	 * @param id  混音 ID
	 * @return + `> 0`: 成功, 音频文件时长，单位为毫秒。
	 *         + `< 0`: 失败
	 * @notes 调用本方法获取音频文件时长前，需要先调用 [preloadAudioMixing](#preloadaudiomixing) 或 [startAudioMixing](#startaudiomixing)。
	 * @group Audio Mixing
	 * @order 20
	 */
	
	getAudioMixingDuration: (id: number) => number;
	/** 
	 * @brief 获取音频文件播放进度
	 * @param id  混音 ID
	 * @return + `> 0`: 成功, 音频文件播放进度，单位为毫秒。
	 *         + `< 0`: 失败
	 * @notes 调用本方法获取音频文件播放进度前，需要先调用 [startAudioMixing](#startaudiomixing) 开始播放音频文件。
	 * @group Audio Mixing
	 * @order 25
	 */
	
	getAudioMixingCurrentPosition: (id: number) => number;
	/** 
	 * @brief 设置音频文件的起始播放位置
	 * @param id 混音 ID
	 * @param position 音频文件起始播放位置，单位为毫秒。
	 *        你可以通过 [getAudioMixingDuration](#getaudiomixingduration) 获取音频文件总时长，position 的值不得大于音频文件总时长。
	 * @notes + 调用本方法你可以根据实际情况从指定的位置播放音频文件，无需从头到尾完整播放一个音频文件。
	 *        + 调用本方法设置音频文件起始播放位置前，需要先调用 [startAudioMixing](#startaudiomixing) 开始播放音频文件。
	 * @group Audio Mixing
	 * @order 26
	 */
	
	setAudioMixingPosition: (id: number, position: number) => void;
	/** 
	 * @brief 开关混音音频帧 PCM 数据回调。
	 * @param id 混音 ID
	 * SDK 将在该混音开启后开始回调音频数据。
	 * @param callback 接收音频数据的回调函数，为空表示关闭数据回调。
	 * 用户断网时，音频数据为 0。
	 * @param frameSize 每个音频帧包含的采样点数。frameSize 越大，每次回调的音频数据越多，回调间隔越长。
	 * 可设置为 256, 512, 1024, 2048, 4096, 8192, 16384。如无特殊需求，建议使用默认值 4096。
	 * @note + 创建引擎后即可调用，混音开启后你将收到回调。
	 * + 进退房不会清除回调开关状态。
	 * @group Audio Mixing
	 * @order 45
	 */
	
	setAudioFrameCallback: (id: number, callback?: (data: AudioFrameData) => void, frameSize?: number) => void;
	/** 
	 * @brief 启动 PCM 音频数据混音
	 * @param type 混音类型。是否本地播放、以及是否发送到远端
	 * @notes + 必须先调用本方法启动 PCM 音频数据混音，随后调用 [pushAudioMixingBuffer](#pushaudiomixingbuffer) 方法，才会开始混音。
	 *       + 如要结束 PCM 音频数据混音，使用 [disableAudioMixingBuffer](#disableaudiomixingbuffer)。
	 * @group Audio Mixing
	 * @order 30
	 */
	
	enableAudioMixingBuffer: (type: AudioMixingType) => void;
	/** 
	 * @brief 关闭 PCM 混音
	 * @group Audio Mixing
	 * @order 31
	 *
	 */
	
	disableAudioMixingBuffer: () => void;
	/** 
	 * @brief 推送 PCM 音频数据用于混音
	 * @param buffer 音频缓冲池，详见[浏览器文档](https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer)
	 * @notes 调用该方法前，须通过 [enableAudioMixingBuffer](#enableaudiomixingbuffer) 启动外部音频流混音。
	 * @group Audio Mixing
	 * @order 32
	 */
	
	pushAudioMixingBuffer: (buffer: AudioBuffer) => void;
}
/**
 * @hidden
 */
export interface IBLWRTCEngine extends IRTCEngine {
	/** 
	 * @hidden
	 * @brief 设置是单流渲染或者正常渲染模式
	 * @param streamIndex 视频流类型 默认为 StreamIndex.STREAM_INDEX_SCREEN
	 * @notes 只能在进房之前调用
	 */
	setRemoteScreenVideoStreamIndex: (streamIndex: StreamIndex) => boolean;
}
/** 
 * @brief 在 Electron 框架下屏幕共享源的缩略图
 */

export interface IElectronNativeImage {
	/** 
	 * @brief base 64 编码 Data URL 字符串。参见 [nativeImage](http://electron.atom.io/docs/api/native-image)。
	 */
	
	toDataURL: () => string;
}
/** 
 * @id EngineEvents
 * @list overview
 * @detail callback
 */

export interface IEngineEvents {
	/** 
	 * @brief 播放器事件
	 * @param event
	 * @group Video Management
	 * @order 65
	 */
	
	[EngineEventsTypes.onPlayerEvent]: (event: PlayerEvent) => void;
	/** 
	 * @brief 远端可见用户加入房间，或房内不可见用户切换为可见的回调
	 * @param event
	 * @group Room Management
	 * @order 30
	 */
	
	[EngineEventsTypes.onUserJoined]: (event: onUserJoinedEvent) => void;
	/** 
	 * @brief 远端可见用户离开房间，或房内可见用户切换为隐身的回调
	 * @param event
	 * @group Room Management
	 * @order 31
	 */
	
	[EngineEventsTypes.onUserLeave]: (event: onUserLeaveEvent) => void;
	/** 
	 * @brief 连接状态发生变化
	 * @param event
	 * @group Room Management
	 * @order 35
	 */
	
	[EngineEventsTypes.onConnectionStateChanged]: (event: ConnectionStateChangeEvent) => void;
	/** 
	 * @hidden
	 * @brief Vendor ICE 连接状态发生变化
	 * @param event
	 */
	
	[EngineEventsTypes.onVendorConnectionStateChanged]: (event: VendorConnectionStateChangeEvent) => void;
	/** 
	 * @brief 房间内新增远端摄像头/麦克风采集音视频流的回调。
	 * @param event
	 * @notes 当房间内的远端用户调用 [publishStream](104478#publishstream) 成功发布由摄像头/麦克风采集的媒体流时，本地用户会收到该回调，此时本地用户可以自行选择是否调用 [subscribeStream](104478#subscribestream) 订阅此流。
	 * @group Audio & Video Transport
	 * @order 60
	 */
	
	[EngineEventsTypes.onUserPublishStream]: (event: {
		/** 
		 * @brief 远端流发布用户的用户 ID
		 */
		
		userId: string;
		/** 
		 * @brief 远端媒体流的类型
		 */
		
		mediaType: MediaType;
	}) => void;
	/** 
	 * @brief 房间内远端摄像头/麦克风采集的媒体流移除的回调。
	 * @param event
	 * @notes 当房间内的远端用户调用 [unpublishStream](104478#unpublishstream) 成功取消发布由摄像头/麦克风采集的媒体流时，本地用户会收到该回调，此时本地用户可以自行选择是否调用 [unsubscribeStream](104478#unsubscribestream) 取消订阅此流。
	 * @group Audio & Video Transport
	 * @order 61
	 */
	
	[EngineEventsTypes.onUserUnpublishStream]: (event: {
		/** 
		 * @brief 移除的远端流发布用户的用户 ID
		 */
		
		userId: string;
		/** 
		 * @brief 远端媒体流的类型
		 */
		
		mediaType: MediaType;
		/** 
		 * @brief 远端流移除的原因
		 */
		
		reason: StreamRemoveReason;
	}) => void;
	/** 
	 * @brief 房间内新增远端屏幕共享音视频流的回调。
	 * @param event
	 * @notes 当房间内的远端用户调用 [publishScreen](104478#publishscreen) 成功发布来自屏幕共享的音视频流时，本地用户会收到该回调，此时本地用户可以自行选择是否调用 [subscribeScreen](104478#subscribescreen) 订阅此流。
	 * @group Screen Sharing
	 * @order 30
	 */
	
	[EngineEventsTypes.onUserPublishScreen]: (event: {
		/** 
		 * @brief 远端流发布用户的用户 ID
		 */
		
		userId: string;
		/** 
		 * @brief 远端媒体流的类型
		 */
		
		mediaType: MediaType;
	}) => void;
	/** 
	 * @brief 房间内远端屏幕共享音视频流移除的回调。
	 * @param event
	 * @notes 当房间内的远端用户调用 [unpublishScreen](104478#unpublishscreen) 成功取消发布由摄像头/麦克风采集的媒体流时，本地用户会收到该回调，此时本地用户可以自行选择是否调用 [unsubscribeScreen](104478#unsubscribescreen) 取消订阅此流。
	 * @group Screen Sharing
	 * @order 31
	 */
	
	[EngineEventsTypes.onUserUnpublishScreen]: (event: {
		/** 
		 * @brief 移除的远端流发布用户的用户 ID
		 */
		
		userId: string;
		/** 
		 * @brief 远端媒体流的类型
		 */
		
		mediaType: MediaType;
		/** 
		 * @brief 远端流移除的原因
		 */
		
		reason: StreamRemoveReason;
	}) => void;
	/** 
	 * @hidden
	 * @deprecated since 4.47, use on onRemoteVideoFirstFrame instead.
	 * @brief 视频首帧渲染
	 * @param event
	 */
	
	[EngineEventsTypes.onVideoFirstFrameRendered]: (event: onVideoFirstFrameRenderedEvent) => void;
	/** 
	 * @hidden
	 * @deprecated since 4.47, use on onRemoteVideoFirstFrame instead.
	 * @brief 视频首帧渲染
	 * @param event
	 */
	
	[EngineEventsTypes.onVideoFirstFrameDecoded]: (event: onVideoFirstFrameDecodedEvent) => void;
	/** 
	 * @brief 视频首帧渲染
	 * @param event
	 * @group Audio & Video Transport
	 * @order 65
	 */
	
	[EngineEventsTypes.onRemoteVideoFirstFrame]: (event: onVideoFirstFrameRenderedEvent) => void;
	/** 
	 * @hidden
	 * @deprecated since 4.47, use on onRemoteAudioFirstFrame instead.
	 * @brief 音频首帧解码
	 * @param event
	 */
	
	[EngineEventsTypes.onAudioFirstFrameDecoded]: (event: onAudioFirstFrameDecodedEvent) => void;
	/** 
	 * @brief 远端音频首帧播放事件
	 * @param event
	 * @group Audio & Video Transport
	 * @order 66
	 */
	
	[EngineEventsTypes.onRemoteAudioFirstFrame]: (event: onAudioFirstFrameDecodedEvent) => void;
	/** 
	 * @brief 当视频设备（即摄像头）连接状态发生改变时，会触发该回调。例如因设备拔插导致设备断开/连接。<br/>
	 * > 需要先获取设备权限（可通过 [enableDevices](104478#enabledevices) 获取），才可以收到该回调。
	 * @param event 设备信息（例如设备标识、类型等）及连接状态。
	 * @group Device Management
	 * @order 60
	 */
	
	[EngineEventsTypes.onVideoDeviceStateChanged]: (event: DeviceInfo) => void;
	/** 
	 * @brief 当音频媒体设备（即麦克风、扬声器）连接状态发生改变时，会触发该回调。例如因设备拔插导致设备断开/连接。<br/>
	 * > 需要先获取设备权限（可通过 [enableDevices](104478#enabledevices) 获取），才可以收到该回调。
	 * @param event 设备信息（例如设备标识、类型等）及连接状态。
	 * @group Device Management
	 * @order 50
	 */
	
	[EngineEventsTypes.onAudioDeviceStateChanged]: (event: DeviceInfo) => void;
	/** 
	 * @brief 断流事件，建议在回调里重新采集。
	 * @param event
	 * @group Video Management
	 * @order 75
	 */
	
	[EngineEventsTypes.onTrackEnded]: (event: {
		/** 
		 * @brief 媒体流类型，参看 [kind](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack/kind)。
		 */
		
		kind: string;
		/** 
		 * @brief 是否屏幕流
		 */
		
		isScreen: boolean;
	}) => void;
	/** 
	 * @internal
	 */
	
	[EngineEventsTypes.onTrackMute]: (event: {
		/** 
		 * @brief 类型
		 */
		
		kind: string;
		/** 
		 * @brief 是否屏幕流
		 */
		
		isScreen: boolean;
	}) => void;
	/** 
	 * @internal
	 */
	
	[EngineEventsTypes.onTrackUnmute]: (event: {
		/** 
		 * @brief 类型
		 */
		
		kind: string;
		/** 
		 * @brief 是否屏幕流
		 */
		
		isScreen: boolean;
	}) => void;
	/** 
	 * @brief 接收到房间内广播消息的事件。
	 * @param event
	 * @group Message
	 * @order 55
	 */
	
	[EngineEventsTypes.onRoomMessageReceived]: (event: {
		/** 
		 * @brief 发送消息用户的 userId
		 */
		
		userId: string;
		/** 
		 * @brief 消息内容
		 */
		
		message: any;
	}) => void;
	/** 
	 * @brief 接收到房间内二进制广播消息的事件。
	 * @param event
	 * @group Message
	 * @order 56
	 */
	
	[EngineEventsTypes.onRoomBinaryMessageReceived]: (event: {
		/** 
		 * @brief 发送消息用户的 userId
		 */
		
		userId: string;
		/** 
		 * @brief 消息内容
		 */
		
		message: ArrayBuffer;
	}) => void;
	/** 
	 * @brief 收到来自房间中其他用户通过 [sendUserMessage](104478#sendusermessage) 发来的点对点文本消息时，会收到此事件
	 * @param event
	 * @group Message
	 * @order 50
	 */
	
	[EngineEventsTypes.onUserMessageReceived]: (event: UserMessageEvent) => void;
	/** 
	 * @brief 收到来自房间中其他用户通过 sendUserBinaryMessage 发来的点对点二进制消息时，会收到此事件
	 * @param event
	 * @group Message
	 * @order 51
	 */
	
	[EngineEventsTypes.onUserBinaryMessageReceived]: (event: UserBinaryMessageEvent) => void;
	/** 
	 * @brief 用户订阅的远端音/视频流统计信息以及网络状况，统计周期为 2s
	 * @param stats
	 * @group Audio & Video Transport
	 * @order 70
	 */
	
	[EngineEventsTypes.onRemoteStreamStats]: (stats: RemoteStreamStats) => void;
	/** 
	 * @brief 本地音/视频流统计信息以及网络状况，统计周期为 2s
	 * @param stats
	 * @group Audio & Video Transport
	 * @order 71
	 */
	
	[EngineEventsTypes.onLocalStreamStats]: (stats: LocalStreamStats) => void;
	/** 
	 * @deprecated since 4.65, use [onWTNRemoteVideoStats](104479#wtnstreamevents-onwtnremotevideostats) and [onWTNRemoteAudioStats](104479#wtnstreamevents-onwtnremoteaudiostats) instead.
	 * @brief 调用 [startPlayPublicStream](104478#startplaypublicstream) 订阅公共流，后将触发此回调，周期为 2s，包含各项统计信息。
	 * @param stats
	 */
	
	[EngineEventsTypes.onPublicStreamStats]: (stats: PublicStreamStats) => void;
	/** 
	 * @hidden
	 * @deprecated since 4.42, use onLocalAudioPropertiesReport and onRemoteAudioPropertiesReport instead.
	 * 事件频道内所有用户的音量
	 * @brief 事件频道内所有用户的音量
	 * 如果本地用户未进房，则列表中只有 `local_user` 的音量信息
	 * @param event
	 */
	
	[EngineEventsTypes.onAudioVolumeIndication]: (event: {
		/** 
		 * @brief 房间内活跃用户及其音量信息。
		 */
		
		speakers: AudioVolumeInfo[];
	}) => void;
	/** 
	 * @brief 调用 [enableAudioPropertiesReport](104478#enableaudiopropertiesreport) 后，根据设置的 interval 值，你会周期性地收到此回调，了解本地音频的瞬时信息。
	 *        本地音频包括使用 RTC SDK 内部机制采集的麦克风音频和屏幕音频。
	 * @param event 本地音频信息。
	 * @group Audio Management
	 * @order 55
	 */
	
	[EngineEventsTypes.onLocalAudioPropertiesReport]: (event: LocalAudioPropertiesInfo[]) => void;
	/** 
	 * @brief 远端用户进房后，本地调用 [enableAudioPropertiesReport](104478#enableaudiopropertiesreport)，根据设置的 interval 值，本地会周期性地收到此回调，了解订阅的远端用户的瞬时音频信息。
	 *        远端用户的音频包括使用 RTC SDK 内部机制/自定义机制采集的麦克风音频和屏幕音频。
	 * @param event 远端音频信息，其中包含音频流属性、房间 ID、用户 ID。
	 * @group Audio Management
	 * @order 56
	 */
	
	[EngineEventsTypes.onRemoteAudioPropertiesReport]: (event: RemoteAudioPropertiesInfo[]) => void;
	/** 
	 * @brief 成功调用 [enableAudioPropertiesReport](104478#enableaudiopropertiesreport) 后，当房间内用户数量大于或等于 2 且有活跃用户时，你会周期性收到此回调，获取房间内音量最大用户的信息。
	 * @param userInfo 音量最大用户的信息。
	 * @group Audio Management
	 * @order 60
	 */
	
	[EngineEventsTypes.onActiveSpeaker]: (userInfo: UserInfo) => void;
	/** 
	 * @brief 当调用 [setAudioPlaybackDevice](104478#setaudioplaybackdevice) 设置音频播放设备时，会收到此事件。
	 * @param event 媒体设备信息，参看 [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo)。
	 * @group Audio Management
	 * @order 65
	 */
	
	[EngineEventsTypes.onAudioPlaybackDeviceChanged]: (event: MediaDeviceInfo) => void;
	/** 
	 * @brief 房间内的可见用户调用 [startAudioCapture](104478#startaudiocapture) 开启音频采集时，房间内其他用户会收到此事件。
	 * @param event
	 * @group Audio Management
	 * @order 70
	 */
	
	[EngineEventsTypes.onUserStartAudioCapture]: (event: {
		/** 
		 * @brief 开启音频采集的远端用户 ID
		 */
		
		userId: string;
	}) => void;
	/** 
	 * @brief 房间内的可见用户调用 [stopAudioCapture](104478#stopaudiocapture) 关闭音频采集时，房间内其他用户会收到此事件。
	 * @param event
	 * @group Audio Management
	 * @order 71
	 */
	
	[EngineEventsTypes.onUserStopAudioCapture]: (event: {
		/** 
		 * @brief 关闭音频采集的远端用户 ID
		 */
		
		userId: string;
	}) => void;
	/** 
	 * @brief 房间内的可见用户调用 [startVideoCapture](104478#startvideocapture) 开启内部视频采集时，房间内其他用户会收到此事件。
	 * @param event
	 * @group Video Management
	 * @order 55
	 */
	
	[EngineEventsTypes.onUserStartVideoCapture]: (event: {
		/** 
		 * @brief 开启视频采集的用户 ID
		 */
		
		userId: string;
	}) => void;
	/** 
	 * @brief 房间内的可见用户调用 [stopVideoCapture](104478#stopvideocapture) 关闭内部视频采集时，房间内其他用户会收到此事件。
	 * @param event
	 * @group Video Management
	 * @order 56
	 */
	
	[EngineEventsTypes.onUserStopVideoCapture]: (event: {
		/** 
		 * @brief 停止视频采集的用户的 ID
		 */
		
		userId: string;
	}) => void;
	/** 
	 * @brief 接收到包含 SEI 数据的视频帧事件
	 * @param event SEI 数据事件
	 * @group Message
	 * @order 60
	 */
	
	[EngineEventsTypes.onSEIMessageReceived]: (event: onSEIMessageEvent) => void;
	/** 
	 * @brief 包含 SEI 信息的流更新事件。
	 *        在语音通话场景下，远端用户调用 [sendSEIMessage](104478#sendseimessage) 通过黑帧视频流发送 SEI 数据时，流的发送状态会通过此事件回调本地用户。
	 *        你可以通过此事件判断携带 SEI 数据的视频帧为黑帧，从而不对该视频帧进行渲染。
	 * @param event 包含 SEI 信息的流更新事件。
	 * @group Message
	 * @order 61
	 */
	
	[EngineEventsTypes.onSEIStreamUpdate]: (event: onSEIStreamUpdateEvent) => void;
	/** 
	 * @brief 如果开启了自动订阅，订阅成功或者失败后可以收到此事件
	 * @param event
	 * @group Audio & Video Transport
	 * @order 75
	 */
	
	[EngineEventsTypes.onAutoSubscribeResult]: (event: {
		/** 
		 * @brief 订阅用户的 userId
		 */
		
		userId: string;
		/** 
		 * @brief 是否为屏幕流
		 */
		
		isScreen: boolean;
		/** 
		 * @brief 订阅状态
		 */
		
		state: SubscribeState;
	}) => void;
	/** 
	 * @brief 如果开启了自动发布，发布成功或者失败后可以收到此事件
	 * @param event
	 * @group Audio & Video Transport
	 * @order 76
	 */
	
	[EngineEventsTypes.onAutoPublishResult]: (event: {
		/** 
		 * @brief 是否为屏幕流
		 */
		
		isScreen: boolean;
		/** 
		 * @brief 发布状态
		 */
		
		state: PublishState;
	}) => void;
	/** 
	 * @brief 自动播放失败
	 * @param event 播放器事件
	 * @group Video Management
	 * @order 70
	 */
	
	[EngineEventsTypes.onAutoplayFailed]: (event: AutoPlayFailedEvent) => void;
	/** 
	 * @hidden
	 * @deprecated since 4.44, use onStreamMixingEvent instead.
	 * @brief 转推直播结果事件
	 * @param event
	 */
	
	[EngineEventsTypes.onLiveTranscodingResult]: (event: LiveTranscodingResultEvent) => void;
	/** 
	 * @brief 当 SDK 内部发生不可逆转错误时触发该回调。
	 * @param event
	 * @group Room Management
	 * @order 40
	 */
	
	[EngineEventsTypes.onError]: (event: {
		/** 
		 * @brief 错误码，具体错误原因参看 [ErrorCode](104480#errorcode)。
		 */
		
		errorCode: ErrorCode.DUPLICATE_LOGIN | ErrorCode.RTM_DUPLICATE_LOGIN | ErrorCode.RTM_TOKEN_ERROR | ErrorCode.TOKEN_EXPIRED | ErrorCode.RECONNECT_FAILED | ErrorCode.KICKED_OUT | ErrorCode.ROOM_DISMISS;
		/** 
		 * @brief （可选参数）房间解封时间，unix 时间戳，单位毫秒。
		 *         当 `forbiddenTime` 为 0 时，代表允许用户重新进房。
		 */
		
		forbiddenTime?: number;
	}) => void;
	/** 
	 * @brief 音频混音文件播放状态改变事件
	 * @param event
	 * @group Audio Mixing
	 * @order 40
	 */
	
	[EngineEventsTypes.onAudioMixingStateChanged]: (event: AudioMixingStateChangedEvent) => void;
	/** 
	 * @brief 接收到房间外消息的事件。
	 * @param event
	 * @group Message
	 * @order 65
	 */
	
	[EngineEventsTypes.onUserMessageReceivedOutsideRoom]: (event: UserMessageEvent) => void;
	/** 
	 * @brief 接收到房间外二进制消息的事件。
	 * @param event
	 * @group Message
	 * @order 66
	 */
	
	[EngineEventsTypes.onUserBinaryMessageReceivedOutsideRoom]: (event: UserBinaryMessageEvent) => void;
	/** 
	 * @brief Token 过期前 30 秒将触发该回调。
	 *        调用 [updateToken](104478#updatetoken) 更新 Token。否则 Token 过期后，用户将被移出房间无法继续进行音视频通话。
	 * @group Room Management
	 * @order 45
	 */
	
	[EngineEventsTypes.onTokenWillExpire]: () => void;
	/** 
	 * @brief Token 发布权限过期前 30 秒将触发该回调。
	 *        收到该回调后，调用 [updateToken](104478#updatetoken) 更新 Token。
	 * @notes 若未及时更新 Token，发布权限过期后，已在发布中的流会停止发布，发布端会收到 [onTokenPublishPrivilegeDidExpired](104479#ontokenpublishprivilegedidexpired) 回调；同时远端用户会收到 [onUserUnpublishStream](104479#onuserunpublishstream)/[onUserUnpublishScreen](104479#onuserunpublishscreen) 回调，移除原因为 `STREAM_REMOVE_REASON_TOKEN_PRIVILEGE_EXPIRED`。
	 * @group Room Management
	 * @order 50
	 */
	
	[EngineEventsTypes.onTokenPublishPrivilegeWillExpire]: () => void;
	/** 
	 * @brief Token 发布权限过期时触发该回调，调用 [updateToken](104478#updatetoken) 更新 Token。
	 * @param e
	 * @group Room Management
	 * @order 51
	 */
	
	[EngineEventsTypes.onTokenPublishPrivilegeDidExpired]: (e: {
		/** 
		 * @brief 错误码，`TOKEN_NO_PUBLISH_PERMISSION` 代表 Token 发布权限过期。
		 */
		
		errorCode?: ErrorCode;
		/** 
		 * @brief 错误信息。
		 */
		
		message?: string;
	}) => void;
	/** 
	 * @brief Token 订阅权限过期前 30 秒将触发该回调。
	 *        收到该回调后，调用 [updateToken](104478#updatetoken) 更新 Token。
	 * @notes 若收到该回调后未及时更新 Token，Token 订阅权限过期后，已订阅的流会取消订阅，订阅端会收到 [onTokenSubscribePrivilegeDidExpired](104479#ontokensubscribeprivilegedidexpired) 回调。
	 *        此时尝试新订阅流会失败，并返回错误码 `TOKEN_NO_SUBSCRIBE_PERMISSION` 提示 Token 订阅权限过期。
	 * @group Room Management
	 * @order 55
	 */
	
	[EngineEventsTypes.onTokenSubscribePrivilegeWillExpire]: () => void;
	/** 
	 * @brief Token 订阅权限过期时触发该回调，调用 [updateToken](104478#updatetoken) 更新 Token。
	 * @param e
	 * @group Room Management
	 * @order 56
	 */
	
	[EngineEventsTypes.onTokenSubscribePrivilegeDidExpired]: (e: {
		/** 
		 * @brief 错误码，`TOKEN_NO_SUBSCRIBE_PERMISSION` 代表 Token 订阅权限过期。
		 */
		
		errorCode?: ErrorCode;
		/** 
		 * @brief 错误信息。
		 */
		
		message?: string;
	}) => void;
	/** 
	 * @brief 调用 [startCloudProxy](104478#startcloudproxy) 开启云代理，SDK 首次成功连接云代理服务器时，回调此事件。
	 * @param event
	 * @group Security and Encryption
	 * @order 3
	 */
	
	[EngineEventsTypes.onCloudProxyConnected]: (event: CloudProxyConnectedEvent) => void;
	/** 
	 * @brief 公共流发布结果回调。
	 *        调用 [startPushPublicStream](104478#startpushpublicstream) 发布公共流后，结果通过此回调通知用户。
	 * @param event
	 * @group WTN stream
	 * @order 8
	 */
	
	[EngineEventsTypes.onPushPublicStreamResult]: (event: PublicStreamResultEvent) => void;
	/** 
	 * @deprecated since 4.65, use [onWTNSEIMessageReceived](104479#wtnstreamevents-onwtnseimessagereceived) instead.
	 * @brief 回调公共流中包含的 SEI 信息。
	 *        调用 [startPlayPublicStream](104478#startplaypublicstream) 接口启动拉公共流功能后，通过此回调收到公共流中的 SEI 消息。
	 * @param event
	 * @notes 当公共流中的多路视频流均包含有 SEI 信息时：
	 *        + SEI 不互相冲突时，将通过多次回调分别发送；
	 *        + SEI 在同一帧有冲突时，则只有一条流中的 SEI 信息被透传并融合到公共流中。
	 */
	
	[EngineEventsTypes.onPublicStreamSEIMessageReceived]: (event: PublicStreamSEIMessageEvent) => void;
	/** 
	 * @deprecated since 4.65, use [onWTNFirstRemoteVideoFrameDecoded](104479#wtnstreamevents-onwtnfirstremotevideoframedecoded) instead.
	 * @brief 公共流的视频首帧解码成功。
	 *        关于订阅公共流，参看 [startPlayPublicStream](104478#startplaypublicstream)。
	 * @param event
	 */
	
	[EngineEventsTypes.onFirstPublicStreamVideoFrameDecoded]: (event: PublicStreamVideoFirstFrameDecodedEvent) => void;
	/** 
	 * @deprecated since 4.65.
	 * @brief 公共流的音频首帧解码成功。
	 *        关于订阅公共流，参看 [startPlayPublicStream](104478#startplaypublicstream)。
	 * @param event
	 */
	
	[EngineEventsTypes.onFirstPublicStreamAudioFrameDecoded]: (event: PublicStreamAudioFirstFrameDecodedEvent) => void;
	/** 
	 * @deprecated since 4.65, use [onWTNRemoteVideoStateChanged](104479#wtnstreamevents-onwtnremotevideostatechanged) instead.
	 * @brief 公共流的首帧视频渲染成功。
	 *        关于订阅公共流，参看 [startPlayPublicStream](104478#startplaypublicstream)。
	 * @param event
	 */
	
	[EngineEventsTypes.onFirstPublicStreamVideoFrameRendered]: (event: PublicStreamAudioFirstFrameDecodedEvent) => void;
	/** 
	 * @brief 回调音频设备测试时的播放音量
	 * @param volume 音频设备测试播放音量。单位：毫秒。推荐设置为 200 ms。范围：[0,255]
	 * @notes 调用 [startAudioPlaybackDeviceTest](104478#startaudioplaybackdevicetest) 或 [startAudioDeviceRecordTest](104478#startaudiodevicerecordtest)，开始播放音频文件或录音时，将开启该回调。本回调为周期性回调，回调周期由上述接口的 `interval` 参数指定。
	 * @group Device Management
	 * @order 40
	 */
	
	[EngineEventsTypes.onAudioPlaybackDeviceTestVolume]: (volume: number) => void;
	/** 
	 * @brief 加入房间后，会以每2秒一次的频率，收到本端上行及下行的网络质量信息。
	 * @param uplinkNetworkQuality 上行网络质量。
	 * @param downlinkNetworkQuality 下行网络质量。
	 * @group Audio & Video Transport
	 * @order 80
	 */
	
	[EngineEventsTypes.onNetworkQuality]: (uplinkNetworkQuality: NetworkQuality, downlinkNetworkQuality: NetworkQuality) => void;
	/** 
	 * @brief 订阅的视频流发生回退，或从回退中恢复时，收到此回调。
	 * @param event 流切换信息
	 * @group Audio & Video Transport
	 * @order 85
	 */
	
	[EngineEventsTypes.onSimulcastSubscribeFallback]: (event: RemoteStreamSwitch) => void;
	/** 
	 * @brief 远端视频分辨率发生改变时，房间内订阅此视频流的用户会收到此回调。
	 * @param key 远端流信息
	 * @param info 视频帧信息
	 * @group Audio & Video Transport
	 * @order 90
	 */
	
	[EngineEventsTypes.onRemoteVideoSizeChanged]: (
	/** 
	 * @brief 远端流信息
	 */
	
	key: RemoteStreamKey, 
	/** 
	 * @brief 视频帧信息
	 */
	
	info: {
		/** 
		 * @brief 宽度，单位：px
		 */
		
		width: number;
		/** 
		 * @brief 高度，单位：px
		 */
		
		height: number;
	}) => void;
	/** 
	 * @brief 转推直播相关事件
	 * @param event
	 * @group Push to CDN
	 * @order 15
	 */
	
	[EngineEventsTypes.onStreamMixingEvent]: (event: StreamMixingEvent) => void;
	/** 
	 * @brief 调用服务端接口 BanUserStream/UnbanUserStream 封禁/解禁指定用户的视频流发布时，触发该回调。
	 * @param event
	 * @notes + 房间内指定用户被禁止/解禁视频流发送时，房间内所有用户都会收到该回调。
	 *        + 若被封禁用户断网或退房后再进房，则依然是封禁状态，且房间内所有人会再次收到该回调。
	 *        + 指定用户被封禁后，房间内其他用户退房后再进房，会再次收到该回调。
	 *        + 在控制台开启大会模式后，只有被封禁/解禁用户会收到该回调。
	 *        + 同一房间解散后再次创建，房间内状态清空。
	 * @group Audio & Video Transport
	 * @order 95
	 */
	
	[EngineEventsTypes.onVideoStreamBanned]: (event: VideoStreamBannedEvent) => void;
	/** 
	 * @brief 调用服务端接口 BanUserStream/UnbanUserStream 封禁/解禁指定用户的音频流发布时，触发该回调。
	 * @param event
	 * @notes + 房间内指定用户被禁止/解禁音频流发送时，房间内所有用户都会收到该回调。
	 *        + 若被封禁用户断网或退房后再进房，则依然是封禁状态，且房间内所有人会再次收到该回调。
	 *        + 指定用户被封禁后，房间内其他用户退房后再进房，会再次收到该回调。
	 *        + 在控制台开启大会模式后，只有被封禁/解禁用户会收到该回调。
	 *        + 同一房间解散后再次创建，房间内状态清空。
	 * @group Audio & Video Transport
	 * @order 96
	 */
	
	[EngineEventsTypes.onAudioStreamBanned]: (event: AudioStreamBannedEvent) => void;
	/** 
	 * @brief 当实际采集的参数与设置的编码参数不一致时，SDK 会触发该回调返回实际采集视频的参数。
	 * @param e 实际采集视频的参数。
	 * @group Video Management
	 * @order 60
	 */
	
	[EngineEventsTypes.onLocalVideoSizeChanged]: (e: {
		/** 
		 * @brief 视频流属性。
		 */
		
		streamIndex: StreamIndex;
		/** 
		 * @brief 视频实际采集参数。
		 */
		
		info: {
			/** 
			 * @brief 视频宽度，单位：px。
			 */
			
			width: number;
			/** 
			 * @brief 视频高度，单位：px。
			 */
			
			height: number;
		};
	}) => void;
	/** 
	 * @brief 字幕状态发生改变回调。
	 *        当你调用 [startSubtitle](104478#startsubtitle) 和 [stopSubtitle](104478#stopsubtitle) 使字幕状态发生改变或字幕任务出现错误时，触发该回调。
	 * @param e 字幕任务状态。
	 * @group Live Caption and Translation
	 * @order 10
	 */
	
	[EngineEventsTypes.onSubtitleStateChanged]: (e: SubtitleEvent) => void;
	/** 
	 * @brief 字幕相关信息回调。
	 *        当你成功调用 [startSubtitle](104478#startsubtitle) 后会收到此回调，通知字幕的相关信息。
	 * @param e 字幕具体内容。如果开启的字幕翻译任务包含多种目标语言时，翻译结果也将包含多个语种，可以根据 `userId` 和 `language` 提取 `text` 的值。
	 * @group Live Caption and Translation
	 * @order 11
	 */
	
	[EngineEventsTypes.onSubtitleMessageReceived]: (e: SubtitleMessage[]) => void;
	/** 
	 * @brief 设置接收客户端即时消息的服务器成功或失败时收到本事件。
	 * @param error 错误码
	 * @notes + 调用 [setServerParams](104478#setserverparams) 时触发。
	 *        + 当调用 [setServerParams](104478#setserverparams) 设置服务器参数后断网，会在重连成功后收到本事件。
	 * @group Message
	 * @order 70
	 */
	
	[EngineEventsTypes.onServerParamsSetResult]: (error?: ErrorCode) => void;
	/** 
	 * @hidden
	 * @brief 插件功能更新本地track时收到本事件
	 * @param e 被更新的track信息
	 */
	
	[EngineEventsTypes.onLocalStreamTrackChangedByExtension]: (e: {
		streamIndex: StreamIndex;
		type: "video" | "audio";
	}) => void;
	/** 
	 * @brief 设置跨房间转发媒体流失败时收到本事件。
	 * @param e 跨房间转发媒体流状态信息。
	 * @group Audio & Video Transport
	 * @order 100
	 */
	
	[EngineEventsTypes.onForwardStreamError]: (e: ForwardStreamStateInfo) => void;
	/** 
	 * @hidden
	 * @brief 进房信令超时，准备尝试用纯 TCP 进房
	 */
	
	[EngineEventsTypes.onRejoinWithTcp]: () => void;
	/** 
	 * @hidden
	 * @brief 尝试使用 TCP 进行 ICE 建连
	 */
	
	[EngineEventsTypes.onIceConnectWithTcp]: () => void;
	/** 
	 * @hidden
	 * @brief 发布失败后，SDK内部重新发起重试
	 */
	
	[EngineEventsTypes.onPublishRetry]: (e: {
		screen: boolean;
	}) => void;
	/** 
	 * @hidden
	 * @brief 订阅失败后，SDK内部重新发起重试
	 */
	
	[EngineEventsTypes.onSubscribeRetry]: (e: {
		userId: string;
		screen: boolean;
	}) => void;
	/** 
	 * @hidden
	 * @brief 1. 4.58 or 4.59新增 2. 代替 onAutoPublishResult 3. 用户感知一下内部的发布状态
	 */
	
	[EngineEventsTypes.onPublishResult]: (e: {
		isScreen: boolean;
		isAutoPublish: boolean;
		errorCode?: ErrorCode;
	}) => void;
	/** 
	 * @hidden
	 * @brief 1. 4.58 or 4.59新增 2. 代替 onAutoSubscribeResult 3. 用户感知一下内部的发布状态
	 */
	
	[EngineEventsTypes.onSubscribeResult]: (e: {
		userId: string;
		isScreen: boolean;
		isAutoSubscribe: boolean;
		errorCode?: ErrorCode;
	}) => void;
}
export interface IJoinRoomConfig {
	useTcpAfterJoinTimeout: boolean;
	joinWithTcpOnly: boolean;
	joinWithTcpOnlyDelay: number;
}
export interface IPCKillSwitch {
	ctor_sdpsemantics_add: boolean;
	ctor_encodedinsetablestream_add: boolean;
	sld_rtcpfb_rrtr_add: boolean;
	sld_ext_sdesmid_remove: boolean;
	sld_fmtp_sps_add: boolean;
	sld_fmtp_bitrate_add: boolean;
	sld_fmtp_opus_add: boolean;
	sld_iceoption_renomination: boolean;
}
/** 
 * @id RTCEngine
 * @list overview
 * @detail api
 */

export interface IRTCEngine extends EnhancedEventEmitter<IEngineEvents> {
	/** 
	 * @brief 加入已有房间，或创建一个新房间并加入。
	 * 调用此方法时需指定 `roomId`。若 `roomId` 对应的房间已经存在，SDK 直接加入该房间；若 `roomId` 对应的房间不存在，SDK 会自动基于 `roomId` 创建一个新房间并加入。
	 * @param token 动态密钥，用于对进房用户进行鉴权验证。
	 *     进入房间需要携带 Token。测试时可使用控制台生成临时 Token，正式上线需要使用密钥 SDK 在你的服务端生成并下发 Token。Token 有效期及生成方式参看[使用 Token 完成鉴权](70121)。
	 *     使用不同 AppID 的 App 是不能互通的。
	 *     请务必保证生成 Token 使用的 AppID 和创建引擎时使用的 AppID 相同，否则会导致加入房间失败。
	 * @param roomId 需要加入或新创建的房间 ID。该字符串需符合正则表达式：`[a-zA-Z0-9_@\-\.]{1,128}`。
	 * @param userInfo 用户信息。
	 * @param roomConfig 房间参数配置，设置房间模式以及是否自动发布或订阅流。
	 * @return + `INVALID_TOKEN`: 进房时使用了已过期的 Token 或使用的 Token 无效。
	 *         + `JOIN_ROOM_FAILED`: 进房失败。
	 *         + `REPEAT_JOIN`: 重复进房。
	 *         + `ROOM_FORBIDDEN`: 房间被封禁导致进房失败。
	 *         + `USER_FORBIDDEN`: 用户被封禁导致进房失败。
	 * @notes + 同一个 App ID 的同一个房间内，每个用户的用户 ID 必须是唯一的。如果两个用户的用户 ID 相同，则先进房的用户将自动退房并收到 `DUPLICATE_LOGIN` 错误。
	 *        + 本地用户调用 [setUserVisibility](#setuservisibility) 将自身设为可见后加入房间，远端用户会收到 [onUserJoined](104479#onuserjoined) 回调通知。
	 *        + 房间内不可见用户的容量远远大于可见用户，而且用户默认可见，因此对于不参与互动的用户，你需要调用 [setUserVisibility](#setuservisibility)，将其更改为不可见用户，从而避免因房间内用户达到数量上限所导致的进房失败。默认情况下，一个 RTC 房间最多同时容纳 50 名可见用户，最多 30 人可同时上麦。更多信息参看[用户和媒体流上限](https://www.volcengine.com/docs/6348/257549)。
	 *        + 用户加入房间成功后，在本地网络状况不佳的情况下，SDK 可能会与服务器失去连接，并触发 [onConnectionStateChanged](104479#onconnectionstatechanged) 回调。此时 SDK 会自动重试，直到成功重连。重连成功后，如果加入房间的为可见用户，远端用户会收到 [onUserJoined](104479#onuserjoined)  回调通知。
	 * @group Room Management
	 * @order 0
	 */
	
	joinRoom: (token: string | null, roomId: string, userInfo: UserInfo, roomConfig?: RoomConfig) => Promise<void>;
	/** 
	 * @brief 离开房间。
	 * 用户调用此方法离开房间，结束通话过程，释放所有通话相关的资源。
	 * @param waitAck 保留参数，无实际意义。
	 * @notes + 可见的用户离开房间后，房间内其他用户会收到 [onUserLeave](104479#onuserleave) 回调通知。
	 *    + 调用 [joinRoom](#joinroom) 方法加入房间后，必须调用此方法结束通话，否则无法开始下一次通话。重复调用此方法没有负面影响。
	 * @group Room Management
	 * @order 1
	 */
	
	leaveRoom: (waitAck?: boolean) => Promise<void>;
	/** 
	 * @hidden
	 * @brief 销毁 [createEngine](104478#createengine) 所创建引擎实例，并释放所有相关资源。
	 * @notes + 请确保和需要销毁的 `RTCEngine` 实例相关的业务场景全部结束后，才调用此方法
	 *        + 该方法在调用之后，会销毁所有和此 `RTCEngine` 实例相关的内存，并且停止与媒体服务器的任何交互
	 *        + 本方法为阻塞调用，会阻塞当前线程直到 SDK 彻底完成退出逻辑，因而需要注意不要在回调线程中直接调用本方法，也需要注意不要在回调方法中等待主线程的执行，而同时在主线程调用本方法，从而造成死锁
	 */
	
	destroy: () => void;
	/** 
	 * @brief 在当前所在房间内发布本地摄像头/麦克风采集的媒体流
	 * @param mediaType 媒体流类型，用于指定发布音频/视频。
	 * @notes + 调用 [setUserVisibility](#setuservisibility) 方法将自身设置为不可见后无法调用该方法，需将自身切换至可见后方可调用该方法发布摄像头音视频流。
	 *        + 如果你需要发布屏幕共享流，调用 [publishScreen](#publishscreen)。
	 *        + 调用此方法后，房间中的所有远端用户会收到 [onUserPublishStream](104479#onuserpublishstream) 回调通知。
	 *        + 调用 [unpublishStream](#unpublishstream) 取消发布。
	 * @return + `NO_PUBLISH_PERMISSION`: 无发布权限，请先调用 [setUserVisibility](#setuservisibility) 将自身切换至可见后再发布流。
	 *         + `TOKEN_NO_PUBLISH_PERMISSION`: Token 无发布权限或发布权限过期，调用 [updateToke](#updatetoken) 更新 Token 发布权限。
	 *         + `PUBLISH_FAILED`: 发布流失败，具体原因查看 message。
	 * @group Audio & Video Transport
	 * @order 0
	 */
	
	publishStream: (mediaType: MediaType) => Promise<void>;
	/** 
	 * @brief 停止将本地摄像头/麦克风采集的媒体流发布到当前所在房间中
	 * @param mediaType 媒体流类型，用于指定停止发布音频/视频。
	 * @notes + 调用 [publishStream](#publishstream) 手动发布摄像头/麦克风采集的音视频流后，你需调用此接口停止发布。
	 *        + 调用此方法停止发布音视频流后，房间中的其他用户将会收到 [onUserUnpublishStream](104479#onuserunpublishstream) 回调通知。
	 * @group Audio & Video Transport
	 * @order 1
	 */
	
	unpublishStream: (mediaType: MediaType) => Promise<void>;
	/** 
	 * @brief 在当前所在房间内发布本地屏幕共享音视频流
	 * @param mediaType 媒体流类型，用于指定发布屏幕音频/视频。
	 * @notes + 调用 [setUserVisibility](#setuservisibility) 方法将自身设置为不可见后无法调用该方法，需将自身切换至可见后方可调用该方法发布屏幕流。
	 *        + 调用该方法后，房间中的所有远端用户会收到 [onUserPublishScreen](104479#onuserpublishscreen) 回调。
	 *        + 调用 [unpublishScreen](#unpublishscreen) 取消发布。
	 * @return + `NO_PUBLISH_PERMISSION`: 无发布权限，请先调用 [setUserVisibility](#setuservisibility) 将自身切换至可见后再发布流。
	 *         + `TOKEN_NO_PUBLISH_PERMISSION`: Token 无发布权限或发布权限过期，调用 [updateToke](#updatetoken) 更新 Token 发布权限。
	 *         + `PUBLISH_FAILED`: 发布流失败，具体原因查看 message。
	 * @group Screen Sharing
	 * @order 10
	 */
	
	publishScreen: (mediaType: MediaType) => Promise<void>;
	/** 
	 * @brief 停止将本地屏幕共享音视频流发布到当前所在房间中
	 * @param mediaType 媒体流类型，用于指定停止发布屏幕音频/视频
	 * @notes + 调用 [publishScreen](#publishscreen) 发布屏幕流后，你需调用此接口停止发布。
	 *        + 调用此方法停止发布屏幕音视频流后，房间中的其他用户将会收到 [onUserUnpublishScreen](104479#onuserunpublishscreen) 回调。
	 * @group Screen Sharing
	 * @order 11
	 */
	
	unpublishScreen: (mediaType: MediaType) => Promise<void>;
	/** 
	 * @brief 订阅房间内指定的通过摄像头/麦克风采集的媒体流。
	 *        该方法对自动订阅和手动订阅模式均适用。
	 * @param userId 指定订阅的远端发布音视频流的用户 ID。
	 * @param mediaType 媒体流类型，用于指定订阅音频/视频。
	 * @notes 你必须先通过 [onUserPublishStream](104479#onuserpublishstream) 回调获取当前房间里的远端摄像头音视频流信息，然后调用本方法按需订阅。
	 * @return + `STREAM_NOT_EXIST`: 目标流不存在。请输入正确的 ID，或确认目标流在房间内。
	 *         + `TOKEN_NO_SUBSCRIBE_PERMISSION`: Token 无订阅权限或订阅权限过期，调用 [updateToke](#updatetoken) 更新 Token 订阅权限。
	 * @group Audio & Video Transport
	 * @order 5
	 */
	
	subscribeStream: (userId: string, mediaType: MediaType) => Promise<void>;
	/** 
	 * @brief 取消订阅房间内指定的通过摄像头/麦克风采集的媒体流。
	 *        该方法对自动订阅和手动订阅模式均适用。
	 * @param userId 指定取消订阅的远端发布音视频流的用户 ID。
	 * @param mediaType 媒体流类型，用于指定取消订阅音频/视频。
	 * @return `STREAM_NOT_EXIST`: 目标流不存在。请输入正确的 ID，或确认目标流在房间内。
	 * @group Audio & Video Transport
	 * @order 6
	 */
	
	unsubscribeStream: (userId: string, mediaType: MediaType) => Promise<void>;
	/** 
	 * @brief 订阅房间内指定的远端屏幕共享音视频流。
	 *        该方法对自动订阅和手动订阅模式均适用。
	 * @param userId 指定订阅的远端发布屏幕流的用户 ID。
	 * @param mediaType 媒体流类型，用于指定订阅音频/视频。
	 * @notes 你必须先通过 [onUserPublishScreen](104479#onuserpublishscreen) 回调获取当前房间里的远端屏幕流信息，然后调用本方法按需订阅。
	 * @return + `STREAM_NOT_EXIST`: 目标流不存在。请输入正确的 ID，或确认目标流在房间内。
	 *         + `TOKEN_NO_SUBSCRIBE_PERMISSION`: Token 无订阅权限或订阅权限过期，调用 [updateToke](#updatetoken) 更新 Token 订阅权限。
	 * @group Screen Sharing
	 * @order 15
	 */
	
	subscribeScreen: (userId: string, mediaType: MediaType) => Promise<void>;
	/** 
	 * @brief 取消订阅房间内指定的远端屏幕共享音视频流。
	 *        该方法对自动订阅和手动订阅模式均适用。
	 * @param userId 指定取消订阅的远端发布屏幕流的用户 ID。
	 * @param mediaType 媒体流类型，用于指定取消订阅音频/视频。
	 * @group Screen Sharing
	 * @order 16
	 */
	
	unsubscribeScreen: (userId: string, mediaType: MediaType) => Promise<void>;
	/** 
	 * @brief 更新 Token。
	 *        用于加入房间的 Token 有一定的有效期。Token 过期前 30 秒将收到 [onTokenWillExpire](104479#ontokenwillexpire) 回调，需要调用此方法更新房间的 Token 信息。
	 * @param token 获取的新的有效 Token。
	 * @notes + 调用 [joinRoom](#joinroom) 方法加入房间或断网重连进入房间时，如果 Token 过期，将导致加入房间失败，回调错误码为 `INVALID_TOKEN`。此时需要重新获取 Token，并调用此方法更新 Token。
	 *        + 如果因 Token 过期导致加入房间失败，则调用此方法更新 Token 后，SDK 会自动重新加入房间，不需要再次调用 [joinRoom](#joinroom) 方法。
	 *        + Token 过期后，用户将被移出房间无法继续进行音视频通话。
	 * @return + `UPDATE_TOKEN_WITH_INVALID_TOKEN`: 传入的 Token 无效。
	 *         + `UPDATE_TOKEN_BEFORE_JOIN`: 不在房间内，请先调用 [joinRoom](#joinroom) 加入房间。
	 * @group Room Management
	 * @order 5
	 */
	
	updateToken: (token: string) => Promise<void>;
	/** 
	 * @brief 设置内部采集时使用的麦克风。
	 * @param deviceId 设备 ID，可以通过调用 [enumerateAudioCaptureDevices](#enumerateaudiocapturedevices) 获取设备列表。
	 * @return
	 * @notes 如果设置时正在使用麦克风进行音频采集，切换操作当即生效；如果设置时未开启采集，则会在开启内部采集时打开设置的麦克风。
	 * @group Device Management
	 * @order 45
	 */
	
	setAudioCaptureDevice: (deviceId: string) => Promise<void>;
	/** 
	 * @brief 设置内部采集时使用的摄像头。
	 * @param deviceId 设备 ID，可以通过调用 [enumerateVideoCaptureDevices](#enumeratevideocapturedevices) 获取设备列表。
	 * @return
	 * @notes + 如果设置时正在使用摄像头进行视频采集，切换操作当即生效；如果设置时未开启采集，则会在开启采集时打开设置的摄像头。
	 *        + 在移动端场景下，可以通过设置 deviceId 为 `"user"` 来指定前置摄像头，可以通过设置 deviceId 为 `"environment"` 来指定后置摄像头。
	 *        + 默认摄像头由浏览器指定。
	 * @group Device Management
	 * @order 55
	 */
	
	setVideoCaptureDevice: (deviceId: string) => Promise<void>;
	/** 
	 * @brief 开启内部视频采集。默认为关闭状态。
	 *        内部视频采集是指：使用 RTC SDK 内置的视频采集机制进行视频采集。
	 *        可见用户进房后调用该方法，房间中的其他用户会收到 [onUserStartVideoCapture](104479#onuserstartvideocapture) 的回调。
	 * @param deviceId 设备 ID，你需在此传入采集视频的设备 ID，以免出现无画面或显示非所需画面等异常。你可以通过调用 [enumerateDevices](#enumeratedevices) 获取设备列表。
	 * @return 实际生效的视频采集参数。参看 [MediaTrackSettings](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings)。请关注其中的 `frameRate`, `height`, `width` 等值。
	 *         还可能返回如下错误码。
	 *         + `REPEAT_CAPTURE`: 重复采集。
	 *         + `GET_VIDEO_TRACK_FAILED`: 采集视频失败，请确认是否有可用的采集设备，或是否被其他 App 占用。
	 *         + `STREAM_TYPE_NOT_MATCH`: 流类型不匹配。调用 setVideoSourceType 设置了自定义媒体源后，又调用内部采集相关的接口。
	 * @notes + 调用 [stopVideoCapture](#stopvideocapture) 可以停止内部视频采集。否则，只有当销毁引擎实例时，内部视频采集才会停止。
	 *        + 创建引擎后，无论是否发布视频数据，你都可以调用该方法开启内部视频采集。只有当（内部或外部）视频采集开始以后视频流才会发布。
	 *        + 内部视频采集使用的摄像头由 [setVideoCaptureDevice](#setvideocapturedevice) 接口指定。
	 * @group Video Management
	 * @order 5
	 */
	
	startVideoCapture: (deviceId?: string) => Promise<MediaTrackSettings>;
	/** 
	 * @brief 关闭内部视频采集。
	 *        发布流后调用该方法，房间中的其他用户会收到 [onUserStopVideoCapture](104479#onuserstopvideocapture) 的回调。
	 * @return `STREAM_TYPE_NOT_MATCH`: 流类型不匹配。调用 setVideoSourceType 设置了自定义媒体源后，又调用内部采集相关的接口。
	 * @notes + 调用 [startVideoCapture](#startvideocapture) 可以开启内部视频采集。
	 *        + 如果不调用本方法停止内部视频采集，则只有当销毁引擎实例时，内部视频采集才会停止。
	 * @group Video Management
	 * @order 6
	 */
	
	stopVideoCapture: () => Promise<void>;
	/** 
	 * @brief 开启内部音频采集。默认为关闭状态。
	 *        内部采集是指：使用 RTC SDK 内置采集机制进行音频采集。
	 *        可见用户进房后调用该方法，房间中的其他用户会收到 [onUserStartAudioCapture](104479#onuserstartaudiocapture) 的回调。
	 * @param deviceId 设备 ID，你需在此传入采集音频的设备 ID，以免出现无声等异常。你可以通过调用 [enumerateDevices](#enumeratedevices) 获取设备列表。
	 * @return 实际生效的音频采集参数。参看 [MediaTrackSettings](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings)。
	 *         还可能返回如下错误码。
	 *         + `REPEAT_CAPTURE`: 重复采集。
	 *         + `GET_AUDIO_TRACK_FAILED`: 采集音频失败，请确认是否有可用的采集设备，或是否被其他 App 占用。
	 *         + `STREAM_TYPE_NOT_MATCH`: 流类型不匹配。调用 setAudioSourceType 设置了自定义媒体源后，又调用内部采集相关的接口。
	 * @notes + 调用 [stopAudioCapture](#stopaudiocapture) 可以停止内部音频采集。否则，只有当销毁引擎实例时，内部音频采集才会停止。
	 *        + 创建引擎后，无论是否发布音频数据，你都可以调用该方法开启音频采集，只有当（内部或外部）音频采集开始以后音频流才会发布。
	 * @group Audio Management
	 * @order 5
	 */
	
	startAudioCapture: (deviceId?: string) => Promise<MediaTrackSettings>;
	/** 
	 * @brief 立即关闭内部音频采集。
	 *        发布流后调用该方法，房间内的其他用户会收到 [onUserStopAudioCapture](104479#onuserstopaudiocapture) 的回调。
	 * @return `STREAM_TYPE_NOT_MATCH`: 流类型不匹配。调用 setAudioSourceType 设置了自定义媒体源后，又调用内部采集相关的接口。
	 * @notes + 调用 [startAudioCapture](#startaudiocapture) 可以开启内部音频采集。
	 *        + 如果不调用本方法停止内部音频采集，则只有当销毁引擎实例时，内部音频采集才会停止。
	 * @group Audio Management
	 * @order 7
	 */
	
	stopAudioCapture: () => Promise<void>;
	/** 
	 * @brief 使用内部采集模块同时开启音视频采集。调用该方法，浏览器会同时请求麦克风和摄像头授权，用户只需授权一次。
	 *        可见用户进房后调用该方法，房间中的其他用户会收到 [onUserStartVideoCapture](104479#onuserstartvideocapture) 和 [onUserStartAudioCapture](104479#onuserstartaudiocapture) 的回调。
	 * @param optionsOrAudioDeviceId 单参数使用时可以同时设置音视频设备 ID；双参数使用时为音频设备 ID。
	 * @param videoDeviceId 视频设备 ID。
	 * @return 实际生效的音视频采集参数。参看 [MediaTrackSettings](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings)。请关注其中的 `deviceId`, `channelCount`, `sampleRate`, `frameRate`, `height`, `width` 等值。
	 *         还可能返回如下错误码。
	 *         + `REPEAT_CAPTURE`: 重复采集。
	 *         + `GET_AUDIO_TRACK_FAILED`: 采集音频失败，请确认是否有可用的采集设备，或是否被其他 App 占用。
	 *         + `GET_VIDEO_TRACK_FAILED`: 采集视频失败，请确认是否有可用的采集设备，或是否被其他 App 占用。
	 *         + `STREAM_TYPE_NOT_MATCH`: 流类型不匹配。调用 setAudioSourceType/setVideoSourceType 设置了自定义媒体源后，又调用内部采集相关的接口。
	 * @notes + 采集的音视频可以通过 [publishStream](#publishstream) 发布/ [unPublishStream](#unpublishstream) 取消发布。
	 *        + 该方法和 [startVideoCapture](#startvideocapture) / [startAudioCapture](#startaudiocapture) 无法同时调用。
	 *        + 调用该方法时，摄像头和麦克风其中之一无法完成采集，则音视频采集失败。
	 *        + 若需停止音视频采集，调用 [stopVideoCapture](#stopvideocapture) / [stopAudioCapture](#stopaudiocapture)。
	 * @group Audio Management
	 * @order 6
	 */
	
	startAudioAndVideoCapture: (optionsOrAudioDeviceId?: {
		/** 
		 * @brief 音频设备 ID。
		 */
		
		audioDeviceId?: string;
		/** 
		 * @brief 视频设备 ID。
		 */
		
		videoDeviceId?: string;
	} | string, videoDeviceId?: string) => Promise<{
		audioTrackSettings: MediaTrackSettings;
		videoTrackSettings: MediaTrackSettings;
	}>;
	/** 
	 * @hidden
	 * @brief 使用内部采集模块同时开启音视频采集。调用该方法，浏览器会同时请求麦克风和摄像头授权，用户只需授权一次。
	 * 调用该方法，房间中的其他用户会收到 [onUserStartVideoCapture](104479#onuserstartvideocapture) 和 [onUserStartAudioCapture](104479#onuserstartaudiocapture) 的回调。
	 * @param videoDeviceId 视频设备 ID。
	 * @param audioDeviceId 音频设备 ID。
	 * @return 实际生效的音视频采集参数。参看 [MediaTrackSettings](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings)。请关注其中的 `deviceId`, `channelCount`, `sampleRate`, `frameRate`, `height`, `width` 等值。
	 * @notes + 采集的音视频可以通过 [publishStream](#publishstream) 发布/ [unPublishStream](#unpublishstream) 取消发布。
	 *        + 该方法和 [startVideoCapture](#startvideocapture) / [startAudioCapture](#startaudiocapture) 无法同时调用。
	 *        + 调用该方法时，摄像头和麦克风其中之一无法完成采集，则音视频采集失败。
	 *        + 若需停止音视频采集，调用 [stopVideoCapture](#stopvideocapture) / [stopAudioCapture](#stopaudiocapture)。
	 */
	
	startVideoAndAudioCapture: (videoDeviceId?: string, audioDeviceId?: string) => Promise<{
		audioTrackSettings: MediaTrackSettings;
		videoTrackSettings: MediaTrackSettings;
	}>;
	/** 
	 * @brief 使用内部采集模块，采集当前屏幕视频流，用于共享。
	 * @param screenConfig 共享屏幕属性
	 * @return `GET_SCREEN_TRACK_FAILED`: 采集屏幕共享失败。
	 * @notes + 调用此方法仅开启屏幕流视频采集，不会发布采集到的视频。发布屏幕流视频需要调用 [publishScreen](#publishscreen)。
	 *        + 要关闭屏幕视频源采集，调用 [stopScreenCapture](#stopscreencapture)。
	 *        + 调用此接口前，你可以调用 [setScreenEncoderConfig](#setscreenencoderconfig) 设置屏幕视频流的采集帧率和编码分辨率。
	 *        + 屏幕共享功能限制参看 [Web SDK 屏幕共享功能已知限制](111854#屏幕共享)。
	 * @group Screen Sharing
	 * @order 0
	 */
	
	startScreenCapture: (screenConfig?: ScreenConfig) => Promise<void>;
	/** 
	 * @brief 停止屏幕共享流内部采集。
	 * @return
	 * @group Screen Sharing
	 * @order 1
	 */
	
	stopScreenCapture: () => Promise<void>;
	/** 
	 * @brief 设置本地视频渲染时，使用的视图，并设置渲染模式。
	 *        调用本方法绑定视图以后，你可以通过 `onPlayerEvent` 来监听播放状态。
	 *        你可以通过再次调用本方法，并绑定空视图来解除绑定。如果已创建了多个播放器，且存在默认播放器，不指定 playerId，将解绑默认播放器。
	 * @param streamIndex 视频流属性
	 * @param videoPlayerOption 视图信息和渲染模式。4.61 版本起，支持多次调用本接口，传入不同的 playerId，将同一条流绑定多个渲染视图。
	 * @notes + 你应在加入房间后，绑定视图。退出房间后，此设置仍然有效。
	 * + 绑定播放器时，如果指定的 playerId 已经存在，不会重复创建播放器。
	 * @group Video Management
	 * @order 20
	 */
	
	setLocalVideoPlayer: (streamIndex: StreamIndex, videoPlayerOption?: Partial<Omit<VideoPlayerOption, "rotation">>) => HTMLVideoElement | undefined;
	/** 
	 * @brief 设置远端视频渲染时使用的视图，并设置渲染模式。
	 *        建议在收到 [onUserPublishStream](104479#onuserpublishstream)/[onUserPublishScreen](104479#onuserpublishscreen) 事件后，调用本方法对远端视频视图进行设置。
	 *        你可以通过再次调用本方法，并绑定空视图来解除绑定。如果已创建了多个播放器，且存在默认播放器，不指定 playerId，将解绑默认播放器。
	 * @param streamIndex 视频流属性。
	 * @param videoPlayerOption 视图信息和渲染模式。4.61 版本起，支持多次调用本接口，传入不同的 playerId，将同一条流绑定多个渲染视图。
	 *  4.56 版本起支持通过 `rotation` 参数设置远端视频渲染的旋转角度。
	 * @notes 你应在加入房间后，绑定视图。每次加入房间需要重新设置。
	 * @group Video Management
	 * @order 21
	 */
	
	setRemoteVideoPlayer: (streamIndex: StreamIndex, videoPlayerOption: VideoPlayerOption) => HTMLVideoElement | undefined;
	/** 
	 * @brief 是否开启本地视频流镜像模式。
	 * @param mirrorType 是否开启镜像模式
	 * @group Video Management
	 * @order 30
	 */
	
	setLocalVideoMirrorType: (mirrorType: MirrorType) => void;
	/** 
	 * @brief 开关远端视频流镜像模式。
	 * @param userId 远端用户 ID。
	 * @param streamIndex 流属性，主流或屏幕流。
	 * @param mirrorType 是否开启镜像模式。
	 * @notes + 此外，你还需要调用 [setRemoteVideoPlayer](104478#rtcengine-setremotevideoplayer) 实现指定镜像显示远端流的播放器。
	 * @group Video Management
	 * @order 32
	 */
	
	setRemoteVideoMirrorType: (userId: string, streamIndex: StreamIndex, mirrorType: MirrorType) => void;
	/** 
	 * @brief 设置音频播放设备，例如扬声器或者耳机，默认使用扬声器。
	 * @param deviceId 音频播放设备（扬声器或者耳机）ID，你可以通过调用 [enumerateDevices](#enumeratedevices) 获取。
	 * @return + `INVALID_DEVICE_ID`: 输入的设备 ID 无效。
	 *         + `NOT_SUPPORTED`: 浏览器不支持设置音频播放设备或测试音频采集/播放设备。
	 * @notes  + 该方法仅在桌面端 Chrome 浏览器可用。
	 * + 进房前和进房后，均可调用此方法设置音频播放设备。
	 * @group Audio Management
	 * @order 1
	 */
	
	setAudioPlaybackDevice: (deviceId: string) => Promise<void>;
	/** 
	 * @brief 手动开启音视频流播放。
	 * @param userId 指定流所属的用户 ID 或  WTN 流 ID。空值代表本地媒体流。传入 WTN 流 ID 时，`mediaType` 和 `streamIndex` 不生效。
	 * @param mediaType  媒体流类型，用于指定发布音频/视频。默认值为 `AUDIO_AND_VIDEO`。本方法对本地音频流不生效。开启音频选路时，无法操作音频。
	 * @param streamIndex 视频流属性。不传参数将同时控制主流和屏幕流。
	 * @param playerId 播放器 ID。不指定时视为默认播放器。
	 * @return 当音视频正常播放时调用本接口也将返回 Promise 对象
	 * @note + 调用本方法前，需要通过 [`setLocalVideoPlayer`](104478#rtcengine-setlocalvideoplayer) 或 [`setRemoteVideoPlayer`](104478#rtcengine-setremotevideoplayer) 绑定播放器。
	 * + 音频或/和视频不在播放时，都可以调用本方法手动开启播放。
	 * + 参考[自动播放策略](https://www.volcengine.com/docs/6348/130302)，获取更多相关信息。
	 * @group Video Management
	 * @order 25
	 */
	
	play: (userId?: string, mediaType?: MediaType, streamIndex?: StreamIndex, playerId?: string) => Promise<void>;
	
	/** 
	 * @brief 暂停音视频流播放。
	 * @param userId 指定流所属的用户 ID 或  WTN 流 ID。空值代表本地媒体流。传入 WTN 流 ID 时，`mediaType` 和 `streamIndex` 不生效。
	 * @param mediaType 媒体流类型。默认值为 `AUDIO_AND_VIDEO`。本方法对本地音频流不生效。开启音频选路时，无法操作音频。
	 * @param streamIndex 视频流属性，主流或屏幕流。不传参数将同时控制主流和屏幕流。
	 * @param playerId 播放器 ID。不指定时视为默认播放器。
	 * @notes 开启音频选路时，本方法不会生效。
	 * 成功调用本方法停止渲染音视频后：
	 * + 媒体流会在已绑定的多个播放器中暂停渲染。
	 * + 不会解除订阅关系，因此订阅此媒体流的计费不会停止。
	 * + 不会解除播放器绑定，你可以随时调用 [play](#play) 继续播放。
	 * + 通过 [onLocalAudioPropertiesReport](104479#onlocalaudiopropertiesreport) 或 [onRemoteAudioPropertiesReport](104479#onremoteaudiopropertiesreport) 回调或 [getAudioVolume](104478#rtcengine-getaudiovolume) 接口获取到的音量不会为 `0`。
	 * @group Video Management
	 * @order 26
	 */
	stop: (userId?: string, mediaType?: MediaType, streamIndex?: StreamIndex, playerId?: string) => void;
	/** 
	 * @brief 获取音量大小。包括内部采集、外部采集的本地流以及远端流。
	 * @param streamIndex 视频流属性，主流或屏幕流。
	 * @param userId 指定播放的流所属的用户 ID。空值代表本地媒体流。
	 * @return 当指定的流不存在时，线性和非线性音量结果均为 0。
	 * + 线性音量，与原始音量呈线性关系，数值越大，音量越大。取值范围是：[0,255]。
	 * &ensp; - \[0, 25]：近似无声
	 * &ensp; - \[26, 75]: 低音量
	 * &ensp; - \[76, 204]: 中音量
	 * &ensp; - \[205, 255]: 高音量
	 * + 非线性音量。由原始音量的对数值转化而来，因此在中低音量时更灵敏，可以用作 Active Speaker（房间内最活跃用户）的识别。取值范围是：[-127，0]，单位 dB。
	 * &ensp; - \[-127, -60]：近似无声
	 * &ensp; - \[-59, -40]: 低音量
	 * &ensp; - \[-39, -20]: 中音量
	 * &ensp; - \[-19, 0]: 高音量
	 * @notes + 重复调用本方法的间隔应 >= 100ms。
	 * + 你还可以通过 [onLocalAudioPropertiesReport](104479#onlocalaudiopropertiesreport) 和 [onRemoteAudioPropertiesReport](104479#onremoteaudiopropertiesreport) 周期回调获取音量信息。
	 * @group Audio Management
	 * @order 27
	 */
	
	getAudioVolume: (streamIndex: StreamIndex, userId?: string) => {
		linearVolume: number;
		nonlinearVolume: number;
	};
	/** 
	 * @brief 开关音频帧 PCM 数据回调。
	 * @param streamIndex 流属性，包括主流、屏幕流。
	 * @param userId 发布该音频的用户 ID。不传参数代表本地音频流。
	 * SDK 将在指定用户发布音频流后开始回调音频数据。
	 * 音频选路下只能开启本地音频帧回调。
	 * @param callback 接收音频数据的回调函数，为空表示关闭数据回调。
	 * 用户断网时，回调的音频数据为 0。
	 * @param frameSize 每个音频帧包含的采样点数。frameSize 越大，每次回调的音频数据越多，回调间隔越长。
	 * 可设置为 256, 512, 1024, 2048, 4096, 8192, 16384。如无特殊需求，建议使用默认值 4096。
	 * @note + 创建引擎后即可调用，本地音频采集开始或远端音频到达后，你将收到相应回调。
	 * + 用户进退房或重新发布等行为不会清除回调开关状态。
	 * @group Custom Stream Processing
	 * @order 40
	 */
	
	setAudioFrameCallback: (streamIndex: StreamIndex, userId?: string, callback?: (data: AudioFrameData) => void, frameSize?: number) => void;
	/** 
	 * @brief 暂停接收来自远端的媒体流。
	 * @param mediaType 媒体流类型，指定需要暂停接收音频还是视频流
	 * @return
	 * @notes + 该方法仅暂停远端流的接收，并不影响远端流的采集和发送。
	 *        + 该方法不改变用户的订阅状态以及订阅流的属性。
	 *        + 若想恢复接收远端流，需调用 [resumeAllSubscribedStream](#resumeallsubscribedstream)。
	 * @group Audio & Video Transport
	 * @order 15
	 */
	
	pauseAllSubscribedStream: (mediaType: MediaType) => Promise<void>;
	/** 
	 * @brief 恢复接收来自远端的媒体流
	 * @param mediaType 媒体流类型，指定音频还是视频流
	 * @return
	 * @notes + 该方法仅恢复远端流的接收，并不影响远端流的采集和发送；
	 *        + 该方法不改变用户的订阅状态以及订阅流的属性。
	 * @group Audio & Video Transport
	 * @order 16
	 */
	
	resumeAllSubscribedStream: (mediaType: MediaType) => Promise<void>;
	/** 
	 * @brief 给房间内指定的用户发送点对点文本消息。
	 *        若消息发送成功，则 userId 所指定的用户会收到 [onUserMessageReceived](104479#onusermessagereceived) 回调。
	 * @param userId 消息接收用户的 ID
	 * @param message 发送的文本消息内容，消息不超过 64 KB。
	 * @return + `USER_MESSAGE_TIMEOUT`: 发送消息超时。
	 *         + `USER_MESSAGE_BROKEN`: 通道断开，发送失败。
	 *         + `USER_MESSAGE_NO_RECEIVER`: 找不到接收者，请检查传入的 userId 是否正确。
	 *         + `USER_MESSAGE_NOT_JOIN`: 消息发送方没有加入房间。
	 *         + `USER_MESSAGE_UNKNOWN`: 消息未知错误。
	 * @notes 在发送房间内文本消息前，必须先调用 [joinRoom](#joinroom) 加入房间。
	 * @group Message
	 * @order 0
	 */
	
	sendUserMessage: (userId: string, message: string) => Promise<unknown> | undefined;
	/** 
	 * @brief 给房间内指定的用户发送点对点二进制消息。
	 * 若消息发送成功，则 userId 所指定的用户会收到 [onUserBinaryMessageReceived](104479#onuserbinarymessagereceived) 回调。
	 * @param userId 消息接收用户的 ID
	 * @param message 发送的二进制消息内容，消息不超过 64 KB。
	 * @return + `USER_MESSAGE_TIMEOUT`: 发送消息超时。
	 *         + `USER_MESSAGE_BROKEN`: 通道断开，发送失败。
	 *         + `USER_MESSAGE_NO_RECEIVER`: 找不到接收者，请检查传入的 userId 是否正确。
	 *         + `USER_MESSAGE_NOT_JOIN`: 消息发送方没有加入房间。
	 *         + `USER_MESSAGE_UNKNOWN`: 消息未知错误。
	 * @notes 在发送房间内二进制消息前，必须先调用 [joinRoom](#joinroom) 加入房间。
	 * @group Message
	 * @order 1
	 */
	
	sendUserBinaryMessage: (userId: string, message: ArrayBuffer) => Promise<unknown>;
	/** 
	 * @brief 给房间内的所有其他用户群发文本消息。
	 *        若消息发送成功，同一房间内的其他用户会收到 [onRoomMessageReceived](104479#onroommessagereceived) 回调。
	 * @param message  发送的文本消息内容，消息不超过 64 KB。
	 * @return
	 * @group Message
	 * @order 5
	 */
	
	sendRoomMessage: (message: string) => Promise<any> | undefined;
	/** 
	 * @brief 给房间内的所有其他用户群发二进制消息。
	 *        若消息发送成功，同一房间内的其他用户会收到通过 [onRoomBinaryMessageReceived](104479#onroombinarymessagereceived) 回调发送的消息
	 * @param message  发送的文本消息，不超过 64 KB。
	 * @return
	 * @group Message
	 * @order 6
	 */
	
	sendRoomBinaryMessage: (message: ArrayBuffer) => Promise<any> | undefined;
	/** 
	 * @brief 通过视频帧发送 SEI 数据。
	 *        在视频通话场景下，SEI 数据会随视频帧发送；在语音通话场景下，SDK 会自动生成一路 16px × 16px 的黑帧视频流用来发送 SEI 数据。
	 * @param streamIndex 指定携带 SEI 信息的媒体流类型。语音通话场景下，建议将该值设为 `STREAM_INDEX_MAIN`。
	 * @param message SEI 消息，不大于 4 KB。
	 * 当消息为空或大小超限，终止发送，并收到相应的错误提示。
	 * SEI PayLoadType 需为 `5` 或 `100`。
	 * @param repeatCount 消息发送重复次数，SEI 数据会添加到当前视频帧开始的连续 `repeatCount+1` 个视频帧中。取值范围 `[0, min{30, %{视频帧率}×2}]`，推荐范围 `[2,4]`。
	 * @notes + 功能兼容性说明：<br/>
	 *         &ensp; - SEI 消息仅支持在 H.264 编码，且内核版本为 Chromium 86 及以上、Firefox 117 及以上、Safari 15.4 及以上的浏览器上使用。
	 *         &ensp; - Android 设备无法在语音通话场景下自动生成黑帧视频流发送 SEI 数据。
	 *         &ensp; - iOS 设备不支持使用 SEI 功能。
	 *        + 语音通话场景下收发 SEI 消息，仍然需要订阅视频流，而非音频流。可以在订阅端进房时设置自动订阅视频流，或调用 [subscribeStream](#subscribestream)，媒体流类型选择 `AUDIO_AND_VIDEO`。
	 *        + 语音通话场景下，若调用此接口后 1 分钟内未有 SEI 数据发送，则 SDK 会自动取消发布视频黑帧。
	 *        + 消息发送成功后，远端会收到 [onSEIMessageReceived](104479#onseimessagereceived) 事件。
	 *        + 语音通话场景下，黑帧视频流的发送状态会通过 [onSEIStreamUpdate](104479#onseistreamupdate) 事件回调远端用户。
	 * @group Message
	 * @order 10
	 */
	
	sendSEIMessage: (streamIndex: StreamIndex, message: Uint8Array | string, repeatCount: number) => void;
	/** 
	 * @brief 在视频发布端设置摄像头视频流的发布参数。
	 * @param descriptions 视频流的发布参数。
	 * @notes + 若期望发布多路不同分辨率的流，你需要通过 [setLocalSimulcastMode](#rtcengine-setlocalsimulcastmode) 开启并分别指定小流的发布参数。发布 Simulcast 流时，本接口设置的是大流参数。
	 * + 调用该方法前，SDK 默认发布一条分辨率 640 × 480 px，帧率 15 FPS，最大编码码率 600 Kbps 的流。
	 * + 你可以在视频流发布前后调用本方法。
	 * + 当使用移动端在竖持状态下发布视频流时，设置的分辨率宽高与实际发流参数相反。例如，当设置发送分辨率为 640 × 480 px 时，实际发流参数为 480 × 640 px。
	 * + 若设置的参数浏览器不支持，RTC SDK 按照浏览器支持的参数范围进行采集和编码，并通过回调 [onLocalVideoSizeChanged](104479#onlocalvideosizechanged) 通知采集的实际参数。
	 * + 该方法适用于摄像头采集的视频流，设置屏幕共享视频流参数参看 [setScreenEncoderConfig](#setscreenencoderconfig)。
	 * @group Video Management
	 * @order 35
	 */
	
	setVideoEncoderConfig: (descriptions: VideoEncoderConfig | VideoEncoderConfig[]) => Promise<void>;
	/** 
	 * @brief 设置共享屏幕的视频编码参数，同时对视频采集生效。
	 *        若设置的参数浏览器不支持，RTC SDK 按照浏览器支持的参数范围进行采集和编码，并通过回调 [onLocalVideoSizeChanged](104479#onlocalvideosizechanged) 通知采集的实际参数。
	 * @param description 共享屏幕的视频编码参数。
	 * @notes + 默认分辨率 1920 × 1080 px，帧率 15 FPS，最大编码码率 3000 Kbps。
	 *        + 建议在采集视频前设置编码参数。若采集前未设置编码参数，则使用默认编码参数。
	 * @group Screen Sharing
	 * @order 5
	 */
	
	setScreenEncoderConfig: (description: ScreenEncoderConfig) => Promise<void>;
	/** 
	 * @hidden Deprecated since V4.63, use setRemoteSimulcastStreamType instead.
	 * @brief 设置期望订阅的远端视频流的参数。
	 * @param userId 期望配置订阅参数的远端视频流发布用户的 ID。
	 * @param remoteVideoConfig 期望配置的远端视频流参数。
	 * @notes + 该方法仅在发布端调用 [enableSimulcastMode](#enablesimulcastmode) 开启了发送多路视频流的情况下生效，此时订阅端将收到与设置的期望参数最相近的一路流。
	 *        + 若发布端开启了推送多路流功能，但订阅端不对流参数进行设置，则默认接受发送端设置的分辨率最大的一路视频流。
	 *        + 该方法需在进房后调用，若想进房前设置，你需调用 [joinRoom](#joinroom)，并对 `roomConfig` 中的 `remoteVideoConfig` 进行设置。
	 * @group Audio & Video Transport
	 * @order 20
	 */
	
	setRemoteVideoConfig: (userId: string, remoteVideoConfig: RemoteVideoConfig) => Promise<void>;
	/** 
	 * @brief 发布端开启 Simulcast 功能时，订阅端可以使用本方法设置期望订阅的远端视频流的参数。
	 * @param userId 期望配置订阅参数的远端视频流发布用户的 ID。
	 * @param streamType 订阅大小流偏好。
	 * 当订阅的小流未发布时，会订阅大流。当订阅的中流未发布时，但小流已发布，会订阅小流。
	 * @return 调用失败说明参见 [MIXING_OLD_AND_NEW_APIS](104480#errorcode)。
	 * @notes + 该方法仅在发布端调用 [setLocalSimulcastMode](#setLocalSimulcastMode) 开启了发送多路视频流的情况下生效，此时订阅端将收到与设置的期望参数最相近的一路流。
	 *        + 若发布端开启了推送多路流功能，但订阅端不对流参数进行设置，则默认接受发送端设置的分辨率最大的一路视频流。
	 *        + 该方法可在进房后调用。
	 *        + 更多信息详见[使用 Simulcast 功能](https://www.volcengine.com/docs/6348/1359024)文档。
	 * @group Audio & Video Transport
	 * @order 25
	 */
	
	setRemoteSimulcastStreamType: (userId: string, streamType: SimulcastStreamType) => Promise<void>;
	/** 
	 * @hidden Deprecated since V4.63, use setLocalSimulcastMode instead.
	 * @brief 在视频发布端设置摄像头视频流的大小流模式。
	 * @param enabled 是否开启大小流。
	 * @return + `true`：设置成功。
	 *         + `false`：设置失败。
	 * @notes + 仅可以在发布之前进行大小流模式的设置。
	 *        + 开启大小流模式后，SDK 会自动设置各路视频的编码参数。如果你需要手动设置，可以调用 [setVideoEncoderConfig](#setvideoencoderconfig)。
	 *        + Firefox 浏览器不支持大小流功能。
	 * @group Audio & Video Transport
	 * @order 25
	 */
	
	enableSimulcastMode: (enabled: boolean) => boolean;
	/** 
	 * @valid since V4.63
	 * @brief 在视频发布端开启 Simulcast 功能，设置或更新中、小流的发布参数。
	 * @param mode 默认为只发送单流。你应在进房前调用本接口设定本参数。
	 * @param streamConfig 中、小流发布编码参数。分辨率按照从小到大顺序，且每路流参数分辨率需小于通过 [setVideoEncoderConfig](#rtcengine-setvideoencoderconfig) 设置的大流参数。否则可能会设置失败。
	 *        你可以在进房前后设置本参数。发布后，无法修改小流路数，但可以更新中、小流的编码参数。
	 *        多流模式下，默认小流参数为 120px × 90px \@10fps, 码率为 100kpbs。
	 * - 浏览器最多支持发送 3 路不同分辨率视频流，此时大流分辨率应超过 540P。
	 * - 当大流分辨率 < 180P 时，仅能发 1 路流。
	 * - 当大流分辨率 介于 180P 和 540P 之间时，可以发送 1 路大流和 1 路小流。
	 * @return 调用失败说明参见 [SET_SIMULCAST_FAILED](104480#errorcode) 和  [MIXING_OLD_AND_NEW_APIS](104480#errorcode)。
	 * @note + Simulcast 只对摄像头采集到的视频流生效。
	 * + 在发布端开启 Simulcast 功能对浏览器的版本要求参见[Web SDK 浏览器兼容性和已知问题](https://www.volcengine.com/docs/6348/111854)。
	 * @group Audio & Video Transport
	 * @order 20
	 */
	
	setLocalSimulcastMode: (mode: VideoSimulcastMode, streamConfig?: VideoEncoderConfig[]) => Promise<void>;
	/** 
	 * @hidden
	 * @deprecated since 4.42, use enableAudioPropertiesReport instead
	 * @brief 开启/关闭音量提示。默认关闭。
	 *        开启音量提示后，将按设置的时间间隔，收到本地采集音量或订阅的远端用户的音量信息回调。
	 *        关于回调的具体信息，参看 [onAudioVolumeIndication](104479#onaudiovolumeindication)。
	 * @param interval 收到音量提示回调的时间间隔
	 *        建议设置为大于等于 200 毫秒；小于 10 毫秒时，行为未定义。
	 *        + `≤ 0`：禁用音量提示功能。
	 *        + `> 0`：启用音量提示功能，并设置收到音量提示回调的时间间隔。单位为毫秒。
	 */
	
	setAudioVolumeIndicationInterval: (interval?: number) => void;
	/** 
	 * @brief 启用音频信息提示。
	 * @param config 音频信息提示相关设置
	 * @notes 开启提示后，你可以：
	 *       + 通过 [onLocalAudioPropertiesReport](104479#onlocalaudiopropertiesreport) 回调获取本地麦克风和屏幕音频流采集的音频信息；
	 *       + 通过 [onRemoteAudioPropertiesReport](104479#onremoteaudiopropertiesreport) 回调获取订阅的远端用户的音频信息。
	 * @group Audio Management
	 * @order 35
	 */
	
	enableAudioPropertiesReport: (config?: AudioPropertiesConfig) => void;
	/** 
	 * @brief 开启转推直播，并设置合流的视频视图布局和音频属性。
	 * @param transcode 转推直播配置参数。
	 * @return
	 * @notes + 调用该方法后，关于启动结果和推流过程中的错误，会收到 [onStreamMixingEvent](104479#onstreammixingevent) 回调。
	 *        + 如果你在[控制台](https://console.volcengine.com/rtc/cloudRTC?tab=callback)配置了转推直播的服务端回调，调用本接口会收到 [TranscodeStarted](https://www.volcengine.com/docs/6348/75125#transcodestarted)。重复调用该接口时，第二次调用会同时触发 [TranscodeStarted](https://www.volcengine.com/docs/6348/75125#transcodestarted) 和 [TranscodeUpdated](https://www.volcengine.com/docs/6348/75125#transcodeupdated)。
	 *        + 调用 [stopLiveTranscoding](#stoplivetranscoding) 停止转推直播。
	 * @group Push to CDN
	 * @order 5
	 */
	
	startLiveTranscoding: (transcode: LiveTranscodeConfig) => Promise<void>;
	/** 
	 * @brief 更新转推直播参数。
	 *        使用 [startLiveTranscoding](104478#startlivetranscoding) 启用转推直播功能后，使用此方法更新功能配置参数。
	 * @param transcode 转推直播配置参数。除特殊说明外，均支持过程中更新。
	 * @return
	 * @group Push to CDN
	 * @order 6
	 */
	
	updateLiveTranscoding: (transcode: Partial<LiveTranscodeConfig>) => Promise<void>;
	/** 
	 * @brief 停止转推直播。
	 * 关于启动转推直播，参看 [startLiveTranscoding](104478#startlivetranscoding)。
	 * @return
	 * @group Push to CDN
	 * @order 7
	 */
	
	stopLiveTranscoding: () => Promise<void>;
	/** 
	 * @brief 设置业务标识参数
	 *        可通过 businessId 区分不同的业务场景。businessId 由客户自定义，相当于一个“标签”，可以分担和细化现在 AppId 的逻辑划分的功能，但不需要鉴权。
	 * @param businessId businessId 只是一个标签，颗粒度需要用户自定义。
	 * @return + `true`：设置成功。
	 *         + `false`：设置失败。
	 * @notes 需要在调用 [joinRoom](#joinroom) 之前调用，[joinRoom](#joinroom) 之后调用该方法无效。
	 * @group Engine Management
	 * @order 5
	 */
	
	setBusinessId: (businessId: string) => boolean;
	/** 
	 * @brief 设置用户可见性。未调用该接口前，本地用户默认对他人可见。
	 *        默认情况下，一个 RTC 房间最多同时容纳 50 名可见用户，最多 30 人可同时上麦。更多信息参看[用户和媒体流上限](https://www.volcengine.com/docs/6348/257549)。
	 * @param enable 用户是否对房间内其他用户可见。
	 *    &ensp;    + `true`: 可以在房间内发布音视频流，房间中的其他用户将收到用户的行为通知，例如进房、开启视频采集和退房。
	 *    &ensp;    + `false`: 不可以在房间内发布音视频流，房间中的其他用户不会收到用户的行为通知，例如进房、开启视频采集和退房。
	 * @return
	 * @notes + 该方法在加入房间前后均可调用。
	 *        + 在房间内调用此方法，房间内其他用户会收到相应的回调通知：
	 *            - 从 `false` 切换至 `true` 时，房间内其他用户会收到 [onUserJoined](104479#onuserjoined) 回调通知；
	 *            - 从 `true` 切换至 `false` 时，房间内其他用户会收到 [onUserLeave](104479#onuserleave) 回调通知。
	 * @group Room Management
	 * @order 10
	 */
	
	setUserVisibility: (enable: boolean) => Promise<void>;
	/** 
	 * @brief 使用用户自定义的 videoTrack。
	 *        调用本方法前必须先调用 [setVideoSourceType](104478#setvideosourcetype) 设置为自定义视频采集。
	 * @param index 视频指针。
	 * @param track 自定义的 videoTrack，参看 [MediaStreamTrack](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStreamTrack)。
	 * @return
	 * @group Custom Stream Processing
	 * @order 5
	 */
	
	setExternalVideoTrack: (index: StreamIndex, track: MediaStreamTrack) => Promise<void>;
	/** 
	 * @brief 使用用户自定义的 audioTrack。
	 *        调用本方法前必须先调用 [setAudioSourceType](104478#setaudiosourcetype) 设置为自定义音频采集。
	 * @param index 音频流指针
	 * @param track 自定义的 audioTrack，参看 [MediaStreamTrack](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStreamTrack)。
	 * @return
	 * @group Custom Stream Processing
	 * @order 15
	 */
	
	setExternalAudioTrack: (index: StreamIndex, track: MediaStreamTrack) => Promise<void>;
	/** 
	 * @brief 设置向 SDK 输入的视频源
	 * 默认使用内部采集。内部采集指：使用 RTC SDK 内置的视频采集机制进行视频采集。
	 * 该方法进房前后均可调用。
	 * 当你已调用 [startVideoCapture](104478#startvideocapture) 开启内部采集后，再调用此方法切换至自定义采集时，SDK 会自动关闭内部采集。
	 * 当你调用此方法开启自定义采集，再调用此方法切换至内部采集时，必须再调用 [startVideoCapture](104478#startvideocapture) 手动开启内部采集。
	 * @param index 视频流指针
	 * @param videoSourceType 视频采集模块
	 * @return
	 * @group Custom Stream Processing
	 * @order 0
	 */
	
	setVideoSourceType: (index: StreamIndex, videoSourceType: VideoSourceType) => Promise<void>;
	/** 
	 * @brief 设置向 SDK 输入的音频源
	 * 默认使用内部采集。内部采集指：使用 RTC SDK 内置的音频采集机制进行音频采集。
	 * 该方法进房前后均可调用。
	 * 当你已调用 [startAudioCapture](104478#startaudiocapture) 开启内部采集后，再调用此方法切换至自定义采集时，SDK 会自动关闭内部采集。
	 * 当你调用此方法开启自定义采集，再调用此方法切换至内部采集时，必须再调用 [startAudioCapture](104478#startaudiocapture) 手动开启内部采集。
	 * @param index 音频流指针
	 * @param audioSourceType 音频采集模块
	 * @return
	 * @group Custom Stream Processing
	 * @order 10
	 */
	
	setAudioSourceType: (index: StreamIndex, audioSourceType: AudioSourceType) => Promise<void>;
	/** 
	 * @brief 混音管理接口创建。
	 * @return 混音管理对象
	 * @group Audio Mixing
	 * @order 0
	 */
	
	getAudioMixingManager: () => IAudioMixingManager;
	/** 
	 * @brief WTN 流接口创建。
	 * @return WTN 流管理对象
	 * @group WTN stream
	 * @order 10
	 */
	
	getWTNStreamManager: () => IWTNStream;
	/** 
	 * @brief > Available since v4.66.<br>
	 * 获取通话 ID。该方法需要在加入房间后调用。
	 * 当创建一个房间开启音视频通话后，系统会为该房间生成一个对应 `callId`，标识此房间的通话。
	 * @return 当前房间的通话 ID（`callId`）。
	 * @group Room Management
	 * @order 0
	 */
	
	getCallId: () => string | undefined;
	/** 
	 * @brief 设置 RTC SDK 内部采集时的音频采集参数。默认参数由浏览器决定。
	 * @param config 音频采集参数。例如，关闭浏览器音频 3A。支持传入设置的参数见 [MediaTrackConstraints](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaTrackConstraints)
	 * @return
	 * @notes 你需要在开始音频采集和首次发布之前调用本接口。
	 * @group Audio Management
	 * @order 30
	 */
	
	setAudioCaptureConfig: (config: TrackCaptureConfig) => Promise<void>;
	/** 
	 * @hidden
	 * @deprecated since v4.51, use setVideoEncoderConfig instead.
	 * @brief 设置 RTC SDK 内部采集时的视频采集参数。默认参数由浏览器决定。
	 * @param config 视频采集参数。支持传入设置的参数见 [MediaTrackConstraints](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaTrackConstraints)。
	 *               传入的 `frameRate`, `height`, `width` 仅为期望分辨率和帧率，内部采集实际生效的分辨率和帧率需要参看 [startVideoCapture](104478#startvideocapture) 的返回值。
	 * @return
	 * @note  + 本接口在引擎创建后即可调用，建议在调用 [startVideoCapture](#startvideocapture) 前调用本接口。
	 *        + 自 v4.51 起，修改采集分辨率时，实际发布分辨率会同时改变。
	 */
	
	setVideoCaptureConfig: (config: TrackCaptureConfig) => Promise<MediaTrackSettings>;
	/** 
	 * @brief 登录即时消息服务器。
	 *        调用此方法登录后，可以向同 `appID` 下其他已登录用户发送文本或二进制消息。
	 * @param token 用户登录必须携带的 Token，用于鉴权验证。
	 *              测试时可使用[控制台](https://console.volcengine.com/rtc/listRTC)生成临时 Token，`roomId` 填任意值。
	 *              正式上线需要使用密钥 SDK 在你的服务端生成并下发 Token，`roomId` 置空，Token 有效期及生成方式参看[使用 Token 完成鉴权](70121)。
	 * @param userId 用户 ID。
	 * @return + `ALREADY_LOGIN`: 已有相同 userId 的用户登录了实时信令服务器，请勿重复登录或使用不同的 userId 登录。
	 *         + `LOGIN_FAILED`: 登录实时信令服务器失败，具体原因查看 message。
	 * @notes + 在调用本接口登录后，如果想要登出，需要调用 [logout](#logout)。
	 *        + 同一个 App ID 的每个用户的用户 ID 必须是唯一的。如果两个用户的用户 ID 相同，则先登录的用户将自动登出，并收到 `RTM_DUPLICATE_LOGIN` 错误。
	 * @group Message
	 * @order 15
	 */
	
	login: (token: string | null, userId: string) => Promise<void>;
	/** 
	 * @brief 登出 RTS 服务器。调用本接口登出后，无法调用房间外消息以及端到服务器消息相关的方法或收到相关回调。
	 * @return
	 * @group Message
	 * @order 16
	 */
	
	logout: () => Promise<void>;
	/** 
	 * @brief 更新用户用于登录的 Token。Token 有一定的有效期，当 Token 过期时，需调用此方法更新登录的 Token 信息。
	 * @param token 更新的动态密钥
	 * @return
	 * @notes + 如果 Token 无效导致登录失败，则调用此方法更新 Token 后，SDK 会自动重新登录，你无需再次调用 login 方法。
	 *        + Token 过期时，如果已经成功登录，则不会受到影响。Token 过期的错误会在下一次使用过期 Token 登录时，或因本地网络状况不佳导致断网重新登录时通知。
	 * @group Message
	 * @order 20
	 */
	
	updateLoginToken: (token: string | null) => Promise<void>;
	/** 
	 * @brief 查询对端用户或本端用户的登录状态。在发送房间外消息之前，用户可以通过本接口了解对端用户是否登录，从而决定是否发送消息。也可以通过本接口查询自己查看自己的登录状态。
	 * @param userId 需要查询的用户 ID
	 * @return
	 * @notes 必须调用 [login](#login) 登录后，才能调用本接口。
	 * @group Message
	 * @order 25
	 */
	
	getPeerOnlineStatus: (userId: string) => Promise<USER_ONLINE_STATUS>;
	/** 
	 * @brief 给房间外指定的用户发送文本消息（P2P）
	 * @param userId 消息接收用户的 ID
	 * @param message 发送的文本消息内容。消息不超过 64 KB。
	 * @return + `USER_MESSAGE_TIMEOUT`: 发送消息超时。
	 *         + `USER_MESSAGE_BROKEN`: 通道断开，发送失败。
	 *         + `USER_MESSAGE_NO_RECEIVER`: 找不到接收者，请检查传入的 userId 是否正确。
	 *         + `NOT_LOGIN`: 消息发送方没有登录。
	 *         + `USER_MESSAGE_UNKNOWN`: 消息未知错误。
	 * @notes + 必须调用 [login](#login) 登录后，才能调用本接口。
	 *        + 若文本消息发送成功，指定的用户会通过 [onUserMessageReceivedOutsideRoom](104479#onusermessagereceivedoutsideroom) 回调收到该消息。
	 * @group Message
	 * @order 30
	 */
	
	sendUserMessageOutsideRoom: (userId: string, message: string) => Promise<any>;
	/** 
	 * @brief 给房间外指定的用户发送二进制消息（P2P）
	 * @param userId 消息接收用户的 ID
	 * @param message 发送的二进制消息内容。消息不超过 64 KB。
	 * @return + `USER_MESSAGE_TIMEOUT`: 发送消息超时。
	 *         + `USER_MESSAGE_BROKEN`: 通道断开，发送失败。
	 *         + `USER_MESSAGE_NO_RECEIVER`: 找不到接收者，请检查传入的 userId 是否正确。
	 *         + `NOT_LOGIN`: 消息发送方没有登录。
	 *         + `USER_MESSAGE_UNKNOWN`: 消息未知错误。
	 * @notes + 必须调用 [login](#login) 登录后，才能调用本接口。
	 *        + 若文本消息发送成功，则 uid 所指定的用户会通过 [EngineEventsTypes.onUserBinaryMessageReceivedOutsideRoom](104479#onuserbinarymessagereceivedoutsideroom) 回调收到该消息。
	 * @group Message
	 * @order 31
	 */
	
	sendUserBinaryMessageOutsideRoom: (userId: string, message: ArrayBuffer) => Promise<any>;
	/** 
	 * @brief 设置业务服务器参数。调用 [sendServerMessage](104478#sendservermessage) 或 [sendServerBinaryMessage](104478#sendserverbinarymessage) 发送消息给业务服务器之前，必须需要设置有效签名和业务服务器地址。
	 * @param signature 动态签名，应用服务器可使用该签名对消息来源进行验证。
	 *        签名需自行定义，可传入任意非空字符串，建议将 uid 等信息编码为签名。
	 *        设置的签名会以 post 形式发送至通过本方法中 url 参数设置的应用服务器地址。
	 * @param url 业务服务器的地址
	 * @return
	 * @notes + 用户必须调用 [login](#login) 登录后，才能调用本接口。
	 *        + 调用本接口后将触发 [onServerParamsSetResult](104479#onserverparamssetresult) 回调。
	 * @group Message
	 * @order 35
	 */
	
	setServerParams: (signature: string, url: string) => Promise<any>;
	/** 
	 * @brief 客户端给业务服务器发送文本消息（P2Server）
	 * @param message 发送的文本消息内容。消息不超过 64 KB。
	 * @return + `USER_MESSAGE_TIMEOUT`: 发送消息超时。
	 *         + `USER_MESSAGE_BROKEN`: 通道断开，发送失败。
	 *         + `USER_MESSAGE_NO_RECEIVER`: 找不到接收者，请检查传入的 userId 是否正确。
	 *         + `USER_MESSAGE_SEND_TO_SERVER_ERROR`: 服务器无应答。
	 *         + `USER_MESSAGE_SERVER_RESPONSE_ERROR`: 业务服务器 Http 响应状态码不是 200。
	 *         + `NOT_LOGIN`: 消息发送方没有登录。
	 *         + `USER_MESSAGE_SERVER_PARAMS_NOTSET`: 尚未设置业务服务器参数。
	 *         + `USER_MESSAGE_UNKNOWN`: 消息未知错误。
	 * @notes 在向业务服务器发送文本消息前，必须先调用 [login](#login) 完成登录，随后调用 [setServerParams](#setserverparams) 设置业务服务器。
	 * @group Message
	 * @order 36
	 */
	
	sendServerMessage: (message: string) => Promise<any>;
	/** 
	 * @brief 客户端给业务服务器发送二进制消息（P2Server）
	 * @param message 发送的二进制消息内容。消息不超过 64 KB。
	 * @return + `USER_MESSAGE_TIMEOUT`: 发送消息超时。
	 *         + `USER_MESSAGE_BROKEN`: 通道断开，发送失败。
	 *         + `USER_MESSAGE_NO_RECEIVER`: 找不到接收者，请检查传入的 userId 是否正确。
	 *         + `USER_MESSAGE_SEND_TO_SERVER_ERROR`: 服务器无应答。
	 *         + `USER_MESSAGE_SERVER_RESPONSE_ERROR`: 业务服务器 Http 响应状态码不是 200。
	 *         + `NOT_LOGIN`: 消息发送方没有登录。
	 *         + `USER_MESSAGE_SERVER_PARAMS_NOTSET`: 尚未设置业务服务器参数。
	 *         + `USER_MESSAGE_UNKNOWN`: 消息未知错误。
	 * @notes 在向业务服务器发送文本消息前，必须先调用 [login](#login) 完成登录，随后调用 [setServerParams](#setserverparams) 设置业务服务器。
	 * @group Message
	 * @order 37
	 */
	
	sendServerBinaryMessage: (message: ArrayBuffer) => Promise<any>;
	/** 
	 * @brief 开启云代理
	 * @param cloudProxyInfo 云代理服务器信息列表。
	 * @notes + 在加入房间前调用此接口
	 *        + 在开启云代理后，进行通话前网络探测
	 *        + 开启云代理后，并成功链接云代理服务器后，会收到 [onCloudProxyConnected](104479#oncloudproxyconnected)。
	 *        + 要关闭云代理，调用 [stopCloudProxy](#stopcloudproxy)。
	 * @group Security and Encryption
	 * @order 1
	 */
	
	startCloudProxy: (cloudProxyInfo: CloudProxyInfo) => void;
	/** 
	 * @brief 关闭云代理
	 * @notes 要开启云代理，调用 [startCloudProxy](#startcloudproxy)。
	 * @group Security and Encryption
	 * @order 2
	 */
	
	stopCloudProxy: () => void;
	/** 
	 * @brief 将房间内的单路媒体流，或多路媒体流合成后发布为一路 WTN 流。
	 *        发布后，同一 AppId 下的用户无需进房，即可通过 StreamId 订阅该流。
	 * @param publicStreamId  WTN 流 ID。该字符串需符合正则表达式：`[a-zA-Z0-9_@\-\.]{1,128}`。
	 * @param publicStreamParam  WTN 流参数。
	 *        一路 WTN 流可以包含多路房间内的媒体流，按照指定的布局方式进行聚合。
	 *        如果指定的媒体流还未发布，则 WTN 流将在指定流开始发布后实时更新。
	 * @return `REPEAT_PUSH`: 重复发布 WTN 流。
	 * @notes + 使用同一 `appID` 的用户，无论是否进房，可以调用 [startPlayWTN](104478#wtnstream-startplaywtn) 获取和播放指定的 WTN 流。
	 *        + 同一用户使用同一 WTN 流 ID 多次调用本接口无效。调用 [updatePublicStreamParam](#updatepublicstreamparam) 更新 WTN 流参数。
	 *        + 不同用户使用同一 WTN 流 ID 多次调用本接口时，RTC SDK 将使用最后一次调用时传入的参数更新 WTN 流。
	 *        + 使用不同的 WTN 流 ID 多次调用本接口可以发布多路 WTN 流。
	 *        + 调用 [stopPushPublicStream](#stoppushpublicstream) 停止推 WTN 流。
	 * @group WTN stream
	 * @order 4
	 */
	
	startPushPublicStream: (publicStreamId: string, publicStreamParam: PublicStreamConfig) => Promise<void>;
	/** 
	 * @brief 更新 WTN 流参数。由 [startPushPublicStream](104478#rtcengine-startpushpublicstream) 发布的 WTN 流。
	 * @param publicStreamId  WTN 流 ID。
	 *                       指定的流必须为当前用户所发布。
	 * @param publicStreamParam  WTN 流参数。
	 * @return `REPEAT_PLAY`: 重复订阅 WTN 流。
	 * @group WTN stream
	 * @order 5
	 */
	
	updatePublicStreamParam: (publicStreamId: string, publicStreamParam: Partial<PublicStreamConfig>) => Promise<void>;
	/** 
	 * @brief 停止发布 WTN 流。由 [startPushPublicStream](104478#rtcengine-startpushpublicstream) 发布的 WTN 流。
	 * @param publicStreamId  WTN 流 ID。
	 *                       指定的流必须为当前用户所发布。
	 * @return
	 * @notes 通过 [startPlayWTN](104478#wtnstream-startplaywtn) 发布的 WTN 流需要通过 [stopPlayWTN](104478#wtnstream-stopplaywtn) 停止发布。
	 * @group WTN stream
	 * @order 6
	 */
	
	stopPushPublicStream: (publicStreamId: string) => Promise<void>;
	/** 
	 * @deprecated since 4.65, use [startPlayWTN](104478#wtnstream-startplaywtn) instead.
	 * @brief 订阅指定公共流。
	 *        无论用户是否在房间内，都可以调用本接口获取和播放指定的公共流。
	 * @param publicStreamId 公共流 ID。
	 *                       如果指定流暂未发布，则本地客户端将在其开始发布后接收到流数据。
	 * @return
	 * @notes + 建议在调用本接口前，先调用 [setPublicStreamVideoPlayer](#setpublicstreamvideoplayer) 设置使用的视图和渲染模式。
	 *        + 调用本接口后，可以通过 [onFirstPublicStreamVideoFrameDecoded](104479#onfirstpublicstreamvideoframedecoded) 和 [onFirstPublicStreamAudioFrameDecoded](104479#onfirstpublicstreamaudioframedecoded) 回调公共流的视频和音频首帧解码情况。
	 *        + 调用本接口后，可以通过 [onPublicStreamSEIMessageReceived](104479#onpublicstreamseimessagereceived) 回调公共流中包含的 SEI 信息。
	 *        + 调用 [stopPlayPublicStream](#stopplaypublicstream) 取消订阅公共流。
	 */
	
	startPlayPublicStream: (publicStreamId: string) => Promise<void>;
	/** 
	 * @deprecated since 4.65, use [stopPlayWTN](104478#wtnstream-stopplaywtn) instead.
	 * @brief 取消订阅指定公共流。
	 *        关于订阅公共流，查看 [startPlayPublicStream](104478#startplaypublicstream)。
	 * @param publicStreamId 公共流 ID。
	 * @return
	 */
	
	stopPlayPublicStream: (publicStreamId: string) => Promise<void>;
	/** 
	 * @deprecated since 4.65, use [setWTNRemoteVideoPlayer](104478#wtnstream-setwtnremotevideoplayer) instead.
	 * @brief 为指定公共流设置使用的视图和渲染模式。
	 * @param publicStreamId 公共流 ID。
	 * @param videoPlayerOption 视图信息和渲染模式。
	 */
	
	setPublicStreamVideoPlayer: (publicStreamId: string, videoPlayerOption: Omit<VideoPlayerOption, "userId" | "playerId">) => void;
	/** 
	 * @brief 停止内部摄像头采集时，使用静态图片填充本地推送的视频流。
	 * @param index
	 * @param filePath 以 Http 协议表示的图片地址，或 Blob 对象。
	 *    图片类型支持：JPG、PNG、BMP。
	 *    图片长宽比和视频编码参数不一致时，图片会被等比缩放，直至其两边长小于等于视频编码参数中的宽高。
	 * @notes + Mac 端的 Chrome 浏览器上支持此功能
	 * + 建议你在结束采集前，就进行静态图片填充设置，避免视频录制时，出现黑帧。
	 * + 本地预览时，无法看到此图片。
	 * @group Video Management
	 * @order 40
	 */
	
	setDummyCaptureImagePath: (index: StreamIndex, filePath: string) => Promise<void>;
	/** 
	 * @brief 获取合流转推默认参数。
	 * @return 转推直播默认音视频参数。
	 * @group Push to CDN
	 * @order 0
	 */
	
	defaultTranscoding: () => Required<LiveTranscodeConfig>;
	/** 
	 * @brief 设置订阅的音视频流的回退选项。
	 *        回退指在网络不佳时允许订阅流进行降级或只订阅音频流，以保证通话流畅。
	 * @param option 订阅的音视频流回退选项
	 * @return + `true` 设置成功；
	 *         + `false` 设置失败。
	 * @notes + 使用前提：必须在进房前调用本方法，进房后设置或更改设置无效。并且已经调用 [setLocalSimulcastMode](#rtcengine-setlocalsimulcastmode) 开启 Simulcast 功能。
	 *        + 设置回退选项后，订阅的音视频流发生回退或从回退中恢复时，会收到 [onSimulcastSubscribeFallback](104479#onsimulcastsubscribefallback) 和 [onRemoteVideoSizeChanged](104479#onremotevideosizechanged) 回调通知。
	 *        + 可以调用 API 或者在服务端下发策略设置回退。当使用服务端下发配置实现时，下发配置优先级高于在客户端使用 API 设定的配置。
	 * @group Audio & Video Transport
	 * @order 30
	 */
	
	setSubscribeFallbackOption: (option: SubscribeFallbackOption) => boolean;
	/** 
	 * @brief 设置用户优先级。
	 *        该方法与 [setSubscribeFallbackOption](104478#setsubscribefallbackoption) 搭配使用。
	 *        开启回退后，会优先保证收到的高优先级用户的流的质量。
	 * @param userId 远端用户的 ID
	 * @param priority 远端用户优先级
	 * @return + `true` 设置成功；
	 *         + `false` 设置失败。
	 * @group Audio & Video Transport
	 * @order 35
	 */
	
	setRemoteUserPriority: (userId: string, priority: RemoteUserPriority) => boolean;
	/** 
	 * @brief 启动音频播放设备检测。测试启动后，循环播放指定的音频文件，同时将通过 [onAudioPlaybackDeviceTestVolume](104479#onaudioplaybackdevicetestvolume) 回调播放时的音量信息。
	 * @param filePath 指定播放设备检测的音频文件网络地址。包括格式 wav 和 mp3。
	 * @param indicationInterval [onAudioPlaybackDeviceTestVolume](104479#onaudioplaybackdevicetestvolume) 音量回调的时间间隔，推荐设置为 200 毫秒或以上。单位为毫秒。最小值为 100 毫秒。
	 * @return 当测试流程结束时 Resolve。
	 *         `REPEAT_DEVICE_TEST`: 重复开启检测。
	 * @notes + 该方法在用户进房前后均可调用。但不可与其它音频设备测试功能同时应用。
	 * + 调用 [stopAudioPlaybackDeviceTest](#stopaudioplaybackdevicetest) 可以停止测试。
	 * @group Device Management
	 * @order 20
	 */
	
	startAudioPlaybackDeviceTest: (filePath: string, indicationInterval: number) => Promise<void>;
	/** 
	 * @brief 停止音频播放设备测试。
	 * @notes 调用 [startAudioPlaybackDeviceTest](#startaudioplaybackdevicetest) 后，调用本方法停止测试。
	 * @group Device Management
	 * @order 21
	 */
	
	stopAudioPlaybackDeviceTest: () => void;
	/** 
	 * @brief 开始音频采集设备和音频播放设备测试。
	 *        建议提前调用 [enableAudioPropertiesReport](104478#enableaudiopropertiesreport) 注册音量提示回调，测试开始后，音频设备开始采集本地声音，可以通过 [onLocalAudioPropertiesReport](104479#onlocalaudiopropertiesreport) 获取采集音量。
	 * @param indicationInterval 测试录音播放时触发 [onAudioPlaybackDeviceTestVolume](104479#onaudioplaybackdevicetestvolume) 播放音量回调，本参数指定了该周期回调的时间间隔。推荐设置为 200 毫秒或以上。单位为毫秒。最小值为 100 毫秒。
	 * @param onAutoplayFailed 由于浏览器自动播放策略影响，导致录制音频播放失败时回调。`resume` 为恢复播放方法，建议在用户点击后同步执行。
	 * @return 当测试流程结束时 Resolve。
	 *         还可能返回如下错误码。
	 *         + `NOT_SUPPORTED`: 浏览器不支持设置音频播放设备或测试音频采集/播放设备。
	 *         + `REPEAT_DEVICE_TEST`: 重复开启检测。
	 *         + `AUDIO_DEVICE_RECORD_FAILED`: 开启音频设备测试失败，请重试。
	 * @notes + 该方法在 joinRoom 前后均可调用。但不可与其它音频设备测试功能同时应用。
	 *        + 音频回路测试时可调用 [setCaptureVolume]({{api}}#RTCEngine.setCaptureVolume) 调节采集音量；调用 [setPlaybackVolume]({{api}}#RTCEngine.setPlaybackVolume) 无效。
	 *        + 调用本接口 30s 后，采集自动停止，并开始播放采集到的声音。录音播放完毕后，设备测试流程自动结束。你也可以在 30 s 内调用 [stopAudioDeviceRecordAndPlayTest](#stopaudiodevicerecordandplaytest) 来停止采集并开始播放此前采集到的声音。
	 *        + 调用 [stopAudioDevicePlayTest](#stopaudiodeviceplaytest) 可以停止音频设备采集和播放测试。
	 *        + 该方法仅在本地进行音频设备测试，不涉及网络连接。
	 * @group Device Management
	 * @order 25
	 */
	
	startAudioDeviceRecordTest: (indicationInterval: number, onAutoplayFailed?: (resume: () => Promise<any>) => any) => Promise<void>;
	/** 
	 * @brief 停止采集本地音频，并开始播放采集到的声音。录音播放完毕后，设备测试流程结束。
	 *        调用 [startAudioDeviceRecordTest](104478#startaudiodevicerecordtest) 30s 内调用本接口来停止采集并开始播放此前采集到的声音。
	 * @notes 调用本接口开始播放录音后，可以在播放过程中调用 [stopAudioDevicePlayTest](#stopaudiodeviceplaytest) 停止播放。
	 * @group Device Management
	 * @order 26
	 */
	
	stopAudioDeviceRecordAndPlayTest: () => void;
	/** 
	 * @brief 停止由调用 [startAudioDeviceRecordTest](104478#startaudiodevicerecordtest) 开始的音频播放设备测试。
	 *        在音频播放设备测试自动结束前，可调用本接口停止音频采集与播放测试。
	 * @group Device Management
	 * @order 27
	 */
	
	stopAudioDevicePlayTest: () => void;
	/** 
	 * @brief 设置音质档位
	 * @param profile 音质档位。不同的音质档位有着不同的音频参数，带来不同的听觉体验，你应根据业务场景选择适合的音质档位。
	 * @notes 你需要在开始音频采集和首次发布之前调用本接口。
	 * @return
	 * @group Audio Management
	 * @order 20
	 */
	
	setAudioProfile: (profile: AudioProfileType) => Promise<void>;
	/** 
	 * @hidden
	 * @brief 设置音频编码码率
	 * @param maxBitrate 码率值，取值范围为 [6, 256]
	 * @return
	 */
	
	setAudioEncodeMaxBitrate: (maxBitrate: number) => Promise<void>;
	/** 
	 * @brief 获取本地用户的音频或者视频的 [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack)。
	 * @param streamIndex 流属性，包括主流、屏幕流。
	 * @param type 媒体流类型，视频或音频。
	 *             音频：可分别获取本地麦克风、本地音频外部源、播放本地音频文件、本地屏幕流音频的音轨。
	 *             视频：可分别获取本地摄像头、本地视频外部源、本地屏幕视频的视频轨道。
	 * @return 当 MediaStreamTrack 不存在时，比如没有开启采集，返回 `undefined`。
	 * @notes + 调用时机，本地采集开启后或已指定外部 MediaStreamTrack 后。
	 *        + 当调用接口或拔出设备关闭本地采集时，将触发该 MediaStreamTrack 回调的 `ended` 事件，MediaStreamTrack 随即被关闭。
	 *        + 通过 MediaStreamTrack 可以获取实际分辨率、设备 ID 参数、实时音量信息，对轨道进行 muted 和 stop 操作，调整音量等。
	 *        + 我们推荐使用 RTC 提供的接口实现以下功能：<br/>
	 *         &ensp; - 获取本地流分辨率和音量：[onLocalStreamStats](104479#onlocalstreamstats)
	 *         &ensp; - 获取设备 ID： [enumerateDevices](#enumeratedevices)
	 *         &ensp; - 停止采集：[stopAudioCapture](#stopaudiocapture)，[stopVideoCapture](#stopvideocapture)
	 * @group Custom Stream Processing
	 * @order 20
	 */
	
	getLocalStreamTrack: (streamIndex: StreamIndex, type: "video" | "audio") => MediaStreamTrack | undefined;
	/** 
	 * @brief 获取已订阅的远端用户的音频或者视频的 [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack)。
	 * @param userId 远端用户 ID。
	 * @param streamIndex 流属性，包括主流、屏幕流。
	 * @param type 媒体流类型，视频或音频。
	 *             可分别单独获取远端麦克风、远端屏幕音频的音轨。
	 *             可分别获取远端摄像头、远端屏幕视频的视频轨道。
	 * @return 当 MediaStreamTrack 不存在时，比如没有订阅该流，返回 `undefined`。
	 * @notes + 调用时机，订阅该远端流之后。
	 *        + 本地用户取消订阅该流时，将触发该 MediaStreamTrack 回调的 `ended` 事件， MediaStreamTrack 随即被关闭。
	 *        + 通过 MediaStreamTrack 可以获取实际分辨率、实时音量信息，对轨道进行 muted 和 stop 操作，调整音量等。
	 *        + 我们推荐使用 RTC 提供的接口实现以下功能。<br/>
	 *         &ensp; - 获取远端流分辨率和音量：[onRemoteStreamStats]({{callback}}#onremotestreamstats)
	 *         &ensp; - 取消订阅：[unsubscribeStream](#unsubscribestream)，[unsubscribeScreen](#unsubscribescreen)
	 * @group Custom Stream Processing
	 * @order 25
	 */
	
	getRemoteStreamTrack: (userId: string, streamIndex: StreamIndex, type: "video" | "audio") => MediaStreamTrack | undefined;
	/** 
	 * @brief 获取已订阅的 WTN 流的音频或者视频的 [MediaStreamTrack](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack)。
	 * @param id  WTN 流 ID。
	 * @param type 媒体流类型，视频或音频。
	 * @return 当 MediaStreamTrack 不存在时，比如没有订阅该 WTN 流，返回 `undefined`。
	 * @notes + 调用时机，调用 [startPlayWTN](104478#wtnstream-startplaywtn) 订阅 WTN 流后。
	 *        + 调用 [stopPlayWTN](104478#wtnstream-stopplaywtn) 停止订阅 WTN 流时，将触发该 MediaStreamTrack 回调的 `ended` 事件， MediaStreamTrack 随即被关闭。
	 * @group Custom Stream Processing
	 * @order 30
	 */
	
	getPublicStreamTrack: (id: string, type: "video" | "audio") => MediaStreamTrack | undefined;
	/** 
	 * @brief 截取本地视频画面
	 * @param streamIndex 截图的视频流。
	 * @notes + 在调用此接口前，请确保已经发起采集。当 [getLocalStreamTrack](104478#getlocalstreamtrack) 不为空时，说明已经采集到视频流。
	 * + 本地视频处理的效果仅美颜和虚拟背景会包含在截取的画面中。
	 * + 不管采用 SDK 内部采集，还是自定义采集，都可以进行截图。
	 * @return `INVOKED_BEFORE_CAPTURE`: 指定的视频流不存在，请确保指定的流已发布。
	 * @group Video Snapshot
	 * @order 0
	 */
	
	takeLocalSnapshot: (streamIndex: StreamIndex) => Promise<ImageData>;
	/** 
	 * @brief 截取远端视频画面
	 * @param id 用户 ID/ WTN 流 ID
	 * @param streamIndex 截图的视频流。
	 * @return `STREAM_NOT_EXIST`: 目标流不存在。请输入正确的 ID，或确认目标流在房间内。
	 * @notes 在调用此接口前，请确保已经订阅远端流。当 [getRemoteStreamTrack](104478#rtcengine-getremotestreamtrack) 不为空时，说明已经订阅到远端流。
	 * @group Video Snapshot
	 * @order 1
	 */
	
	takeRemoteSnapshot: (id: string, streamIndex: StreamIndex) => Promise<ImageData>;
	/** 
	 * @brief 注册插件。
	 *        你可以通过插件实现[基础美颜功能](https://www.volcengine.com/docs/6348/148646)、[虚拟背景功能](https://www.volcengine.com/docs/6348/697417)、[AI 降噪功能](https://www.volcengine.com/docs/6348/148647)。
	 * @param extension 插件实例。
	 * @return
	 * @group Extensions
	 * @order 0
	 */
	
	registerExtension: (extension: RTCExtension) => Promise<void>;
	/** 
	 * @brief 识别或翻译房间内所有用户的语音，形成字幕。语音识别或翻译的结果会通过 [onSubtitleMessageReceived](104479#onsubtitlemessagereceived) 事件回调给你。
	 *        调用该方法后，你会收到 [onSubtitleStateChanged](104479#onsubtitlestatechanged) 回调，通知字幕是否开启。
	 * @param config 字幕配置信息。
	 * @return `SUBTITLE_ALREADY_ON`: 重复调用，字幕已开启。
	 * @notes + 使用字幕功能前，你需要在 [RTC 控制台](https://console.volcengine.com/rtc/cloudRTC?tab=subtitle) 开启实时字幕功能。</br>
	 *         &ensp; - 如果你需要使用流式语音识别模式，你应在[语音技术控制台](https://console.volcengine.com/speech/service/16)创建流式语音识别应用。创建时，服务类型应选择 `流式语音识别`，而非 `音视频字幕生成`。创建后，在 [RTC 控制台](https://console.volcengine.com/rtc/cloudRTC?tab=subtitle) 上启动流式语音识别，并填写创建语音技术应用时获取的相关信息，包括：APP ID，Access Token，和 Cluster ID。
	 *         &ensp; - 如果你需要使用实时语音翻译模式，你应开通机器翻译服务，参考[开通服务](https://www.volcengine.com/docs/4640/130262)。完成开通后，在 [RTC 控制台](https://console.volcengine.com/rtc/cloudRTC?tab=subtitle) 上启用实时语音翻译模式。
	 *        + 此方法需要在进房后调用。
	 *        + 如需指定源语言，你需要在调用 [joinRoom]({{api}}#RTCEngine.joinRoom) 接口进房时，通过 `extraInfo` 参数传入格式为 `"语种英文名": "语种代号"` JSON 字符串，例如设置源语言为英文时，传入 `"source_language": "en"`。如未指定源语言，SDK 会将浏览器语种设定为源语言。如果你的浏览器语种不是中文、英文和日文，此时 SDK 会自动将中文设为源语言。</br>
	 *         &ensp; - 识别模式下，你可以传入 [RTC 控制台](https://console.volcengine.com/rtc/cloudRTC?tab=subtitle)上预设或自定义的语种英文名和语种代号。识别模式下支持的语言参看[识别模式语种支持](https://www.volcengine.com/docs/6561/109880)。
	 *         &ensp; - 翻译模式下，你需要传入机器翻译规定的语种英文名和语种代号。翻译模式下支持的语言及对应的代号参看[翻译模式语言支持](https://www.volcengine.com/docs/4640/35107)。
	 * @group Live Caption and Translation
	 * @order 0
	 */
	
	startSubtitle: (config: RTCSubtitleConfig) => Promise<void>;
	/** 
	 * @brief 开启字幕翻译后切换源语种。
	 * @param config 源字幕配置。
	 * @return 切换成功后，你会收到 [onSubtitleStateChanged](104479#onsubtitlestatechanged) 回调通知。
	 * @notes + 你可以在调用 [startSubtitle]({{api}}#RTCEngine.startSubtitle) 开启字幕翻译后，调用本接口，动态切换源语种。
	 * + 如需在开启字幕翻译前指定源语言，你需要在调用 [joinRoom]({{api}}#RTCEngine.joinRoom) 接口进房时，通过 `extraInfo` 参数传入格式为 `"语种英文名": "语种代号"` JSON 字符串，例如设置源语言为英文时，传入 `"source_language": "en"`。如未指定源语言，SDK 会将浏览器语种设定为源语言。如果你的浏览器语种不是中文、英文和日文，此时 SDK 会自动将中文设为源语言。
	 * + 识别模式下，应确保指定的源语种已在 [RTC 控制台](https://console.volcengine.com/rtc/cloudRTC?tab=subtitle)上添加。
	 * @group Live Caption and Translation
	 * @order 2
	 */
	
	updateSubtitleConfig: (config: UpdateSubtitleConfig) => Promise<void>;
	/** 
	 * @brief 关闭字幕。
	 *        调用该方法后，你会收到 [onSubtitleStateChanged](104479#onsubtitlestatechanged) 回调，通知字幕是否关闭。
	 * @group Live Caption and Translation
	 * @order 1
	 */
	
	stopSubtitle: () => void;
	/** 
	 * @brief 设置远端音视频流是否同步渲染。
	 *        你可以通过关闭音视频同步，达到超低端到端延时的效果。
	 * @param  sync
	 *        &ensp; `true`：（默认值）开启同步。
	 *        &ensp; `false`：关闭同步。
	 * @return + `true`：设置成功。
	 *         + `false`：设置失败。
	 * @notes 必须在进房前设置，进房后设置或更改设置无效。
	 * @group Custom Stream Processing
	 * @order 35
	 */
	
	setRemoteStreamRenderSync: (sync: boolean) => boolean;
	/** 
	 * @hidden
	 */
	
	setJoinRoomParams: (params: ExtraJoinRoomParams) => void;
	/** 
	 * @hidden
	 */
	
	connect: () => Promise<void>;
	/** 
	 * @brief 调节音频采集音量。
	 * @param streamIndex 流属性，指定调节主流或屏幕流的采集音量。
	 * @param volume 采集的音量值和原始音量的比值，取值范围 [0, 400]，单位 %。默认值为 100%。
	 *               为保证更好的通话质量，建议将 volume 值设为 [0,100]。
	 * @notes + 建议开启采集后设置采集音量。
	 *        + 若调用本方法时尚未开始采集，设置将在开始采集后生效。
	 *        + 采集音量调节仅控制混音前的音频流。
	 * @group Audio Management
	 * @order 25
	 */
	
	setCaptureVolume: (streamIndex: StreamIndex, volume: number) => void;
	/** 
	 * @brief 调节本地播放的单个远端用户的音量。
	 * @param userId 音频所属远端用户 ID
	 * @param streamIndex 流属性，指定调节主流或屏幕流的播放音量。
	 * @param volume 播放的音量值和原始音量的比值，取值范围 [0, 400]，单位 %。默认值为 100%。
	 *               为保证更好的通话质量，建议将 volume 值设为 [0,100]。
	 * @notes + 建议成功播放远端流后设置音量。
	 *        + 若调用本方法时尚未订阅远端用户或没有播放远端用户音频，设置将在开始播放远端音频后生效。
	 *        + [大会模式](113547)下不支持设置远端用户音量。
	 * @group Audio Management
	 * @order 26
	 */
	
	setPlaybackVolume: (userId: string, streamIndex: StreamIndex, volume: number) => void;
	/** 
	 * @deprecated since 4.65, use [setWTNRemoteAudioPlaybackVolume](104478#wtnstream-setwtnremoteaudioplaybackvolume) instead.
	 * @brief 调节本地播放的 WTN 流播放音量。
	 * @param publicStreamId 音频所属 WTN 流 ID
	 * @param volume 播放的音量值和原始音量的比值，取值范围 [0, 400]，单位 %。默认值为 100%。
	 *               为保证更好的通话质量，建议将 volume 值设为 [0,100]。
	 * @notes + 建议成功播放 WTN 流后设置音量。
	 *        + 若调用本方法时尚未播放 WTN 流，设置将在开始播放后生效。
	 */
	
	setPublicStreamVolume: (publicStreamId: string, volume: number) => void;
	/** 
	 * @brief 开始跨房间转发媒体流，示例代码可参看[跨房间转发媒体流功能文档](https://www.volcengine.com/docs/6348/104398)。
	 *        在调用 [joinRoom]({{api}}#RTCEngine.joinRoom) 后调用本接口，实现向多个房间转发媒体流，适用于跨房间连麦等场景。
	 * @param forwardStreamInfos 跨房间转发媒体流信息。
	 * @return 跨房间转发媒体流状态信息。
	 *         还可能返回错误码 `UNEXPECTED_INVOKE_FORWARD_STREAM`: 跨房间转发媒体流相关 API 的调用时机不正确，请参考各接口说明确认调用的先后顺序。
	 * @notes + 开始转发后，目标房间中的用户将接收到本地用户进房 [onUserJoined]({{callback}}#EngineEvents.onUserJoined) 和发流 [onUserPublishStream]({{callback}}#EngineEvents.onUserPublishStream)/[onUserPublishScreen]({{callback}}#EngineEvents.onUserPublishScreen) 的回调。
	 *        + 调用本方法后，可以调用 [updateForwardStreamToRooms]({{api}}#RTCEngine.updateForwardStreamToRooms) 更新目标房间信息，如增加或减少目标房间等。
	 *        + 调用本方法后，可以调用 [stopForwardStreamToRooms]({{api}}#RTCEngine.stopForwardStreamToRooms) 停止向所有房间转发媒体流。
	 *        + 调用本方法后，可以调用 [pauseForwardStreamToAllRooms]({{api}}#RTCEngine.pauseForwardStreamToAllRooms) 暂停向所有房间转发媒体流，并在之后调用 [resumeForwardStreamToAllRooms]({{api}}#RTCEngine.resumeForwardStreamToAllRooms) 恢复转发。
	 * @group Audio & Video Transport
	 * @order 40
	 */
	
	startForwardStreamToRooms: (forwardStreamInfos: ForwardStreamInfo[]) => Promise<ForwardStreamStateInfo[]>;
	/** 
	 * @brief 更新跨房间媒体流转发信息。
	 *        通过 [startForwardStreamToRooms]({{api}}#RTCEngine.startForwardStreamToRooms) 发起媒体流转发后，可调用本方法增加或者减少目标房间，或更新房间密钥。
	 * @param forwardStreamInfos 跨房间媒体流转发目标房间信息。
	 * @return 跨房间转发媒体流状态信息。
	 *         还可能返回错误码 `UNEXPECTED_INVOKE_FORWARD_STREAM`: 跨房间转发媒体流相关 API 的调用时机不正确，请参考各接口说明确认调用的先后顺序。
	 * @notes + 增加目标房间后，新增目标房间中的用户将接收到本地用户进房 [onUserJoined]({{callback}}#EngineEvents.onUserJoined) 和发流 [onUserPublishStream]({{callback}}#EngineEvents.onUserPublishStream)/[onUserPublishScreen]({{callback}}#EngineEvents.onUserPublishScreen) 的回调。
	 *        + 删减目标房间后，原目标房间中的用户将接收到本地用户停止发布 [onUserUnpublishStream]({{callback}}#EngineEvents.onUserUnpublishStream)/[onUserUnpublishScreen]({{callback}}#EngineEvents.onUserUnpublishScreen) 和退房 [onUserLeave]({{callback}}#EngineEvents.onUserLeave) 的回调。
	 * @group Audio & Video Transport
	 * @order 41
	 */
	
	updateForwardStreamToRooms: (forwardStreamInfos: ForwardStreamInfo[]) => Promise<ForwardStreamStateInfo[]>;
	/** 
	 * @brief 停止向所有目标房间转发媒体流。
	 * @return 跨房间转发媒体流状态信息。
	 *         还可能返回错误码 `UNEXPECTED_INVOKE_FORWARD_STREAM`: 跨房间转发媒体流相关 API 的调用时机不正确，请参考各接口说明确认调用的先后顺序。
	 * @notes + 调用本方法后，原目标房间中的用户将接收到本地用户停止发布 [onUserUnpublishStream]({{callback}}#EngineEvents.onUserUnpublishStream)/[onUserUnpublishScreen]({{callback}}#EngineEvents.onUserUnpublishScreen) 和退房 [onUserLeave]({{callback}}#EngineEvents.onUserLeave) 的回调。
	 *        + 如果需要停止向指定的房间转发媒体流，请调用 [updateForwardStreamToRooms]({{api}}#RTCEngine.updateForwardStreamToRooms) 更新房间信息。
	 *        + 如果需要暂停转发，请调用 [pauseForwardStreamToAllRooms]({{api}}#RTCEngine.pauseForwardStreamToAllRooms)，并在之后调用 [resumeForwardStreamToAllRooms]({{api}}#RTCEngine.resumeForwardStreamToAllRooms) 恢复转发。
	 * @group Audio & Video Transport
	 * @order 42
	 */
	
	stopForwardStreamToRooms: () => Promise<ForwardStreamStateInfo[]>;
	/** 
	 * @brief 暂停向所有目标房间转发媒体流。
	 *        调用本方法暂停向所有目标房间转发后，你可以调用 [resumeForwardStreamToAllRooms]({{api}}#RTCEngine.resumeForwardStreamToAllRooms) 恢复转发。
	 * @return 跨房间转发媒体流状态信息。
	 *         还可能返回错误码 `UNEXPECTED_INVOKE_FORWARD_STREAM`: 跨房间转发媒体流相关 API 的调用时机不正确，请参考各接口说明确认调用的先后顺序。
	 * @notes 调用本方法后，目标房间中的用户将接收到本地用户停止发布 [onUserUnpublishStream]({{callback}}#EngineEvents.onUserUnpublishStream)/[onUserUnpublishScreen]({{callback}}#EngineEvents.onUserUnpublishScreen) 和退房 [onUserLeave]({{callback}}#EngineEvents.onUserLeave) 的回调。
	 * @group Audio & Video Transport
	 * @order 43
	 */
	
	pauseForwardStreamToAllRooms: () => Promise<ForwardStreamStateInfo[]>;
	/** 
	 * @brief 恢复向所有目标房间转发媒体流。
	 * @return 跨房间转发媒体流状态信息。
	 *         还可能返回错误码 `UNEXPECTED_INVOKE_FORWARD_STREAM`: 跨房间转发媒体流相关 API 的调用时机不正确，请参考各接口说明确认调用的先后顺序。
	 * @notes 目标房间中的用户将接收到本地用户进房 [onUserJoined]({{callback}}#EngineEvents.onuserjoined) 和发流 [onUserPublishStream]({{callback}}#EngineEvents.onuserpublishstream)/[onUserPublishScreen]({{callback}}#EngineEvents.onuserpublishscreen) 的回调。
	 * @group Audio & Video Transport
	 * @order 44
	 */
	
	resumeForwardStreamToAllRooms: () => Promise<ForwardStreamStateInfo[]>;
	/** 
	 * @hidden
	 */
	
	peerConnection: RTCPeerConnection | undefined;
	/** 
	 * @hidden
	 */
	
	iceState: RTCIceConnectionState | undefined;
	/** 
	 * @brief 设置本端发布流在音频选路中的优先级。
	 * @param audioSelectionPriority 本端发布流在音频选路中的优先级，默认正常参与音频选路。
	 * @note + 在控制台上为本 appId 开启音频选路后，调用本接口才会生效。进房前后调用均可生效。更多信息参见[音频选路](https://www.volcengine.com/docs/6348/113547)。
	 * + 如果本端用户同时加入不同房间，使用本接口进行的设置相互独立。<br>
	 * @group Room Management
	 * @order 12
	 */
	
	setAudioSelectionConfig: (audioSelectionPriority: AudioSelectionPriority) => Promise<void>;
	/** 
	 * @brief 获取用户订阅的远端视频流统计信息以及网络状况。
	 * @return 包括摄像头采集和屏幕共享视频。
	 * @notes 连续 1 秒内调用本接口获取到的信息相同。
	 * @group Audio & Video Transport
	 * @order 66
	 */
	
	getRemoteVideoStats: () => Record<string, RemoteUserVideoStats[]>;
	/** 
	 * @brief 获取用户订阅的远端音频流统计信息以及网络状况。
	 * @return 包括麦克风采集和屏幕共享音频。
	 * @notes 连续 1 秒内调用本接口获取到的信息相同。
	 * @group Audio & Video Transport
	 * @order 67
	 */
	
	getRemoteAudioStats: () => Record<string, RemoteUserAudioStats[]>;
	/** 
	 * @brief 获取本地视频流统计信息以及网络状况。
	 * @return 包括摄像头采集和屏幕共享视频。
	 * @notes 连续 1 秒内调用本接口获取到的信息相同。
	 * @group Audio & Video Transport
	 * @order 68
	 */
	
	getLocalVideoStats: () => LocalUserVideoStats;
	/** 
	 * @brief 本地音频流统计信息以及网络状况。
	 * @return 包括麦克风采集和屏幕共享音频。
	 * @notes 连续 1 秒内调用本接口获取到的信息相同。
	 * @group Audio & Video Transport
	 * @order 69
	 */
	
	getLocalAudioStats: () => LocalUserAudioStats;
	/** 
	 * @hidden for internal use
	 */
	
	getPublicVideoStats: () => Record<string, RemoteVideoStats>;
	/** 
	 * @hidden for internal use
	 */
	
	getPublicAudioStats: () => Record<string, RemoteAudioStats>;
	/** 
	 * @valid since V4.63
	 * @brief 打开/关闭耳返功能。
	 * @param streamIndex 流属性，包括主流、屏幕流。
	 * @param position 是否开启耳返音频。指定耳返的音频是否经过前处理。
	 * @return 开启功能后，如果耳返自动播放失败，建议在收到 [onAutoplayFailed](104479#engineevents-onautoplayfailed) 通知时再次调用本接口开启。
	 * @note - 你可以在创建引擎后随时开关耳返功能。
	 *       - 你可以通过 [setEarMonitorVolume](104478#rtcengine-setearmonitorvolume) 调节耳返音量。
	 *       - 使用耳返功能建议佩戴耳机，确保获取到最佳的音频效果。
	 * @group Audio Management
	 * @order 75
	 */
	
	setEarMonitorMode: (streamIndex: StreamIndex, position: EarMonitorPosition) => Promise<void>;
	/** 
	 * @valid since V4.63
	 * @brief 设置耳返音量。
	 * @param streamIndex 流属性，包括主流、屏幕流。
	 * @param volume 耳返音量，调节范围：[0,400]。初始值为 `100`。
	 * @note  建议开始采集音频并开启了耳返功能后，设置耳返音量。
	 * @group Audio Management
	 * @order 80
	 */
	
	setEarMonitorVolume: (streamIndex: StreamIndex, volume: number) => void;
}
/** 
 * @id VERTC
 * @list overview
 * @detail api
 */

export interface IVERTC {
	/** 
	 * @brief 创建引擎对象。你必须先使用此方法，以使用 RTC 提供的各种音视频能力。
	 * 再次调用此方法时，会创建另一个独立的引擎实例。
	 * @param appId 每个应用的唯一标识符，由 RTC 控制台随机生成的。不同的 AppId 生成的实例在 RTC 中进行音视频通话完全独立，无法互通。
	 * @param config 引擎级的设置项。例如，是否开启自动播放。
	 * @return 创建成功后返回一个可用的 `IRTCEngine` 实例
	 * @notes + 通过分别调用 [destroyEngine](#destroyengine) 销毁已经创建的多个引擎实例。
	 *        + 每个引擎都将消耗一定系统资源，通常不建议同时创建多于 2 个引擎实例。
	 * @group Engine Management
	 * @order 0
	 */
	
	createEngine: (appId: string, config?: EngineConfig) => IRTCEngine;
	/** 
	 * @hidden
	 */
	
	createBLWEngine: (appId: string, config?: EngineConfig) => IRTCEngine;
	/** 
	 * @brief 手动销毁通过 [createEngine](104478#createengine) 所创建的引擎对象。
	 * @param engine 销毁所有和此 `IRTCEngine` 实例相关的内存，并且停止与媒体服务器的任何交互。
	 * @notes + 请确保与需要销毁的相关的业务场景全部结束后，才调用此方法。
	 *        + 本方法为阻塞调用，会阻塞当前线程直到 SDK 彻底完成退出逻辑，因而需要注意不要在回调线程中直接调用本方法，也需要注意不要在回调方法中等待主线程的执行，而同时在主线程调用本方法，从而造成死锁
	 * @group Engine Management
	 * @order 1
	 */
	
	destroyEngine: (engine: IRTCEngine) => void;
	/** 
	 * @brief 获取 SDK 当前的版本号。
	 * @return SDK 当前的版本号
	 * @group Engine Management
	 * @order 10
	 */
	
	getSdkVersion: () => string;
	/** 
	 * @brief 枚举可用的媒体输入和输出设备，比如麦克风、摄像头、耳机等。
	 *        可以通过该方法获取设备的 deviceId, 用于在 [setAudioPlaybackDevice](104478#setaudioplaybackdevice)、[startVideoCapture](104478#startvideocapture)、[startAudioCapture](104478#startaudiocapture) 方法中指定采集/播放设备。
	 * @return 媒体设备列表。参看 [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo)。
	 * @notes 浏览器只有在已经获得设备权限时，才能准确获取设备信息。建议通过 [enableDevices](104478#vertc-enabledevices) 访问授权后调用本接口。
	 * @group Device Management
	 * @order 0
	 */
	
	enumerateDevices: () => Promise<MediaDeviceInfo[]>;
	/** 
	 * @brief 向用户获取设备权限
	 * @param options 需要获取权限的设备类型
	 * @return + `video: boolean` 是否获得视频设备权限
	 *         + `audio: boolean` 是否获得音频设备权限
	 *         + `videoExceptionError?: DOMException` 获取视频设备权限报错信息
	 *         + `audioExceptionError?: DOMException` 获取音频设备权限报错信息
	 * @group Device Management
	 * @order 5
	 */
	
	enableDevices: (options?: {
		/** 
		 * @brief 视频设备
		 */
		
		video: boolean;
		/** 
		 * @brief 音频设备
		 */
		
		audio: boolean;
	}) => Promise<{
		video: boolean;
		audio: boolean;
		videoExceptionError?: DOMException;
		audioExceptionError?: DOMException;
	}>;
	/** 
	 * @brief 该方法枚举可用的麦克风。
	 *        可以通过该方法获取设备的 `deviceId`, 用于在 [startAudioCapture](104478#startaudiocapture)、[setAudioCaptureDevice](104478#setaudiocapturedevice) 方法中指定使用的麦克风设备。
	 * @return 所有的麦克风设备列表。参看 [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo)。
	 * @notes 浏览器只有在已经获得设备权限时，才能准确获取设备信息。建议通过 [enableDevices](104478#vertc-enabledevices) 访问授权后调用本接口。
	 * @group Device Management
	 * @order 10
	 */
	
	enumerateAudioCaptureDevices: () => Promise<MediaDeviceInfo[]>;
	/** 
	 * @brief 该方法枚举可用的摄像头等。
	 *        可以通过该方法获取设备的 deviceId, 用于在 [startVideoCapture](104478#startvideocapture)、[setVideoCaptureDevice](104478#setvideocapturedevice) 方法中指定使用的摄像头设备。
	 * @return 所有的摄像头设备列表。参看 [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo)。
	 * @notes 浏览器只有在已经获得设备权限时，才能准确获取设备信息。建议通过 [enableDevices](104478#vertc-enabledevices) 访问授权后调用本接口。
	 * @group Device Management
	 * @order 11
	 */
	
	enumerateVideoCaptureDevices: () => Promise<MediaDeviceInfo[]>;
	/** 
	 * @brief 该方法枚举可用的音频播放设备，例如耳机、音箱等。
	 *        可以通过该方法获取设备的 deviceId, 可用于 [setAudioPlaybackDevice](104478#setaudioplaybackdevice) 方法中指定音频播放设备。
	 * @return 所有的音频播放设备列表。参看 [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo)。
	 * @notes 浏览器只有在已经获得设备权限时，才能准确获取设备信息。建议通过 [enableDevices](104478#vertc-enabledevices) 访问授权后调用本接口。
	 * @group Device Management
	 * @order 12
	 */
	
	enumerateAudioPlaybackDevices: () => Promise<MediaDeviceInfo[]>;
	/** 
	 * @brief 浏览器是否支持
	 * @return  + `True`: 支持
	 *          + `False`：不支持
	 * @group Engine Management
	 * @order 15
	 */
	
	isSupported: () => Promise<boolean>;
	/** 
	 * @brief 获取当前浏览器支持的编解码类型。
	 * 若你已开通 vp8 业务，可以在进房前调用该接口查看当前浏览器是否支持 vp8 编码类型
	 * @return 当前浏览器支持的编解码类型
	 * @group Engine Management
	 * @order 20
	 */
	
	getSupportedCodecs: () => Promise<string[]>;
	/** 
	 * @brief 配置本地缓存的日志级别, 以及可使用的最大缓存空间。
	 * @notes 本方法必须在调用 [createEngine](#createengine) 之前调用。若在 [createEngine](#createengine) 之后调用，则在 [destroyEngine](#destroyengine) 后的下一次 [createEngine](#createengine) 后生效。
	 * @group Engine Management
	 * @order 25
	 */
	
	setLogConfig: ({ logLevel, LogfileSize, }: {
		/** 
		 * @brief 本地缓存的日志级别。
		 * • `none`: 关闭日志。（默认值）
		 * • `error`: 错误。
		 * • `warning`: 警告。
		 * • `info`: 信息。
		 * • `trace`: 跟踪。
		 */
		
		logLevel?: "none" | "error" | "warning" | "info" | "trace";
		/** 
		 * @brief 日志可使用的最大缓存空间，单位为 MB。取值范围为 1～100 MB，默认值为 10 MB。
		 */
		
		LogfileSize?: number;
	}) => void;
	/** 
	 * @brief 下载本地缓存生成文件。
	 * @param key 本地缓存的 key。若为空则下载当前缓存中的日志。
	 * @group Engine Management
	 * @order 26
	 */
	
	downloadLog: (key?: string) => void;
	/** 
	 * @valid since V4.63
	 * @brief 在 Electron 框架下使用屏幕共享功能时，返回屏幕共享源列表。
	 * @param type 需要获取的共享源类型，应用窗口或屏幕。如果为空则获取所有可以获取的共享源。
	 * @notes 实现步骤和注意事项参见 [Electron 框架下通过 Web SDK 实现屏幕共享](https://www.volcengine.com/docs/6348/1340581)
	 * @return 屏幕共享源列表。
	 * 调用失败说明参见 [ERR_ELECTRON_IS_NULL](104480#errorcode) 和 [ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR](104480#errorcode)
	 * @group Screen Sharing
	 * @order 3
	 */
	
	getElectronScreenSources: (type?: ScreenSourceType) => Promise<ElectronDesktopCapturerSource[]>;
}
/** 
 * @id WTNstream
 * @list overview
 * @detail api
 */

export interface IWTNStream extends EnhancedEventEmitter<IWTNStreamEvents> {
	/** 
	 * @valid since 4.65
	 * @brief 将本地音视频发布为一路 WTN 流，用户无需进房。
	 *        发布后，同一 AppId 下的用户无需进房，即可通过 StreamId 订阅该流。
	 * @param token 动态密钥，用于对发流用户进行鉴权验证。
	 *        测试时可使用控制台生成临时 Token，RoomId 填写任意值。正式上线需要使用密钥 SDK 在你的服务端生成并下发 Token。Token 有效期及生成方式参看[使用 Token 完成鉴权](70121)。
	 *        使用不同 AppID 的 App 是不能互通的。
	 *        请务必保证生成 Token 使用的 AppID 和创建引擎时使用的 AppID 相同，否则会导致失败。
	 * @param streamId WTN ID。该字符串需符合正则表达式：`[a-zA-Z0-9_@\-\.]{1,128}`。
	 * @param videoMute 是否关闭视频。 `true`：关闭视频；`false`：开启视频。
	 * @param audioMute 是否关闭音频。 `true`：关闭音频；`false`：开启音频。
	 * @return 同时将收到 [onWTNPushStateChanged](104479#wtnstreamevents-onwtnpushstatechanged) 回调。
	 * @notes + 使用同一 `appID` 的用户，无论是否进房，可以调用 [startPlayWTN](#startplaywtn) 获取和播放指定的 WTN 流。
	 *        + 不同用户使用同一 WTN 流 ID 多次调用本接口时，RTC SDK 将使用最后一次调用时传入的参数更新 WTN 流。
	 *        + 使用不同的 WTN 流 ID 多次调用本接口可以发布多路 WTN 流。
	 *        + 调用 [stopPushWTN](#stopPushWTN) 停止推 WTN 流。
	 * @group WTN stream
	 * @order 11
	 */
	
	startPushWTN: (token: string | null, streamId: string, videoMute: boolean, audioMute: boolean) => Promise<void>;
	/** 
	 * @valid since 4.65
	 * @brief 停止发布 WTN 流。由 [startPushWTN](104478#wtnstream-startpushwtn) 发布的 WTN 流。
	 * @param streamId  WTN 流 ID。
	 *                  指定的流必须为当前用户所发布。
	 * @return 同时将收到 [onWTNPushStateChanged](104479#wtnstreamevents-onwtnpushstatechanged) 回调。
	 * @notes 通过 [startPushPublicStream](104478#rtcengine-startpushpublicstream) 发布的 WTN 流需要通过 [stopPushPublicStream](104478#rtcengine-stoppushpublicstream) 停止发布。
	 * @group WTN stream
	 * @order 12
	 */
	
	stopPushWTN: (streamId: string) => Promise<void>;
	/** 
	 * @valid since 4.65
	 * @brief 暂停/继续发布指定 WTN 流的音频。
	 * @param streamId WTN 流 ID。当前用户通过 [startPushWTN](104478#wtnstream-startpushwtn) 发布的 WTN 流。
	 * @param mute 是否关闭音频<br>
	 *       - `true`：关闭
	 *       - `false`：打开
	 * @return 同时将收到 [onWTNPushStateChanged](104479#wtnstreamevents-onwtnpushstatechanged) 回调。
	 * @group WTN stream
	 * @order 14
	 */
	
	muteWTNLocalAudio: (streamId: string, mute: boolean) => Promise<void>;
	/** 
	 * @valid since 4.65
	 * @brief 暂停/继续发布指定 WTN 流的视频。
	 * @param streamId WTN 流 ID。当前用户通过 [startPushWTN](104478#wtnstream-startpushwtn) 发布的 WTN 流。
	 * @param mute 是否关闭视频<br>
	 *       - `true`：关闭
	 *       - `false`：打开
	 * @return 同时将收到 [onWTNPushStateChanged](104479#wtnstreamevents-onwtnpushstatechanged) 回调。
	 * @group WTN stream
	 * @order 13
	 */
	
	muteWTNLocalVideo: (streamId: string, mute: boolean) => Promise<void>;
	/** 
	 * @valid since 4.65
	 * @brief 通过 WTN 流视频帧发送 SEI 数据。
	 * @param streamId WTN 流 ID。当前用户通过 [startPushWTN](104478#wtnstream-startpushwtn) 发布的 WTN 流。
	 * @param sei SEI 消息。
	 * @param repeatCount 消息发送重复次数。取值范围是 [0, max{29, %{视频帧率}-1}]。推荐范围 [2,4]。 <br>
	 *                    调用此接口后，SEI 数据会添加到从当前视频帧开始的连续 `repeat_count+1` 个视频帧中。
	 * @note
	 *        - 每秒发送的 SEI 消息数量建议不超过当前的视频帧率。
	 *        - 视频帧仅携带前后 2s 内收到的 SEI 数据。
	 *        - 消息发送成功后，远端会收到 [onWTNSEIMessageReceived](104479#wtnstreamevents-onwtnseimessagereceived) 回调。
	 *        - 调用失败时，本地及远端都不会收到回调。
	  * @group WTN stream
	  * @order 37
	 */
	
	sendWTNSEIMessage: (streamId: string, sei: Uint8Array, repeatCount: number) => void;
	/** 
	 * @valid since 4.65
	 * @brief 订阅指定 WTN 流。
	 *        无论用户是否在房间内，都可以调用本接口获取和播放指定的 WTN 流。
	 * @param token 动态密钥，用于对订阅用户进行鉴权验证。
	 *        测试时可使用控制台生成临时 Token，正式上线需要使用密钥 SDK 在你的服务端生成并下发 Token。Token 有效期及生成方式参看[使用 Token 完成鉴权](70121)。
	 *     使用不同 AppID 的 App 是不能互通的。
	 *     请务必保证生成 Token 使用的 AppID 和创建引擎时使用的 AppID 相同，否则会导致失败。
	 * @param streamId  WTN 流 ID。可以是远端通过 [startPushWTN](104478#wtnstream-startpushwtn) 或 [startPushPublicStream](104478#rtcengine-startpushpublicstream) 发布的流。
	 *                  如果指定流暂未发布，则本地客户端将在其开始发布后接收到流数据。
	 * @param videoMute 是否关闭视频。 `true`：关闭视频；`false`：开启视频。
	 * @param audioMute 是否关闭音频。 `true`：关闭音频；`false`：开启音频。
	 * @return
	 * @notes + 建议在调用本接口前，先调用 [setPublicStreamVideoPlayer](#setpublicstreamvideoplayer) 设置使用的视图和渲染模式。
	 *        + 调用本接口后，可以通过 [onFirstPublicStreamVideoFrameDecoded](104479#onfirstpublicstreamvideoframedecoded) 和 [onFirstPublicStreamAudioFrameDecoded](104479#onfirstpublicstreamaudioframedecoded) 回调 WTN 流的视频和音频首帧解码情况。
	 *        + 调用本接口后，可以通过 [onPublicStreamSEIMessageReceived](104479#onpublicstreamseimessagereceived) 回调 WTN 流中包含的 SEI 信息。
	 *        + 调用 [stopPlayPublicStream](#stopplaypublicstream) 取消订阅 WTN 流。
	 * @group WTN stream
	 * @order 20
	 */
	
	startPlayWTN: (token: string | null, streamId: string, videoMute: boolean, audioMute: boolean) => Promise<void>;
	/** 
	 * @valid since 4.65
	 * @brief 取消订阅指定 WTN 流。
	 * @param streamId  WTN 流 ID。
	 * @return
	 * @notes 关于订阅 WTN 流，查看 [startPlayWTN](#startplaywtn)。
	 * @group WTN stream
	 * @order 22
	 */
	
	stopPlayWTN: (streamId: string) => Promise<void>;
	/** 
	 * @valid since 4.65
	 * @brief 暂停/恢复订阅指定 WTN 流的音频。
	 * @param streamId  WTN 流 ID。 当前用户已通过 [startPlayWTN](#startplaywtn) 订阅该 WTN 流。
	 * @param mute 是否关闭音频<br>
	 *       - `true`：关闭
	 *       - `false`：打开
	 * @return
	 * @group WTN stream
	 * @order 23
	 */
	
	muteWTNRemoteAudio: (streamId: string, mute: boolean) => Promise<void>;
	/** 
	 * @valid since 4.65
	 * @brief 暂停/恢复订阅指定 WTN 流的视频。
	 * @param streamId  WTN 流 ID。当前用户已通过 [startPlayWTN](#startplaywtn) 订阅该 WTN 流。
	 * @param mute 是否关闭视频<br>
	 *       - `true`：关闭
	 *       - `false`：打开
	 * @return
	 * @notes 通过 [startPlayWTN](#startplaywtn) 订阅 WTN 流后，你可以通过本接口暂停/恢复订阅 WTN 流的视频。
	 * @group WTN stream
	 * @order 24
	 */
	
	muteWTNRemoteVideo: (streamId: string, mute: boolean) => Promise<void>;
	/** 
	 * @valid since 4.65.
	 * @brief 为指定 WTN 流设置使用的视图和渲染模式。
	 * @param streamId  WTN 流 ID。
	 * @param videoPlayerOption 视图信息和渲染模式。
	 * @return 参见 [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)。
	 * @group WTN stream
	 * @order 25
	 */
	
	setWTNRemoteVideoPlayer: (streamId: string, videoPlayerOption: Omit<VideoPlayerOption, "userId" | "playerId">) => HTMLVideoElement | undefined;
	/** 
	 * @valid since 4.65.
	 * @brief 调节本地播放的 WTN 流播放音量。
	 * @param streamId 音频所属 WTN 流 ID
	 * @param volume 播放的音量值和原始音量的比值，取值范围 [0, 400]，单位 %。默认值为 100%。
	 *               为保证更好的通话质量，建议将 volume 值设为 [0,100]。
	 * @notes + 建议成功播放 WTN 流后设置音量。
	 *        + 若调用本方法时尚未播放 WTN 流，设置将在开始播放后生效。
	 * @group WTN stream
	 * @order 26
	 */
	
	setWTNRemoteAudioPlaybackVolume: (streamId: string, volume: number) => void;
}
/** 
 * @id WTNstreamEvents
 * @list overview
 * @detail callback
 */

export interface IWTNStreamEvents {
	/** 
	 * @brief WTN 流发布结果回调。
	 *        调用 [startPushWTN](104478#wtnstream-startpushwtn) 发布 WTN 流后，结果通过此回调通知用户。
	 * @param event
	 * @group WTN stream
	 * @order 16
	 */
	
	[WTNStreamEventsTypes.onWTNPushStateChanged]: (event: onWTNPushStateChangedEvent) => void;
	/** 
	 * @brief 调用 [startPlayWTN](104478#wtnstream-startplaywtn) 订阅 WTN 流后，结果通过此回调通知用户。
	 * @param event
	 * @group WTN stream
	 * @order 29
	 */
	
	[WTNStreamEventsTypes.onWTNPlayStateChanged]: (event: onWTNPlayStateChangedEvent) => void;
	/** 
	 * @brief 调用 [startPlayWTN](104478#wtnstream-startplaywtn) 订阅 WTN 流后，音频订阅状态通过此回调通知用户。
	 * @param event
	 * @group WTN stream
	 * @order 27
	 */
	
	[WTNStreamEventsTypes.onWTNRemoteAudioStateChanged]: (event: onWTNRemoteAudioStateChangedEvent) => void;
	/** 
	 * @brief 调用 [startPlayWTN](104478#wtnstream-startplaywtn) 订阅 WTN 流后，视频订阅状态通过此回调通知用户。
	 * @param event
	 * @group WTN stream
	 * @order 28
	 */
	
	[WTNStreamEventsTypes.onWTNRemoteVideoStateChanged]: (event: onWTNRemoteVideoStateChangedEvent) => void;
	/** 
	 * @brief 调用 [startPlayWTN](104478#wtnstream-startplaywtn) 订阅 WTN 流，后将触发此回调，周期为 2s，包含视频统计信息。
	 * @param event
	 * @group WTN stream
	 * @order 33
	 */
	
	[WTNStreamEventsTypes.onWTNRemoteVideoStats]: (event: onWTNRemoteVideoStatsEvent) => void;
	/** 
	 * @brief 调用 [startPlayWTN](104478#wtnstream-startplaywtn) 订阅 WTN 流，后将触发此回调，周期为 2s，包含音频统计信息。
	 * @param event
	 * @group WTN stream
	 * @order 31
	 */
	
	[WTNStreamEventsTypes.onWTNRemoteAudioStats]: (event: onWTNRemoteAudioStatsEvent) => void;
	/** 
	 * @brief WTN 流的视频首帧解码成功。
	 *        关于订阅 WTN 流，参看 [startPlayWTN](104478#wtnstream-startplaywtn)。
	 * @param event
	 * @group WTN stream
	 * @order 36
	 */
	
	[WTNStreamEventsTypes.onWTNFirstRemoteVideoFrameDecoded]: (event: onWTNFirstRemoteVideoFrameDecodedEvent) => void;
	/** 
	 * @brief 回调 WTN 流中包含的 SEI 信息。
	 *        调用 [startPlayWTN](104478#wtnstream-startplaywtn) 接口启动拉 WTN 流功能后，通过此回调收到 WTN 流中的 SEI 消息。
	 * @param event
	 * @notes 当 WTN 流中的多路视频流均包含有 SEI 信息时：
	 *        + SEI 不互相冲突时，将通过多次回调分别发送；
	 *        + SEI 在同一帧有冲突时，则只有一条流中的 SEI 信息被透传并融合到 WTN 流中。
	 * @group WTN stream
	 * @order 40
	 */
	
	[WTNStreamEventsTypes.onWTNSEIMessageReceived]: (event: onWTNSEIMessageReceivedEvent) => void;
}
/** 
 * @brief 初始发布状态
 */

export interface InitPublishState {
	/** 
	 * @brief 麦克风音频流
	 */
	
	audio: boolean;
	/** 
	 * @brief 摄像头流
	 */
	
	video: boolean;
	/** 
	 * @brief 设备音频
	 */
	
	screenAudio: boolean;
	/** 
	 * @brief 屏幕视频流
	 */
	
	screenVideo: boolean;
}
/** 
 * @brief 音频转码配置参数。值不合法或未设置时，自动使用默认值。
 */

export interface LiveTranscodeAudioConfig {
	/** 
	 * @brief 音频编码格式，选填，默认为 `AAC`。
	 */
	
	codec?: "AAC";
	/** 
	 * @brief 音频码率，单位 Kbps。可取范围 [32, 192]，默认值为 64 Kbps。
	 */
	
	kBitRate: number;
	/** 
	 * @brief 音频采样率，单位 Hz。可取 32000 Hz、44100 Hz、48000 Hz，默认值为 48000 Hz。
	 */
	
	sampleRate: number;
	/** 
	 * @brief 音频声道数。可取 1（单声道）、2（双声道），默认值为 2。
	 */
	
	channels: number;
	/** 
	 * @brief <span id="aac_profile"></span>
	 *        AAC 编码规格。默认值为 `LC`。
	 */
	
	AACProfile: AAC_PROFILE;
}
/** 
 * @brief 转码推流配置参数。
 */

export interface LiveTranscodeConfig {
	/** 
	 * @brief 推流 CDN 地址。仅支持 RTMP 协议，Url 必须满足正则 `/^rtmps?:\/\//`。
	 *        本参数不支持过程中更新。
	 */
	
	url: string;
	/** 
	 * @brief 音频转码配置参数。
	 *        本参数不支持过程中更新。
	 */
	
	audio?: Partial<LiveTranscodeAudioConfig>;
	/** 
	 * @brief 视频转码配置参数。
	 */
	
	video?: Partial<LiveTranscodeVideoConfig>;
	/** 
	 * @brief 用户布局信息。
	 */
	
	layout?: Partial<LiveTranscodeLayoutConfig>;
}
/** 
 * @brief 视频流合流整体布局信息。
 *        开启转推直播功能后，你可以设置参与合流的每路视频流的预设布局信息和合流背景信息等。
 */

export interface LiveTranscodeLayoutConfig {
	/** 
	 * @brief 用户布局信息列表。值不合法或未设置时，自动使用默认值。
	 */
	
	regions: LiveTranscodeLayoutRegion[];
	/** 
	 * @brief 透传的 App 数据，长度不超过 4 KB。
	 */
	
	appData: string;
	/** 
	 * @brief 合流背景颜色，用十六进制颜色码（HEX）表示。例如，#FFFFFF 表示纯白，#000000 表示纯黑。默认值为 #000000。
	 *        值不合法或未设置时，自动使用默认值。
	 */
	
	backgroundColor: string;
}
/** 
 * @brief 单个视频流在合流中的布局信息。
 */

export interface LiveTranscodeLayoutRegion {
	/** 
	 * @brief 透明度，可选范围为 (0.0, 1.0]，0.0 为全透明。默认值为 1.0。
	 */
	
	alpha?: number;
	/** 
	 * @brief 视频流发布用户的用户 ID
	 */
	
	userId: string;
	/** 
	 * @brief 视频流对应区域左上角的横坐标相对整体画面的归一化比例，取值的范围为 [0.0, 1.0)。默认值为 0.0。
	 */
	
	x?: number;
	/** 
	 * @brief 视频流对应区域左上角的纵坐标相对整体画面的归一化比例，取值的范围为 [0.0, 1.0)。默认值为 0.0。
	 */
	
	y?: number;
	/** 
	 * @brief 用户视频布局在画布中的层级。取值范围为 [0 - 100]，0 为底层，值越大越上层。默认值为 0。
	 */
	
	zorder?: number;
	/** 
	 * @brief 视频流对应区域宽度相对整体画面的归一化比例，取值的范围为 (0.0, 1.0]。默认值为 1.0。
	 */
	
	w?: number;
	/** 
	 * @brief 视频流对应区域高度相对整体画面的归一化比例，取值的范围为 (0.0, 1.0]。默认值为 1.0。
	 */
	
	h?: number;
	/** 
	 * @brief 图片或视频流的缩放模式，默认值为 1。可选取值如下：
	 * • 1: 视频尺寸等比缩放，优先保证窗口被填满。当视频尺寸与显示窗口尺寸不一致时，多出的视频将被截掉。
	 * • 2: 视频尺寸等比缩放，优先保证视频内容全部显示。当视频尺寸与显示窗口尺寸不一致时，会把窗口未被填满的区域填充成黑色。
	 * • 3: 视频尺寸非等比例缩放，把窗口充满。当视频尺寸与显示窗口尺寸不一致时，视频高或宽方向会被拉伸。
	 */
	
	renderMode?: number;
	/** 
	 * @brief 合流内容控制。默认值为 0，可选取值如下：
	 * • 0: 输出的混流包含音视频。
	 * • 1: 只包含音频。
	 * • 2: 只包含视频。
	 */
	
	contentControl?: number;
	/** 
	 * @brief 是否是屏幕流
	 */
	
	isScreenStream: boolean;
	/** 
	 * @hidden
	 * @brief 是否本地用户
	 */
	
	isLocalUser?: boolean;
}
/** 
 * @brief 视频转码配置参数。值不合法或未设置时，自动使用默认值。
 */

export interface LiveTranscodeVideoConfig {
	/** 
	 * @brief 合流视频宽度。单位为 px，范围为 [2, 1920]，必须是偶数。默认值为 640 px。
	 *        设置值为非偶数时，自动向上取偶数。
	 */
	
	width: number;
	/** 
	 * @brief 合流视频高度。单位为 px，范围为 [2, 1920]，必须是偶数。默认值为 360 px。
	 *        设置值为非偶数时，自动向上取偶数。
	 */
	
	height: number;
	/** 
	 * @brief 视频编码格式。默认值为 `H264`。
	 *        本参数不支持过程中更新。
	 */
	
	codec: TRANSCODING_VIDEO_CODEC;
	/** 
	 * @brief 合流视频帧率。单位为 FPS，取值范围为 [1,60]，默认值为 15 FPS。
	 */
	
	fps: number;
	/** 
	 * @brief 视频 I 帧时间间隔。单位为秒，取值范围为 [1, 5]，默认值为 2 秒。
	 *        本参数不支持过程中更新。
	 */
	
	gop: number;
	/** 
	 * @hidden
	 * @brief 是否使用低延时特性。默认开启。
	 */
	
	/** 
	 * @brief 合流视频码率。单位为 Kbps，取值范围为 [1,10000]，默认值为自适应模式。
	 */
	
	kBitRate: number;
}
/** 
 * @hidden
 * @brief 转推直播事件
 */

export interface LiveTranscodingResultEvent {
	/** 
	 * @brief 转推直播事件编号
	 */
	
	code: number;
	/** 
	 * @brief 转推直播事件详情
	 */
	
	message: string;
}
/** 
 * @brief 本地音频信息
 */

export interface LocalAudioPropertiesInfo {
	/** 
	 * @brief 流属性，标记该流为麦克风采集音频流或屏幕音频流。
	 */
	
	streamIndex: StreamIndex;
	/** 
	 * @brief 音频属性信息。
	 */
	
	audioPropertiesInfo: AudioPropertiesInfo;
}
/** 
 * 本地音频流统计信息以及网络状况，统计周期为 2s 。
 * 本地用户发布音频流成功后，SDK 会周期性地通知本地用户发布的音频流在此次统计周期内的发送状况。此数据结构为回调给用户的参数类型。
 */

export interface LocalAudioStats {
	/** 
	 * @brief 音频丢包率。统计周期内的音频上行丢包率，取值范围为 [0, 1] 。
	 */
	
	audioLossRate: number;
	/** 
	 * @brief 发送码率。统计周期内的音频接收码率，单位为 kbps 。
	 */
	
	sendKBitrate: number;
	/** 
	 * @brief 采集采样率。统计周期内的音频采集采样率信息，单位为 Hz 。
	 */
	
	recordSampleRate: number;
	/** 
	 * @brief 统计间隔。此次统计周期的间隔，单位为 ms 。
	 */
	
	statsInterval: number;
	/** 
	 * @brief 客户端到服务端数据传输的往返时延，单位：ms
	 */
	
	rtt: number;
	/** 
	 * @brief 声道数
	 */
	
	numChannels: number;
	/** 
	 * @hidden
	 * @brief 音频发送采样率。此次统计周期内的音频发送采样率信息，单位为 Hz 。
	 */
	
	sentSampleRate?: number;
}
/** 
 * 本地媒体流统计信息以及网络状况，统计周期为 2s 。
 * 本地用户发布媒体流成功后，SDK 会周期性地通知本地用户发布的媒体流在此次统计周期内的发送状况。此数据结构为回调给用户的参数类型。
 */

export interface LocalStreamStats {
	/** 
	 * @brief 本地发送音频流的统计信息。
	 */
	
	audioStats: LocalAudioStats;
	/** 
	 * @brief 本地发送视频流的统计信息。
	 */
	
	videoStats: LocalVideoStats;
	/** 
	 * @brief 所属用户的媒体流是否为屏幕流。你可以知道当前统计数据来自主流还是屏幕流。
	 */
	
	isScreen: boolean;
	/** 
	 * @hidden
	 * @brief 本地媒体上行网络质量。
	 */
	
	txQuality?: number;
	/** 
	 * @hidden
	 * @brief 本地媒体下行网络质量。
	 */
	
	rxQuality?: number;
}
/** 
 * 本地媒体流统计信息以及网络状况，统计周期为 2s 。
 * 本地用户发布媒体流成功后，SDK 会周期性地通知本地用户发布的媒体流在此次统计周期内的发送状况。此数据结构为回调给用户的参数类型。
 */

export interface LocalUserAudioStats {
	/** 
	 * @brief 麦克风音频流信息
	 */
	
	mainAudioStats: LocalAudioStats;
	/** 
	 * @brief 屏幕音频流信息
	 */
	
	screenAudioStats: LocalAudioStats;
}
/** 
 * 本地媒体流统计信息以及网络状况，统计周期为 1s 。
 */

export interface LocalUserVideoStats {
	/** 
	 * @brief 摄像头采集视频流
	 */
	
	mainVideoStats: LocalVideoStats;
	/** 
	 * @brief 屏幕共享流
	 */
	
	screenVideoStats: LocalVideoStats;
}
/** 
 * 本地视频流统计信息以及网络状况，统计周期为 2s 。
 * 本地用户发布视频流成功后，SDK 会周期性地通知本地用户发布的视频流在此次统计周期内的发送状况。此数据结构为回调给用户的参数类型。
 */

export interface LocalVideoStats {
	/** 
	 * @brief 发送码率，单位：kbps。统计周期内的视频发送码率
	 */
	
	sentKBitrate: number;
	/** 
	 * @hidden
	 * @brief 采集帧率。此次统计周期内的视频采集帧率，单位为 fps 。
	 */
	
	inputFrameRate?: number;
	/** 
	 * @brief 发送帧率。统计周期内的视频发送帧率，单位为 fps 。
	 */
	
	sentFrameRate: number;
	/** 
	 * @brief 编码器输出帧率。当前编码器在此次统计周期内的输出帧率，单位为 fps 。
	 */
	
	encoderOutputFrameRate: number;
	/** 
	 * @brief 本地渲染帧率。统计周期内的本地视频渲染帧率，单位为 fps 。
	 */
	
	rendererOutputFrameRate?: number;
	/** 
	 * @hidden
	 * @brief 目标发送码率。此次统计周期内的视频目标发送码率，单位为 kbps 。
	 */
	
	targetKBitrate?: number;
	/** 
	 * @hidden
	 * @brief 目标发送帧率。此次统计周期内的目标发送帧率，单位为 fps 。
	 */
	
	targetFrameRate?: number;
	/** 
	 * @brief 统计间隔。此次统计周期的间隔，单位为 ms 。
	 */
	
	statsInterval: number;
	/** 
	 * @brief 视频丢包率。统计周期内的视频上行丢包率，取值范围为 [0, 1] 。
	 */
	
	videoLossRate: number;
	/** 
	 * @brief 客户端到服务端数据传输的往返时延，单位：ms
	 */
	
	rtt: number;
	/** 
	 * @hidden
	 * @brief 视频编码码率。此次统计周期内的视频编码码率，单位为 kbps 。
	 */
	
	encodedBitrate?: number;
	/** 
	 * @brief 视频编码宽度，单位为 px。
	 */
	
	encodedFrameWidth: number;
	/** 
	 * @brief 视频编码高度，单位为 px。
	 */
	
	encodedFrameHeight: number;
	/** 
	 * @brief 统计周期内发送的视频帧总数
	 */
	
	encodedFrameCount: number;
	/** 
	 * @brief 视频编码格式。
	 *        "H264": H.264 格式。
	 *        "VP8": VP8 格式。
	 */
	
	codecType: "H264" | "VP8";
	/** 
	 * @brief 所属用户的媒体流是否为屏幕流。你可以知道当前统计数据来自主流还是屏幕流。
	 */
	
	isScreen: boolean;
}
/** 
 * @brief 混音配置
 */

export interface MixOption {
	/** 
	 * @brief 混音播放次数
	 *        + play_count <= 0: 无限循环
	 *        + play_count == 1: 播放一次（默认）
	 *        + play_count > 1: 播放 play_count 次
	 */
	
	playCount: number;
	/** 
	 * @brief 混音播放类型
	 */
	
	type?: AudioMixingType;
}
/** 
 * @brief 播放器事件
 */

export interface PlayerEvent {
	/** 
	 * @brief 类型
	 */
	
	type: "video" | "audio";
	/** 
	 * @brief 事件名称
	 */
	
	eventName: string;
	/** 
	 * @brief 播放事件。详见[官方文档](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play_event)
	 */
	
	rawEvent: Event;
	/** 
	 * @brief 进房用户的 userId
	 */
	
	userId: string;
	/** 
	 * @brief  公共流 ID。
	 */
	
	publicStreamId?: string;
	/** 
	 * @brief 媒体就绪状态，详见[官方文档](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState)
	 *
	 */
	
	readyState: number;
	/** 
	 * @brief 当前时间
	 */
	
	currentTime: number;
	/** 
	 * @brief 所属用户的媒体流是否为屏幕流。你可以知道当前统计数据来自主流还是屏幕流。
	 */
	
	isScreen?: boolean;
	/** 
	 * @brief 播放器 ID。空值为默认播放器。
	 */
	
	playerId?: string;
}
/** 
 * @brief 公共流首帧解码/渲染事件。
 */

export interface PublicStreamAudioFirstFrameDecodedEvent {
	/** 
	 * @brief  公共流 ID。
	 */
	
	publicStreamId: string;
}
/** 
 * @brief  WTN 流配置信息
 */

export interface PublicStreamConfig {
	/** 
	 * @brief 视频参数
	 */
	
	video?: {
		/** 
		 * @brief 宽度，单位：px。
		 *        仅支持设为偶数，如果设为奇数，将导致 WTN 流发布失败。
		 */
		
		width?: number;
		/** 
		 * @brief 高度，单位：px。
		 *        仅支持设为偶数，如果设为奇数，云端媒体处理会直接拒绝，导致 WTN 流失败。
		 */
		
		height?: number;
		/** 
		 * @brief 帧率，单位：fps
		 */
		
		fps?: number;
		/** 
		 * @brief 码率，单位：kbps
		 */
		
		kBitRate: number;
	};
	/** 
	 * @brief  WTN 流的布局模式
	 */
	
	layout?: {
		/** 
		 * @brief 补帧模式
		 */
		
		interpolationMode?: PublicInterpolationMode;
		/** 
		 * @brief 背景颜色，用 Hex 色值表示。
		 */
		
		backgroundColor?: string;
		/** 
		 * @brief 背景图片的 URL。长度最大为 1024 byte。可以传入的图片的格式包括：JPG, JPEG, PNG。
		 */
		
		backgroundImage?: string;
		/** 
		 * @brief 多路媒体流布局设置。
		 */
		
		regions?: PublicStreamLayoutRegion[];
	};
}
/** 
 * @brief 公共流发布结果
 */

export interface PublicStreamResultEvent {
	/** 
	 * @brief 公共流发布事件编号
	 */
	
	code: number;
	/** 
	 * @brief 公共流发布事件详情
	 * + `200`: 发布或订阅成功
	 * + `1191`: 公共流的参数异常，请修改参数后重试
	 * + `1192`: 服务端状态异常，将自动重试
	 * + `1193`: 内部错误，不可恢复，请重试
	 * + `1195`: 推流失败，将自动重试，用户不需要处理
	 * + `1196`: 推流失败，10 s 后会重试，重试 3 次后停止重试
	 */
	
	message: string;
}
/** 
 * @brief 公共流中包含的 SEI 信息。
 */

export interface PublicStreamSEIMessageEvent {
	/** 
	 * @brief  公共流 ID
	 */
	
	publicStreamId: string;
	/** 
	 * @brief 收到的 SEI 消息内容
	 */
	
	sei: Uint8Array;
}
/** 
 * @brief 视频订阅配置信息
 */

/** 
 * @brief 流属性。
 */

export interface RTCStream {
	/** 
	 * @brief 用户 ID
	 */
	
	userId: string;
	/** 
	 * @brief 是否是屏幕流
	 */
	
	isScreen: boolean;
	/** 
	 * @brief 是否包含视频流
	 */
	
	hasVideo: boolean;
	/** 
	 * @brief 是否包含音频流
	 */
	
	hasAudio: boolean;
	/** 
	 * @brief 视频流的属性
	 * 当远端用户调用 [setVideoEncoderConfig](#setvideoencoderconfig) 方法发布多个配置的视频流时，此处会包含该用户发布的所有视频流的属性信息。
	 */
	
	videoStreamDescriptions?: VideoStreamDescription[];
}
/** 
 * @brief 字幕配置信息。
 */

export interface RTCSubtitleConfig {
	/** 
	 * @brief 目标语言语种代号，参看[语言支持信息](https://www.volcengine.com/docs/4640/35107)。
	 */
	
	targetLanguage?: string | string[];
	/** 
	 * @brief 字幕模式。
	 */
	
	mode: SUBTITLE_MODE;
}
/** 
 * @brief 远端音频信息
 */

export interface RemoteAudioPropertiesInfo {
	/** 
	 * @brief 远端流信息
	 */
	
	streamKey: StreamKey;
	/** 
	 * @brief 远端音频属性信息
	 */
	
	audioPropertiesInfo: AudioPropertiesInfo;
}
/** 
 * 远端音频流统计信息，统计周期为 2s 。
 * 本地用户订阅音频流成功后，SDK 会周期性地通知远端的音频流在此次统计周期内的接收状况。此数据结构为回调给用户的参数类型。
 */

export interface RemoteAudioStats {
	/** 
	 * @brief 音频丢包率。统计周期内的音频下行丢包率，取值范围为 [0, 1] 。
	 */
	
	audioLossRate: number;
	/** 
	 * @brief 接收码率。统计周期内的音频接收码率，单位为 kbps 。
	 */
	
	receivedKBitrate: number;
	/** 
	 * @brief 统计周期内的卡顿次数
	 */
	
	stallCount?: number;
	/** 
	 * @brief 统计周期内的卡顿时长，单位为 ms 。
	 */
	
	stallDuration?: number;
	/** 
	 * @hidden
	 * @brief 用户体验级别的端到端延时，单位：ms。媒体信息从发送端采集完成并开始编码到接收端解码完成并渲染开始的耗时
	 */
	
	e2eDelay: number;
	/** 
	 * @brief 全链路往返传输时延。单位 ms。
	 * @notes 对于 FireFox 浏览器，此值不准确。
	 */
	
	totalRtt: number;
	/** 
	 * @hidden
	 * @brief 统计周期内的音频播放采样率信息，单位为 Hz 。
	 */
	
	playoutSampleRate?: number;
	/** 
	 * @brief 统计间隔。此次统计周期的间隔，单位为 ms 。
	 */
	
	statsInterval: number;
	/** 
	 * @brief 往返时延，单位：ms
	 */
	
	rtt: number;
	/** 
	 * @hidden
	 * @brief 媒体流质量。（值含义参考 NetworkQuality 。TBD）
	 */
	
	quality?: number;
	/** 
	 * @brief 抖动延迟，单位：ms
	 */
	
	jitterBufferDelay: number;
	/** 
	 * @brief 声道数
	 */
	
	numChannels: number;
	/** 
	 * @brief 接收侧采样率
	 */
	
	receivedSampleRate: number;
	/** 
	 * @hidden
	 * @brief 视频冻结率
	 */
	
	frozenRate?: number;
	/** 
	 * @brief 音频丢包补偿(PLC) 样点总个数
	 */
	
	concealedSamples: number;
	/** 
	 * @brief 音频丢包补偿(PLC) 累计次数
	 */
	
	concealmentEvent: number;
	/** 
	 * @hidden
	 * @brief 音频解码采样率。统计周期内的音频解码采样率信息，单位为 Hz 。
	 */
	
	decSampleRate?: number;
	/** 
	 * @hidden
	 * @brief 此次订阅中，对远端音频流进行解码的累计耗时。单位为 s。
	 */
	
	decDuration?: number;
}
/** 
 * @brief 远端流信息
 */

export interface RemoteStreamKey {
	/** 
	 * @brief 房间 ID
	 */
	
	roomId: string;
	/** 
	 * @brief 用户 ID
	 */
	
	userId: string;
	/** 
	 * @brief 流属性，包括主流、屏幕流。
	 */
	
	streamIndex: StreamIndex;
}
/** 
 * 远端媒体流统计信息，统计周期为 2s 。
 * 本地用户订阅媒体流成功后，SDK 会周期性地通知远端的媒体流在此次统计周期内的接收状况。此数据结构为回调给用户的参数类型。
 */

export interface RemoteStreamStats {
	/** 
	 * @brief 进房用户的 userId
	 */
	
	userId: string;
	/** 
	 * @brief 远端音频流信息
	 */
	
	audioStats: RemoteAudioStats;
	/** 
	 * @brief 远端视频流信息
	 */
	
	videoStats: RemoteVideoStats;
	/** 
	 * @brief 所属用户的媒体流是否为屏幕流。你可以知道当前统计数据来自主流还是屏幕流。
	 */
	
	isScreen: boolean;
	/** 
	 * @hidden
	 * @brief 本地媒体上行网络质量。
	 */
	
	txQuality?: number;
	/** 
	 * @hidden
	 * @brief 本地媒体下行网络质量。
	 */
	
	rxQuality?: number;
}
/** 
 * @brief 流切换信息。本地用户订阅的远端流触发回退策略时的流切换信息。
 */

export interface RemoteStreamSwitch {
	/** 
	 * @brief 订阅的音视频流的发布者的用户 ID
	 */
	
	userId: string;
	/** 
	 * @brief 是否是屏幕共享流
	 */
	
	isScreen: boolean;
	/** 
	 * @brief 原分辨率视频流的下标
	 */
	
	beforeVideoIndex: number;
	/** 
	 * @brief 现分辨率视频流的下标
	 */
	
	afterVideoIndex: number;
	/** 
	 * @brief 原媒体流是否是视频流
	 */
	
	beforeEnable: boolean;
	/** 
	 * @brief 现媒体流是否是视频流
	 */
	
	afterEnable: boolean;
	/** 
	 * @brief 触发流回退或恢复的原因
	 */
	
	reason: FallbackOrRecoverReason;
}
/** 
 * 用户订阅的远端音频流统计信息以及网络状况，统计周期为 1s。
 */

export interface RemoteUserAudioStats {
	/** 
	 * @brief 麦克风音频流信息
	 */
	
	mainAudioStats: RemoteAudioStats;
	/** 
	 * @brief 屏幕音频流信息
	 */
	
	screenAudioStats: RemoteAudioStats;
}
/** 
 * 用户订阅的远端视频流统计信息以及网络状况，统计周期为 1s。
 */

export interface RemoteUserVideoStats {
	/** 
	 * @brief 摄像头采集视频流
	 */
	
	mainVideoStats: RemoteVideoStats;
	/** 
	 * @brief 屏幕共享流
	 */
	
	screenVideoStats: RemoteVideoStats;
}
/** 
 * @brief 远端视频流参数
 */

export interface RemoteVideoConfig {
	/** 
	 * @brief 视频宽度，单位：px
	 */
	
	width: number;
	/** 
	 * @brief 视频宽度，单位：px
	 */
	
	height: number;
}
/** 
 * 远端视频流统计信息，统计周期为 2s 。
 * 本地用户订阅视频流成功后，SDK 会周期性地通知远端的视频流在此次统计周期内的接收状况。此数据结构为回调给用户的参数类型。
 */

export interface RemoteVideoStats {
	/** 
	 * @brief 宽度，单位：px
	 */
	
	width: number;
	/** 
	 * @brief 高度，单位：px
	 */
	
	height: number;
	/** 
	 * @brief 视频丢包率。统计周期内的视频下行丢包率，取值范围为 [0, 1] 。
	 */
	
	videoLossRate: number;
	/** 
	 * @brief 接收码率。统计周期内的视频接收码率，单位为 kbps 。
	 */
	
	receivedKBitrate: number;
	/** 
	 * @brief 解码器输出帧率。统计周期内的视频解码器输出帧率，单位 fps 。
	 */
	
	decoderOutputFrameRate: number;
	/** 
	 * @hidden
	 * @brief 渲染帧率。统计周期内的视频渲染帧率，单位 fps 。
	 */
	
	rendererOutputFrameRate?: number;
	/** 
	 * @brief 统计周期内的卡顿次数
	 */
	
	stallCount?: number;
	/** 
	 * @brief 统计周期内的卡顿时长，单位为 ms 。
	 */
	
	stallDuration?: number;
	/** 
	 * @hidden
	 */
	
	stallDuration100MS?: number;
	/** 
	 * @hidden
	 */
	
	stallCount100MS?: number;
	/** 
	 * @hidden
	 * @brief 用户体验级别的端到端延时，单位：ms。媒体信息从发送端采集完成并开始编码到接收端解码完成并渲染开始的耗时
	 */
	
	e2eDelay: number;
	/** 
	 * @brief 全链路往返传输时延。单位 ms。
	 * @notes 对于 FireFox 浏览器，此值不准确。
	 */
	
	totalRtt: number;
	/** 
	 * @brief 所属用户的媒体流是否为屏幕流。你可以知道当前统计数据来自主流还是屏幕流。
	 */
	
	isScreen: boolean;
	/** 
	 * @brief 统计间隔。此次统计周期的间隔，单位为 ms 。
	 */
	
	statsInterval: number;
	/** 
	 * @brief 客户端到服务端数据传输的往返时延，单位：ms
	 */
	
	rtt: number;
	/** 
	 * @hidden
	 * @brief 远端用户在加入房间后发生音频卡顿的累计时长占音频总有效时长的百分比。音频有效时长是指远端用户进房发布音频流后，除停止发送音频流和禁用音频模块之外的音频时长。
	 */
	
	frozenRate?: number;
	/** 
	 * @hidden
	 * @brief 视频分辨率序号。通过此参数指定希望订阅的流。在此之前，远端用户已经通过调用 [setVideoEncoderConfig](104478#setvideoencoderconfig) 方法，启动发布多路不同分辨率的视频流。编号 `0` 至 `3`代表流质量从高至低。
	 */
	
	videoIndex?: number;
	/** 
	 * @brief 视频编码格式。
	 *        "H264": H.264 格式。
	 *        "VP8": VP8 格式。
	 */
	
	codecType: "H264" | "VP8";
}
/** 
 * @brief 房间参数配置。
 */

export interface RoomConfig {
	/** 
	 * @brief 是否自动发布音视频流，默认为自动发布。
	 *        取消自动发布后，通过调用 [publishStream](104478#publishstream) 进行音视频流发布。
	 */
	
	isAutoPublish?: boolean;
	/** 
	 * @brief 是否自动订阅音频流，默认为自动订阅。
	 *        不包含屏幕流。
	 *        进房后，你可以调用 [subscribeStream](104478#subscribestream)、[unsubscribeStream](104478#unsubscribestream) 修改订阅设置。
	 */
	
	isAutoSubscribeAudio?: boolean;
	/** 
	 * @brief 是否自动订阅视频流，默认为自动订阅。
	 *        不包含屏幕流。
	 *        进房后，你可以调用 [subscribeStream](104478#subscribestream)、[unsubscribeStream](104478#unsubscribestream) 修改订阅设置。
	 */
	
	isAutoSubscribeVideo?: boolean;
	/** 
	 * @hidden
	 * @deprecated since 4.51, use setAudioProfile instead.
	 * @brief 房间模式
	 *        根据所需场景，选择合适的房间模式，应用不同的音视频算法、视频参数和网络配置
	 *        调用 [setAudioProfile](104478#setaudioprofile) 选择音频参数配置
	 */
	
	roomProfileType?: RoomProfileType;
	/** 
	 * @brief 远端视频流参数。
	 */
	
	remoteVideoConfig?: RemoteVideoConfig;
	/** 
	* @brief 房间的创建模式。支持同时创建 RTC 和 RTS 房间（默认），或仅创建 RTS 房间。
	*/
	
	roomMode?: RoomMode;
}
/** 
 * @brief 屏幕共享流设置
 */

export interface ScreenConfig {
	/** 
	 * @brief 在共享屏幕时是否显示共享音频选项:
	 *        • Windows 支持在共享整个屏幕时共享系统音频；在共享 Chrome 标签页时共享 Tab 标签页面音频。
	 *        • macOS 仅支持在共享 Chrome 标签页时共享 Tab 标签页面音频。
	 */
	
	enableAudio?: boolean;
	/** 
	 * @brief 默认选中的共享内容类型，可选择：屏幕、标签页、应用窗口。
	 * 仅支持 Chrome 107 及以上版本、Edge 107 及以上版本。
	 * 详见 [displaySurface](https://developer.chrome.com/docs/web-platform/screen-sharing-controls/#displaySurface)。
	 */
	
	displaySurface?: "monitor" | "browser" | "window";
	/** 
	 * @brief 是否允许共享系统音频：
	 * `include`：（默认）允许。
	 * `exclude`：禁止。
	 * Windows 设备上的 Chrome 105 及以上版本、Edge 105 及以上版本。
	 * Electron 框架下，只支持在 Windows 系统共享系统音频。
	 * 详见 [systemAudio](https://developer.chrome.com/docs/web-platform/screen-sharing-controls/#systemAudio)。
	 */
	
	systemAudio?: "include" | "exclude";
	/** 
	 * @brief 是否允许用户动态切换共享的标签页：
	 * `include`：（默认）允许。
	 * `exclude`：禁止。
	 * 仅支持 Chrome 107 及以上版本、Edge 107 及以上版本。
	 * 详见 [surfaceSwitching](https://developer.chrome.com/docs/web-platform/screen-sharing-controls/#surfaceSwitching)。
	 */
	
	surfaceSwitching?: "include" | "exclude";
	/** 
	 * @brief 是否允许用户共享当前标签页：
	 * `include`：（默认）允许。
	 * `exclude`：禁止。
	 * 仅支持 Chrome 107 及以上版本、Edge 107 及以上版本。
	 * 详见 [selfBrowserSurface](https://developer.chrome.com/docs/web-platform/screen-sharing-controls/#selfBrowserSurface)。
	 */
	
	selfBrowserSurface?: "include" | "exclude";
	/** 
	 * @brief 在 Electron 框架下指定屏幕共享源 ID。
	 * 你可以通过 [getElectronScreenSources](104478#vertc-getelectronscreensources) 获取。
	 * 不传本参数时，SDK 将在开始共享前弹出默认选择框，供用户选择屏幕共享源。
	 */
	
	sourceId?: string;
}
/** 
 * @brief 屏幕共享的视频编码参数。
 */

export interface ScreenEncoderConfig {
	/** 
	 * @brief 视频宽度，单位为像素。默认值为 1920 px。
	 *        支持传入 `number` 或一个整形约束对象，参看 [ConstrainULong](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#constrainulong)。
	 */
	
	width: ConstrainULong;
	/** 
	 * @brief 视频高度，单位为像素。默认值为 1080 px。
	 *        支持传入 `number` 或一个整形约束对象，参看 [ConstrainULong](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#constrainulong)。
	 */
	
	height: ConstrainULong;
	/** 
	 * @brief 视频帧率，默认值为 15 FPS。
	 *        支持传入 `number` 或一个浮点形约束对象，参看 [ConstrainDouble](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#constraindouble)。
	 */
	
	frameRate: ConstrainDouble;
	/** 
	 * @brief 最大编码码率，RTC SDK 内部采集和自定义采集均需设定 > 0 的数值，单位为 Kbps。默认值为 3000 Kbps。
	 */
	
	maxKbps: number;
	/** 
	 * @brief 视频内容类型。
	 *        `'text'`：清晰度优先，适用于视频内容只包含大量文本的情况。
	 *        `'motion'`：流畅度优先，适用于视频内容为摄像头采集、电影、视频、游戏的情况。
	 *        `'detail'`：清晰度优先，适用于视频内容包含图片、文本混排的情况。
	 * @notes Firefox 浏览器不支持设置此参数，参看 [contentHint 浏览器兼容信息](https://caniuse.com/?search=contentHint)。
	 */
	
	contentHint?: "text" | "motion" | "detail";
}
export interface SetParamInterface {
	VERSION: string;
	ICE_CONFIG_REQUEST_URLS_INTERNAL: string[];
	ICE_CONFIG_REQUEST_URLS: string[] | string;
	EXPECTED_ADDR: string;
	LOG_SERVER_URL: string;
	CONFIG_REQUEST_DOMAINS: string[];
	DEVICE_ID: string;
	OVERSEA: boolean;
	PLATFORM: string;
	PRODUCT: string;
	FORCE_ENABLED_REPORT_CALLBACKS: string[];
	SKIP_WEB_AUDIO_IN_TRACK: boolean;
	ENFORCE_WEB_AUDIO_SUPPORTED: boolean;
	AUDIO_STALL: boolean;
	VIDEO_STALL: boolean;
	VIDEO_STALL_100MS: boolean;
	STATS_SCALLBACK_SUPPORT: boolean;
	JOIN_ROOM_CONFIG: IJoinRoomConfig;
	ENABLE_REPORT_IDB_BUFFER?: boolean;
	SIGNAL_COMPRESSION: boolean;
	SIGNAL_CROP_JOINROOM: boolean;
	VIDEO_STALL_DATA: number;
	AUDIO_STALL_DATA: number;
	IOS_SAFARI_ORIENTATION: boolean;
	BLACK_FRAME_LIFETIME: number;
	FALLBACK_ENCODE_CODEC: string;
	SEI_TIME_OUT: number;
	SEI_COUNT_FPS: number;
	/** 是否开启提前建连 */
	PRE_ICE: boolean;
	STATS_LOOP_INTERVAL: number;
	HIDDEN_STATS: boolean;
	UPLOAD_REMOTE_STATS: string | SubMediaType;
	SDK_CODEC_NEGOTIATION: boolean;
	AINR_CACHE_TIME?: number;
	AINR_DUMP_TIME?: number;
	AINR_ENABLE_DUMP?: boolean;
	AINR_OVERLOAD_THRESHOLD?: number;
	AINR_URLS?: string;
	MEDIA_PROCESSING_TYPE?: number;
	AUDIO_CODEC: string;
	DISABLE_ENCODED_TRANSFORM: boolean;
	SKIP_SEI_FILTER: boolean;
	AREA_CODE: string;
	DISABLE_COMPUTE_PRESSURE: boolean;
	SEND_MESSAGE_SYNC: boolean;
	H264_HW_ENCODER: boolean;
	GPU_URL: string;
	ENABLE_FALLBACK_HANDLER: boolean;
	ENABLE_STANDARD_HANDLER: boolean;
	ENABLE_PLAY_AFTER_CLICK: boolean;
	PC_KILLSWITCH: Partial<IPCKillSwitch>;
	AUTOPLAY_WORKAROUND: boolean;
	ENGINE_WEB_CONFIG: {};
	DISABLE_IOS_MUTE_WORKAROUND: boolean;
}
/** 
 * @brief 远端流信息
 */

export interface StreamKey {
	/** 
	 * @brief 房间 ID
	 */
	
	roomId: string;
	/** 
	 * @brief 用户 ID
	 */
	
	userId: string;
	/** 
	 * @brief 流属性，标记该流为麦克风采集音频流或屏幕音频流。
	 */
	
	streamIndex: StreamIndex;
}
/** 
 * @brief 转推直播相关事件。
 */

export interface StreamMixingEvent {
	/** 
	 * @brief 转推直播事件类型。
	 */
	
	event: StreamMixingEventType;
	/** 
	 * @brief 转推直播事件错误码。
	 */
	
	error: StreamMixingEventErrorCode;
	/** 
	 * @brief 转推直播事件错误详情。
	 */
	
	message: string;
}
/** 
 * @brief 选择订阅配置
 */

export interface SubscribeConfig {
	/** 
	 * @brief 是否是屏幕流
	 */
	
	isScreen: boolean;
	/** 
	 * @brief 是否订阅视频
	 */
	
	subVideo: boolean;
	/** 
	 * @brief 是否订阅音频
	 */
	
	subAudio: boolean;
}
/** 
 * @brief 字幕任务状态。
 */

export interface SubtitleEvent {
	/** 
	 * @brief 字幕任务状态类型。
	 */
	
	event: SubtitleEventType;
	/** 
	 * @brief 字幕任务错误码。
	 *        + `SUBTITLE_ERR_POSTPROCESS`: 云端媒体处理内部出现错误。
	 *        + `SUBTITLE_ERR_CONNECTION_ERROR`: 第三方服务连接失败。
	 *        + `SUBTITLE_ERR_PROCESS_ERROR`: 云端媒体处理超时未响应。
	 *        + `SUBTITLE_ERR_UNKNOWN`: 客户端无法识别云端媒体处理发送的错误码。
	 */
	
	errorCode?: ErrorCode;
	/** 
	 * @brief 字幕相关信息。
	 */
	
	errorMessage?: string;
}
/** 
 * @brief 字幕具体内容。
 */

export interface SubtitleMessage {
	/** 
	 * @brief 说话者的用户ID。
	 */
	
	userId: string;
	/** 
	 * @brief 语音识别或翻译后的文本, 采用 UTF-8 编码。
	 */
	
	text: string;
	/** 
	 * @brief 语音识别出的文本是否为一段完整的一句话。 True 代表是, False 代表不是。
	 */
	
	definite: boolean;
	/** 
	 * @brief 语音识别或翻译后形成的文本的序列号。同一发言人的完整发言和不完整发言会按递增顺序单独分别编号。
	 */
	
	sequence: number;
	/** 
	 * @brief 字幕语种代号。
	 */
	
	language: string;
	/** 
	 * @brief 字幕模式。
	 */
	
	mode: SUBTITLE_MODE;
}
/** 
 * @brief 字幕配置信息。用于更新字幕翻译源语种。
 */

export interface UpdateSubtitleConfig {
	/** 
	 * @brief 源语言的语种代号。支持：
	 * + zh：中文
	 * + ja：日语
	 * + en：英语
	 * + ko：韩语
	 */
	
	sourceLanguage: string;
}
/** 
 * @brief 点对点二进制消息
 */

export interface UserBinaryMessageEvent {
	/** 
	 * @brief 发送消息的用户
	 */
	
	userId: string;
	/** 
	 * @brief 点对点二进制消息
	 */
	
	message: ArrayBuffer;
}
/** 
 * 用户连接事件
 */

export interface UserConnectionEvent {
	/** 
	 * @brief 用户信息
	 */
	
	userInfo: UserInfo;
	/** 
	 * @brief 用户的媒体流发布状态
	 */
	
	publishState: InitPublishState;
}
/** 
 * 用户连接断开事件
 */

export interface UserDisconnectionEvent {
	/** 
	 * @brief 用户信息
	 */
	
	userInfo: UserInfo;
	/** 
	 * @brief 原因
	 */
	
	reason: string;
}
/** 
 * @brief 用户信息。
 */

export interface UserInfo {
	/** 
	 * @brief 用户 ID，长度在 128 字节以内的非空字符串。
	 */
	
	userId: string;
	/** 
	 * @brief 用户传递的额外信息，最大长度为 200 字节。会在 [onUserJoined](104479#onuserjoined) 中回调给远端用户。
	 * @notes 支持以下字符集范围:
	 *     + 26 个大写字母: A ~ Z
	 *     + 26 个小写字母: a ~ z
	 *     + 10 个数字: 0 ~ 9
	 *     + 特殊字符: 下划线 "_"，at 符 "@"，减号 "-"
	 */
	
	extraInfo?: string;
}
/** 
 * @brief 点对点文本消息
 */

export interface UserMessageEvent {
	/** 
	 * @brief 发送消息的用户
	 */
	
	userId: string;
	/** 
	 * @brief 点对点文本消息
	 */
	
	message: string;
}
export interface VendorConnectionStateChangeEvent extends ConnectionStateChangeEvent {
	userId: string;
}
/** 
 * @brief 视频编码参数。
 */

export interface VideoEncoderConfig {
	/** 
	 * @brief 视频宽度，单位为像素。默认值为 640 px。
	 *        支持传入 `number` 或一个整形约束对象，参看 [ConstrainULong](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#constrainulong)。
	 */
	
	width: ConstrainULong;
	/** 
	 * @brief 视频高度，单位为像素。默认值为 480 px。
	 *        支持传入 `number` 或一个整形约束对象，参看 [ConstrainULong](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#constrainulong)。
	 */
	
	height: ConstrainULong;
	/** 
	 * @brief 视频帧率，单位为 FPS。默认值为 15 FPS。
	 *        支持传入 `number` 或一个浮点形约束对象，参看 [ConstrainDouble](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#constraindouble)。
	 */
	
	frameRate: ConstrainDouble;
	/** 
	 * @brief 最大编码码率，RTC SDK 内部采集和自定义采集均需设定 > 0 的数值，单位为 Kbps。默认值为 600 Kbps。
	 */
	
	maxKbps: number;
	/** 
	 * @brief 视频内容类型。
	 *        `'text'`：清晰度优先，适用于视频内容只包含大量文本的情况。
	 *        `'motion'`：流畅度优先，适用于视频内容为摄像头采集、电影、视频、游戏的情况。
	 *        `'detail'`：清晰度优先，适用于视频内容包含图片、文本混排的情况。
	 * @notes Firefox 浏览器不支持设置此参数，参看 [contentHint 浏览器兼容信息](https://caniuse.com/?search=contentHint)。
	 */
	
	contentHint?: "text" | "motion" | "detail";
	/** 
	 * @brief 设置编码优先级。默认为 `'auto'`，无偏好，SDK 会根据当前视频流的分辨率、设备性能自动匹配适合的编解码格式。
	 */
	
	preferCodecName?: VideoCodecType;
}
/** 
 * @brief 播放器信息和渲染模式
 */

export interface VideoPlayerOption {
	/** 
	 * @brief 渲染窗口，为视频渲染的父元素。视频的 `htmlVideoElement` 将挂在该父元素下进行渲染，且视频渲染的宽高以 `renderDom` 为准，根据渲染模式确定是否完全填充整个父元素的区域。
	 */
	
	renderDom?: string | HTMLElement;
	/** 
	 * @brief 渲染模式。
	 */
	
	renderMode?: VideoRenderMode;
	/** 
	 * @brief 用户 ID，支持以下字符集范围
	 *     + 26 个大写字母 A ~ Z
	 *     + 26 个小写字母 a ~ z
	 *     + 10 个数字 0 ~ 9
	 *     + 下划线 "_"，at 符 "@"，减 号 "-"
	 *     该设置对 WTN 流无效。
	 */
	
	userId: string;
	/** 
	 * @brief 视频帧顺时针的旋转角度。可选值为 0，90，180，270。默认值是 0，即不做旋转处理。
	 *        该设置仅对远端视频有效，调用 [setLocalVideoPlayer](104478#rtcengine-setlocalvideoplayer) 设置本参数不生效。
	 */
	
	rotation?: number;
	/** 
	 * @brief 播放器 ID。不指定时视为默认播放器。
	 *        该设置对 WTN 流无效。
	 */
	
	playerId?: string;
}
/** 
 * @brief 视频流发布封禁/解禁事件
 */

export interface VideoStreamBannedEvent {
	/** 
	 * @brief 被禁用/解禁的视频流用户 ID
	 */
	
	uid: string;
	/** 
	 * @brief 视频流发布状态
	 *        true：视频流发布被禁止
	 *        false: 视频流发布被解禁
	 */
	
	banned: boolean;
}
/** 
 * @brief 视频流的属性
 */

export interface VideoStreamDescription {
	/** 
	 * @brief 宽
	 */
	
	width?: number;
	/** 
	 * @brief 高
	 */
	
	height?: number;
	/** 
	 * @brief 视频帧率
	 */
	
	frameRate?: number;
	/** 
	 * @brief 最大码率
	 */
	
	maxKbps?: number;
}
/** 
 * 第一帧远端音频解码事件
 */

export interface onAudioFirstFrameDecodedEvent {
	/** 
	 * @brief 发布音频用户的 userId
	 */
	
	userId: string;
	/** 
	 * @brief 是否为屏幕共享流
	 */
	
	isScreen: boolean;
}
/** 
 * SDK 与信令服务器连接状态相关事件。
 */

export interface onConnectionStateEvent {
	/** 
	 * @brief SDK 与信令服务器连接状态相关事件。
	 */
	
	state: ConnectionState;
}
/** 
 * 媒体设备状态回调。媒体设备包括音频采集设备、音频渲染设备、视频采集设备三种类型。
 */

export interface onMediaDeviceStateChangeEvent {
	/** 
	 * @brief 设备 ID
	 */
	
	device_id: string;
	/** 
	 * @brief 设备类型
	 */
	
	device_type: string;
	/** 
	 * @brief 设备状态
	 */
	
	device_state: "ACTIVE" | "INACTIVE";
}
/** 
 * 收到带有 SEI 消息的视频帧时，收到此回调
 */

export interface onSEIMessageEvent {
	/** 
	 * @brief 包含 SEI 发送者的用户名，所在的房间名和媒体流
	 */
	
	remoteStreamKey: RemoteStreamKey;
	/** 
	 * @brief 收到的 SEI 消息内容
	 */
	
	sei: Uint8Array;
}
/** 
 * @brief 收到带有 SEI 消息的视频帧时，收到此回调
 */

export interface onSEIMessageReceivedEvent {
	/** 
	 * @brief 包含 SEI 发送者的用户名，所在的房间名和媒体流
	 */
	
	remoteStreamKey: RemoteStreamKey;
}
/** 
 * @brief 包含 SEI 信息的流更新事件。
 */

export interface onSEIStreamUpdateEvent {
	/** 
	 * @brief 用户 ID。
	 */
	
	userId: string;
	/** 
	 * @brief 是否为屏幕流。
	 */
	
	isScreen: boolean;
	/** 
	 * @brief 包含 SEI 信息的流类型。
	 */
	
	type: SEIStreamEventType;
}
/** 
 * 房间内新媒体流发布
 */

export interface onStreamAddEvent {
	/** 
	 * @brief 流属性
	 */
	
	stream: RTCStream;
}
/** 
 * 房间内媒体流停止发布
 */

export interface onStreamRemoveEvent {
	/** 
	 * @brief 流属性
	 */
	
	stream: RTCStream;
	/** 
	 * @brief 停止发流原因
	 */
	
	reason: StreamRemoveReason;
}
/** 
 * 远端用户进房事件
 */

export interface onUserJoinedEvent {
	/** 
	 * @brief 进房用户的 userId
	 */
	
	userInfo: UserInfo;
	/** 
	 * @brief 用户的媒体流发布状态
	 */
	
	publishState: InitPublishState;
}
/** 
 * 远端用户退房事件
 */

export interface onUserLeaveEvent {
	/** 
	 * @brief 用户信息
	 */
	
	userInfo: UserInfo;
	/** 
	 * @brief 远端用户离开房间的原因
	 */
	
	reason: UserOfflineReason;
	/** 
	 * @hidden
	 * @brief 远端用户离开房间的原始信令返回参数
	 */
	
	tag?: UserDisconnectionTag;
}
/** 
 * 第一帧远端视频解码事件
 */

export interface onVideoFirstFrameDecodedEvent {
	/** 
	 * @brief 发布视频用户的 userId
	 */
	
	userId: string;
	/** 
	 * @brief 高度
	 */
	
	height: number;
	/** 
	 * @brief 宽度
	 */
	
	width: number;
}
/** 
 * 第一帧远端视频显示在视图上
 */

export interface onVideoFirstFrameRenderedEvent {
	/** 
	 * @brief 发布视频用户的 userId
	 */
	
	userId: string;
	/** 
	 * @brief 高度
	 */
	
	height: number;
	/** 
	 * @brief 宽度
	 */
	
	width: number;
	/** 
	 * @brief 是否为屏幕流
	 */
	
	isScreen: boolean;
	/** 
	 * @brief 播放器 ID。空值为默认播放器。
	 *        该设置对公共流无效。
	 */
	
	playerId?: string;
}
/** 
 * @brief WTN 流视频首帧事件。
 */

export interface onWTNFirstRemoteVideoFrameDecodedEvent {
	/** 
	 * @brief WTN 流 ID。
	 */
	
	streamId: string;
}
/** 
 * @brief 播放 WTN 流状态。
 */

export interface onWTNPlayStateChangedEvent {
	/** 
	 * @brief WTN 流 ID。
	 */
	
	streamId: string;
	/** 
	 * @brief 播放 WTN 流原状态。
	 */
	
	oldState: WTNPlayState;
	/** 
	 * @brief 播放 WTN 流新状态。
	 */
	
	newState: WTNPlayState;
	/** 
	 * @brief 状态变更原因。
	 */
	
	reason: WTNPlayStateChangedReason;
	/** 
	 * @brief 状态变更耗时。
	 */
	
	elapse: number;
}
/** 
 * @brief WTN 流发布结果。
 */

export interface onWTNPushStateChangedEvent {
	/** 
	 * @brief WTN 流 ID。
	 */
	
	streamId: string;
	/** 
	 * @brief WTN 流发布任务原状态。
	 */
	
	oldState: WTNPushState;
	/** 
	 * @brief WTN 流发布任务新状态。
	 */
	
	newState: WTNPushState;
	/** 
	 * @brief WTN 流发布任务状态变更原因。
	 */
	
	reason: WTNPushStateChangedReason;
	/** 
	 * @brief WTN 流发布任务状态变更耗时。
	 */
	
	elapse: number;
}
/** 
 * @brief 远端 WTN 流音频状态改变。
 */

export interface onWTNRemoteAudioStateChangedEvent {
	/** 
	 * @brief WTN 流 ID。
	 */
	
	streamId: string;
	/** 
	 * @brief WTN 流音频状态改变。
	 */
	
	state: WTNRemoteAudioState;
	/** 
	 * @brief 远端 WTN 流音频状态变化原因
	 */
	
	reason: WTNRemoteAudioStateChangeReason;
}
/** 
 * @brief WTN 流的音频统计信息。
 */

export interface onWTNRemoteAudioStatsEvent {
	/** 
	 * @brief WTN 流 ID。
	 */
	
	streamId: string;
	/** 
	 * @brief WTN 流的音频统计信息。
	 */
	
	audioStats: RemoteAudioStats;
}
/** 
 * @brief WTN 流视频状态改变。
 */

export interface onWTNRemoteVideoStateChangedEvent {
	/** 
	 * @brief WTN 流 ID。
	 */
	
	streamId: string;
	/** 
	 * @brief WTN 流视频状态。
	 */
	
	state: WTNRemoteVideoState;
	/** 
	 * @brief WTN 流视频状态改变原因。
	 */
	
	reason: WTNRemoteVideoStateChangeReason;
}
/** 
 * @brief WTN 流的视频统计信息。
 */

export interface onWTNRemoteVideoStatsEvent {
	/** 
	 * @brief WTN 流 ID。
	 */
	
	streamId: string;
	/** 
	 * @brief WTN 流的视频统计信息。
	 */
	
	videoStats: RemoteVideoStats;
}
/** 
 * @brief WTN 流包含的 SEI 消息。
 */

export interface onWTNSEIMessageReceivedEvent {
	/** 
	 * @brief WTN 流 ID。
	 */
	
	streamId: string;
	/** 
	 * @brief SEI。
	 */
	
	sei: Uint8Array;
}
export type CoreSetParamterInterface = {
	[P in keyof CoreConfigType]: CoreConfigType[P] extends number ? number | string : CoreConfigType[P];
};
/** 
 * @brief 多路媒体流中一路流的布局设置。
 * 本结构体包含了 [LiveTranscodeLayoutRegion](#livetranscodelayoutregion) 中 `isLocalUser` 和 `contentControl` 除外的所有参数及以下参数。
 */

export type PublicStreamLayoutRegion = Omit<LiveTranscodeLayoutRegion, "isLocalUser" | "contentControl"> & {
	/** 
	 * @brief 媒体流发布用户的房间 ID
	 */
	
	roomId: string;
	/** 
	 * @brief  WTN 流输出内容类型
	 */
	
	mediaType?: PublicStreamType;
	/** 
	 * @brief  WTN 流视频裁剪配置
	 */
	
	sourceCrop?: {
		/** 
		 * @brief 裁剪后得到的视频帧左上角横坐标相对于裁剪前整体画面的归一化比例，取值范围[0.0, 1.0)。
		 */
		
		x: number;
		/** 
		 * @brief 裁剪后得到的视频帧左上角纵坐标相对于裁剪前整体画面的归一化比例，取值范围[0.0, 1.0)。
		 */
		
		y: number;
		/** 
		 * @brief 裁剪后得到的视频帧宽度相对于裁剪前整体画面的归一化比例，取值范围(0.0, 1.0]。
		 */
		
		w: number;
		/** 
		 * @brief 裁剪后得到的视频帧高度相对于裁剪前整体画面的归一化比例，取值范围(0.0, 1.0]。
		 */
		
		h: number;
	};
};
/** 
 * @brief 用户订阅的公共流统计信息以及网络状况，统计周期为 2s。
 */

export type PublicStreamStats = Omit<
/** 
 * @brief 远端媒体流统计信息
 */

RemoteStreamStats, "userId" | "isScreen"> & {
	/** 
	 * @brief 公共流 ID。
	 */
	
	publicStreamId: string;
};
/** 
 * 公共流首帧视频解码事件。
 */

export type PublicStreamVideoFirstFrameDecodedEvent = Omit<
/** 
 * @brief 视频首帧解码事件。
 */

onVideoFirstFrameDecodedEvent, "userId"> & {
	/** 
	 * @brief  公共流 ID。
	 */
	
	publicStreamId: string;
};
/** 
 * @brief Electron 框架下，需要获取的共享源类型。
 * • `'screen'`: 屏幕。
 * • `'window'`: 应用和窗口。
 */

export type ScreenSourceType = "screen" | "window";
export type SetParamKey = keyof (SetParamInterface & CoreSetParamterInterface);
export type SubMediaType = ExtendMediaType | MediaType;
/** 
 * @brief 内部采集的媒体属性，详见[浏览器文档](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints)
 */

export type TrackCaptureConfig = Omit<MediaTrackConstraints, "deviceId">;

export {
	_default as default,
};

export as namespace RTC;

export {};
