// node_modules/@volcengine/rtc/index.esm.min.js
function _mergeNamespaces(e, t) {
  return t.forEach(function(t2) {
    t2 && "string" != typeof t2 && !Array.isArray(t2) && Object.keys(t2).forEach(function(i) {
      if ("default" !== i && !(i in e)) {
        var r = Object.getOwnPropertyDescriptor(t2, i);
        Object.defineProperty(e, i, r.get ? r : { enumerable: true, get: function() {
          return t2[i];
        } });
      }
    });
  }), Object.freeze(e);
}
var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function getAugmentedNamespace(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if ("function" == typeof t) {
    var i = function e2() {
      if (this instanceof e2) {
        var i2 = [null];
        return i2.push.apply(i2, arguments), new (Function.bind.apply(t, i2))();
      }
      return t.apply(this, arguments);
    };
    i.prototype = t.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: true }), Object.keys(e).forEach(function(t2) {
    var r = Object.getOwnPropertyDescriptor(e, t2);
    Object.defineProperty(i, t2, r.get ? r : { enumerable: true, get: function() {
      return e[t2];
    } });
  }), i;
}
var defineProperty$c = { exports: {} };
var check = function(e) {
  return e && e.Math === Math && e;
};
var globalThis_1 = check("object" == typeof globalThis && globalThis) || check("object" == typeof window && window) || check("object" == typeof self && self) || check("object" == typeof commonjsGlobal && commonjsGlobal) || check("object" == typeof commonjsGlobal && commonjsGlobal) || /* @__PURE__ */ function() {
  return this;
}() || Function("return this")();
var fails$s = function(e) {
  try {
    return !!e();
  } catch (e2) {
    return true;
  }
};
var fails$r = fails$s;
var functionBindNative = !fails$r(function() {
  var e = (function() {
  }).bind();
  return "function" != typeof e || e.hasOwnProperty("prototype");
});
var NATIVE_BIND$3 = functionBindNative;
var FunctionPrototype$3 = Function.prototype;
var apply$4 = FunctionPrototype$3.apply;
var call$m = FunctionPrototype$3.call;
var functionApply = "object" == typeof Reflect && Reflect.apply || (NATIVE_BIND$3 ? call$m.bind(apply$4) : function() {
  return call$m.apply(apply$4, arguments);
});
var NATIVE_BIND$2 = functionBindNative;
var FunctionPrototype$2 = Function.prototype;
var call$l = FunctionPrototype$2.call;
var uncurryThisWithBind = NATIVE_BIND$2 && FunctionPrototype$2.bind.bind(call$l, call$l);
var functionUncurryThis = NATIVE_BIND$2 ? uncurryThisWithBind : function(e) {
  return function() {
    return call$l.apply(e, arguments);
  };
};
var uncurryThis$w = functionUncurryThis;
var toString$g = uncurryThis$w({}.toString);
var stringSlice$5 = uncurryThis$w("".slice);
var classofRaw$2 = function(e) {
  return stringSlice$5(toString$g(e), 8, -1);
};
var classofRaw$1 = classofRaw$2;
var uncurryThis$v = functionUncurryThis;
var functionUncurryThisClause = function(e) {
  if ("Function" === classofRaw$1(e)) return uncurryThis$v(e);
};
var documentAll = "object" == typeof document && document.all;
var isCallable$l = void 0 === documentAll && void 0 !== documentAll ? function(e) {
  return "function" == typeof e || e === documentAll;
} : function(e) {
  return "function" == typeof e;
};
var objectGetOwnPropertyDescriptor = {};
var fails$q = fails$s;
var descriptors = !fails$q(function() {
  return 7 !== Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
});
var NATIVE_BIND$1 = functionBindNative;
var call$k = Function.prototype.call;
var functionCall = NATIVE_BIND$1 ? call$k.bind(call$k) : function() {
  return call$k.apply(call$k, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$9 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$9 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function(e) {
  var t = getOwnPropertyDescriptor$9(this, e);
  return !!t && t.enumerable;
} : $propertyIsEnumerable$1;
var match;
var version;
var createPropertyDescriptor$8 = function(e, t) {
  return { enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t };
};
var uncurryThis$u = functionUncurryThis;
var fails$p = fails$s;
var classof$c = classofRaw$2;
var $Object$4 = Object;
var split$3 = uncurryThis$u("".split);
var indexedObject = fails$p(function() {
  return !$Object$4("z").propertyIsEnumerable(0);
}) ? function(e) {
  return "String" === classof$c(e) ? split$3(e, "") : $Object$4(e);
} : $Object$4;
var isNullOrUndefined$5 = function(e) {
  return null == e;
};
var isNullOrUndefined$4 = isNullOrUndefined$5;
var $TypeError$h = TypeError;
var requireObjectCoercible$7 = function(e) {
  if (isNullOrUndefined$4(e)) throw new $TypeError$h("Can't call method on " + e);
  return e;
};
var IndexedObject$2 = indexedObject;
var requireObjectCoercible$6 = requireObjectCoercible$7;
var toIndexedObject$9 = function(e) {
  return IndexedObject$2(requireObjectCoercible$6(e));
};
var isCallable$k = isCallable$l;
var isObject$g = function(e) {
  return "object" == typeof e ? null !== e : isCallable$k(e);
};
var path$e = {};
var path$d = path$e;
var globalThis$w = globalThis_1;
var isCallable$j = isCallable$l;
var aFunction = function(e) {
  return isCallable$j(e) ? e : void 0;
};
var getBuiltIn$h = function(e, t) {
  return arguments.length < 2 ? aFunction(path$d[e]) || aFunction(globalThis$w[e]) : path$d[e] && path$d[e][t] || globalThis$w[e] && globalThis$w[e][t];
};
var uncurryThis$t = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$t({}.isPrototypeOf);
var globalThis$v = globalThis_1;
var navigator$1 = globalThis$v.navigator;
var userAgent$7 = navigator$1 && navigator$1.userAgent;
var environmentUserAgent = userAgent$7 ? String(userAgent$7) : "";
var globalThis$u = globalThis_1;
var userAgent$6 = environmentUserAgent;
var process$3 = globalThis$u.process;
var Deno$1 = globalThis$u.Deno;
var versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;
var v8 = versions && versions.v8;
v8 && (version = (match = v8.split("."))[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1])), !version && userAgent$6 && (!(match = userAgent$6.match(/Edge\/(\d+)/)) || match[1] >= 74) && (match = userAgent$6.match(/Chrome\/(\d+)/)) && (version = +match[1]);
var environmentV8Version = version;
var V8_VERSION$3 = environmentV8Version;
var fails$o = fails$s;
var globalThis$t = globalThis_1;
var $String$5 = globalThis$t.String;
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$o(function() {
  var e = Symbol("symbol detection");
  return !$String$5(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && V8_VERSION$3 && V8_VERSION$3 < 41;
});
var NATIVE_SYMBOL$5 = symbolConstructorDetection;
var useSymbolAsUid = NATIVE_SYMBOL$5 && !Symbol.sham && "symbol" == typeof Symbol.iterator;
var getBuiltIn$g = getBuiltIn$h;
var isCallable$i = isCallable$l;
var isPrototypeOf$f = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$3 = Object;
var isSymbol$5 = USE_SYMBOL_AS_UID$1 ? function(e) {
  return "symbol" == typeof e;
} : function(e) {
  var t = getBuiltIn$g("Symbol");
  return isCallable$i(t) && isPrototypeOf$f(t.prototype, $Object$3(e));
};
var $String$4 = String;
var tryToString$6 = function(e) {
  try {
    return $String$4(e);
  } catch (e2) {
    return "Object";
  }
};
var isCallable$h = isCallable$l;
var tryToString$5 = tryToString$6;
var $TypeError$g = TypeError;
var aCallable$c = function(e) {
  if (isCallable$h(e)) return e;
  throw new $TypeError$g(tryToString$5(e) + " is not a function");
};
var aCallable$b = aCallable$c;
var isNullOrUndefined$3 = isNullOrUndefined$5;
var getMethod$4 = function(e, t) {
  var i = e[t];
  return isNullOrUndefined$3(i) ? void 0 : aCallable$b(i);
};
var call$j = functionCall;
var isCallable$g = isCallable$l;
var isObject$f = isObject$g;
var $TypeError$f = TypeError;
var ordinaryToPrimitive$1 = function(e, t) {
  var i, r;
  if ("string" === t && isCallable$g(i = e.toString) && !isObject$f(r = call$j(i, e))) return r;
  if (isCallable$g(i = e.valueOf) && !isObject$f(r = call$j(i, e))) return r;
  if ("string" !== t && isCallable$g(i = e.toString) && !isObject$f(r = call$j(i, e))) return r;
  throw new $TypeError$f("Can't convert object to primitive value");
};
var sharedStore = { exports: {} };
var isPure = true;
var globalThis$s = globalThis_1;
var defineProperty$b = Object.defineProperty;
var defineGlobalProperty$1 = function(e, t) {
  try {
    defineProperty$b(globalThis$s, e, { value: t, configurable: true, writable: true });
  } catch (i) {
    globalThis$s[e] = t;
  }
  return t;
};
var globalThis$r = globalThis_1;
var defineGlobalProperty = defineGlobalProperty$1;
var SHARED = "__core-js_shared__";
var store$3 = sharedStore.exports = globalThis$r[SHARED] || defineGlobalProperty(SHARED, {});
(store$3.versions || (store$3.versions = [])).push({ version: "3.39.0", mode: "pure", copyright: "Â© 2014-2024 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.39.0/LICENSE", source: "https://github.com/zloirock/core-js" });
var sharedStoreExports = sharedStore.exports;
var store$2 = sharedStoreExports;
var shared$7 = function(e, t) {
  return store$2[e] || (store$2[e] = t || {});
};
var requireObjectCoercible$5 = requireObjectCoercible$7;
var $Object$2 = Object;
var toObject$c = function(e) {
  return $Object$2(requireObjectCoercible$5(e));
};
var uncurryThis$s = functionUncurryThis;
var toObject$b = toObject$c;
var hasOwnProperty = uncurryThis$s({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function(e, t) {
  return hasOwnProperty(toObject$b(e), t);
};
var uncurryThis$r = functionUncurryThis;
var id = 0;
var postfix = Math.random();
var toString$f = uncurryThis$r(1 .toString);
var uid$3 = function(e) {
  return "Symbol(" + (void 0 === e ? "" : e) + ")_" + toString$f(++id + postfix, 36);
};
var globalThis$q = globalThis_1;
var shared$6 = shared$7;
var hasOwn$h = hasOwnProperty_1;
var uid$2 = uid$3;
var NATIVE_SYMBOL$4 = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var Symbol$3 = globalThis$q.Symbol;
var WellKnownSymbolsStore$2 = shared$6("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$3.for || Symbol$3 : Symbol$3 && Symbol$3.withoutSetter || uid$2;
var wellKnownSymbol$q = function(e) {
  return hasOwn$h(WellKnownSymbolsStore$2, e) || (WellKnownSymbolsStore$2[e] = NATIVE_SYMBOL$4 && hasOwn$h(Symbol$3, e) ? Symbol$3[e] : createWellKnownSymbol("Symbol." + e)), WellKnownSymbolsStore$2[e];
};
var call$i = functionCall;
var isObject$e = isObject$g;
var isSymbol$4 = isSymbol$5;
var getMethod$3 = getMethod$4;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$p = wellKnownSymbol$q;
var $TypeError$e = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$p("toPrimitive");
var toPrimitive$7 = function(e, t) {
  if (!isObject$e(e) || isSymbol$4(e)) return e;
  var i, r = getMethod$3(e, TO_PRIMITIVE);
  if (r) {
    if (void 0 === t && (t = "default"), i = call$i(r, e, t), !isObject$e(i) || isSymbol$4(i)) return i;
    throw new $TypeError$e("Can't convert object to primitive value");
  }
  return void 0 === t && (t = "number"), ordinaryToPrimitive(e, t);
};
var toPrimitive$6 = toPrimitive$7;
var isSymbol$3 = isSymbol$5;
var toPropertyKey$4 = function(e) {
  var t = toPrimitive$6(e, "string");
  return isSymbol$3(t) ? t : t + "";
};
var globalThis$p = globalThis_1;
var isObject$d = isObject$g;
var document$3 = globalThis$p.document;
var EXISTS$1 = isObject$d(document$3) && isObject$d(document$3.createElement);
var documentCreateElement$1 = function(e) {
  return EXISTS$1 ? document$3.createElement(e) : {};
};
var DESCRIPTORS$j = descriptors;
var fails$n = fails$s;
var createElement$2 = documentCreateElement$1;
var ie8DomDefine = !DESCRIPTORS$j && !fails$n(function() {
  return 7 !== Object.defineProperty(createElement$2("div"), "a", { get: function() {
    return 7;
  } }).a;
});
var DESCRIPTORS$i = descriptors;
var call$h = functionCall;
var propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;
var createPropertyDescriptor$7 = createPropertyDescriptor$8;
var toIndexedObject$8 = toIndexedObject$9;
var toPropertyKey$3 = toPropertyKey$4;
var hasOwn$g = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$i ? $getOwnPropertyDescriptor$2 : function(e, t) {
  if (e = toIndexedObject$8(e), t = toPropertyKey$3(t), IE8_DOM_DEFINE$1) try {
    return $getOwnPropertyDescriptor$2(e, t);
  } catch (e2) {
  }
  if (hasOwn$g(e, t)) return createPropertyDescriptor$7(!call$h(propertyIsEnumerableModule$2.f, e, t), e[t]);
};
var fails$m = fails$s;
var isCallable$f = isCallable$l;
var replacement = /#|\.prototype\./;
var isForced$2 = function(e, t) {
  var i = data[normalize(e)];
  return i === POLYFILL || i !== NATIVE && (isCallable$f(t) ? fails$m(t) : !!t);
};
var normalize = isForced$2.normalize = function(e) {
  return String(e).replace(replacement, ".").toLowerCase();
};
var data = isForced$2.data = {};
var NATIVE = isForced$2.NATIVE = "N";
var POLYFILL = isForced$2.POLYFILL = "P";
var isForced_1 = isForced$2;
var aCallable$a = aCallable$c;
var NATIVE_BIND = functionBindNative;
var bind$a = functionUncurryThisClause(functionUncurryThisClause.bind);
var functionBindContext = function(e, t) {
  return aCallable$a(e), void 0 === t ? e : NATIVE_BIND ? bind$a(e, t) : function() {
    return e.apply(t, arguments);
  };
};
var objectDefineProperty = {};
var DESCRIPTORS$h = descriptors;
var fails$l = fails$s;
var v8PrototypeDefineBug = DESCRIPTORS$h && fails$l(function() {
  return 42 !== Object.defineProperty(function() {
  }, "prototype", { value: 42, writable: false }).prototype;
});
var isObject$c = isObject$g;
var $String$3 = String;
var $TypeError$d = TypeError;
var anObject$d = function(e) {
  if (isObject$c(e)) return e;
  throw new $TypeError$d($String$3(e) + " is not an object");
};
var DESCRIPTORS$g = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$c = anObject$d;
var toPropertyKey$2 = toPropertyKey$4;
var $TypeError$c = TypeError;
var $defineProperty$1 = Object.defineProperty;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$g ? V8_PROTOTYPE_DEFINE_BUG$1 ? function(e, t, i) {
  if (anObject$c(e), t = toPropertyKey$2(t), anObject$c(i), "function" == typeof e && "prototype" === t && "value" in i && WRITABLE in i && !i[WRITABLE]) {
    var r = $getOwnPropertyDescriptor$1(e, t);
    r && r[WRITABLE] && (e[t] = i.value, i = { configurable: CONFIGURABLE$1 in i ? i[CONFIGURABLE$1] : r[CONFIGURABLE$1], enumerable: ENUMERABLE in i ? i[ENUMERABLE] : r[ENUMERABLE], writable: false });
  }
  return $defineProperty$1(e, t, i);
} : $defineProperty$1 : function(e, t, i) {
  if (anObject$c(e), t = toPropertyKey$2(t), anObject$c(i), IE8_DOM_DEFINE) try {
    return $defineProperty$1(e, t, i);
  } catch (e2) {
  }
  if ("get" in i || "set" in i) throw new $TypeError$c("Accessors not supported");
  return "value" in i && (e[t] = i.value), e;
};
var DESCRIPTORS$f = descriptors;
var definePropertyModule$4 = objectDefineProperty;
var createPropertyDescriptor$6 = createPropertyDescriptor$8;
var createNonEnumerableProperty$7 = DESCRIPTORS$f ? function(e, t, i) {
  return definePropertyModule$4.f(e, t, createPropertyDescriptor$6(1, i));
} : function(e, t, i) {
  return e[t] = i, e;
};
var globalThis$o = globalThis_1;
var apply$3 = functionApply;
var uncurryThis$p = functionUncurryThisClause;
var isCallable$e = isCallable$l;
var getOwnPropertyDescriptor$8 = objectGetOwnPropertyDescriptor.f;
var isForced$1 = isForced_1;
var path$c = path$e;
var bind$9 = functionBindContext;
var createNonEnumerableProperty$6 = createNonEnumerableProperty$7;
var hasOwn$f = hasOwnProperty_1;
var wrapConstructor = function(e) {
  var t = function(i, r, o) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new e();
        case 1:
          return new e(i);
        case 2:
          return new e(i, r);
      }
      return new e(i, r, o);
    }
    return apply$3(e, this, arguments);
  };
  return t.prototype = e.prototype, t;
};
var _export = function(e, t) {
  var i, r, o, n, s, a, d, c2, l, u = e.target, h = e.global, _ = e.stat, p = e.proto, m = h ? globalThis$o : _ ? globalThis$o[u] : globalThis$o[u] && globalThis$o[u].prototype, S = h ? path$c : path$c[u] || createNonEnumerableProperty$6(path$c, u, {})[u], g = S.prototype;
  for (n in t) r = !(i = isForced$1(h ? n : u + (_ ? "." : "#") + n, e.forced)) && m && hasOwn$f(m, n), a = S[n], r && (d = e.dontCallGetSet ? (l = getOwnPropertyDescriptor$8(m, n)) && l.value : m[n]), s = r && d ? d : t[n], (i || p || typeof a != typeof s) && (c2 = e.bind && r ? bind$9(s, globalThis$o) : e.wrap && r ? wrapConstructor(s) : p && isCallable$e(s) ? uncurryThis$p(s) : s, (e.sham || s && s.sham || a && a.sham) && createNonEnumerableProperty$6(c2, "sham", true), createNonEnumerableProperty$6(S, n, c2), p && (hasOwn$f(path$c, o = u + "Prototype") || createNonEnumerableProperty$6(path$c, o, {}), createNonEnumerableProperty$6(path$c[o], n, s), e.real && g && (i || !g[n]) && createNonEnumerableProperty$6(g, n, s)));
};
var $$I = _export;
var DESCRIPTORS$e = descriptors;
var defineProperty$a = objectDefineProperty.f;
$$I({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty$a, sham: !DESCRIPTORS$e }, { defineProperty: defineProperty$a });
var path$b = path$e;
var Object$3 = path$b.Object;
var defineProperty$9 = defineProperty$c.exports = function(e, t, i) {
  return Object$3.defineProperty(e, t, i);
};
Object$3.defineProperty.sham && (defineProperty$9.sham = true);
var definePropertyExports = defineProperty$c.exports;
var parent$17 = definePropertyExports;
var defineProperty$8 = parent$17;
var parent$16 = defineProperty$8;
var defineProperty$7 = parent$16;
var parent$15 = defineProperty$7;
var defineProperty$6 = parent$15;
var defineProperty$5 = defineProperty$6;
var _Object$defineProperty = getDefaultExportFromCjs(defineProperty$5);
var classof$b = classofRaw$2;
var isArray$6 = Array.isArray || function(e) {
  return "Array" === classof$b(e);
};
var ceil = Math.ceil;
var floor$4 = Math.floor;
var mathTrunc = Math.trunc || function(e) {
  var t = +e;
  return (t > 0 ? floor$4 : ceil)(t);
};
var trunc2 = mathTrunc;
var toIntegerOrInfinity$4 = function(e) {
  var t = +e;
  return t != t || 0 === t ? 0 : trunc2(t);
};
var toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
var min$1 = Math.min;
var toLength$1 = function(e) {
  var t = toIntegerOrInfinity$3(e);
  return t > 0 ? min$1(t, 9007199254740991) : 0;
};
var toLength = toLength$1;
var lengthOfArrayLike$9 = function(e) {
  return toLength(e.length);
};
var $TypeError$b = TypeError;
var MAX_SAFE_INTEGER = 9007199254740991;
var doesNotExceedSafeInteger$3 = function(e) {
  if (e > MAX_SAFE_INTEGER) throw $TypeError$b("Maximum allowed index exceeded");
  return e;
};
var DESCRIPTORS$d = descriptors;
var definePropertyModule$3 = objectDefineProperty;
var createPropertyDescriptor$5 = createPropertyDescriptor$8;
var createProperty$4 = function(e, t, i) {
  DESCRIPTORS$d ? definePropertyModule$3.f(e, t, createPropertyDescriptor$5(0, i)) : e[t] = i;
};
var wellKnownSymbol$o = wellKnownSymbol$q;
var TO_STRING_TAG$3 = wellKnownSymbol$o("toStringTag");
var test$2 = {};
test$2[TO_STRING_TAG$3] = "z";
var toStringTagSupport = "[object z]" === String(test$2);
var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
var isCallable$d = isCallable$l;
var classofRaw = classofRaw$2;
var wellKnownSymbol$n = wellKnownSymbol$q;
var TO_STRING_TAG$2 = wellKnownSymbol$n("toStringTag");
var $Object$1 = Object;
var CORRECT_ARGUMENTS = "Arguments" === classofRaw(/* @__PURE__ */ function() {
  return arguments;
}());
var tryGet = function(e, t) {
  try {
    return e[t];
  } catch (e2) {
  }
};
var classof$a = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function(e) {
  var t, i, r;
  return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (i = tryGet(t = $Object$1(e), TO_STRING_TAG$2)) ? i : CORRECT_ARGUMENTS ? classofRaw(t) : "Object" === (r = classofRaw(t)) && isCallable$d(t.callee) ? "Arguments" : r;
};
var uncurryThis$o = functionUncurryThis;
var isCallable$c = isCallable$l;
var store$1 = sharedStoreExports;
var functionToString = uncurryThis$o(Function.toString);
isCallable$c(store$1.inspectSource) || (store$1.inspectSource = function(e) {
  return functionToString(e);
});
var inspectSource$2 = store$1.inspectSource;
var uncurryThis$n = functionUncurryThis;
var fails$k = fails$s;
var isCallable$b = isCallable$l;
var classof$9 = classof$a;
var getBuiltIn$f = getBuiltIn$h;
var inspectSource$1 = inspectSource$2;
var noop = function() {
};
var construct = getBuiltIn$f("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$4 = uncurryThis$n(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop);
var isConstructorModern = function(e) {
  if (!isCallable$b(e)) return false;
  try {
    return construct(noop, [], e), true;
  } catch (e2) {
    return false;
  }
};
var isConstructorLegacy = function(e) {
  if (!isCallable$b(e)) return false;
  switch (classof$9(e)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING || !!exec$4(constructorRegExp, inspectSource$1(e));
  } catch (e2) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$3 = !construct || fails$k(function() {
  var e;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    e = true;
  }) || e;
}) ? isConstructorLegacy : isConstructorModern;
var isArray$5 = isArray$6;
var isConstructor$2 = isConstructor$3;
var isObject$b = isObject$g;
var wellKnownSymbol$m = wellKnownSymbol$q;
var SPECIES$4 = wellKnownSymbol$m("species");
var $Array$1 = Array;
var arraySpeciesConstructor$1 = function(e) {
  var t;
  return isArray$5(e) && (t = e.constructor, (isConstructor$2(t) && (t === $Array$1 || isArray$5(t.prototype)) || isObject$b(t) && null === (t = t[SPECIES$4])) && (t = void 0)), void 0 === t ? $Array$1 : t;
};
var arraySpeciesConstructor = arraySpeciesConstructor$1;
var arraySpeciesCreate$3 = function(e, t) {
  return new (arraySpeciesConstructor(e))(0 === t ? 0 : t);
};
var fails$j = fails$s;
var wellKnownSymbol$l = wellKnownSymbol$q;
var V8_VERSION$2 = environmentV8Version;
var SPECIES$3 = wellKnownSymbol$l("species");
var arrayMethodHasSpeciesSupport$2 = function(e) {
  return V8_VERSION$2 >= 51 || !fails$j(function() {
    var t = [];
    return (t.constructor = {})[SPECIES$3] = function() {
      return { foo: 1 };
    }, 1 !== t[e](Boolean).foo;
  });
};
var $$H = _export;
var fails$i = fails$s;
var isArray$4 = isArray$6;
var isObject$a = isObject$g;
var toObject$a = toObject$c;
var lengthOfArrayLike$8 = lengthOfArrayLike$9;
var doesNotExceedSafeInteger$2 = doesNotExceedSafeInteger$3;
var createProperty$3 = createProperty$4;
var arraySpeciesCreate$2 = arraySpeciesCreate$3;
var arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$2;
var wellKnownSymbol$k = wellKnownSymbol$q;
var V8_VERSION$1 = environmentV8Version;
var IS_CONCAT_SPREADABLE = wellKnownSymbol$k("isConcatSpreadable");
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION$1 >= 51 || !fails$i(function() {
  var e = [];
  return e[IS_CONCAT_SPREADABLE] = false, e.concat()[0] !== e;
});
var isConcatSpreadable = function(e) {
  if (!isObject$a(e)) return false;
  var t = e[IS_CONCAT_SPREADABLE];
  return void 0 !== t ? !!t : isArray$4(e);
};
var FORCED$5 = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport$1("concat");
$$H({ target: "Array", proto: true, arity: 1, forced: FORCED$5 }, { concat: function(e) {
  var t, i, r, o, n, s = toObject$a(this), a = arraySpeciesCreate$2(s, 0), d = 0;
  for (t = -1, r = arguments.length; t < r; t++) if (isConcatSpreadable(n = -1 === t ? s : arguments[t])) for (o = lengthOfArrayLike$8(n), doesNotExceedSafeInteger$2(d + o), i = 0; i < o; i++, d++) i in n && createProperty$3(a, d, n[i]);
  else doesNotExceedSafeInteger$2(d + 1), createProperty$3(a, d++, n);
  return a.length = d, a;
} });
var classof$8 = classof$a;
var $String$2 = String;
var toString$e = function(e) {
  if ("Symbol" === classof$8(e)) throw new TypeError("Cannot convert a Symbol value to a string");
  return $String$2(e);
};
var objectDefineProperties = {};
var toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
var max$1 = Math.max;
var min = Math.min;
var toAbsoluteIndex$2 = function(e, t) {
  var i = toIntegerOrInfinity$2(e);
  return i < 0 ? max$1(i + t, 0) : min(i, t);
};
var toIndexedObject$7 = toIndexedObject$9;
var toAbsoluteIndex$1 = toAbsoluteIndex$2;
var lengthOfArrayLike$7 = lengthOfArrayLike$9;
var createMethod$3 = function(e) {
  return function(t, i, r) {
    var o = toIndexedObject$7(t), n = lengthOfArrayLike$7(o);
    if (0 === n) return !e && -1;
    var s, a = toAbsoluteIndex$1(r, n);
    if (e && i != i) {
      for (; n > a; ) if ((s = o[a++]) != s) return true;
    } else for (; n > a; a++) if ((e || a in o) && o[a] === i) return e || a || 0;
    return !e && -1;
  };
};
var arrayIncludes = { includes: createMethod$3(true), indexOf: createMethod$3(false) };
var hiddenKeys$5 = {};
var uncurryThis$m = functionUncurryThis;
var hasOwn$e = hasOwnProperty_1;
var toIndexedObject$6 = toIndexedObject$9;
var indexOf$1 = arrayIncludes.indexOf;
var hiddenKeys$4 = hiddenKeys$5;
var push$e = uncurryThis$m([].push);
var objectKeysInternal = function(e, t) {
  var i, r = toIndexedObject$6(e), o = 0, n = [];
  for (i in r) !hasOwn$e(hiddenKeys$4, i) && hasOwn$e(r, i) && push$e(n, i);
  for (; t.length > o; ) hasOwn$e(r, i = t[o++]) && (~indexOf$1(n, i) || push$e(n, i));
  return n;
};
var enumBugKeys$3 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var objectKeys$3 = Object.keys || function(e) {
  return internalObjectKeys$1(e, enumBugKeys$2);
};
var DESCRIPTORS$c = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$2 = objectDefineProperty;
var anObject$b = anObject$d;
var toIndexedObject$5 = toIndexedObject$9;
var objectKeys$2 = objectKeys$3;
objectDefineProperties.f = DESCRIPTORS$c && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function(e, t) {
  anObject$b(e);
  for (var i, r = toIndexedObject$5(t), o = objectKeys$2(t), n = o.length, s = 0; n > s; ) definePropertyModule$2.f(e, i = o[s++], r[i]);
  return e;
};
var activeXDocument;
var getBuiltIn$e = getBuiltIn$h;
var html$2 = getBuiltIn$e("document", "documentElement");
var shared$5 = shared$7;
var uid$1 = uid$3;
var keys$5 = shared$5("keys");
var sharedKey$4 = function(e) {
  return keys$5[e] || (keys$5[e] = uid$1(e));
};
var anObject$a = anObject$d;
var definePropertiesModule$1 = objectDefineProperties;
var enumBugKeys$1 = enumBugKeys$3;
var hiddenKeys$3 = hiddenKeys$5;
var html$1 = html$2;
var documentCreateElement = documentCreateElement$1;
var sharedKey$3 = sharedKey$4;
var GT = ">";
var LT = "<";
var PROTOTYPE$1 = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$3("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(e) {
  return LT + SCRIPT + GT + e + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(e) {
  e.write(scriptTag("")), e.close();
  var t = e.parentWindow.Object;
  return e = null, t;
};
var NullProtoObjectViaIFrame = function() {
  var e, t = documentCreateElement("iframe"), i = "java" + SCRIPT + ":";
  return t.style.display = "none", html$1.appendChild(t), t.src = String(i), (e = t.contentWindow.document).open(), e.write(scriptTag("document.F=Object")), e.close(), e.F;
};
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (e2) {
  }
  NullProtoObject = "undefined" != typeof document ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  for (var e = enumBugKeys$1.length; e--; ) delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[e]];
  return NullProtoObject();
};
hiddenKeys$3[IE_PROTO$1] = true;
var objectCreate = Object.create || function(e, t) {
  var i;
  return null !== e ? (EmptyConstructor[PROTOTYPE$1] = anObject$a(e), i = new EmptyConstructor(), EmptyConstructor[PROTOTYPE$1] = null, i[IE_PROTO$1] = e) : i = NullProtoObject(), void 0 === t ? i : definePropertiesModule$1.f(i, t);
};
var objectGetOwnPropertyNames = {};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys$2 = enumBugKeys.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function(e) {
  return internalObjectKeys(e, hiddenKeys$2);
};
var objectGetOwnPropertyNamesExternal = {};
var uncurryThis$l = functionUncurryThis;
var arraySlice$5 = uncurryThis$l([].slice);
var classof$7 = classofRaw$2;
var toIndexedObject$4 = toIndexedObject$9;
var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var arraySlice$4 = arraySlice$5;
var windowNames = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
var getWindowNames = function(e) {
  try {
    return $getOwnPropertyNames$1(e);
  } catch (e2) {
    return arraySlice$4(windowNames);
  }
};
objectGetOwnPropertyNamesExternal.f = function(e) {
  return windowNames && "Window" === classof$7(e) ? getWindowNames(e) : $getOwnPropertyNames$1(toIndexedObject$4(e));
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$7;
var defineBuiltIn$8 = function(e, t, i, r) {
  return r && r.enumerable ? e[t] = i : createNonEnumerableProperty$5(e, t, i), e;
};
var defineProperty$4 = objectDefineProperty;
var defineBuiltInAccessor$4 = function(e, t, i) {
  return defineProperty$4.f(e, t, i);
};
var wellKnownSymbolWrapped = {};
var wellKnownSymbol$j = wellKnownSymbol$q;
wellKnownSymbolWrapped.f = wellKnownSymbol$j;
var set$1;
var get;
var has;
var path$a = path$e;
var hasOwn$d = hasOwnProperty_1;
var wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var defineProperty$3 = objectDefineProperty.f;
var wellKnownSymbolDefine = function(e) {
  var t = path$a.Symbol || (path$a.Symbol = {});
  hasOwn$d(t, e) || defineProperty$3(t, e, { value: wrappedWellKnownSymbolModule$1.f(e) });
};
var call$g = functionCall;
var getBuiltIn$d = getBuiltIn$h;
var wellKnownSymbol$i = wellKnownSymbol$q;
var defineBuiltIn$7 = defineBuiltIn$8;
var symbolDefineToPrimitive = function() {
  var e = getBuiltIn$d("Symbol"), t = e && e.prototype, i = t && t.valueOf, r = wellKnownSymbol$i("toPrimitive");
  t && !t[r] && defineBuiltIn$7(t, r, function(e2) {
    return call$g(i, this);
  }, { arity: 1 });
};
var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
var classof$6 = classof$a;
var objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function() {
  return "[object " + classof$6(this) + "]";
};
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var defineProperty$2 = objectDefineProperty.f;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$7;
var hasOwn$c = hasOwnProperty_1;
var toString$d = objectToString;
var wellKnownSymbol$h = wellKnownSymbol$q;
var TO_STRING_TAG$1 = wellKnownSymbol$h("toStringTag");
var setToStringTag$9 = function(e, t, i, r) {
  var o = i ? e : e && e.prototype;
  o && (hasOwn$c(o, TO_STRING_TAG$1) || defineProperty$2(o, TO_STRING_TAG$1, { configurable: true, value: t }), r && !TO_STRING_TAG_SUPPORT && createNonEnumerableProperty$4(o, "toString", toString$d));
};
var globalThis$n = globalThis_1;
var isCallable$a = isCallable$l;
var WeakMap$1 = globalThis$n.WeakMap;
var weakMapBasicDetection = isCallable$a(WeakMap$1) && /native code/.test(String(WeakMap$1));
var NATIVE_WEAK_MAP = weakMapBasicDetection;
var globalThis$m = globalThis_1;
var isObject$9 = isObject$g;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$7;
var hasOwn$b = hasOwnProperty_1;
var shared$4 = sharedStoreExports;
var sharedKey$2 = sharedKey$4;
var hiddenKeys$1 = hiddenKeys$5;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$5 = globalThis$m.TypeError;
var WeakMap = globalThis$m.WeakMap;
var enforce = function(e) {
  return has(e) ? get(e) : set$1(e, {});
};
var getterFor = function(e) {
  return function(t) {
    var i;
    if (!isObject$9(t) || (i = get(t)).type !== e) throw new TypeError$5("Incompatible receiver, " + e + " required");
    return i;
  };
};
if (NATIVE_WEAK_MAP || shared$4.state) {
  store = shared$4.state || (shared$4.state = new WeakMap());
  store.get = store.get, store.has = store.has, store.set = store.set, set$1 = function(e, t) {
    if (store.has(e)) throw new TypeError$5(OBJECT_ALREADY_INITIALIZED);
    return t.facade = e, store.set(e, t), t;
  }, get = function(e) {
    return store.get(e) || {};
  }, has = function(e) {
    return store.has(e);
  };
} else {
  STATE = sharedKey$2("state");
  hiddenKeys$1[STATE] = true, set$1 = function(e, t) {
    if (hasOwn$b(e, STATE)) throw new TypeError$5(OBJECT_ALREADY_INITIALIZED);
    return t.facade = e, createNonEnumerableProperty$3(e, STATE, t), t;
  }, get = function(e) {
    return hasOwn$b(e, STATE) ? e[STATE] : {};
  }, has = function(e) {
    return hasOwn$b(e, STATE);
  };
}
var store;
var STATE;
var internalState = { set: set$1, get, has, enforce, getterFor };
var bind$8 = functionBindContext;
var uncurryThis$k = functionUncurryThis;
var IndexedObject$1 = indexedObject;
var toObject$9 = toObject$c;
var lengthOfArrayLike$6 = lengthOfArrayLike$9;
var arraySpeciesCreate$1 = arraySpeciesCreate$3;
var push$d = uncurryThis$k([].push);
var createMethod$2 = function(e) {
  var t = 1 === e, i = 2 === e, r = 3 === e, o = 4 === e, n = 6 === e, s = 7 === e, a = 5 === e || n;
  return function(d, c2, l, u) {
    for (var h, _, p = toObject$9(d), m = IndexedObject$1(p), S = lengthOfArrayLike$6(m), g = bind$8(c2, l), v3 = 0, f = u || arraySpeciesCreate$1, y = t ? f(d, S) : i || s ? f(d, 0) : void 0; S > v3; v3++) if ((a || v3 in m) && (_ = g(h = m[v3], v3, p), e)) if (t) y[v3] = _;
    else if (_) switch (e) {
      case 3:
        return true;
      case 5:
        return h;
      case 6:
        return v3;
      case 2:
        push$d(y, h);
    }
    else switch (e) {
      case 4:
        return false;
      case 7:
        push$d(y, h);
    }
    return n ? -1 : r || o ? o : y;
  };
};
var arrayIteration = { forEach: createMethod$2(0), map: createMethod$2(1), filter: createMethod$2(2), some: createMethod$2(3), every: createMethod$2(4), find: createMethod$2(5), findIndex: createMethod$2(6), filterReject: createMethod$2(7) };
var $$G = _export;
var globalThis$l = globalThis_1;
var call$f = functionCall;
var uncurryThis$j = functionUncurryThis;
var DESCRIPTORS$b = descriptors;
var NATIVE_SYMBOL$3 = symbolConstructorDetection;
var fails$h = fails$s;
var hasOwn$a = hasOwnProperty_1;
var isPrototypeOf$e = objectIsPrototypeOf;
var anObject$9 = anObject$d;
var toIndexedObject$3 = toIndexedObject$9;
var toPropertyKey$1 = toPropertyKey$4;
var $toString$2 = toString$e;
var createPropertyDescriptor$4 = createPropertyDescriptor$8;
var nativeObjectCreate = objectCreate;
var objectKeys$1 = objectKeys$3;
var getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;
var getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;
var getOwnPropertySymbolsModule$3 = objectGetOwnPropertySymbols;
var getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;
var definePropertyModule$1 = objectDefineProperty;
var definePropertiesModule = objectDefineProperties;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var defineBuiltIn$6 = defineBuiltIn$8;
var defineBuiltInAccessor$3 = defineBuiltInAccessor$4;
var shared$3 = shared$7;
var sharedKey$1 = sharedKey$4;
var hiddenKeys = hiddenKeys$5;
var uid = uid$3;
var wellKnownSymbol$g = wellKnownSymbol$q;
var wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var defineWellKnownSymbol$m = wellKnownSymbolDefine;
var defineSymbolToPrimitive$1 = symbolDefineToPrimitive;
var setToStringTag$8 = setToStringTag$9;
var InternalStateModule$5 = internalState;
var $forEach$1 = arrayIteration.forEach;
var HIDDEN = sharedKey$1("hidden");
var SYMBOL = "Symbol";
var PROTOTYPE = "prototype";
var setInternalState$5 = InternalStateModule$5.set;
var getInternalState$2 = InternalStateModule$5.getterFor(SYMBOL);
var ObjectPrototype$1 = Object[PROTOTYPE];
var $Symbol = globalThis$l.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var RangeError$1 = globalThis$l.RangeError;
var TypeError$4 = globalThis$l.TypeError;
var QObject = globalThis$l.QObject;
var nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$2.f;
var nativeDefineProperty = definePropertyModule$1.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule$1.f;
var push$c = uncurryThis$j([].push);
var AllSymbols = shared$3("symbols");
var ObjectPrototypeSymbols = shared$3("op-symbols");
var WellKnownSymbolsStore$1 = shared$3("wks");
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
var fallbackDefineProperty = function(e, t, i) {
  var r = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, t);
  r && delete ObjectPrototype$1[t], nativeDefineProperty(e, t, i), r && e !== ObjectPrototype$1 && nativeDefineProperty(ObjectPrototype$1, t, r);
};
var setSymbolDescriptor = DESCRIPTORS$b && fails$h(function() {
  return 7 !== nativeObjectCreate(nativeDefineProperty({}, "a", { get: function() {
    return nativeDefineProperty(this, "a", { value: 7 }).a;
  } })).a;
}) ? fallbackDefineProperty : nativeDefineProperty;
var wrap = function(e, t) {
  var i = AllSymbols[e] = nativeObjectCreate(SymbolPrototype);
  return setInternalState$5(i, { type: SYMBOL, tag: e, description: t }), DESCRIPTORS$b || (i.description = t), i;
};
var $defineProperty = function(e, t, i) {
  e === ObjectPrototype$1 && $defineProperty(ObjectPrototypeSymbols, t, i), anObject$9(e);
  var r = toPropertyKey$1(t);
  return anObject$9(i), hasOwn$a(AllSymbols, r) ? (i.enumerable ? (hasOwn$a(e, HIDDEN) && e[HIDDEN][r] && (e[HIDDEN][r] = false), i = nativeObjectCreate(i, { enumerable: createPropertyDescriptor$4(0, false) })) : (hasOwn$a(e, HIDDEN) || nativeDefineProperty(e, HIDDEN, createPropertyDescriptor$4(1, nativeObjectCreate(null))), e[HIDDEN][r] = true), setSymbolDescriptor(e, r, i)) : nativeDefineProperty(e, r, i);
};
var $defineProperties = function(e, t) {
  anObject$9(e);
  var i = toIndexedObject$3(t), r = objectKeys$1(i).concat($getOwnPropertySymbols(i));
  return $forEach$1(r, function(t2) {
    DESCRIPTORS$b && !call$f($propertyIsEnumerable, i, t2) || $defineProperty(e, t2, i[t2]);
  }), e;
};
var $create = function(e, t) {
  return void 0 === t ? nativeObjectCreate(e) : $defineProperties(nativeObjectCreate(e), t);
};
var $propertyIsEnumerable = function(e) {
  var t = toPropertyKey$1(e), i = call$f(nativePropertyIsEnumerable, this, t);
  return !(this === ObjectPrototype$1 && hasOwn$a(AllSymbols, t) && !hasOwn$a(ObjectPrototypeSymbols, t)) && (!(i || !hasOwn$a(this, t) || !hasOwn$a(AllSymbols, t) || hasOwn$a(this, HIDDEN) && this[HIDDEN][t]) || i);
};
var $getOwnPropertyDescriptor = function(e, t) {
  var i = toIndexedObject$3(e), r = toPropertyKey$1(t);
  if (i !== ObjectPrototype$1 || !hasOwn$a(AllSymbols, r) || hasOwn$a(ObjectPrototypeSymbols, r)) {
    var o = nativeGetOwnPropertyDescriptor$1(i, r);
    return !o || !hasOwn$a(AllSymbols, r) || hasOwn$a(i, HIDDEN) && i[HIDDEN][r] || (o.enumerable = true), o;
  }
};
var $getOwnPropertyNames = function(e) {
  var t = nativeGetOwnPropertyNames(toIndexedObject$3(e)), i = [];
  return $forEach$1(t, function(e2) {
    hasOwn$a(AllSymbols, e2) || hasOwn$a(hiddenKeys, e2) || push$c(i, e2);
  }), i;
};
var $getOwnPropertySymbols = function(e) {
  var t = e === ObjectPrototype$1, i = nativeGetOwnPropertyNames(t ? ObjectPrototypeSymbols : toIndexedObject$3(e)), r = [];
  return $forEach$1(i, function(e2) {
    !hasOwn$a(AllSymbols, e2) || t && !hasOwn$a(ObjectPrototype$1, e2) || push$c(r, AllSymbols[e2]);
  }), r;
};
NATIVE_SYMBOL$3 || (defineBuiltIn$6(SymbolPrototype = ($Symbol = function() {
  if (isPrototypeOf$e(SymbolPrototype, this)) throw new TypeError$4("Symbol is not a constructor");
  var e = arguments.length && void 0 !== arguments[0] ? $toString$2(arguments[0]) : void 0, t = uid(e), i = function(e2) {
    var r = void 0 === this ? globalThis$l : this;
    r === ObjectPrototype$1 && call$f(i, ObjectPrototypeSymbols, e2), hasOwn$a(r, HIDDEN) && hasOwn$a(r[HIDDEN], t) && (r[HIDDEN][t] = false);
    var o = createPropertyDescriptor$4(1, e2);
    try {
      setSymbolDescriptor(r, t, o);
    } catch (e3) {
      if (!(e3 instanceof RangeError$1)) throw e3;
      fallbackDefineProperty(r, t, o);
    }
  };
  return DESCRIPTORS$b && USE_SETTER && setSymbolDescriptor(ObjectPrototype$1, t, { configurable: true, set: i }), wrap(t, e);
})[PROTOTYPE], "toString", function() {
  return getInternalState$2(this).tag;
}), defineBuiltIn$6($Symbol, "withoutSetter", function(e) {
  return wrap(uid(e), e);
}), propertyIsEnumerableModule$1.f = $propertyIsEnumerable, definePropertyModule$1.f = $defineProperty, definePropertiesModule.f = $defineProperties, getOwnPropertyDescriptorModule$2.f = $getOwnPropertyDescriptor, getOwnPropertyNamesModule$1.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames, getOwnPropertySymbolsModule$3.f = $getOwnPropertySymbols, wrappedWellKnownSymbolModule.f = function(e) {
  return wrap(wellKnownSymbol$g(e), e);
}, DESCRIPTORS$b && defineBuiltInAccessor$3(SymbolPrototype, "description", { configurable: true, get: function() {
  return getInternalState$2(this).description;
} })), $$G({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL$3, sham: !NATIVE_SYMBOL$3 }, { Symbol: $Symbol }), $forEach$1(objectKeys$1(WellKnownSymbolsStore$1), function(e) {
  defineWellKnownSymbol$m(e);
}), $$G({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL$3 }, { useSetter: function() {
  USE_SETTER = true;
}, useSimple: function() {
  USE_SETTER = false;
} }), $$G({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$3, sham: !DESCRIPTORS$b }, { create: $create, defineProperty: $defineProperty, defineProperties: $defineProperties, getOwnPropertyDescriptor: $getOwnPropertyDescriptor }), $$G({ target: "Object", stat: true, forced: !NATIVE_SYMBOL$3 }, { getOwnPropertyNames: $getOwnPropertyNames }), defineSymbolToPrimitive$1(), setToStringTag$8($Symbol, SYMBOL), hiddenKeys[HIDDEN] = true;
var NATIVE_SYMBOL$2 = symbolConstructorDetection;
var symbolRegistryDetection = NATIVE_SYMBOL$2 && !!Symbol.for && !!Symbol.keyFor;
var $$F = _export;
var getBuiltIn$c = getBuiltIn$h;
var hasOwn$9 = hasOwnProperty_1;
var toString$c = toString$e;
var shared$2 = shared$7;
var NATIVE_SYMBOL_REGISTRY$1 = symbolRegistryDetection;
var StringToSymbolRegistry = shared$2("string-to-symbol-registry");
var SymbolToStringRegistry$1 = shared$2("symbol-to-string-registry");
$$F({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY$1 }, { for: function(e) {
  var t = toString$c(e);
  if (hasOwn$9(StringToSymbolRegistry, t)) return StringToSymbolRegistry[t];
  var i = getBuiltIn$c("Symbol")(t);
  return StringToSymbolRegistry[t] = i, SymbolToStringRegistry$1[i] = t, i;
} });
var $$E = _export;
var hasOwn$8 = hasOwnProperty_1;
var isSymbol$2 = isSymbol$5;
var tryToString$4 = tryToString$6;
var shared$1 = shared$7;
var NATIVE_SYMBOL_REGISTRY = symbolRegistryDetection;
var SymbolToStringRegistry = shared$1("symbol-to-string-registry");
$$E({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, { keyFor: function(e) {
  if (!isSymbol$2(e)) throw new TypeError(tryToString$4(e) + " is not a symbol");
  if (hasOwn$8(SymbolToStringRegistry, e)) return SymbolToStringRegistry[e];
} });
var uncurryThis$i = functionUncurryThis;
var isArray$3 = isArray$6;
var isCallable$9 = isCallable$l;
var classof$5 = classofRaw$2;
var toString$b = toString$e;
var push$b = uncurryThis$i([].push);
var getJsonReplacerFunction = function(e) {
  if (isCallable$9(e)) return e;
  if (isArray$3(e)) {
    for (var t = e.length, i = [], r = 0; r < t; r++) {
      var o = e[r];
      "string" == typeof o ? push$b(i, o) : "number" != typeof o && "Number" !== classof$5(o) && "String" !== classof$5(o) || push$b(i, toString$b(o));
    }
    var n = i.length, s = true;
    return function(e2, t2) {
      if (s) return s = false, t2;
      if (isArray$3(this)) return t2;
      for (var r2 = 0; r2 < n; r2++) if (i[r2] === e2) return t2;
    };
  }
};
var $$D = _export;
var getBuiltIn$b = getBuiltIn$h;
var apply$2 = functionApply;
var call$e = functionCall;
var uncurryThis$h = functionUncurryThis;
var fails$g = fails$s;
var isCallable$8 = isCallable$l;
var isSymbol$1 = isSymbol$5;
var arraySlice$3 = arraySlice$5;
var getReplacerFunction = getJsonReplacerFunction;
var NATIVE_SYMBOL$1 = symbolConstructorDetection;
var $String$1 = String;
var $stringify = getBuiltIn$b("JSON", "stringify");
var exec$3 = uncurryThis$h(/./.exec);
var charAt$5 = uncurryThis$h("".charAt);
var charCodeAt$2 = uncurryThis$h("".charCodeAt);
var replace$7 = uncurryThis$h("".replace);
var numberToString$1 = uncurryThis$h(1 .toString);
var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;
var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL$1 || fails$g(function() {
  var e = getBuiltIn$b("Symbol")("stringify detection");
  return "[null]" !== $stringify([e]) || "{}" !== $stringify({ a: e }) || "{}" !== $stringify(Object(e));
});
var ILL_FORMED_UNICODE = fails$g(function() {
  return '"\\udf06\\ud834"' !== $stringify("\uDF06\uD834") || '"\\udead"' !== $stringify("\uDEAD");
});
var stringifyWithSymbolsFix = function(e, t) {
  var i = arraySlice$3(arguments), r = getReplacerFunction(t);
  if (isCallable$8(r) || void 0 !== e && !isSymbol$1(e)) return i[1] = function(e2, t2) {
    if (isCallable$8(r) && (t2 = call$e(r, this, $String$1(e2), t2)), !isSymbol$1(t2)) return t2;
  }, apply$2($stringify, null, i);
};
var fixIllFormed = function(e, t, i) {
  var r = charAt$5(i, t - 1), o = charAt$5(i, t + 1);
  return exec$3(low, e) && !exec$3(hi, o) || exec$3(hi, e) && !exec$3(low, r) ? "\\u" + numberToString$1(charCodeAt$2(e, 0), 16) : e;
};
$stringify && $$D({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, { stringify: function(e, t, i) {
  var r = arraySlice$3(arguments), o = apply$2(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, r);
  return ILL_FORMED_UNICODE && "string" == typeof o ? replace$7(o, tester, fixIllFormed) : o;
} });
var $$C = _export;
var NATIVE_SYMBOL = symbolConstructorDetection;
var fails$f = fails$s;
var getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;
var toObject$8 = toObject$c;
var FORCED$4 = !NATIVE_SYMBOL || fails$f(function() {
  getOwnPropertySymbolsModule$2.f(1);
});
$$C({ target: "Object", stat: true, forced: FORCED$4 }, { getOwnPropertySymbols: function(e) {
  var t = getOwnPropertySymbolsModule$2.f;
  return t ? t(toObject$8(e)) : [];
} });
var defineWellKnownSymbol$l = wellKnownSymbolDefine;
defineWellKnownSymbol$l("asyncIterator");
var defineWellKnownSymbol$k = wellKnownSymbolDefine;
defineWellKnownSymbol$k("hasInstance");
var defineWellKnownSymbol$j = wellKnownSymbolDefine;
defineWellKnownSymbol$j("isConcatSpreadable");
var defineWellKnownSymbol$i = wellKnownSymbolDefine;
defineWellKnownSymbol$i("iterator");
var defineWellKnownSymbol$h = wellKnownSymbolDefine;
defineWellKnownSymbol$h("match");
var defineWellKnownSymbol$g = wellKnownSymbolDefine;
defineWellKnownSymbol$g("matchAll");
var defineWellKnownSymbol$f = wellKnownSymbolDefine;
defineWellKnownSymbol$f("replace");
var defineWellKnownSymbol$e = wellKnownSymbolDefine;
defineWellKnownSymbol$e("search");
var defineWellKnownSymbol$d = wellKnownSymbolDefine;
defineWellKnownSymbol$d("species");
var defineWellKnownSymbol$c = wellKnownSymbolDefine;
defineWellKnownSymbol$c("split");
var defineWellKnownSymbol$b = wellKnownSymbolDefine;
var defineSymbolToPrimitive = symbolDefineToPrimitive;
defineWellKnownSymbol$b("toPrimitive"), defineSymbolToPrimitive();
var getBuiltIn$a = getBuiltIn$h;
var defineWellKnownSymbol$a = wellKnownSymbolDefine;
var setToStringTag$7 = setToStringTag$9;
defineWellKnownSymbol$a("toStringTag"), setToStringTag$7(getBuiltIn$a("Symbol"), "Symbol");
var defineWellKnownSymbol$9 = wellKnownSymbolDefine;
defineWellKnownSymbol$9("unscopables");
var globalThis$k = globalThis_1;
var setToStringTag$6 = setToStringTag$9;
setToStringTag$6(globalThis$k.JSON, "JSON", true);
var IteratorPrototype$1;
var PrototypeOfArrayIteratorPrototype;
var arrayIterator;
var path$9 = path$e;
var symbol$4 = path$9.Symbol;
var iterators = {};
var DESCRIPTORS$a = descriptors;
var hasOwn$7 = hasOwnProperty_1;
var FunctionPrototype$1 = Function.prototype;
var getDescriptor = DESCRIPTORS$a && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$7(FunctionPrototype$1, "name");
var PROPER = EXISTS && "something" === (function() {
}).name;
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$a || DESCRIPTORS$a && getDescriptor(FunctionPrototype$1, "name").configurable);
var functionName = { EXISTS, PROPER, CONFIGURABLE };
var fails$e = fails$s;
var correctPrototypeGetter = !fails$e(function() {
  function e() {
  }
  return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;
});
var hasOwn$6 = hasOwnProperty_1;
var isCallable$7 = isCallable$l;
var toObject$7 = toObject$c;
var sharedKey = sharedKey$4;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var IE_PROTO = sharedKey("IE_PROTO");
var $Object = Object;
var ObjectPrototype = $Object.prototype;
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(e) {
  var t = toObject$7(e);
  if (hasOwn$6(t, IE_PROTO)) return t[IE_PROTO];
  var i = t.constructor;
  return isCallable$7(i) && t instanceof i ? i.prototype : t instanceof $Object ? ObjectPrototype : null;
};
var fails$d = fails$s;
var isCallable$6 = isCallable$l;
var isObject$8 = isObject$g;
var create$3 = objectCreate;
var getPrototypeOf$2 = objectGetPrototypeOf;
var defineBuiltIn$5 = defineBuiltIn$8;
var wellKnownSymbol$f = wellKnownSymbol$q;
var ITERATOR$6 = wellKnownSymbol$f("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
[].keys && ("next" in (arrayIterator = [].keys()) ? (PrototypeOfArrayIteratorPrototype = getPrototypeOf$2(getPrototypeOf$2(arrayIterator))) !== Object.prototype && (IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype) : BUGGY_SAFARI_ITERATORS$1 = true);
var NEW_ITERATOR_PROTOTYPE = !isObject$8(IteratorPrototype$1) || fails$d(function() {
  var e = {};
  return IteratorPrototype$1[ITERATOR$6].call(e) !== e;
});
isCallable$6((IteratorPrototype$1 = NEW_ITERATOR_PROTOTYPE ? {} : create$3(IteratorPrototype$1))[ITERATOR$6]) || defineBuiltIn$5(IteratorPrototype$1, ITERATOR$6, function() {
  return this;
});
var iteratorsCore = { IteratorPrototype: IteratorPrototype$1, BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1 };
var IteratorPrototype = iteratorsCore.IteratorPrototype;
var create$2 = objectCreate;
var createPropertyDescriptor$3 = createPropertyDescriptor$8;
var setToStringTag$5 = setToStringTag$9;
var Iterators$5 = iterators;
var returnThis$1 = function() {
  return this;
};
var iteratorCreateConstructor = function(e, t, i, r) {
  var o = t + " Iterator";
  return e.prototype = create$2(IteratorPrototype, { next: createPropertyDescriptor$3(+!r, i) }), setToStringTag$5(e, o, false, true), Iterators$5[o] = returnThis$1, e;
};
var uncurryThis$g = functionUncurryThis;
var aCallable$9 = aCallable$c;
var functionUncurryThisAccessor = function(e, t, i) {
  try {
    return uncurryThis$g(aCallable$9(Object.getOwnPropertyDescriptor(e, t)[i]));
  } catch (e2) {
  }
};
var isObject$7 = isObject$g;
var isPossiblePrototype$1 = function(e) {
  return isObject$7(e) || null === e;
};
var isPossiblePrototype = isPossiblePrototype$1;
var $String = String;
var $TypeError$a = TypeError;
var aPossiblePrototype$1 = function(e) {
  if (isPossiblePrototype(e)) return e;
  throw new $TypeError$a("Can't set " + $String(e) + " as a prototype");
};
var uncurryThisAccessor = functionUncurryThisAccessor;
var isObject$6 = isObject$g;
var requireObjectCoercible$4 = requireObjectCoercible$7;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var e, t = false, i = {};
  try {
    (e = uncurryThisAccessor(Object.prototype, "__proto__", "set"))(i, []), t = i instanceof Array;
  } catch (e2) {
  }
  return function(i2, r) {
    return requireObjectCoercible$4(i2), aPossiblePrototype(r), isObject$6(i2) ? (t ? e(i2, r) : i2.__proto__ = r, i2) : i2;
  };
}() : void 0);
var $$B = _export;
var call$d = functionCall;
var FunctionName = functionName;
var createIteratorConstructor$1 = iteratorCreateConstructor;
var getPrototypeOf$1 = objectGetPrototypeOf;
var setToStringTag$4 = setToStringTag$9;
var defineBuiltIn$4 = defineBuiltIn$8;
var wellKnownSymbol$e = wellKnownSymbol$q;
var Iterators$4 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;
FunctionName.CONFIGURABLE, IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$5 = wellKnownSymbol$e("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var iteratorDefine = function(e, t, i, r, o, n, s) {
  createIteratorConstructor$1(i, t, r);
  var a, d, c2, l = function(e2) {
    if (e2 === o && m) return m;
    if (!BUGGY_SAFARI_ITERATORS && e2 && e2 in _) return _[e2];
    switch (e2) {
      case KEYS:
      case VALUES:
      case ENTRIES:
        return function() {
          return new i(this, e2);
        };
    }
    return function() {
      return new i(this);
    };
  }, u = t + " Iterator", h = false, _ = e.prototype, p = _[ITERATOR$5] || _["@@iterator"] || o && _[o], m = !BUGGY_SAFARI_ITERATORS && p || l(o), S = "Array" === t && _.entries || p;
  if (S && (a = getPrototypeOf$1(S.call(new e()))) !== Object.prototype && a.next && (setToStringTag$4(a, u, true, true), Iterators$4[u] = returnThis), PROPER_FUNCTION_NAME$1 && o === VALUES && p && p.name !== VALUES && (h = true, m = function() {
    return call$d(p, this);
  }), o) if (d = { values: l(VALUES), keys: n ? m : l(KEYS), entries: l(ENTRIES) }, s) for (c2 in d) (BUGGY_SAFARI_ITERATORS || h || !(c2 in _)) && defineBuiltIn$4(_, c2, d[c2]);
  else $$B({ target: t, proto: true, forced: BUGGY_SAFARI_ITERATORS || h }, d);
  return s && _[ITERATOR$5] !== m && defineBuiltIn$4(_, ITERATOR$5, m, { name: o }), Iterators$4[t] = m, d;
};
var createIterResultObject$3 = function(e, t) {
  return { value: e, done: t };
};
var toIndexedObject$2 = toIndexedObject$9;
var Iterators$3 = iterators;
var InternalStateModule$4 = internalState;
objectDefineProperty.f;
var defineIterator$1 = iteratorDefine;
var createIterResultObject$2 = createIterResultObject$3;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState$4 = InternalStateModule$4.set;
var getInternalState$1 = InternalStateModule$4.getterFor(ARRAY_ITERATOR);
defineIterator$1(Array, "Array", function(e, t) {
  setInternalState$4(this, { type: ARRAY_ITERATOR, target: toIndexedObject$2(e), index: 0, kind: t });
}, function() {
  var e = getInternalState$1(this), t = e.target, i = e.index++;
  if (!t || i >= t.length) return e.target = null, createIterResultObject$2(void 0, true);
  switch (e.kind) {
    case "keys":
      return createIterResultObject$2(i, false);
    case "values":
      return createIterResultObject$2(t[i], false);
  }
  return createIterResultObject$2([i, t[i]], false);
}, "values"), Iterators$3.Arguments = Iterators$3.Array;
var domIterables = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
var DOMIterables$1 = domIterables;
var globalThis$j = globalThis_1;
var setToStringTag$3 = setToStringTag$9;
var Iterators$2 = iterators;
for (COLLECTION_NAME in DOMIterables$1) setToStringTag$3(globalThis$j[COLLECTION_NAME], COLLECTION_NAME), Iterators$2[COLLECTION_NAME] = Iterators$2.Array;
var COLLECTION_NAME;
var parent$14 = symbol$4;
var symbol$3 = parent$14;
var wellKnownSymbol$d = wellKnownSymbol$q;
var defineProperty$1 = objectDefineProperty.f;
var METADATA = wellKnownSymbol$d("metadata");
var FunctionPrototype = Function.prototype;
void 0 === FunctionPrototype[METADATA] && defineProperty$1(FunctionPrototype, METADATA, { value: null });
var defineWellKnownSymbol$8 = wellKnownSymbolDefine;
defineWellKnownSymbol$8("asyncDispose");
var defineWellKnownSymbol$7 = wellKnownSymbolDefine;
defineWellKnownSymbol$7("dispose");
var defineWellKnownSymbol$6 = wellKnownSymbolDefine;
defineWellKnownSymbol$6("metadata");
var parent$13 = symbol$3;
var symbol$2 = parent$13;
var getBuiltIn$9 = getBuiltIn$h;
var uncurryThis$f = functionUncurryThis;
var Symbol$2 = getBuiltIn$9("Symbol");
var keyFor2 = Symbol$2.keyFor;
var thisSymbolValue$1 = uncurryThis$f(Symbol$2.prototype.valueOf);
var symbolIsRegistered = Symbol$2.isRegisteredSymbol || function(e) {
  try {
    return void 0 !== keyFor2(thisSymbolValue$1(e));
  } catch (e2) {
    return false;
  }
};
var $$A = _export;
var isRegisteredSymbol$1 = symbolIsRegistered;
$$A({ target: "Symbol", stat: true }, { isRegisteredSymbol: isRegisteredSymbol$1 });
for (shared = shared$7, getBuiltIn$8 = getBuiltIn$h, uncurryThis$e = functionUncurryThis, isSymbol = isSymbol$5, wellKnownSymbol$c = wellKnownSymbol$q, Symbol$1 = getBuiltIn$8("Symbol"), $isWellKnownSymbol = Symbol$1.isWellKnownSymbol, getOwnPropertyNames4 = getBuiltIn$8("Object", "getOwnPropertyNames"), thisSymbolValue = uncurryThis$e(Symbol$1.prototype.valueOf), WellKnownSymbolsStore = shared("wks"), i$1 = 0, symbolKeys = getOwnPropertyNames4(Symbol$1), symbolKeysLength = symbolKeys.length; i$1 < symbolKeysLength; i$1++) try {
  symbolKey = symbolKeys[i$1];
  isSymbol(Symbol$1[symbolKey]) && wellKnownSymbol$c(symbolKey);
} catch (e) {
}
var symbolKey;
var shared;
var getBuiltIn$8;
var uncurryThis$e;
var isSymbol;
var wellKnownSymbol$c;
var Symbol$1;
var $isWellKnownSymbol;
var getOwnPropertyNames4;
var thisSymbolValue;
var WellKnownSymbolsStore;
var i$1;
var symbolKeys;
var symbolKeysLength;
var symbolIsWellKnown = function(e) {
  if ($isWellKnownSymbol && $isWellKnownSymbol(e)) return true;
  try {
    for (var t = thisSymbolValue(e), i = 0, r = getOwnPropertyNames4(WellKnownSymbolsStore), o = r.length; i < o; i++) if (WellKnownSymbolsStore[r[i]] == t) return true;
  } catch (e2) {
  }
  return false;
};
var $$z = _export;
var isWellKnownSymbol$1 = symbolIsWellKnown;
$$z({ target: "Symbol", stat: true, forced: true }, { isWellKnownSymbol: isWellKnownSymbol$1 });
var defineWellKnownSymbol$5 = wellKnownSymbolDefine;
defineWellKnownSymbol$5("customMatcher");
var defineWellKnownSymbol$4 = wellKnownSymbolDefine;
defineWellKnownSymbol$4("observable");
var $$y = _export;
var isRegisteredSymbol2 = symbolIsRegistered;
$$y({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, { isRegistered: isRegisteredSymbol2 });
var $$x = _export;
var isWellKnownSymbol2 = symbolIsWellKnown;
$$x({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, { isWellKnown: isWellKnownSymbol2 });
var defineWellKnownSymbol$3 = wellKnownSymbolDefine;
defineWellKnownSymbol$3("matcher");
var defineWellKnownSymbol$2 = wellKnownSymbolDefine;
defineWellKnownSymbol$2("metadataKey");
var defineWellKnownSymbol$1 = wellKnownSymbolDefine;
defineWellKnownSymbol$1("patternMatch");
var defineWellKnownSymbol = wellKnownSymbolDefine;
defineWellKnownSymbol("replaceAll");
var parent$12 = symbol$2;
var symbol$1 = parent$12;
var symbol = symbol$1;
var _Symbol = getDefaultExportFromCjs(symbol);
var uncurryThis$d = functionUncurryThis;
var toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
var toString$a = toString$e;
var requireObjectCoercible$3 = requireObjectCoercible$7;
var charAt$4 = uncurryThis$d("".charAt);
var charCodeAt$1 = uncurryThis$d("".charCodeAt);
var stringSlice$4 = uncurryThis$d("".slice);
var createMethod$1 = function(e) {
  return function(t, i) {
    var r, o, n = toString$a(requireObjectCoercible$3(t)), s = toIntegerOrInfinity$1(i), a = n.length;
    return s < 0 || s >= a ? e ? "" : void 0 : (r = charCodeAt$1(n, s)) < 55296 || r > 56319 || s + 1 === a || (o = charCodeAt$1(n, s + 1)) < 56320 || o > 57343 ? e ? charAt$4(n, s) : r : e ? stringSlice$4(n, s, s + 2) : o - 56320 + (r - 55296 << 10) + 65536;
  };
};
var stringMultibyte = { codeAt: createMethod$1(false), charAt: createMethod$1(true) };
var charAt$3 = stringMultibyte.charAt;
var toString$9 = toString$e;
var InternalStateModule$3 = internalState;
var defineIterator = iteratorDefine;
var createIterResultObject$1 = createIterResultObject$3;
var STRING_ITERATOR = "String Iterator";
var setInternalState$3 = InternalStateModule$3.set;
var getInternalState = InternalStateModule$3.getterFor(STRING_ITERATOR);
defineIterator(String, "String", function(e) {
  setInternalState$3(this, { type: STRING_ITERATOR, string: toString$9(e), index: 0 });
}, function() {
  var e, t = getInternalState(this), i = t.string, r = t.index;
  return r >= i.length ? createIterResultObject$1(void 0, true) : (e = charAt$3(i, r), t.index += e.length, createIterResultObject$1(e, false));
});
var WrappedWellKnownSymbolModule$2 = wellKnownSymbolWrapped;
var iterator$4 = WrappedWellKnownSymbolModule$2.f("iterator");
var parent$11 = iterator$4;
var iterator$3 = parent$11;
var parent$10 = iterator$3;
var iterator$2 = parent$10;
var parent$$ = iterator$2;
var iterator$1 = parent$$;
var iterator = iterator$1;
var _Symbol$iterator = getDefaultExportFromCjs(iterator);
function _typeof(e) {
  return (_typeof = "function" == typeof _Symbol && "symbol" == typeof _Symbol$iterator ? function(e2) {
    return typeof e2;
  } : function(e2) {
    return e2 && "function" == typeof _Symbol && e2.constructor === _Symbol && e2 !== _Symbol.prototype ? "symbol" : typeof e2;
  })(e);
}
var WrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;
var toPrimitive$5 = WrappedWellKnownSymbolModule$1.f("toPrimitive");
var parent$_ = toPrimitive$5;
var toPrimitive$4 = parent$_;
var parent$Z = toPrimitive$4;
var toPrimitive$3 = parent$Z;
var parent$Y = toPrimitive$3;
var toPrimitive$2 = parent$Y;
var toPrimitive$1 = toPrimitive$2;
var _Symbol$toPrimitive = getDefaultExportFromCjs(toPrimitive$1);
function toPrimitive(e, t) {
  if ("object" != _typeof(e) || !e) return e;
  var i = e[_Symbol$toPrimitive];
  if (void 0 !== i) {
    var r = i.call(e, t || "default");
    if ("object" != _typeof(r)) return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === t ? String : Number)(e);
}
function toPropertyKey(e) {
  var t = toPrimitive(e, "string");
  return "symbol" == _typeof(t) ? t : t + "";
}
function _defineProperty(e, t, i) {
  return (t = toPropertyKey(t)) in e ? _Object$defineProperty(e, t, { value: i, enumerable: true, configurable: true, writable: true }) : e[t] = i, e;
}
var $$w = _export;
var uncurryThis$c = functionUncurryThis;
var isArray$2 = isArray$6;
var nativeReverse = uncurryThis$c([].reverse);
var test$1 = [1, 2];
$$w({ target: "Array", proto: true, forced: String(test$1) === String(test$1.reverse()) }, { reverse: function() {
  return isArray$2(this) && (this.length = this.length), nativeReverse(this);
} });
var globalThis$i = globalThis_1;
var path$8 = path$e;
var getBuiltInPrototypeMethod$a = function(e, t) {
  var i = path$8[e + "Prototype"], r = i && i[t];
  if (r) return r;
  var o = globalThis$i[e], n = o && o.prototype;
  return n && n[t];
};
var getBuiltInPrototypeMethod$9 = getBuiltInPrototypeMethod$a;
var reverse$6 = getBuiltInPrototypeMethod$9("Array", "reverse");
var isPrototypeOf$d = objectIsPrototypeOf;
var method$7 = reverse$6;
var ArrayPrototype$7 = Array.prototype;
var reverse$5 = function(e) {
  var t = e.reverse;
  return e === ArrayPrototype$7 || isPrototypeOf$d(ArrayPrototype$7, e) && t === ArrayPrototype$7.reverse ? method$7 : t;
};
var parent$X = reverse$5;
var reverse$4 = parent$X;
var parent$W = reverse$4;
var reverse$3 = parent$W;
var parent$V = reverse$3;
var reverse$2 = parent$V;
var reverse$1 = reverse$2;
var reverse2 = reverse$1;
var _reverseInstanceProperty = getDefaultExportFromCjs(reverse2);
var isObject$5 = isObject$g;
var classof$4 = classofRaw$2;
var wellKnownSymbol$b = wellKnownSymbol$q;
var MATCH$2 = wellKnownSymbol$b("match");
var isRegexp = function(e) {
  var t;
  return isObject$5(e) && (void 0 !== (t = e[MATCH$2]) ? !!t : "RegExp" === classof$4(e));
};
var anObject$8 = anObject$d;
var regexpFlags = function() {
  var e = anObject$8(this), t = "";
  return e.hasIndices && (t += "d"), e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.unicodeSets && (t += "v"), e.sticky && (t += "y"), t;
};
var call$c = functionCall;
var hasOwn$5 = hasOwnProperty_1;
var isPrototypeOf$c = objectIsPrototypeOf;
var regExpFlags = regexpFlags;
var RegExpPrototype$1 = RegExp.prototype;
var regexpGetFlags = function(e) {
  var t = e.flags;
  return void 0 !== t || "flags" in RegExpPrototype$1 || hasOwn$5(e, "flags") || !isPrototypeOf$c(RegExpPrototype$1, e) ? t : call$c(regExpFlags, e);
};
var uncurryThis$b = functionUncurryThis;
var toObject$6 = toObject$c;
var floor$3 = Math.floor;
var charAt$2 = uncurryThis$b("".charAt);
var replace$6 = uncurryThis$b("".replace);
var stringSlice$3 = uncurryThis$b("".slice);
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
var getSubstitution$1 = function(e, t, i, r, o, n) {
  var s = i + e.length, a = r.length, d = SUBSTITUTION_SYMBOLS_NO_NAMED;
  return void 0 !== o && (o = toObject$6(o), d = SUBSTITUTION_SYMBOLS), replace$6(n, d, function(n2, d2) {
    var c2;
    switch (charAt$2(d2, 0)) {
      case "$":
        return "$";
      case "&":
        return e;
      case "`":
        return stringSlice$3(t, 0, i);
      case "'":
        return stringSlice$3(t, s);
      case "<":
        c2 = o[stringSlice$3(d2, 1, -1)];
        break;
      default:
        var l = +d2;
        if (0 === l) return n2;
        if (l > a) {
          var u = floor$3(l / 10);
          return 0 === u ? n2 : u <= a ? void 0 === r[u - 1] ? charAt$2(d2, 1) : r[u - 1] + charAt$2(d2, 1) : n2;
        }
        c2 = r[l - 1];
    }
    return void 0 === c2 ? "" : c2;
  });
};
var $$v = _export;
var call$b = functionCall;
var uncurryThis$a = functionUncurryThis;
var requireObjectCoercible$2 = requireObjectCoercible$7;
var isCallable$5 = isCallable$l;
var isNullOrUndefined$2 = isNullOrUndefined$5;
var isRegExp$1 = isRegexp;
var toString$8 = toString$e;
var getMethod$2 = getMethod$4;
var getRegExpFlags$1 = regexpGetFlags;
var getSubstitution = getSubstitution$1;
var wellKnownSymbol$a = wellKnownSymbol$q;
var REPLACE = wellKnownSymbol$a("replace");
var $TypeError$9 = TypeError;
var indexOf = uncurryThis$a("".indexOf);
var replace$5 = uncurryThis$a("".replace);
var stringSlice$2 = uncurryThis$a("".slice);
var max = Math.max;
$$v({ target: "String", proto: true }, { replaceAll: function(e, t) {
  var i, r, o, n, s, a, d, c2, l, u, h = requireObjectCoercible$2(this), _ = 0, p = "";
  if (!isNullOrUndefined$2(e)) {
    if ((i = isRegExp$1(e)) && (r = toString$8(requireObjectCoercible$2(getRegExpFlags$1(e))), !~indexOf(r, "g"))) throw new $TypeError$9("`.replaceAll` does not allow non-global regexes");
    if (o = getMethod$2(e, REPLACE)) return call$b(o, e, h, t);
    if (i) return replace$5(toString$8(h), e, t);
  }
  for (n = toString$8(h), s = toString$8(e), (a = isCallable$5(t)) || (t = toString$8(t)), d = s.length, c2 = max(1, d), l = indexOf(n, s); -1 !== l; ) u = a ? toString$8(t(s, l, n)) : getSubstitution(s, n, l, [], void 0, t), p += stringSlice$2(n, _, l) + u, _ = l + d, l = l + c2 > n.length ? -1 : indexOf(n, s, l + c2);
  return _ < n.length && (p += stringSlice$2(n, _)), p;
} });
var getBuiltInPrototypeMethod$8 = getBuiltInPrototypeMethod$a;
var replaceAll$6 = getBuiltInPrototypeMethod$8("String", "replaceAll");
var isPrototypeOf$b = objectIsPrototypeOf;
var method$6 = replaceAll$6;
var StringPrototype$2 = String.prototype;
var replaceAll$5 = function(e) {
  var t = e.replaceAll;
  return "string" == typeof e || e === StringPrototype$2 || isPrototypeOf$b(StringPrototype$2, e) && t === StringPrototype$2.replaceAll ? method$6 : t;
};
var parent$U = replaceAll$5;
var replaceAll$4 = parent$U;
var parent$T = replaceAll$4;
var replaceAll$3 = parent$T;
var parent$S = replaceAll$3;
var replaceAll$2 = parent$S;
var replaceAll$1 = replaceAll$2;
var replaceAll2 = replaceAll$1;
var _replaceAllInstanceProperty = getDefaultExportFromCjs(replaceAll2);
var whitespaces$2 = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF";
var uncurryThis$9 = functionUncurryThis;
var requireObjectCoercible$1 = requireObjectCoercible$7;
var toString$7 = toString$e;
var whitespaces$1 = whitespaces$2;
var replace$4 = uncurryThis$9("".replace);
var ltrim = RegExp("^[" + whitespaces$1 + "]+");
var rtrim = RegExp("(^|[^" + whitespaces$1 + "])[" + whitespaces$1 + "]+$");
var createMethod = function(e) {
  return function(t) {
    var i = toString$7(requireObjectCoercible$1(t));
    return 1 & e && (i = replace$4(i, ltrim, "")), 2 & e && (i = replace$4(i, rtrim, "$1")), i;
  };
};
var stringTrim = { start: createMethod(1), end: createMethod(2), trim: createMethod(3) };
var PROPER_FUNCTION_NAME = functionName.PROPER;
var fails$c = fails$s;
var whitespaces = whitespaces$2;
var non = "âÂá ";
var stringTrimForced = function(e) {
  return fails$c(function() {
    return !!whitespaces[e]() || non[e]() !== non || PROPER_FUNCTION_NAME && whitespaces[e].name !== e;
  });
};
var $$u = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod = stringTrimForced;
$$u({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, { trim: function() {
  return $trim(this);
} });
var getRandomValues$1;
var getBuiltInPrototypeMethod$7 = getBuiltInPrototypeMethod$a;
var trim$6 = getBuiltInPrototypeMethod$7("String", "trim");
var isPrototypeOf$a = objectIsPrototypeOf;
var method$5 = trim$6;
var StringPrototype$1 = String.prototype;
var trim$5 = function(e) {
  var t = e.trim;
  return "string" == typeof e || e === StringPrototype$1 || isPrototypeOf$a(StringPrototype$1, e) && t === StringPrototype$1.trim ? method$5 : t;
};
var parent$R = trim$5;
var trim$4 = parent$R;
var parent$Q = trim$4;
var trim$3 = parent$Q;
var parent$P = trim$3;
var trim$2 = parent$P;
var trim$1 = trim$2;
var trim2 = trim$1;
var _trimInstanceProperty = getDefaultExportFromCjs(trim2);
var VideoSourceType = ((e) => (e[e.VIDEO_SOURCE_TYPE_EXTERNAL = 0] = "VIDEO_SOURCE_TYPE_EXTERNAL", e[e.VIDEO_SOURCE_TYPE_INTERNAL = 1] = "VIDEO_SOURCE_TYPE_INTERNAL", e))(VideoSourceType || {});
var AudioSourceType = ((e) => (e[e.AUDIO_SOURCE_TYPE_EXTERNAL = 0] = "AUDIO_SOURCE_TYPE_EXTERNAL", e[e.AUDIO_SOURCE_TYPE_INTERNAL = 1] = "AUDIO_SOURCE_TYPE_INTERNAL", e))(AudioSourceType || {});
var UserOfflineReason = ((e) => (e[e.QUIT = 0] = "QUIT", e[e.DROPPED = 1] = "DROPPED", e[e.SWITCH_TO_INVISIBLE = 2] = "SWITCH_TO_INVISIBLE", e[e.KICKED_BY_ADMIN = 3] = "KICKED_BY_ADMIN", e))(UserOfflineReason || {});
var UserDisconnectionTag$1 = ((e) => (e.userLeave = "userLeave", e.connectionLost = "connectionLost", e.userDuplicateLogin = "userDuplicateLogin", e.kickedByAdmin = "kickedByAdmin", e.roleChanged = "roleChanged", e.onUserTokenDidExpire = "onUserTokenDidExpire", e))(UserDisconnectionTag$1 || {});
var ChannelProfile = ((e) => (e[e.CHANNEL_PROFILE_COMMUNICATION = 0] = "CHANNEL_PROFILE_COMMUNICATION", e[e.CHANNEL_PROFILE_LIVE_BROADCASTING = 1] = "CHANNEL_PROFILE_LIVE_BROADCASTING", e))(ChannelProfile || {});
var SubscribeMode = ((e) => (e[e.AUTO_SUBSCRIBE_MODE = 0] = "AUTO_SUBSCRIBE_MODE", e[e.MANUAL_SUBSCRIBE_MODE = 1] = "MANUAL_SUBSCRIBE_MODE", e))(SubscribeMode || {});
var SubscribeState = ((e) => (e[e.SUBSCRIBE_SUCC = 0] = "SUBSCRIBE_SUCC", e[e.SUBSCRIBE_FAIL = 1] = "SUBSCRIBE_FAIL", e))(SubscribeState || {});
var PublishState = ((e) => (e[e.PUBLISH_SUCC = 0] = "PUBLISH_SUCC", e[e.PUBLISH_FAIL = 1] = "PUBLISH_FAIL", e))(PublishState || {});
var MirrorMode = ((e) => (e[e.MIRROR_MODE_OFF = 0] = "MIRROR_MODE_OFF", e[e.MIRROR_MODE_ON = 1] = "MIRROR_MODE_ON", e))(MirrorMode || {});
var VideoRenderMode = ((e) => (e[e.RENDER_MODE_HIDDEN = 0] = "RENDER_MODE_HIDDEN", e[e.RENDER_MODE_FIT = 1] = "RENDER_MODE_FIT", e[e.RENDER_MODE_FILL = 2] = "RENDER_MODE_FILL", e))(VideoRenderMode || {});
var StreamIndex$1 = ((e) => (e[e.STREAM_INDEX_MAIN = 0] = "STREAM_INDEX_MAIN", e[e.STREAM_INDEX_SCREEN = 1] = "STREAM_INDEX_SCREEN", e))(StreamIndex$1 || {});
var MediaType$1 = ((e) => (e[e.AUDIO = 1] = "AUDIO", e[e.VIDEO = 2] = "VIDEO", e[e.AUDIO_AND_VIDEO = 3] = "AUDIO_AND_VIDEO", e))(MediaType$1 || {});
var StreamRemoveReason = ((e) => (e[e.STREAM_REMOVE_REASON_UNPUBLISH = 0] = "STREAM_REMOVE_REASON_UNPUBLISH", e[e.STREAM_REMOVE_REASON_PUBLISH_FAILED = 1] = "STREAM_REMOVE_REASON_PUBLISH_FAILED", e[e.STREAM_REMOVE_REASON_KEEP_LIVE_FAILED = 2] = "STREAM_REMOVE_REASON_KEEP_LIVE_FAILED", e[e.STREAM_REMOVE_REASON_CLIENT_DISCONNECTED = 3] = "STREAM_REMOVE_REASON_CLIENT_DISCONNECTED", e[e.STREAM_REMOVE_REASON_REPUBLISH = 4] = "STREAM_REMOVE_REASON_REPUBLISH", e[e.STREAM_REMOVE_REASON_OTHER = 5] = "STREAM_REMOVE_REASON_OTHER", e[e.STREAM_REMOVE_REASON_TOKEN_PRIVILEGE_EXPIRED = 6] = "STREAM_REMOVE_REASON_TOKEN_PRIVILEGE_EXPIRED", e))(StreamRemoveReason || {});
var ConnectionState = ((e) => (e[e.CONNECTION_START = 0] = "CONNECTION_START", e[e.CONNECTION_STATE_DISCONNECTED = 1] = "CONNECTION_STATE_DISCONNECTED", e[e.CONNECTION_STATE_CONNECTING = 2] = "CONNECTION_STATE_CONNECTING", e[e.CONNECTION_STATE_CONNECTED = 3] = "CONNECTION_STATE_CONNECTED", e[e.CONNECTION_STATE_RECONNECTING = 4] = "CONNECTION_STATE_RECONNECTING", e[e.CONNECTION_STATE_RECONNECTED = 5] = "CONNECTION_STATE_RECONNECTED", e[e.CONNECTION_STATE_LOST = 6] = "CONNECTION_STATE_LOST", e))(ConnectionState || {});
var ReconnectReason = ((e) => (e.ICE_FAILED = "iceFailed", e.NODE_CHANGE = "nodeChange", e.JOIN_TIMEOUT = "joinTimeout", e.NOTIFY_RECONNECT = "notifyReconnect", e))(ReconnectReason || {});
var VideoCodecType = ((e) => (e.AUTO = "auto", e.H264 = "h264", e.VP8 = "vp8", e.ByteVC1 = "ByteVC1", e))(VideoCodecType || {});
var MirrorType = ((e) => (e[e.MIRROR_TYPE_NONE = 0] = "MIRROR_TYPE_NONE", e[e.MIRROR_TYPE_RENDER = 1] = "MIRROR_TYPE_RENDER", e))(MirrorType || {});
var LocalMainReportMode = ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.DISCONNECT = 1] = "DISCONNECT", e[e.RESET = 2] = "RESET", e))(LocalMainReportMode || {});
var AudioReportMode = ((e) => (e[e.MICROPHONE = 0] = "MICROPHONE", e[e.AUDIOMIXING = 1] = "AUDIOMIXING", e))(AudioReportMode || {});
var LogChannel = ((e) => (e[e.domestic = 0] = "domestic", e[e.overseas = 1] = "overseas", e))(LogChannel || {});
var USER_ONLINE_STATUS = ((e) => (e[e.OFFLINE = 0] = "OFFLINE", e[e.ONLINE = 1] = "ONLINE", e[e.UNREACHABLE = 2] = "UNREACHABLE", e))(USER_ONLINE_STATUS || {});
var PublicStreamType = ((e) => (e[e.AUDIO_AND_VIDEO = 0] = "AUDIO_AND_VIDEO", e[e.AUDIO_ONLY = 1] = "AUDIO_ONLY", e[e.VIDEO_ONLY = 2] = "VIDEO_ONLY", e))(PublicStreamType || {});
var PublicInterpolationMode = ((e) => (e[e.PREV_FRAME = 0] = "PREV_FRAME", e[e.OTHER_FRAME = 1] = "OTHER_FRAME", e))(PublicInterpolationMode || {});
var SubscribeFallbackOption = ((e) => (e[e.DISABLE = 0] = "DISABLE", e[e.VIDEO_STREAM_LOW = 1] = "VIDEO_STREAM_LOW", e[e.AUDIO_ONLY = 2] = "AUDIO_ONLY", e))(SubscribeFallbackOption || {});
var RemoteUserPriority = ((e) => (e[e.LOW = 0] = "LOW", e[e.MEDIUM = 100] = "MEDIUM", e[e.HIGH = 200] = "HIGH", e))(RemoteUserPriority || {});
var NetworkQuality = ((e) => (e[e.UNKNOWN = 0] = "UNKNOWN", e[e.EXCELLENT = 1] = "EXCELLENT", e[e.GOOD = 2] = "GOOD", e[e.POOR = 3] = "POOR", e[e.BAD = 4] = "BAD", e[e.VBAD = 5] = "VBAD", e[e.DOWN = 6] = "DOWN", e))(NetworkQuality || {});
var FallbackOrRecoverReason = ((e) => (e[e.Unknown = -1] = "Unknown", e[e.SubscribeFallbackByBandwidth = 0] = "SubscribeFallbackByBandwidth", e[e.SubscribeRecoverByBandwidth = 2] = "SubscribeRecoverByBandwidth", e))(FallbackOrRecoverReason || {});
var RoomProfileType = ((e) => (e[e.communication = 0] = "communication", e[e.chat = 5] = "chat", e[e.chatRoom = 6] = "chatRoom", e[e.coHost = 9] = "coHost", e[e.meeting = 16] = "meeting", e[e.classRoom = 18] = "classRoom", e))(RoomProfileType || {});
var AudioProfileType = ((e) => (e[e.default = 0] = "default", e[e.fluent = 1] = "fluent", e[e.standard = 2] = "standard", e[e.hd = 3] = "hd", e[e.standardStereo = 4] = "standardStereo", e[e.hdMono = 5] = "hdMono", e))(AudioProfileType || {});
var RTCAutoPlayPolicy = ((e) => (e[e.AUTO_PLAY = 0] = "AUTO_PLAY", e[e.VIDEO_ONLY = 1] = "VIDEO_ONLY", e[e.PLAY_MANUALLY = 2] = "PLAY_MANUALLY", e))(RTCAutoPlayPolicy || {});
var AAC_PROFILE = ((e) => (e.LC = "LC", e.HEv1 = "HEv1", e.HEv2 = "HEv2", e))(AAC_PROFILE || {});
var TRANSCODING_VIDEO_CODEC = ((e) => (e.H264 = "H264", e.H265 = "H265", e))(TRANSCODING_VIDEO_CODEC || {});
var SUBTITLE_MODE = ((e) => (e[e.ASR_ONLY = 0] = "ASR_ONLY", e[e.ASR_AND_TRANSLATION = 1] = "ASR_AND_TRANSLATION", e))(SUBTITLE_MODE || {});
var SubtitleEventType = ((e) => (e[e.STARTED = 0] = "STARTED", e[e.STOPPED = 1] = "STOPPED", e[e.ERROR = 2] = "ERROR", e[e.UPDATED = 3] = "UPDATED", e))(SubtitleEventType || {});
var ForwardStreamState = ((e) => (e[e.FORWARD_STREAM_STATE_SUCCESS = 0] = "FORWARD_STREAM_STATE_SUCCESS", e[e.FORWARD_STREAM_STATE_FAILURE = 1] = "FORWARD_STREAM_STATE_FAILURE", e))(ForwardStreamState || {});
var ForwardStreamError = ((e) => (e[e.FORWARD_STREAM_ERROR_OK = 0] = "FORWARD_STREAM_ERROR_OK", e[e.FORWARD_STREAM_ERROR_INVALID_TOKEN = 1202] = "FORWARD_STREAM_ERROR_INVALID_TOKEN", e[e.FORWARD_STREAM_ERROR_RESPONSE = 1203] = "FORWARD_STREAM_ERROR_RESPONSE", e[e.FORWARD_STREAM_ERROR_REMOTE_KICKED = 1204] = "FORWARD_STREAM_ERROR_REMOTE_KICKED", e[e.FORWARD_STREAM_ERROR_NOT_SUPPORT = 1205] = "FORWARD_STREAM_ERROR_NOT_SUPPORT", e))(ForwardStreamError || {});
var AudioSelectionPriority = ((e) => (e[e.DEFAULT = 0] = "DEFAULT", e[e.HIGH = 1] = "HIGH", e))(AudioSelectionPriority || {});
var VideoSimulcastMode = ((e) => (e[e.VIDEO_ONLY_ONE = 0] = "VIDEO_ONLY_ONE", e[e.VIDEO_ON_DEMAND = 1] = "VIDEO_ON_DEMAND", e[e.VIDEO_ALWAYS_SIMULCAST = 2] = "VIDEO_ALWAYS_SIMULCAST", e))(VideoSimulcastMode || {});
var SimulcastStreamType = ((e) => (e.VIDEO_STREAM_HIGH = "high", e.VIDEO_STREAM_MID = "mid", e.VIDEO_STREAM_LOW = "low", e))(SimulcastStreamType || {});
var EarMonitorPosition = ((e) => (e[e.NONE = 0] = "NONE", e[e.AFTER_CAPTURE = 1] = "AFTER_CAPTURE", e[e.AFTER_PROCESS = 2] = "AFTER_PROCESS", e))(EarMonitorPosition || {});
var RoomMode = ((e) => (e[e.ROOM_MODE_RTC = 0] = "ROOM_MODE_RTC", e[e.ROOM_MODE_RTS_ONLY = 1] = "ROOM_MODE_RTS_ONLY", e))(RoomMode || {});
var rnds8$1 = new Uint8Array(16);
function rng$1() {
  if (!getRandomValues$1 && !(getRandomValues$1 = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues$1(rnds8$1);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(e) {
  return "string" == typeof e && REGEX.test(e);
}
for (byteToHex$1 = [], i = 0; i < 256; ++i) byteToHex$1.push((i + 256).toString(16).substr(1));
var byteToHex$1;
var i;
function stringify(e) {
  var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i = (byteToHex$1[e[t + 0]] + byteToHex$1[e[t + 1]] + byteToHex$1[e[t + 2]] + byteToHex$1[e[t + 3]] + "-" + byteToHex$1[e[t + 4]] + byteToHex$1[e[t + 5]] + "-" + byteToHex$1[e[t + 6]] + byteToHex$1[e[t + 7]] + "-" + byteToHex$1[e[t + 8]] + byteToHex$1[e[t + 9]] + "-" + byteToHex$1[e[t + 10]] + byteToHex$1[e[t + 11]] + byteToHex$1[e[t + 12]] + byteToHex$1[e[t + 13]] + byteToHex$1[e[t + 14]] + byteToHex$1[e[t + 15]]).toLowerCase();
  if (!validate(i)) throw TypeError("Stringified UUID is invalid");
  return i;
}
function v4$1(e, t, i) {
  var r = (e = e || {}).random || (e.rng || rng$1)();
  if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
    i = i || 0;
    for (var o = 0; o < 16; ++o) t[i + o] = r[o];
    return t;
  }
  return stringify(r);
}
var isSSR$1 = () => "undefined" == typeof window;
var genUuid$1 = () => v4$1();
var assertValidMsgId = (e) => "number" == typeof e;
var isNativeFunction = (e) => Function.prototype.toString.call(e).includes("[native code]");
function mediaTrackStringify(e) {
  return null == e ? "undefined | null" : "string" == typeof e ? e : JSON.stringify({ contentHint: e.contentHint, enabled: e.enabled, id: e.id, kind: e.kind, label: e.label, muted: e.muted, readyState: e.readyState });
}
function mediaStreamStringify(e) {
  return null == e ? "undefined | null" : "string" == typeof e ? e : JSON.stringify({ id: e.id, active: e.active });
}
function mediaSenderStringify(e) {
  return null == e ? "undefined | null" : "string" == typeof e ? e : JSON.stringify({ track: mediaTrackStringify(e.track) });
}
function mediaReceiverStringify(e) {
  return null == e ? "undefined | null" : "string" == typeof e ? e : JSON.stringify({ track: mediaTrackStringify(e.track) });
}
function mediaTransceiverStringify(e) {
  return null == e ? "undefined | null" : "string" == typeof e ? e : JSON.stringify({ currentDirection: e.currentDirection, direction: e.direction, mid: e.mid, stopped: e.stopped, receiver: mediaReceiverStringify(e.receiver), sender: mediaSenderStringify(e.sender) });
}
var DB_NAME$1 = "@byted/ve-rtc";
var STORE_NAME = "@byted/ve-rtc";
var STORE_CACHED_SIZE_KEY = "@byted/ve-rtc-cache-size";
var IDB = class {
  constructor() {
    _defineProperty(this, "storeKey", void 0), _defineProperty(this, "logLevel", void 0), _defineProperty(this, "LogfileSize", void 0), _defineProperty(this, "db", void 0), _defineProperty(this, "logId", void 0), _defineProperty(this, "cacheLog", void 0), _defineProperty(this, "cachedSize", void 0), _defineProperty(this, "preCacheTime", void 0), _defineProperty(this, "timer", void 0), _defineProperty(this, "_getSize", (e) => new Blob(e).size / 1048576), this.storeKey = "", this.logId = 1, this.cacheLog = "", this.logLevel = "none", this.LogfileSize = 100, this._createStore();
  }
  _createStore() {
    if (isSSR$1() || !window.indexedDB) return;
    const e = indexedDB.open(DB_NAME$1);
    e.onupgradeneeded = () => {
      e.result.createObjectStore(STORE_NAME);
      try {
        localStorage.removeItem(STORE_CACHED_SIZE_KEY);
      } catch (e2) {
      }
    }, e.onerror = (e2) => {
    }, e.onsuccess = () => {
      this.db = e.result, this._getCachedSize();
    };
  }
  _getCachedSize() {
    try {
      const e = localStorage.getItem(STORE_CACHED_SIZE_KEY);
      e ? this.cachedSize = Number(e) : this.values().then((e2) => {
        this.cachedSize = this._getSize(e2), this._setCachedSize();
      });
    } catch (e) {
    }
  }
  _setCachedSize() {
    try {
      localStorage.setItem(STORE_CACHED_SIZE_KEY, "".concat(this.cachedSize));
    } catch (e) {
    }
  }
  _getStore(e) {
    if (this.db) return this.db.transaction(STORE_NAME, e).objectStore(STORE_NAME);
  }
  set(e) {
    return new Promise((t, i) => {
      if ("none" === this.logLevel) return t();
      if (e && this.preCacheTime && this.preCacheTime - Date.now() < 1e3) return this.cacheLog += "\n\n".concat(this.logId, ": ").concat(e), this.logId++, this.timer || (this.timer = setTimeout(() => {
        this.set("");
      }, 1e3 - (this.preCacheTime - Date.now()))), t();
      clearTimeout(this.timer), this.timer = null;
      const r = this._getStore("readwrite");
      if (!r) return i("get store fail");
      this.cachedSize && this.cachedSize > this.LogfileSize && this.keyEarliest().then((e2) => {
        this.get(e2).then((t2) => {
          this.del(e2).then(() => {
            this.cachedSize = this.cachedSize - this._getSize(["".concat(t2)]), this._setCachedSize();
          });
        });
      });
      const o = r.get(this.storeKey);
      o.onsuccess = () => {
        try {
          const i2 = "".concat(o.result || "").concat(this.cacheLog), n = e ? "".concat(i2 ? "\n\n" : "").concat(this.logId, ": ").concat(e) : "";
          r.put("".concat(i2).concat(n), this.storeKey), e && this.logId++, this.cacheLog = "", this.cachedSize = (this.cachedSize || 0) + this._getSize(["".concat(this.cacheLog).concat(n)]), this._setCachedSize(), this.preCacheTime = Date.now(), t();
        } catch (t2) {
          if (!e) return i(t2);
          this.cacheLog += "\n\n".concat(this.logId, ": ").concat(e), this.logId++, i(t2);
        }
      }, o.onerror = (t2) => {
        if (!e) return i(t2);
        this.cacheLog += "\n\n".concat(this.logId, ": ").concat(e), this.logId++, i(t2);
      };
    });
  }
  get(e) {
    return new Promise((t, i) => {
      const r = this._getStore("readonly");
      if (!r) return i();
      const o = r.get(e);
      o.onsuccess = () => {
        t(o.result);
      }, o.onerror = (e2) => {
        i(e2);
      };
    });
  }
  del() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.storeKey;
    return new Promise((t, i) => {
      const r = this._getStore("readwrite");
      if (!r) return i();
      const o = r.delete(e);
      o.onsuccess = () => t(o.result), o.onerror = (e2) => i(e2);
    });
  }
  keyEarliest() {
    return this.keys().then((e) => {
      let t, i = Date.now();
      return e.forEach((e2) => {
        if (!e2 || !e2.length) return;
        const r = e2.split("-")[0];
        Number(r) < i && (i = Number(r), t = e2);
      }), t;
    });
  }
  keys() {
    return new Promise((e, t) => {
      const i = this._getStore("readonly");
      if (!i) return t();
      if (i.getAllKeys) {
        const r2 = i.getAllKeys();
        return r2.onsuccess = () => {
          e(r2.result);
        }, void (r2.onerror = () => {
          t();
        });
      }
      const r = [];
      i.openCursor().onsuccess = function() {
        this.result && (r.push(this.result.key), this.result.continue());
      }, i.transaction.oncomplete = () => e(r);
    });
  }
  values() {
    return new Promise((e, t) => {
      const i = this._getStore("readonly");
      if (!i) return t();
      if (i.getAll) {
        const r2 = i.getAll();
        return r2.onsuccess = () => {
          e(r2.result);
        }, void (r2.onerror = () => {
          t();
        });
      }
      const r = [];
      i.openCursor().onsuccess = function() {
        this.result && (r.push(this.result.value), this.result.continue());
      }, i.transaction.oncomplete = () => e(r);
    });
  }
  download(e) {
    e = e || this.storeKey, this.get(e).then((t) => {
      const i = document.createElement("a");
      i.download = "".concat(e, ".txt"), i.href = "data:text/paint;utf-8,".concat(t || ""), i.click();
    });
  }
};
var iDB = new IDB();
var EventEmitter$1 = class {
  constructor() {
    _defineProperty(this, "_all", {});
  }
  on(e, t) {
    const i = this._all[e];
    i ? i.push(t) : this._all[e] = [t];
  }
  once(e, t) {
    var i = this;
    const r = function() {
      t(...arguments), i.off(e, r);
    };
    this.on(e, r);
  }
  off(e, t) {
    const i = this._all[e];
    null == i || i.splice(i.indexOf(t) >>> 0, 1);
  }
  emit(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    const o = this._all[e];
    null == o || o.slice().forEach((e2) => e2(...i));
  }
  safeEmit(e) {
    try {
      for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
      return this.emit(e, ...i);
    } catch (e2) {
      console.error(e2);
    }
  }
  destroy() {
    this._all = {};
  }
};
var configNumberKeys = ["UPLOAD_CONSOLE_LENGTH_CUT", "UPLOAD_REPORT_LIMIT"];
function needToNumber(e) {
  return configNumberKeys.includes(e);
}
var Config$2 = class extends EventEmitter$1 {
  constructor() {
    super(...arguments), _defineProperty(this, "config", { UPLOAD_CONSOLE_ON: false, UPLOAD_CONSOLE_LENGTH_CUT: 200, UPLOAD_REPORT_LIMIT: 45e4, ENABLE_REPORT_IDB_BUFFER: false });
  }
  setParameter(e, t) {
    if (needToNumber(e)) try {
      const i = Number(t);
      if (Number.isNaN(i)) return;
      this.config[e] = i;
    } catch (i) {
      return void console.warn("Cannot convert core lib parameter ".concat(e, ":").concat(t, " into number"));
    }
    else this.config[e] = t;
    this.emit(e, this.config[e]);
  }
  getParameter(e) {
    return this.config[e];
  }
  getKeys() {
    return Object.keys(this.config);
  }
};
var CoreConfig = new Config$2();
var $$t = _export;
var toObject$5 = toObject$c;
var nativeKeys = objectKeys$3;
var fails$b = fails$s;
var FAILS_ON_PRIMITIVES = fails$b(function() {
  nativeKeys(1);
});
$$t({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, { keys: function(e) {
  return nativeKeys(toObject$5(e));
} });
var path$7 = path$e;
var keys$4 = path$7.Object.keys;
var parent$O = keys$4;
var keys$3 = parent$O;
var parent$N = keys$3;
var keys$2 = parent$N;
var parent$M = keys$2;
var keys$1 = parent$M;
var keys3 = keys$1;
var _Object$keys = getDefaultExportFromCjs(keys3);
var path$6 = path$e;
var getOwnPropertySymbols$4 = path$6.Object.getOwnPropertySymbols;
var parent$L = getOwnPropertySymbols$4;
var getOwnPropertySymbols$3 = parent$L;
var parent$K = getOwnPropertySymbols$3;
var getOwnPropertySymbols$2 = parent$K;
var parent$J = getOwnPropertySymbols$2;
var getOwnPropertySymbols$1 = parent$J;
var getOwnPropertySymbols2 = getOwnPropertySymbols$1;
var _Object$getOwnPropertySymbols = getDefaultExportFromCjs(getOwnPropertySymbols2);
var $$s = _export;
var $filter = arrayIteration.filter;
var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$2;
var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
$$s({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, { filter: function(e) {
  return $filter(this, e, arguments.length > 1 ? arguments[1] : void 0);
} });
var getBuiltInPrototypeMethod$6 = getBuiltInPrototypeMethod$a;
var filter$5 = getBuiltInPrototypeMethod$6("Array", "filter");
var isPrototypeOf$9 = objectIsPrototypeOf;
var method$4 = filter$5;
var ArrayPrototype$6 = Array.prototype;
var filter$4 = function(e) {
  var t = e.filter;
  return e === ArrayPrototype$6 || isPrototypeOf$9(ArrayPrototype$6, e) && t === ArrayPrototype$6.filter ? method$4 : t;
};
var parent$I = filter$4;
var filter$3 = parent$I;
var parent$H = filter$3;
var filter$2 = parent$H;
var parent$G = filter$2;
var filter$1 = parent$G;
var filter2 = filter$1;
var _filterInstanceProperty = getDefaultExportFromCjs(filter2);
var getOwnPropertyDescriptor$7 = { exports: {} };
var $$r = _export;
var fails$a = fails$s;
var toIndexedObject$1 = toIndexedObject$9;
var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var DESCRIPTORS$9 = descriptors;
var FORCED$3 = !DESCRIPTORS$9 || fails$a(function() {
  nativeGetOwnPropertyDescriptor(1);
});
$$r({ target: "Object", stat: true, forced: FORCED$3, sham: !DESCRIPTORS$9 }, { getOwnPropertyDescriptor: function(e, t) {
  return nativeGetOwnPropertyDescriptor(toIndexedObject$1(e), t);
} });
var path$5 = path$e;
var Object$2 = path$5.Object;
var getOwnPropertyDescriptor$6 = getOwnPropertyDescriptor$7.exports = function(e, t) {
  return Object$2.getOwnPropertyDescriptor(e, t);
};
Object$2.getOwnPropertyDescriptor.sham && (getOwnPropertyDescriptor$6.sham = true);
var getOwnPropertyDescriptorExports = getOwnPropertyDescriptor$7.exports;
var parent$F = getOwnPropertyDescriptorExports;
var getOwnPropertyDescriptor$5 = parent$F;
var parent$E = getOwnPropertyDescriptor$5;
var getOwnPropertyDescriptor$4 = parent$E;
var parent$D = getOwnPropertyDescriptor$4;
var getOwnPropertyDescriptor$3 = parent$D;
var getOwnPropertyDescriptor$2 = getOwnPropertyDescriptor$3;
var _Object$getOwnPropertyDescriptor = getDefaultExportFromCjs(getOwnPropertyDescriptor$2);
var DESCRIPTORS$8 = descriptors;
var isArray$1 = isArray$6;
var $TypeError$8 = TypeError;
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS$8 && !function() {
  if (void 0 !== this) return true;
  try {
    Object.defineProperty([], "length", { writable: false }).length = 1;
  } catch (e) {
    return e instanceof TypeError;
  }
}();
var arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(e, t) {
  if (isArray$1(e) && !getOwnPropertyDescriptor$1(e, "length").writable) throw new $TypeError$8("Cannot set read only .length");
  return e.length = t;
} : function(e, t) {
  return e.length = t;
};
var $$q = _export;
var toObject$4 = toObject$c;
var lengthOfArrayLike$5 = lengthOfArrayLike$9;
var setArrayLength = arraySetLength;
var doesNotExceedSafeInteger$1 = doesNotExceedSafeInteger$3;
var fails$9 = fails$s;
var INCORRECT_TO_LENGTH = fails$9(function() {
  return 4294967297 !== [].push.call({ length: 4294967296 }, 1);
});
var properErrorOnNonWritableLength = function() {
  try {
    Object.defineProperty([], "length", { writable: false }).push();
  } catch (e) {
    return e instanceof TypeError;
  }
};
var FORCED$2 = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
$$q({ target: "Array", proto: true, arity: 1, forced: FORCED$2 }, { push: function(e) {
  var t = toObject$4(this), i = lengthOfArrayLike$5(t), r = arguments.length;
  doesNotExceedSafeInteger$1(i + r);
  for (var o = 0; o < r; o++) t[i] = arguments[o], i++;
  return setArrayLength(t, i), i;
} });
var getBuiltInPrototypeMethod$5 = getBuiltInPrototypeMethod$a;
var push$a = getBuiltInPrototypeMethod$5("Array", "push");
var isPrototypeOf$8 = objectIsPrototypeOf;
var method$3 = push$a;
var ArrayPrototype$5 = Array.prototype;
var push$9 = function(e) {
  var t = e.push;
  return e === ArrayPrototype$5 || isPrototypeOf$8(ArrayPrototype$5, e) && t === ArrayPrototype$5.push ? method$3 : t;
};
var parent$C = push$9;
var push$8 = parent$C;
var parent$B = push$8;
var push$7 = parent$B;
var parent$A = push$7;
var push$6 = parent$A;
var push$5 = push$6;
var _pushInstanceProperty = getDefaultExportFromCjs(push$5);
var fails$8 = fails$s;
var arrayMethodIsStrict$2 = function(e, t) {
  var i = [][e];
  return !!i && fails$8(function() {
    i.call(null, t || function() {
      return 1;
    }, 1);
  });
};
var $forEach = arrayIteration.forEach;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$2;
var STRICT_METHOD$1 = arrayMethodIsStrict$1("forEach");
var arrayForEach = STRICT_METHOD$1 ? [].forEach : function(e) {
  return $forEach(this, e, arguments.length > 1 ? arguments[1] : void 0);
};
var $$p = _export;
$$p({ target: "Array", proto: true, forced: [].forEach !== arrayForEach }, { forEach: arrayForEach });
var getBuiltInPrototypeMethod$4 = getBuiltInPrototypeMethod$a;
var forEach$5 = getBuiltInPrototypeMethod$4("Array", "forEach");
var parent$z = forEach$5;
var forEach$4 = parent$z;
var classof$3 = classof$a;
var hasOwn$4 = hasOwnProperty_1;
var isPrototypeOf$7 = objectIsPrototypeOf;
var method$2 = forEach$4;
var ArrayPrototype$4 = Array.prototype;
var DOMIterables = { DOMTokenList: true, NodeList: true };
var forEach$3 = function(e) {
  var t = e.forEach;
  return e === ArrayPrototype$4 || isPrototypeOf$7(ArrayPrototype$4, e) && t === ArrayPrototype$4.forEach || hasOwn$4(DOMIterables, classof$3(e)) ? method$2 : t;
};
var parent$y = forEach$3;
var forEach$2 = parent$y;
var parent$x = forEach$2;
var forEach$1 = parent$x;
var forEach2 = forEach$1;
var _forEachInstanceProperty = getDefaultExportFromCjs(forEach2);
var getBuiltIn$7 = getBuiltIn$h;
var uncurryThis$8 = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var anObject$7 = anObject$d;
var concat$1 = uncurryThis$8([].concat);
var ownKeys$3 = getBuiltIn$7("Reflect", "ownKeys") || function(e) {
  var t = getOwnPropertyNamesModule.f(anObject$7(e)), i = getOwnPropertySymbolsModule$1.f;
  return i ? concat$1(t, i(e)) : t;
};
var $$o = _export;
var DESCRIPTORS$7 = descriptors;
var ownKeys$2 = ownKeys$3;
var toIndexedObject = toIndexedObject$9;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var createProperty$2 = createProperty$4;
$$o({ target: "Object", stat: true, sham: !DESCRIPTORS$7 }, { getOwnPropertyDescriptors: function(e) {
  for (var t, i, r = toIndexedObject(e), o = getOwnPropertyDescriptorModule$1.f, n = ownKeys$2(r), s = {}, a = 0; n.length > a; ) void 0 !== (i = o(r, t = n[a++])) && createProperty$2(s, t, i);
  return s;
} });
var path$4 = path$e;
var getOwnPropertyDescriptors$4 = path$4.Object.getOwnPropertyDescriptors;
var parent$w = getOwnPropertyDescriptors$4;
var getOwnPropertyDescriptors$3 = parent$w;
var parent$v = getOwnPropertyDescriptors$3;
var getOwnPropertyDescriptors$2 = parent$v;
var parent$u = getOwnPropertyDescriptors$2;
var getOwnPropertyDescriptors$1 = parent$u;
var getOwnPropertyDescriptors2 = getOwnPropertyDescriptors$1;
var _Object$getOwnPropertyDescriptors = getDefaultExportFromCjs(getOwnPropertyDescriptors2);
var defineProperties$6 = { exports: {} };
var $$n = _export;
var DESCRIPTORS$6 = descriptors;
var defineProperties$5 = objectDefineProperties.f;
$$n({ target: "Object", stat: true, forced: Object.defineProperties !== defineProperties$5, sham: !DESCRIPTORS$6 }, { defineProperties: defineProperties$5 });
var path$3 = path$e;
var Object$1 = path$3.Object;
var defineProperties$4 = defineProperties$6.exports = function(e, t) {
  return Object$1.defineProperties(e, t);
};
Object$1.defineProperties.sham && (defineProperties$4.sham = true);
var definePropertiesExports = defineProperties$6.exports;
var parent$t = definePropertiesExports;
var defineProperties$3 = parent$t;
var parent$s = defineProperties$3;
var defineProperties$2 = parent$s;
var parent$r = defineProperties$2;
var defineProperties$1 = parent$r;
var defineProperties4 = defineProperties$1;
var _Object$defineProperties = getDefaultExportFromCjs(defineProperties4);
function ownKeys$1(e, t) {
  var i = _Object$keys(e);
  if (_Object$getOwnPropertySymbols) {
    var r = _Object$getOwnPropertySymbols(e);
    t && (r = _filterInstanceProperty(r).call(r, function(t2) {
      return _Object$getOwnPropertyDescriptor(e, t2).enumerable;
    })), _pushInstanceProperty(i).apply(i, r);
  }
  return i;
}
function _objectSpread2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var i, r, o = null != arguments[t] ? arguments[t] : {};
    t % 2 ? _forEachInstanceProperty(i = ownKeys$1(Object(o), true)).call(i, function(t2) {
      _defineProperty(e, t2, o[t2]);
    }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(o)) : _forEachInstanceProperty(r = ownKeys$1(Object(o))).call(r, function(t2) {
      _Object$defineProperty(e, t2, _Object$getOwnPropertyDescriptor(o, t2));
    });
  }
  return e;
}
var isArray2 = isArray$6;
var lengthOfArrayLike$4 = lengthOfArrayLike$9;
var doesNotExceedSafeInteger = doesNotExceedSafeInteger$3;
var bind$7 = functionBindContext;
var flattenIntoArray$1 = function(e, t, i, r, o, n, s, a) {
  for (var d, c2, l = o, u = 0, h = !!s && bind$7(s, a); u < r; ) u in i && (d = h ? h(i[u], u, t) : i[u], n > 0 && isArray2(d) ? (c2 = lengthOfArrayLike$4(d), l = flattenIntoArray$1(e, t, d, c2, l, n - 1) - 1) : (doesNotExceedSafeInteger(l + 1), e[l] = d), l++), u++;
  return l;
};
var flattenIntoArray_1 = flattenIntoArray$1;
var $$m = _export;
var flattenIntoArray = flattenIntoArray_1;
var toObject$3 = toObject$c;
var lengthOfArrayLike$3 = lengthOfArrayLike$9;
var toIntegerOrInfinity = toIntegerOrInfinity$4;
var arraySpeciesCreate = arraySpeciesCreate$3;
$$m({ target: "Array", proto: true }, { flat: function() {
  var e = arguments.length ? arguments[0] : void 0, t = toObject$3(this), i = lengthOfArrayLike$3(t), r = arraySpeciesCreate(t, 0);
  return r.length = flattenIntoArray(r, t, t, i, 0, void 0 === e ? 1 : toIntegerOrInfinity(e)), r;
} });
var getBuiltInPrototypeMethod$3 = getBuiltInPrototypeMethod$a;
var flat$6 = getBuiltInPrototypeMethod$3("Array", "flat");
var isPrototypeOf$6 = objectIsPrototypeOf;
var method$1 = flat$6;
var ArrayPrototype$3 = Array.prototype;
var flat$5 = function(e) {
  var t = e.flat;
  return e === ArrayPrototype$3 || isPrototypeOf$6(ArrayPrototype$3, e) && t === ArrayPrototype$3.flat ? method$1 : t;
};
var parent$q = flat$5;
var flat$4 = parent$q;
var parent$p = flat$4;
var flat$3 = parent$p;
var parent$o = flat$3;
var flat$2 = parent$o;
var flat$1 = flat$2;
var flat2 = flat$1;
var _flatInstanceProperty = getDefaultExportFromCjs(flat2);
var common = {};
!function(e) {
  var t = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
  function i(e2, t2) {
    return Object.prototype.hasOwnProperty.call(e2, t2);
  }
  e.assign = function(e2) {
    for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
      var r2 = t2.shift();
      if (r2) {
        if ("object" != typeof r2) throw new TypeError(r2 + "must be non-object");
        for (var o2 in r2) i(r2, o2) && (e2[o2] = r2[o2]);
      }
    }
    return e2;
  }, e.shrinkBuf = function(e2, t2) {
    return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
  };
  var r = { arraySet: function(e2, t2, i2, r2, o2) {
    if (t2.subarray && e2.subarray) e2.set(t2.subarray(i2, i2 + r2), o2);
    else for (var n = 0; n < r2; n++) e2[o2 + n] = t2[i2 + n];
  }, flattenChunks: function(e2) {
    var t2, i2, r2, o2, n, s;
    for (r2 = 0, t2 = 0, i2 = e2.length; t2 < i2; t2++) r2 += e2[t2].length;
    for (s = new Uint8Array(r2), o2 = 0, t2 = 0, i2 = e2.length; t2 < i2; t2++) n = e2[t2], s.set(n, o2), o2 += n.length;
    return s;
  } }, o = { arraySet: function(e2, t2, i2, r2, o2) {
    for (var n = 0; n < r2; n++) e2[o2 + n] = t2[i2 + n];
  }, flattenChunks: function(e2) {
    return [].concat.apply([], e2);
  } };
  e.setTyped = function(t2) {
    t2 ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, r)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, o));
  }, e.setTyped(t);
}(common);
var deflate$4 = {};
var deflate$3 = {};
var trees$1 = {};
var utils$6 = common;
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(e) {
  for (var t = e.length; --t >= 0; ) e[t] = 0;
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree = new Array(2 * (L_CODES$1 + 2));
zero$1(static_ltree);
var static_dtree = new Array(2 * D_CODES$1);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var static_l_desc;
var static_d_desc;
var static_bl_desc;
var base_dist = new Array(D_CODES$1);
function StaticTreeDesc(e, t, i, r, o) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = i, this.elems = r, this.max_length = o, this.has_stree = e && e.length;
}
function TreeDesc(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
function d_code(e) {
  return e < 256 ? _dist_code[e] : _dist_code[256 + (e >>> 7)];
}
function put_short(e, t) {
  e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255;
}
function send_bits(e, t, i) {
  e.bi_valid > Buf_size - i ? (e.bi_buf |= t << e.bi_valid & 65535, put_short(e, e.bi_buf), e.bi_buf = t >> Buf_size - e.bi_valid, e.bi_valid += i - Buf_size) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += i);
}
function send_code(e, t, i) {
  send_bits(e, i[2 * t], i[2 * t + 1]);
}
function bi_reverse(e, t) {
  var i = 0;
  do {
    i |= 1 & e, e >>>= 1, i <<= 1;
  } while (--t > 0);
  return i >>> 1;
}
function bi_flush(e) {
  16 === e.bi_valid ? (put_short(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8);
}
function gen_bitlen(e, t) {
  var i, r, o, n, s, a, d = t.dyn_tree, c2 = t.max_code, l = t.stat_desc.static_tree, u = t.stat_desc.has_stree, h = t.stat_desc.extra_bits, _ = t.stat_desc.extra_base, p = t.stat_desc.max_length, m = 0;
  for (n = 0; n <= MAX_BITS$1; n++) e.bl_count[n] = 0;
  for (d[2 * e.heap[e.heap_max] + 1] = 0, i = e.heap_max + 1; i < HEAP_SIZE$1; i++) (n = d[2 * d[2 * (r = e.heap[i]) + 1] + 1] + 1) > p && (n = p, m++), d[2 * r + 1] = n, r > c2 || (e.bl_count[n]++, s = 0, r >= _ && (s = h[r - _]), a = d[2 * r], e.opt_len += a * (n + s), u && (e.static_len += a * (l[2 * r + 1] + s)));
  if (0 !== m) {
    do {
      for (n = p - 1; 0 === e.bl_count[n]; ) n--;
      e.bl_count[n]--, e.bl_count[n + 1] += 2, e.bl_count[p]--, m -= 2;
    } while (m > 0);
    for (n = p; 0 !== n; n--) for (r = e.bl_count[n]; 0 !== r; ) (o = e.heap[--i]) > c2 || (d[2 * o + 1] !== n && (e.opt_len += (n - d[2 * o + 1]) * d[2 * o], d[2 * o + 1] = n), r--);
  }
}
function gen_codes(e, t, i) {
  var r, o, n = new Array(MAX_BITS$1 + 1), s = 0;
  for (r = 1; r <= MAX_BITS$1; r++) n[r] = s = s + i[r - 1] << 1;
  for (o = 0; o <= t; o++) {
    var a = e[2 * o + 1];
    0 !== a && (e[2 * o] = bi_reverse(n[a]++, a));
  }
}
function tr_static_init() {
  var e, t, i, r, o, n = new Array(MAX_BITS$1 + 1);
  for (i = 0, r = 0; r < LENGTH_CODES$1 - 1; r++) for (base_length[r] = i, e = 0; e < 1 << extra_lbits[r]; e++) _length_code[i++] = r;
  for (_length_code[i - 1] = r, o = 0, r = 0; r < 16; r++) for (base_dist[r] = o, e = 0; e < 1 << extra_dbits[r]; e++) _dist_code[o++] = r;
  for (o >>= 7; r < D_CODES$1; r++) for (base_dist[r] = o << 7, e = 0; e < 1 << extra_dbits[r] - 7; e++) _dist_code[256 + o++] = r;
  for (t = 0; t <= MAX_BITS$1; t++) n[t] = 0;
  for (e = 0; e <= 143; ) static_ltree[2 * e + 1] = 8, e++, n[8]++;
  for (; e <= 255; ) static_ltree[2 * e + 1] = 9, e++, n[9]++;
  for (; e <= 279; ) static_ltree[2 * e + 1] = 7, e++, n[7]++;
  for (; e <= 287; ) static_ltree[2 * e + 1] = 8, e++, n[8]++;
  for (gen_codes(static_ltree, L_CODES$1 + 1, n), e = 0; e < D_CODES$1; e++) static_dtree[2 * e + 1] = 5, static_dtree[2 * e] = bi_reverse(e, 5);
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}
function init_block(e) {
  var t;
  for (t = 0; t < L_CODES$1; t++) e.dyn_ltree[2 * t] = 0;
  for (t = 0; t < D_CODES$1; t++) e.dyn_dtree[2 * t] = 0;
  for (t = 0; t < BL_CODES$1; t++) e.bl_tree[2 * t] = 0;
  e.dyn_ltree[2 * END_BLOCK] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0;
}
function bi_windup(e) {
  e.bi_valid > 8 ? put_short(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}
function copy_block(e, t, i, r) {
  bi_windup(e), r && (put_short(e, i), put_short(e, ~i)), utils$6.arraySet(e.pending_buf, e.window, t, i, e.pending), e.pending += i;
}
function smaller(e, t, i, r) {
  var o = 2 * t, n = 2 * i;
  return e[o] < e[n] || e[o] === e[n] && r[t] <= r[i];
}
function pqdownheap(e, t, i) {
  for (var r = e.heap[i], o = i << 1; o <= e.heap_len && (o < e.heap_len && smaller(t, e.heap[o + 1], e.heap[o], e.depth) && o++, !smaller(t, r, e.heap[o], e.depth)); ) e.heap[i] = e.heap[o], i = o, o <<= 1;
  e.heap[i] = r;
}
function compress_block(e, t, i) {
  var r, o, n, s, a = 0;
  if (0 !== e.last_lit) do {
    r = e.pending_buf[e.d_buf + 2 * a] << 8 | e.pending_buf[e.d_buf + 2 * a + 1], o = e.pending_buf[e.l_buf + a], a++, 0 === r ? send_code(e, o, t) : (send_code(e, (n = _length_code[o]) + LITERALS$1 + 1, t), 0 !== (s = extra_lbits[n]) && send_bits(e, o -= base_length[n], s), send_code(e, n = d_code(--r), i), 0 !== (s = extra_dbits[n]) && send_bits(e, r -= base_dist[n], s));
  } while (a < e.last_lit);
  send_code(e, END_BLOCK, t);
}
function build_tree(e, t) {
  var i, r, o, n = t.dyn_tree, s = t.stat_desc.static_tree, a = t.stat_desc.has_stree, d = t.stat_desc.elems, c2 = -1;
  for (e.heap_len = 0, e.heap_max = HEAP_SIZE$1, i = 0; i < d; i++) 0 !== n[2 * i] ? (e.heap[++e.heap_len] = c2 = i, e.depth[i] = 0) : n[2 * i + 1] = 0;
  for (; e.heap_len < 2; ) n[2 * (o = e.heap[++e.heap_len] = c2 < 2 ? ++c2 : 0)] = 1, e.depth[o] = 0, e.opt_len--, a && (e.static_len -= s[2 * o + 1]);
  for (t.max_code = c2, i = e.heap_len >> 1; i >= 1; i--) pqdownheap(e, n, i);
  o = d;
  do {
    i = e.heap[1], e.heap[1] = e.heap[e.heap_len--], pqdownheap(e, n, 1), r = e.heap[1], e.heap[--e.heap_max] = i, e.heap[--e.heap_max] = r, n[2 * o] = n[2 * i] + n[2 * r], e.depth[o] = (e.depth[i] >= e.depth[r] ? e.depth[i] : e.depth[r]) + 1, n[2 * i + 1] = n[2 * r + 1] = o, e.heap[1] = o++, pqdownheap(e, n, 1);
  } while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[1], gen_bitlen(e, t), gen_codes(n, c2, e.bl_count);
}
function scan_tree(e, t, i) {
  var r, o, n = -1, s = t[1], a = 0, d = 7, c2 = 4;
  for (0 === s && (d = 138, c2 = 3), t[2 * (i + 1) + 1] = 65535, r = 0; r <= i; r++) o = s, s = t[2 * (r + 1) + 1], ++a < d && o === s || (a < c2 ? e.bl_tree[2 * o] += a : 0 !== o ? (o !== n && e.bl_tree[2 * o]++, e.bl_tree[2 * REP_3_6]++) : a <= 10 ? e.bl_tree[2 * REPZ_3_10]++ : e.bl_tree[2 * REPZ_11_138]++, a = 0, n = o, 0 === s ? (d = 138, c2 = 3) : o === s ? (d = 6, c2 = 3) : (d = 7, c2 = 4));
}
function send_tree(e, t, i) {
  var r, o, n = -1, s = t[1], a = 0, d = 7, c2 = 4;
  for (0 === s && (d = 138, c2 = 3), r = 0; r <= i; r++) if (o = s, s = t[2 * (r + 1) + 1], !(++a < d && o === s)) {
    if (a < c2) do {
      send_code(e, o, e.bl_tree);
    } while (0 != --a);
    else 0 !== o ? (o !== n && (send_code(e, o, e.bl_tree), a--), send_code(e, REP_3_6, e.bl_tree), send_bits(e, a - 3, 2)) : a <= 10 ? (send_code(e, REPZ_3_10, e.bl_tree), send_bits(e, a - 3, 3)) : (send_code(e, REPZ_11_138, e.bl_tree), send_bits(e, a - 11, 7));
    a = 0, n = o, 0 === s ? (d = 138, c2 = 3) : o === s ? (d = 6, c2 = 3) : (d = 7, c2 = 4);
  }
}
function build_bl_tree(e) {
  var t;
  for (scan_tree(e, e.dyn_ltree, e.l_desc.max_code), scan_tree(e, e.dyn_dtree, e.d_desc.max_code), build_tree(e, e.bl_desc), t = BL_CODES$1 - 1; t >= 3 && 0 === e.bl_tree[2 * bl_order[t] + 1]; t--) ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}
function send_all_trees(e, t, i, r) {
  var o;
  for (send_bits(e, t - 257, 5), send_bits(e, i - 1, 5), send_bits(e, r - 4, 4), o = 0; o < r; o++) send_bits(e, e.bl_tree[2 * bl_order[o] + 1], 3);
  send_tree(e, e.dyn_ltree, t - 1), send_tree(e, e.dyn_dtree, i - 1);
}
function detect_data_type(e) {
  var t, i = 4093624447;
  for (t = 0; t <= 31; t++, i >>>= 1) if (1 & i && 0 !== e.dyn_ltree[2 * t]) return Z_BINARY;
  if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return Z_TEXT;
  for (t = 32; t < LITERALS$1; t++) if (0 !== e.dyn_ltree[2 * t]) return Z_TEXT;
  return Z_BINARY;
}
zero$1(base_dist);
var static_init_done = false;
function _tr_init(e) {
  static_init_done || (tr_static_init(), static_init_done = true), e.l_desc = new TreeDesc(e.dyn_ltree, static_l_desc), e.d_desc = new TreeDesc(e.dyn_dtree, static_d_desc), e.bl_desc = new TreeDesc(e.bl_tree, static_bl_desc), e.bi_buf = 0, e.bi_valid = 0, init_block(e);
}
function _tr_stored_block(e, t, i, r) {
  send_bits(e, (STORED_BLOCK << 1) + (r ? 1 : 0), 3), copy_block(e, t, i, true);
}
function _tr_align(e) {
  send_bits(e, STATIC_TREES << 1, 3), send_code(e, END_BLOCK, static_ltree), bi_flush(e);
}
function _tr_flush_block(e, t, i, r) {
  var o, n, s = 0;
  e.level > 0 ? (e.strm.data_type === Z_UNKNOWN$1 && (e.strm.data_type = detect_data_type(e)), build_tree(e, e.l_desc), build_tree(e, e.d_desc), s = build_bl_tree(e), o = e.opt_len + 3 + 7 >>> 3, (n = e.static_len + 3 + 7 >>> 3) <= o && (o = n)) : o = n = i + 5, i + 4 <= o && -1 !== t ? _tr_stored_block(e, t, i, r) : e.strategy === Z_FIXED$1 || n === o ? (send_bits(e, (STATIC_TREES << 1) + (r ? 1 : 0), 3), compress_block(e, static_ltree, static_dtree)) : (send_bits(e, (DYN_TREES << 1) + (r ? 1 : 0), 3), send_all_trees(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1), compress_block(e, e.dyn_ltree, e.dyn_dtree)), init_block(e), r && bi_windup(e);
}
function _tr_tally(e, t, i) {
  return e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & i, e.last_lit++, 0 === t ? e.dyn_ltree[2 * i]++ : (e.matches++, t--, e.dyn_ltree[2 * (_length_code[i] + LITERALS$1 + 1)]++, e.dyn_dtree[2 * d_code(t)]++), e.last_lit === e.lit_bufsize - 1;
}
function adler32$2(e, t, i, r) {
  for (var o = 65535 & e, n = e >>> 16 & 65535, s = 0; 0 !== i; ) {
    i -= s = i > 2e3 ? 2e3 : i;
    do {
      n = n + (o = o + t[r++] | 0) | 0;
    } while (--s);
    o %= 65521, n %= 65521;
  }
  return o | n << 16;
}
trees$1._tr_init = _tr_init, trees$1._tr_stored_block = _tr_stored_block, trees$1._tr_flush_block = _tr_flush_block, trees$1._tr_tally = _tr_tally, trees$1._tr_align = _tr_align;
var adler32_1 = adler32$2;
function makeTable() {
  for (var e, t = [], i = 0; i < 256; i++) {
    e = i;
    for (var r = 0; r < 8; r++) e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[i] = e;
  }
  return t;
}
var crcTable = makeTable();
function crc32$2(e, t, i, r) {
  var o = crcTable, n = r + i;
  e ^= -1;
  for (var s = r; s < n; s++) e = e >>> 8 ^ o[255 & (e ^ t[s])];
  return ~e;
}
var configuration_table;
var crc32_1 = crc32$2;
var messages = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
var utils$5 = common;
var trees = trees$1;
var adler32$1 = adler32_1;
var crc32$1 = crc32_1;
var msg$2 = messages;
var Z_NO_FLUSH$1 = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH$2 = 4;
var Z_BLOCK$1 = 5;
var Z_OK$2 = 0;
var Z_STREAM_END$2 = 1;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_BUF_ERROR$1 = -5;
var Z_DEFAULT_COMPRESSION$1 = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY$1 = 0;
var Z_UNKNOWN = 2;
var Z_DEFLATED$2 = 8;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(e, t) {
  return e.msg = msg$2[t], t;
}
function rank(e) {
  return (e << 1) - (e > 4 ? 9 : 0);
}
function zero(e) {
  for (var t = e.length; --t >= 0; ) e[t] = 0;
}
function flush_pending(e) {
  var t = e.state, i = t.pending;
  i > e.avail_out && (i = e.avail_out), 0 !== i && (utils$5.arraySet(e.output, t.pending_buf, t.pending_out, i, e.next_out), e.next_out += i, t.pending_out += i, e.total_out += i, e.avail_out -= i, t.pending -= i, 0 === t.pending && (t.pending_out = 0));
}
function flush_block_only(e, t) {
  trees._tr_flush_block(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, flush_pending(e.strm);
}
function put_byte(e, t) {
  e.pending_buf[e.pending++] = t;
}
function putShortMSB(e, t) {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t;
}
function read_buf(e, t, i, r) {
  var o = e.avail_in;
  return o > r && (o = r), 0 === o ? 0 : (e.avail_in -= o, utils$5.arraySet(t, e.input, e.next_in, o, i), 1 === e.state.wrap ? e.adler = adler32$1(e.adler, t, o, i) : 2 === e.state.wrap && (e.adler = crc32$1(e.adler, t, o, i)), e.next_in += o, e.total_in += o, o);
}
function longest_match(e, t) {
  var i, r, o = e.max_chain_length, n = e.strstart, s = e.prev_length, a = e.nice_match, d = e.strstart > e.w_size - MIN_LOOKAHEAD ? e.strstart - (e.w_size - MIN_LOOKAHEAD) : 0, c2 = e.window, l = e.w_mask, u = e.prev, h = e.strstart + MAX_MATCH, _ = c2[n + s - 1], p = c2[n + s];
  e.prev_length >= e.good_match && (o >>= 2), a > e.lookahead && (a = e.lookahead);
  do {
    if (c2[(i = t) + s] === p && c2[i + s - 1] === _ && c2[i] === c2[n] && c2[++i] === c2[n + 1]) {
      n += 2, i++;
      do {
      } while (c2[++n] === c2[++i] && c2[++n] === c2[++i] && c2[++n] === c2[++i] && c2[++n] === c2[++i] && c2[++n] === c2[++i] && c2[++n] === c2[++i] && c2[++n] === c2[++i] && c2[++n] === c2[++i] && n < h);
      if (r = MAX_MATCH - (h - n), n = h - MAX_MATCH, r > s) {
        if (e.match_start = t, s = r, r >= a) break;
        _ = c2[n + s - 1], p = c2[n + s];
      }
    }
  } while ((t = u[t & l]) > d && 0 != --o);
  return s <= e.lookahead ? s : e.lookahead;
}
function fill_window(e) {
  var t, i, r, o, n, s = e.w_size;
  do {
    if (o = e.window_size - e.lookahead - e.strstart, e.strstart >= s + (s - MIN_LOOKAHEAD)) {
      utils$5.arraySet(e.window, e.window, s, s, 0), e.match_start -= s, e.strstart -= s, e.block_start -= s, t = i = e.hash_size;
      do {
        r = e.head[--t], e.head[t] = r >= s ? r - s : 0;
      } while (--i);
      t = i = s;
      do {
        r = e.prev[--t], e.prev[t] = r >= s ? r - s : 0;
      } while (--i);
      o += s;
    }
    if (0 === e.strm.avail_in) break;
    if (i = read_buf(e.strm, e.window, e.strstart + e.lookahead, o), e.lookahead += i, e.lookahead + e.insert >= MIN_MATCH) for (n = e.strstart - e.insert, e.ins_h = e.window[n], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[n + 1]) & e.hash_mask; e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[n + MIN_MATCH - 1]) & e.hash_mask, e.prev[n & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = n, n++, e.insert--, !(e.lookahead + e.insert < MIN_MATCH)); ) ;
  } while (e.lookahead < MIN_LOOKAHEAD && 0 !== e.strm.avail_in);
}
function deflate_stored(e, t) {
  var i = 65535;
  for (i > e.pending_buf_size - 5 && (i = e.pending_buf_size - 5); ; ) {
    if (e.lookahead <= 1) {
      if (fill_window(e), 0 === e.lookahead && t === Z_NO_FLUSH$1) return BS_NEED_MORE;
      if (0 === e.lookahead) break;
    }
    e.strstart += e.lookahead, e.lookahead = 0;
    var r = e.block_start + i;
    if ((0 === e.strstart || e.strstart >= r) && (e.lookahead = e.strstart - r, e.strstart = r, flush_block_only(e, false), 0 === e.strm.avail_out)) return BS_NEED_MORE;
    if (e.strstart - e.block_start >= e.w_size - MIN_LOOKAHEAD && (flush_block_only(e, false), 0 === e.strm.avail_out)) return BS_NEED_MORE;
  }
  return e.insert = 0, t === Z_FINISH$2 ? (flush_block_only(e, true), 0 === e.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : (e.strstart > e.block_start && (flush_block_only(e, false), e.strm.avail_out), BS_NEED_MORE);
}
function deflate_fast(e, t) {
  for (var i, r; ; ) {
    if (e.lookahead < MIN_LOOKAHEAD) {
      if (fill_window(e), e.lookahead < MIN_LOOKAHEAD && t === Z_NO_FLUSH$1) return BS_NEED_MORE;
      if (0 === e.lookahead) break;
    }
    if (i = 0, e.lookahead >= MIN_MATCH && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + MIN_MATCH - 1]) & e.hash_mask, i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== i && e.strstart - i <= e.w_size - MIN_LOOKAHEAD && (e.match_length = longest_match(e, i)), e.match_length >= MIN_MATCH) if (r = trees._tr_tally(e, e.strstart - e.match_start, e.match_length - MIN_MATCH), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= MIN_MATCH) {
      e.match_length--;
      do {
        e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + MIN_MATCH - 1]) & e.hash_mask, i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
      } while (0 != --e.match_length);
      e.strstart++;
    } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask;
    else r = trees._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (r && (flush_block_only(e, false), 0 === e.strm.avail_out)) return BS_NEED_MORE;
  }
  return e.insert = e.strstart < MIN_MATCH - 1 ? e.strstart : MIN_MATCH - 1, t === Z_FINISH$2 ? (flush_block_only(e, true), 0 === e.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.last_lit && (flush_block_only(e, false), 0 === e.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE;
}
function deflate_slow(e, t) {
  for (var i, r, o; ; ) {
    if (e.lookahead < MIN_LOOKAHEAD) {
      if (fill_window(e), e.lookahead < MIN_LOOKAHEAD && t === Z_NO_FLUSH$1) return BS_NEED_MORE;
      if (0 === e.lookahead) break;
    }
    if (i = 0, e.lookahead >= MIN_MATCH && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + MIN_MATCH - 1]) & e.hash_mask, i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = MIN_MATCH - 1, 0 !== i && e.prev_length < e.max_lazy_match && e.strstart - i <= e.w_size - MIN_LOOKAHEAD && (e.match_length = longest_match(e, i), e.match_length <= 5 && (e.strategy === Z_FILTERED || e.match_length === MIN_MATCH && e.strstart - e.match_start > 4096) && (e.match_length = MIN_MATCH - 1)), e.prev_length >= MIN_MATCH && e.match_length <= e.prev_length) {
      o = e.strstart + e.lookahead - MIN_MATCH, r = trees._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - MIN_MATCH), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do {
        ++e.strstart <= o && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + MIN_MATCH - 1]) & e.hash_mask, i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      } while (0 != --e.prev_length);
      if (e.match_available = 0, e.match_length = MIN_MATCH - 1, e.strstart++, r && (flush_block_only(e, false), 0 === e.strm.avail_out)) return BS_NEED_MORE;
    } else if (e.match_available) {
      if ((r = trees._tr_tally(e, 0, e.window[e.strstart - 1])) && flush_block_only(e, false), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return BS_NEED_MORE;
    } else e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (r = trees._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < MIN_MATCH - 1 ? e.strstart : MIN_MATCH - 1, t === Z_FINISH$2 ? (flush_block_only(e, true), 0 === e.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.last_lit && (flush_block_only(e, false), 0 === e.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE;
}
function deflate_rle(e, t) {
  for (var i, r, o, n, s = e.window; ; ) {
    if (e.lookahead <= MAX_MATCH) {
      if (fill_window(e), e.lookahead <= MAX_MATCH && t === Z_NO_FLUSH$1) return BS_NEED_MORE;
      if (0 === e.lookahead) break;
    }
    if (e.match_length = 0, e.lookahead >= MIN_MATCH && e.strstart > 0 && (r = s[o = e.strstart - 1]) === s[++o] && r === s[++o] && r === s[++o]) {
      n = e.strstart + MAX_MATCH;
      do {
      } while (r === s[++o] && r === s[++o] && r === s[++o] && r === s[++o] && r === s[++o] && r === s[++o] && r === s[++o] && r === s[++o] && o < n);
      e.match_length = MAX_MATCH - (n - o), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= MIN_MATCH ? (i = trees._tr_tally(e, 1, e.match_length - MIN_MATCH), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (i = trees._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), i && (flush_block_only(e, false), 0 === e.strm.avail_out)) return BS_NEED_MORE;
  }
  return e.insert = 0, t === Z_FINISH$2 ? (flush_block_only(e, true), 0 === e.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.last_lit && (flush_block_only(e, false), 0 === e.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE;
}
function deflate_huff(e, t) {
  for (var i; ; ) {
    if (0 === e.lookahead && (fill_window(e), 0 === e.lookahead)) {
      if (t === Z_NO_FLUSH$1) return BS_NEED_MORE;
      break;
    }
    if (e.match_length = 0, i = trees._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, i && (flush_block_only(e, false), 0 === e.strm.avail_out)) return BS_NEED_MORE;
  }
  return e.insert = 0, t === Z_FINISH$2 ? (flush_block_only(e, true), 0 === e.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.last_lit && (flush_block_only(e, false), 0 === e.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE;
}
function Config$1(e, t, i, r, o) {
  this.good_length = e, this.max_lazy = t, this.nice_length = i, this.max_chain = r, this.func = o;
}
function lm_init(e) {
  e.window_size = 2 * e.w_size, zero(e.head), e.max_lazy_match = configuration_table[e.level].max_lazy, e.good_match = configuration_table[e.level].good_length, e.nice_match = configuration_table[e.level].nice_length, e.max_chain_length = configuration_table[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = MIN_MATCH - 1, e.match_available = 0, e.ins_h = 0;
}
function DeflateState() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED$2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new utils$5.Buf16(2 * HEAP_SIZE), this.dyn_dtree = new utils$5.Buf16(2 * (2 * D_CODES + 1)), this.bl_tree = new utils$5.Buf16(2 * (2 * BL_CODES + 1)), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new utils$5.Buf16(MAX_BITS + 1), this.heap = new utils$5.Buf16(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new utils$5.Buf16(2 * L_CODES + 1), zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
function deflateResetKeep(e) {
  var t;
  return e && e.state ? (e.total_in = e.total_out = 0, e.data_type = Z_UNKNOWN, (t = e.state).pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? INIT_STATE : BUSY_STATE, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = Z_NO_FLUSH$1, trees._tr_init(t), Z_OK$2) : err(e, Z_STREAM_ERROR$1);
}
function deflateReset(e) {
  var t = deflateResetKeep(e);
  return t === Z_OK$2 && lm_init(e.state), t;
}
function deflateSetHeader(e, t) {
  return e && e.state ? 2 !== e.state.wrap ? Z_STREAM_ERROR$1 : (e.state.gzhead = t, Z_OK$2) : Z_STREAM_ERROR$1;
}
function deflateInit2(e, t, i, r, o, n) {
  if (!e) return Z_STREAM_ERROR$1;
  var s = 1;
  if (t === Z_DEFAULT_COMPRESSION$1 && (t = 6), r < 0 ? (s = 0, r = -r) : r > 15 && (s = 2, r -= 16), o < 1 || o > MAX_MEM_LEVEL || i !== Z_DEFLATED$2 || r < 8 || r > 15 || t < 0 || t > 9 || n < 0 || n > Z_FIXED) return err(e, Z_STREAM_ERROR$1);
  8 === r && (r = 9);
  var a = new DeflateState();
  return e.state = a, a.strm = e, a.wrap = s, a.gzhead = null, a.w_bits = r, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = o + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + MIN_MATCH - 1) / MIN_MATCH), a.window = new utils$5.Buf8(2 * a.w_size), a.head = new utils$5.Buf16(a.hash_size), a.prev = new utils$5.Buf16(a.w_size), a.lit_bufsize = 1 << o + 6, a.pending_buf_size = 4 * a.lit_bufsize, a.pending_buf = new utils$5.Buf8(a.pending_buf_size), a.d_buf = 1 * a.lit_bufsize, a.l_buf = 3 * a.lit_bufsize, a.level = t, a.strategy = n, a.method = i, deflateReset(e);
}
function deflateInit(e, t) {
  return deflateInit2(e, t, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
}
function deflate$2(e, t) {
  var i, r, o, n;
  if (!e || !e.state || t > Z_BLOCK$1 || t < 0) return e ? err(e, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  if (r = e.state, !e.output || !e.input && 0 !== e.avail_in || r.status === FINISH_STATE && t !== Z_FINISH$2) return err(e, 0 === e.avail_out ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  if (r.strm = e, i = r.last_flush, r.last_flush = t, r.status === INIT_STATE) if (2 === r.wrap) e.adler = 0, put_byte(r, 31), put_byte(r, 139), put_byte(r, 8), r.gzhead ? (put_byte(r, (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)), put_byte(r, 255 & r.gzhead.time), put_byte(r, r.gzhead.time >> 8 & 255), put_byte(r, r.gzhead.time >> 16 & 255), put_byte(r, r.gzhead.time >> 24 & 255), put_byte(r, 9 === r.level ? 2 : r.strategy >= Z_HUFFMAN_ONLY || r.level < 2 ? 4 : 0), put_byte(r, 255 & r.gzhead.os), r.gzhead.extra && r.gzhead.extra.length && (put_byte(r, 255 & r.gzhead.extra.length), put_byte(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (e.adler = crc32$1(e.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = EXTRA_STATE) : (put_byte(r, 0), put_byte(r, 0), put_byte(r, 0), put_byte(r, 0), put_byte(r, 0), put_byte(r, 9 === r.level ? 2 : r.strategy >= Z_HUFFMAN_ONLY || r.level < 2 ? 4 : 0), put_byte(r, OS_CODE), r.status = BUSY_STATE);
  else {
    var s = Z_DEFLATED$2 + (r.w_bits - 8 << 4) << 8;
    s |= (r.strategy >= Z_HUFFMAN_ONLY || r.level < 2 ? 0 : r.level < 6 ? 1 : 6 === r.level ? 2 : 3) << 6, 0 !== r.strstart && (s |= PRESET_DICT), s += 31 - s % 31, r.status = BUSY_STATE, putShortMSB(r, s), 0 !== r.strstart && (putShortMSB(r, e.adler >>> 16), putShortMSB(r, 65535 & e.adler)), e.adler = 1;
  }
  if (r.status === EXTRA_STATE) if (r.gzhead.extra) {
    for (o = r.pending; r.gzindex < (65535 & r.gzhead.extra.length) && (r.pending !== r.pending_buf_size || (r.gzhead.hcrc && r.pending > o && (e.adler = crc32$1(e.adler, r.pending_buf, r.pending - o, o)), flush_pending(e), o = r.pending, r.pending !== r.pending_buf_size)); ) put_byte(r, 255 & r.gzhead.extra[r.gzindex]), r.gzindex++;
    r.gzhead.hcrc && r.pending > o && (e.adler = crc32$1(e.adler, r.pending_buf, r.pending - o, o)), r.gzindex === r.gzhead.extra.length && (r.gzindex = 0, r.status = NAME_STATE);
  } else r.status = NAME_STATE;
  if (r.status === NAME_STATE) if (r.gzhead.name) {
    o = r.pending;
    do {
      if (r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > o && (e.adler = crc32$1(e.adler, r.pending_buf, r.pending - o, o)), flush_pending(e), o = r.pending, r.pending === r.pending_buf_size)) {
        n = 1;
        break;
      }
      n = r.gzindex < r.gzhead.name.length ? 255 & r.gzhead.name.charCodeAt(r.gzindex++) : 0, put_byte(r, n);
    } while (0 !== n);
    r.gzhead.hcrc && r.pending > o && (e.adler = crc32$1(e.adler, r.pending_buf, r.pending - o, o)), 0 === n && (r.gzindex = 0, r.status = COMMENT_STATE);
  } else r.status = COMMENT_STATE;
  if (r.status === COMMENT_STATE) if (r.gzhead.comment) {
    o = r.pending;
    do {
      if (r.pending === r.pending_buf_size && (r.gzhead.hcrc && r.pending > o && (e.adler = crc32$1(e.adler, r.pending_buf, r.pending - o, o)), flush_pending(e), o = r.pending, r.pending === r.pending_buf_size)) {
        n = 1;
        break;
      }
      n = r.gzindex < r.gzhead.comment.length ? 255 & r.gzhead.comment.charCodeAt(r.gzindex++) : 0, put_byte(r, n);
    } while (0 !== n);
    r.gzhead.hcrc && r.pending > o && (e.adler = crc32$1(e.adler, r.pending_buf, r.pending - o, o)), 0 === n && (r.status = HCRC_STATE);
  } else r.status = HCRC_STATE;
  if (r.status === HCRC_STATE && (r.gzhead.hcrc ? (r.pending + 2 > r.pending_buf_size && flush_pending(e), r.pending + 2 <= r.pending_buf_size && (put_byte(r, 255 & e.adler), put_byte(r, e.adler >> 8 & 255), e.adler = 0, r.status = BUSY_STATE)) : r.status = BUSY_STATE), 0 !== r.pending) {
    if (flush_pending(e), 0 === e.avail_out) return r.last_flush = -1, Z_OK$2;
  } else if (0 === e.avail_in && rank(t) <= rank(i) && t !== Z_FINISH$2) return err(e, Z_BUF_ERROR$1);
  if (r.status === FINISH_STATE && 0 !== e.avail_in) return err(e, Z_BUF_ERROR$1);
  if (0 !== e.avail_in || 0 !== r.lookahead || t !== Z_NO_FLUSH$1 && r.status !== FINISH_STATE) {
    var a = r.strategy === Z_HUFFMAN_ONLY ? deflate_huff(r, t) : r.strategy === Z_RLE ? deflate_rle(r, t) : configuration_table[r.level].func(r, t);
    if (a !== BS_FINISH_STARTED && a !== BS_FINISH_DONE || (r.status = FINISH_STATE), a === BS_NEED_MORE || a === BS_FINISH_STARTED) return 0 === e.avail_out && (r.last_flush = -1), Z_OK$2;
    if (a === BS_BLOCK_DONE && (t === Z_PARTIAL_FLUSH ? trees._tr_align(r) : t !== Z_BLOCK$1 && (trees._tr_stored_block(r, 0, 0, false), t === Z_FULL_FLUSH && (zero(r.head), 0 === r.lookahead && (r.strstart = 0, r.block_start = 0, r.insert = 0))), flush_pending(e), 0 === e.avail_out)) return r.last_flush = -1, Z_OK$2;
  }
  return t !== Z_FINISH$2 ? Z_OK$2 : r.wrap <= 0 ? Z_STREAM_END$2 : (2 === r.wrap ? (put_byte(r, 255 & e.adler), put_byte(r, e.adler >> 8 & 255), put_byte(r, e.adler >> 16 & 255), put_byte(r, e.adler >> 24 & 255), put_byte(r, 255 & e.total_in), put_byte(r, e.total_in >> 8 & 255), put_byte(r, e.total_in >> 16 & 255), put_byte(r, e.total_in >> 24 & 255)) : (putShortMSB(r, e.adler >>> 16), putShortMSB(r, 65535 & e.adler)), flush_pending(e), r.wrap > 0 && (r.wrap = -r.wrap), 0 !== r.pending ? Z_OK$2 : Z_STREAM_END$2);
}
function deflateEnd(e) {
  var t;
  return e && e.state ? (t = e.state.status) !== INIT_STATE && t !== EXTRA_STATE && t !== NAME_STATE && t !== COMMENT_STATE && t !== HCRC_STATE && t !== BUSY_STATE && t !== FINISH_STATE ? err(e, Z_STREAM_ERROR$1) : (e.state = null, t === BUSY_STATE ? err(e, Z_DATA_ERROR$1) : Z_OK$2) : Z_STREAM_ERROR$1;
}
function deflateSetDictionary(e, t) {
  var i, r, o, n, s, a, d, c2, l = t.length;
  if (!e || !e.state) return Z_STREAM_ERROR$1;
  if (2 === (n = (i = e.state).wrap) || 1 === n && i.status !== INIT_STATE || i.lookahead) return Z_STREAM_ERROR$1;
  for (1 === n && (e.adler = adler32$1(e.adler, t, l, 0)), i.wrap = 0, l >= i.w_size && (0 === n && (zero(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0), c2 = new utils$5.Buf8(i.w_size), utils$5.arraySet(c2, t, l - i.w_size, i.w_size, 0), t = c2, l = i.w_size), s = e.avail_in, a = e.next_in, d = e.input, e.avail_in = l, e.next_in = 0, e.input = t, fill_window(i); i.lookahead >= MIN_MATCH; ) {
    r = i.strstart, o = i.lookahead - (MIN_MATCH - 1);
    do {
      i.ins_h = (i.ins_h << i.hash_shift ^ i.window[r + MIN_MATCH - 1]) & i.hash_mask, i.prev[r & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = r, r++;
    } while (--o);
    i.strstart = r, i.lookahead = MIN_MATCH - 1, fill_window(i);
  }
  return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = MIN_MATCH - 1, i.match_available = 0, e.next_in = a, e.input = d, e.avail_in = s, i.wrap = n, Z_OK$2;
}
configuration_table = [new Config$1(0, 0, 0, 0, deflate_stored), new Config$1(4, 4, 8, 4, deflate_fast), new Config$1(4, 5, 16, 8, deflate_fast), new Config$1(4, 6, 32, 32, deflate_fast), new Config$1(4, 4, 16, 16, deflate_slow), new Config$1(8, 16, 32, 32, deflate_slow), new Config$1(8, 16, 128, 128, deflate_slow), new Config$1(8, 32, 128, 256, deflate_slow), new Config$1(32, 128, 258, 1024, deflate_slow), new Config$1(32, 258, 258, 4096, deflate_slow)], deflate$3.deflateInit = deflateInit, deflate$3.deflateInit2 = deflateInit2, deflate$3.deflateReset = deflateReset, deflate$3.deflateResetKeep = deflateResetKeep, deflate$3.deflateSetHeader = deflateSetHeader, deflate$3.deflate = deflate$2, deflate$3.deflateEnd = deflateEnd, deflate$3.deflateSetDictionary = deflateSetDictionary, deflate$3.deflateInfo = "pako deflate (from Nodeca project)";
var strings$2 = {};
var utils$4 = common;
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, [0]);
} catch (e) {
  STR_APPLY_OK = false;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (e) {
  STR_APPLY_UIA_OK = false;
}
for (_utf8len = new utils$4.Buf8(256), q = 0; q < 256; q++) _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
var _utf8len;
var q;
function buf2binstring(e, t) {
  if (t < 65534 && (e.subarray && STR_APPLY_UIA_OK || !e.subarray && STR_APPLY_OK)) return String.fromCharCode.apply(null, utils$4.shrinkBuf(e, t));
  for (var i = "", r = 0; r < t; r++) i += String.fromCharCode(e[r]);
  return i;
}
function ZStream$2() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
_utf8len[254] = _utf8len[254] = 1, strings$2.string2buf = function(e) {
  var t, i, r, o, n, s = e.length, a = 0;
  for (o = 0; o < s; o++) 55296 == (64512 & (i = e.charCodeAt(o))) && o + 1 < s && 56320 == (64512 & (r = e.charCodeAt(o + 1))) && (i = 65536 + (i - 55296 << 10) + (r - 56320), o++), a += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
  for (t = new utils$4.Buf8(a), n = 0, o = 0; n < a; o++) 55296 == (64512 & (i = e.charCodeAt(o))) && o + 1 < s && 56320 == (64512 & (r = e.charCodeAt(o + 1))) && (i = 65536 + (i - 55296 << 10) + (r - 56320), o++), i < 128 ? t[n++] = i : i < 2048 ? (t[n++] = 192 | i >>> 6, t[n++] = 128 | 63 & i) : i < 65536 ? (t[n++] = 224 | i >>> 12, t[n++] = 128 | i >>> 6 & 63, t[n++] = 128 | 63 & i) : (t[n++] = 240 | i >>> 18, t[n++] = 128 | i >>> 12 & 63, t[n++] = 128 | i >>> 6 & 63, t[n++] = 128 | 63 & i);
  return t;
}, strings$2.buf2binstring = function(e) {
  return buf2binstring(e, e.length);
}, strings$2.binstring2buf = function(e) {
  for (var t = new utils$4.Buf8(e.length), i = 0, r = t.length; i < r; i++) t[i] = e.charCodeAt(i);
  return t;
}, strings$2.buf2string = function(e, t) {
  var i, r, o, n, s = t || e.length, a = new Array(2 * s);
  for (r = 0, i = 0; i < s; ) if ((o = e[i++]) < 128) a[r++] = o;
  else if ((n = _utf8len[o]) > 4) a[r++] = 65533, i += n - 1;
  else {
    for (o &= 2 === n ? 31 : 3 === n ? 15 : 7; n > 1 && i < s; ) o = o << 6 | 63 & e[i++], n--;
    n > 1 ? a[r++] = 65533 : o < 65536 ? a[r++] = o : (o -= 65536, a[r++] = 55296 | o >> 10 & 1023, a[r++] = 56320 | 1023 & o);
  }
  return buf2binstring(a, r);
}, strings$2.utf8border = function(e, t) {
  var i;
  for ((t = t || e.length) > e.length && (t = e.length), i = t - 1; i >= 0 && 128 == (192 & e[i]); ) i--;
  return i < 0 || 0 === i ? t : i + _utf8len[e[i]] > t ? i : t;
};
var zstream = ZStream$2;
var zlib_deflate = deflate$3;
var utils$3 = common;
var strings$1 = strings$2;
var msg$1 = messages;
var ZStream$1 = zstream;
var toString$6 = Object.prototype.toString;
var Z_NO_FLUSH = 0;
var Z_FINISH$1 = 4;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_SYNC_FLUSH = 2;
var Z_DEFAULT_COMPRESSION = -1;
var Z_DEFAULT_STRATEGY = 0;
var Z_DEFLATED$1 = 8;
function Deflate(e) {
  if (!(this instanceof Deflate)) return new Deflate(e);
  this.options = utils$3.assign({ level: Z_DEFAULT_COMPRESSION, method: Z_DEFLATED$1, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Z_DEFAULT_STRATEGY, to: "" }, e || {});
  var t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new ZStream$1(), this.strm.avail_out = 0;
  var i = zlib_deflate.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
  if (i !== Z_OK$1) throw new Error(msg$1[i]);
  if (t.header && zlib_deflate.deflateSetHeader(this.strm, t.header), t.dictionary) {
    var r;
    if (r = "string" == typeof t.dictionary ? strings$1.string2buf(t.dictionary) : "[object ArrayBuffer]" === toString$6.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, (i = zlib_deflate.deflateSetDictionary(this.strm, r)) !== Z_OK$1) throw new Error(msg$1[i]);
    this._dict_set = true;
  }
}
function deflate$1(e, t) {
  var i = new Deflate(t);
  if (i.push(e, true), i.err) throw i.msg || msg$1[i.err];
  return i.result;
}
function deflateRaw(e, t) {
  return (t = t || {}).raw = true, deflate$1(e, t);
}
function gzip(e, t) {
  return (t = t || {}).gzip = true, deflate$1(e, t);
}
Deflate.prototype.push = function(e, t) {
  var i, r, o = this.strm, n = this.options.chunkSize;
  if (this.ended) return false;
  r = t === ~~t ? t : true === t ? Z_FINISH$1 : Z_NO_FLUSH, "string" == typeof e ? o.input = strings$1.string2buf(e) : "[object ArrayBuffer]" === toString$6.call(e) ? o.input = new Uint8Array(e) : o.input = e, o.next_in = 0, o.avail_in = o.input.length;
  do {
    if (0 === o.avail_out && (o.output = new utils$3.Buf8(n), o.next_out = 0, o.avail_out = n), (i = zlib_deflate.deflate(o, r)) !== Z_STREAM_END$1 && i !== Z_OK$1) return this.onEnd(i), this.ended = true, false;
    0 !== o.avail_out && (0 !== o.avail_in || r !== Z_FINISH$1 && r !== Z_SYNC_FLUSH) || ("string" === this.options.to ? this.onData(strings$1.buf2binstring(utils$3.shrinkBuf(o.output, o.next_out))) : this.onData(utils$3.shrinkBuf(o.output, o.next_out)));
  } while ((o.avail_in > 0 || 0 === o.avail_out) && i !== Z_STREAM_END$1);
  return r === Z_FINISH$1 ? (i = zlib_deflate.deflateEnd(this.strm), this.onEnd(i), this.ended = true, i === Z_OK$1) : r !== Z_SYNC_FLUSH || (this.onEnd(Z_OK$1), o.avail_out = 0, true);
}, Deflate.prototype.onData = function(e) {
  this.chunks.push(e);
}, Deflate.prototype.onEnd = function(e) {
  e === Z_OK$1 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = utils$3.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
}, deflate$4.Deflate = Deflate, deflate$4.deflate = deflate$1, deflate$4.deflateRaw = deflateRaw, deflate$4.gzip = gzip;
var inflate$4 = {};
var getRegExpFlags = regexpGetFlags;
var flags$6 = getRegExpFlags;
var isPrototypeOf$5 = objectIsPrototypeOf;
var flags$5 = flags$6;
var RegExpPrototype = RegExp.prototype;
var flags_1 = function(e) {
  return e === RegExpPrototype || isPrototypeOf$5(RegExpPrototype, e) ? flags$5(e) : e.flags;
};
var parent$n = flags_1;
var flags$4 = parent$n;
var parent$m = flags$4;
var flags$3 = parent$m;
var parent$l = flags$3;
var flags$2 = parent$l;
var flags$1 = flags$2;
var flags = flags$1;
var _flagsInstanceProperty = getDefaultExportFromCjs(flags);
var inflate$3 = {};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function(e, t) {
  var i, r, o, n, s, a, d, c2, l, u, h, _, p, m, S, g, v3, f, y, E, T, b, I, R, C;
  i = e.state, r = e.next_in, R = e.input, o = r + (e.avail_in - 5), n = e.next_out, C = e.output, s = n - (t - e.avail_out), a = n + (e.avail_out - 257), d = i.dmax, c2 = i.wsize, l = i.whave, u = i.wnext, h = i.window, _ = i.hold, p = i.bits, m = i.lencode, S = i.distcode, g = (1 << i.lenbits) - 1, v3 = (1 << i.distbits) - 1;
  e: do {
    p < 15 && (_ += R[r++] << p, p += 8, _ += R[r++] << p, p += 8), f = m[_ & g];
    t: for (; ; ) {
      if (_ >>>= y = f >>> 24, p -= y, 0 === (y = f >>> 16 & 255)) C[n++] = 65535 & f;
      else {
        if (!(16 & y)) {
          if (64 & y) {
            if (32 & y) {
              i.mode = TYPE$1;
              break e;
            }
            e.msg = "invalid literal/length code", i.mode = BAD$1;
            break e;
          }
          f = m[(65535 & f) + (_ & (1 << y) - 1)];
          continue t;
        }
        for (E = 65535 & f, (y &= 15) && (p < y && (_ += R[r++] << p, p += 8), E += _ & (1 << y) - 1, _ >>>= y, p -= y), p < 15 && (_ += R[r++] << p, p += 8, _ += R[r++] << p, p += 8), f = S[_ & v3]; ; ) {
          if (_ >>>= y = f >>> 24, p -= y, 16 & (y = f >>> 16 & 255)) {
            if (T = 65535 & f, p < (y &= 15) && (_ += R[r++] << p, (p += 8) < y && (_ += R[r++] << p, p += 8)), (T += _ & (1 << y) - 1) > d) {
              e.msg = "invalid distance too far back", i.mode = BAD$1;
              break e;
            }
            if (_ >>>= y, p -= y, T > (y = n - s)) {
              if ((y = T - y) > l && i.sane) {
                e.msg = "invalid distance too far back", i.mode = BAD$1;
                break e;
              }
              if (b = 0, I = h, 0 === u) {
                if (b += c2 - y, y < E) {
                  E -= y;
                  do {
                    C[n++] = h[b++];
                  } while (--y);
                  b = n - T, I = C;
                }
              } else if (u < y) {
                if (b += c2 + u - y, (y -= u) < E) {
                  E -= y;
                  do {
                    C[n++] = h[b++];
                  } while (--y);
                  if (b = 0, u < E) {
                    E -= y = u;
                    do {
                      C[n++] = h[b++];
                    } while (--y);
                    b = n - T, I = C;
                  }
                }
              } else if (b += u - y, y < E) {
                E -= y;
                do {
                  C[n++] = h[b++];
                } while (--y);
                b = n - T, I = C;
              }
              for (; E > 2; ) C[n++] = I[b++], C[n++] = I[b++], C[n++] = I[b++], E -= 3;
              E && (C[n++] = I[b++], E > 1 && (C[n++] = I[b++]));
            } else {
              b = n - T;
              do {
                C[n++] = C[b++], C[n++] = C[b++], C[n++] = C[b++], E -= 3;
              } while (E > 2);
              E && (C[n++] = C[b++], E > 1 && (C[n++] = C[b++]));
            }
            break;
          }
          if (64 & y) {
            e.msg = "invalid distance code", i.mode = BAD$1;
            break e;
          }
          f = S[(65535 & f) + (_ & (1 << y) - 1)];
        }
      }
      break;
    }
  } while (r < o && n < a);
  r -= E = p >> 3, _ &= (1 << (p -= E << 3)) - 1, e.next_in = r, e.next_out = n, e.avail_in = r < o ? o - r + 5 : 5 - (r - o), e.avail_out = n < a ? a - n + 257 : 257 - (n - a), i.hold = _, i.bits = p;
};
var utils$2 = common;
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
var inftrees = function(e, t, i, r, o, n, s, a) {
  var d, c2, l, u, h, _, p, m, S, g = a.bits, v3 = 0, f = 0, y = 0, E = 0, T = 0, b = 0, I = 0, R = 0, C = 0, P = 0, A = null, O = 0, k = new utils$2.Buf16(MAXBITS + 1), N = new utils$2.Buf16(MAXBITS + 1), w = null, M = 0;
  for (v3 = 0; v3 <= MAXBITS; v3++) k[v3] = 0;
  for (f = 0; f < r; f++) k[t[i + f]]++;
  for (T = g, E = MAXBITS; E >= 1 && 0 === k[E]; E--) ;
  if (T > E && (T = E), 0 === E) return o[n++] = 20971520, o[n++] = 20971520, a.bits = 1, 0;
  for (y = 1; y < E && 0 === k[y]; y++) ;
  for (T < y && (T = y), R = 1, v3 = 1; v3 <= MAXBITS; v3++) if (R <<= 1, (R -= k[v3]) < 0) return -1;
  if (R > 0 && (e === CODES$1 || 1 !== E)) return -1;
  for (N[1] = 0, v3 = 1; v3 < MAXBITS; v3++) N[v3 + 1] = N[v3] + k[v3];
  for (f = 0; f < r; f++) 0 !== t[i + f] && (s[N[t[i + f]]++] = f);
  if (e === CODES$1 ? (A = w = s, _ = 19) : e === LENS$1 ? (A = lbase, O -= 257, w = lext, M -= 257, _ = 256) : (A = dbase, w = dext, _ = -1), P = 0, f = 0, v3 = y, h = n, b = T, I = 0, l = -1, u = (C = 1 << T) - 1, e === LENS$1 && C > ENOUGH_LENS$1 || e === DISTS$1 && C > ENOUGH_DISTS$1) return 1;
  for (; ; ) {
    p = v3 - I, s[f] < _ ? (m = 0, S = s[f]) : s[f] > _ ? (m = w[M + s[f]], S = A[O + s[f]]) : (m = 96, S = 0), d = 1 << v3 - I, y = c2 = 1 << b;
    do {
      o[h + (P >> I) + (c2 -= d)] = p << 24 | m << 16 | S;
    } while (0 !== c2);
    for (d = 1 << v3 - 1; P & d; ) d >>= 1;
    if (0 !== d ? (P &= d - 1, P += d) : P = 0, f++, 0 == --k[v3]) {
      if (v3 === E) break;
      v3 = t[i + s[f]];
    }
    if (v3 > T && (P & u) !== l) {
      for (0 === I && (I = T), h += y, R = 1 << (b = v3 - I); b + I < E && !((R -= k[b + I]) <= 0); ) b++, R <<= 1;
      if (C += 1 << b, e === LENS$1 && C > ENOUGH_LENS$1 || e === DISTS$1 && C > ENOUGH_DISTS$1) return 1;
      o[l = P & u] = T << 24 | b << 16 | h - n;
    }
  }
  return 0 !== P && (o[h + P] = v3 - I << 24 | 64 << 16), a.bits = T, 0;
};
var utils$1 = common;
var adler32 = adler32_1;
var crc32 = crc32_1;
var inflate_fast2 = inffast;
var inflate_table2 = inftrees;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH$1 = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
function zswap32(e) {
  return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
}
function InflateState() {
  this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new utils$1.Buf16(320), this.work = new utils$1.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
function inflateResetKeep(e) {
  var t;
  return e && e.state ? (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = HEAD, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new utils$1.Buf32(ENOUGH_LENS), t.distcode = t.distdyn = new utils$1.Buf32(ENOUGH_DISTS), t.sane = 1, t.back = -1, Z_OK) : Z_STREAM_ERROR;
}
function inflateReset(e) {
  var t;
  return e && e.state ? ((t = e.state).wsize = 0, t.whave = 0, t.wnext = 0, inflateResetKeep(e)) : Z_STREAM_ERROR;
}
function inflateReset2(e, t) {
  var i, r;
  return e && e.state ? (r = e.state, t < 0 ? (i = 0, t = -t) : (i = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Z_STREAM_ERROR : (null !== r.window && r.wbits !== t && (r.window = null), r.wrap = i, r.wbits = t, inflateReset(e))) : Z_STREAM_ERROR;
}
function inflateInit2(e, t) {
  var i, r;
  return e ? (r = new InflateState(), e.state = r, r.window = null, (i = inflateReset2(e, t)) !== Z_OK && (e.state = null), i) : Z_STREAM_ERROR;
}
function inflateInit(e) {
  return inflateInit2(e, DEF_WBITS);
}
var lenfix;
var distfix;
var virgin = true;
function fixedtables(e) {
  if (virgin) {
    var t;
    for (lenfix = new utils$1.Buf32(512), distfix = new utils$1.Buf32(32), t = 0; t < 144; ) e.lens[t++] = 8;
    for (; t < 256; ) e.lens[t++] = 9;
    for (; t < 280; ) e.lens[t++] = 7;
    for (; t < 288; ) e.lens[t++] = 8;
    for (inflate_table2(LENS, e.lens, 0, 288, lenfix, 0, e.work, { bits: 9 }), t = 0; t < 32; ) e.lens[t++] = 5;
    inflate_table2(DISTS, e.lens, 0, 32, distfix, 0, e.work, { bits: 5 }), virgin = false;
  }
  e.lencode = lenfix, e.lenbits = 9, e.distcode = distfix, e.distbits = 5;
}
function updatewindow(e, t, i, r) {
  var o, n = e.state;
  return null === n.window && (n.wsize = 1 << n.wbits, n.wnext = 0, n.whave = 0, n.window = new utils$1.Buf8(n.wsize)), r >= n.wsize ? (utils$1.arraySet(n.window, t, i - n.wsize, n.wsize, 0), n.wnext = 0, n.whave = n.wsize) : ((o = n.wsize - n.wnext) > r && (o = r), utils$1.arraySet(n.window, t, i - r, o, n.wnext), (r -= o) ? (utils$1.arraySet(n.window, t, i - r, r, 0), n.wnext = r, n.whave = n.wsize) : (n.wnext += o, n.wnext === n.wsize && (n.wnext = 0), n.whave < n.wsize && (n.whave += o))), 0;
}
function inflate$2(e, t) {
  var i, r, o, n, s, a, d, c2, l, u, h, _, p, m, S, g, v3, f, y, E, T, b, I, R, C = 0, P = new utils$1.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return Z_STREAM_ERROR;
  (i = e.state).mode === TYPE && (i.mode = TYPEDO), s = e.next_out, o = e.output, d = e.avail_out, n = e.next_in, r = e.input, a = e.avail_in, c2 = i.hold, l = i.bits, u = a, h = d, b = Z_OK;
  e: for (; ; ) switch (i.mode) {
    case HEAD:
      if (0 === i.wrap) {
        i.mode = TYPEDO;
        break;
      }
      for (; l < 16; ) {
        if (0 === a) break e;
        a--, c2 += r[n++] << l, l += 8;
      }
      if (2 & i.wrap && 35615 === c2) {
        i.check = 0, P[0] = 255 & c2, P[1] = c2 >>> 8 & 255, i.check = crc32(i.check, P, 2, 0), c2 = 0, l = 0, i.mode = FLAGS;
        break;
      }
      if (i.flags = 0, i.head && (i.head.done = false), !(1 & i.wrap) || (((255 & c2) << 8) + (c2 >> 8)) % 31) {
        e.msg = "incorrect header check", i.mode = BAD;
        break;
      }
      if ((15 & c2) !== Z_DEFLATED) {
        e.msg = "unknown compression method", i.mode = BAD;
        break;
      }
      if (l -= 4, T = 8 + (15 & (c2 >>>= 4)), 0 === i.wbits) i.wbits = T;
      else if (T > i.wbits) {
        e.msg = "invalid window size", i.mode = BAD;
        break;
      }
      i.dmax = 1 << T, e.adler = i.check = 1, i.mode = 512 & c2 ? DICTID : TYPE, c2 = 0, l = 0;
      break;
    case FLAGS:
      for (; l < 16; ) {
        if (0 === a) break e;
        a--, c2 += r[n++] << l, l += 8;
      }
      if (i.flags = c2, (255 & _flagsInstanceProperty(i)) !== Z_DEFLATED) {
        e.msg = "unknown compression method", i.mode = BAD;
        break;
      }
      if (57344 & _flagsInstanceProperty(i)) {
        e.msg = "unknown header flags set", i.mode = BAD;
        break;
      }
      i.head && (i.head.text = c2 >> 8 & 1), 512 & _flagsInstanceProperty(i) && (P[0] = 255 & c2, P[1] = c2 >>> 8 & 255, i.check = crc32(i.check, P, 2, 0)), c2 = 0, l = 0, i.mode = TIME;
    case TIME:
      for (; l < 32; ) {
        if (0 === a) break e;
        a--, c2 += r[n++] << l, l += 8;
      }
      i.head && (i.head.time = c2), 512 & _flagsInstanceProperty(i) && (P[0] = 255 & c2, P[1] = c2 >>> 8 & 255, P[2] = c2 >>> 16 & 255, P[3] = c2 >>> 24 & 255, i.check = crc32(i.check, P, 4, 0)), c2 = 0, l = 0, i.mode = OS;
    case OS:
      for (; l < 16; ) {
        if (0 === a) break e;
        a--, c2 += r[n++] << l, l += 8;
      }
      i.head && (i.head.xflags = 255 & c2, i.head.os = c2 >> 8), 512 & _flagsInstanceProperty(i) && (P[0] = 255 & c2, P[1] = c2 >>> 8 & 255, i.check = crc32(i.check, P, 2, 0)), c2 = 0, l = 0, i.mode = EXLEN;
    case EXLEN:
      if (1024 & _flagsInstanceProperty(i)) {
        for (; l < 16; ) {
          if (0 === a) break e;
          a--, c2 += r[n++] << l, l += 8;
        }
        i.length = c2, i.head && (i.head.extra_len = c2), 512 & _flagsInstanceProperty(i) && (P[0] = 255 & c2, P[1] = c2 >>> 8 & 255, i.check = crc32(i.check, P, 2, 0)), c2 = 0, l = 0;
      } else i.head && (i.head.extra = null);
      i.mode = EXTRA;
    case EXTRA:
      if (1024 & _flagsInstanceProperty(i) && ((_ = i.length) > a && (_ = a), _ && (i.head && (T = i.head.extra_len - i.length, i.head.extra || (i.head.extra = new Array(i.head.extra_len)), utils$1.arraySet(i.head.extra, r, n, _, T)), 512 & _flagsInstanceProperty(i) && (i.check = crc32(i.check, r, _, n)), a -= _, n += _, i.length -= _), i.length)) break e;
      i.length = 0, i.mode = NAME;
    case NAME:
      if (2048 & _flagsInstanceProperty(i)) {
        if (0 === a) break e;
        _ = 0;
        do {
          T = r[n + _++], i.head && T && i.length < 65536 && (i.head.name += String.fromCharCode(T));
        } while (T && _ < a);
        if (512 & _flagsInstanceProperty(i) && (i.check = crc32(i.check, r, _, n)), a -= _, n += _, T) break e;
      } else i.head && (i.head.name = null);
      i.length = 0, i.mode = COMMENT;
    case COMMENT:
      if (4096 & _flagsInstanceProperty(i)) {
        if (0 === a) break e;
        _ = 0;
        do {
          T = r[n + _++], i.head && T && i.length < 65536 && (i.head.comment += String.fromCharCode(T));
        } while (T && _ < a);
        if (512 & _flagsInstanceProperty(i) && (i.check = crc32(i.check, r, _, n)), a -= _, n += _, T) break e;
      } else i.head && (i.head.comment = null);
      i.mode = HCRC;
    case HCRC:
      if (512 & _flagsInstanceProperty(i)) {
        for (; l < 16; ) {
          if (0 === a) break e;
          a--, c2 += r[n++] << l, l += 8;
        }
        if (c2 !== (65535 & i.check)) {
          e.msg = "header crc mismatch", i.mode = BAD;
          break;
        }
        c2 = 0, l = 0;
      }
      i.head && (i.head.hcrc = _flagsInstanceProperty(i) >> 9 & 1, i.head.done = true), e.adler = i.check = 0, i.mode = TYPE;
      break;
    case DICTID:
      for (; l < 32; ) {
        if (0 === a) break e;
        a--, c2 += r[n++] << l, l += 8;
      }
      e.adler = i.check = zswap32(c2), c2 = 0, l = 0, i.mode = DICT;
    case DICT:
      if (0 === i.havedict) return e.next_out = s, e.avail_out = d, e.next_in = n, e.avail_in = a, i.hold = c2, i.bits = l, Z_NEED_DICT;
      e.adler = i.check = 1, i.mode = TYPE;
    case TYPE:
      if (t === Z_BLOCK || t === Z_TREES) break e;
    case TYPEDO:
      if (i.last) {
        c2 >>>= 7 & l, l -= 7 & l, i.mode = CHECK;
        break;
      }
      for (; l < 3; ) {
        if (0 === a) break e;
        a--, c2 += r[n++] << l, l += 8;
      }
      switch (i.last = 1 & c2, l -= 1, 3 & (c2 >>>= 1)) {
        case 0:
          i.mode = STORED;
          break;
        case 1:
          if (fixedtables(i), i.mode = LEN_, t === Z_TREES) {
            c2 >>>= 2, l -= 2;
            break e;
          }
          break;
        case 2:
          i.mode = TABLE;
          break;
        case 3:
          e.msg = "invalid block type", i.mode = BAD;
      }
      c2 >>>= 2, l -= 2;
      break;
    case STORED:
      for (c2 >>>= 7 & l, l -= 7 & l; l < 32; ) {
        if (0 === a) break e;
        a--, c2 += r[n++] << l, l += 8;
      }
      if ((65535 & c2) != (c2 >>> 16 ^ 65535)) {
        e.msg = "invalid stored block lengths", i.mode = BAD;
        break;
      }
      if (i.length = 65535 & c2, c2 = 0, l = 0, i.mode = COPY_, t === Z_TREES) break e;
    case COPY_:
      i.mode = COPY;
    case COPY:
      if (_ = i.length) {
        if (_ > a && (_ = a), _ > d && (_ = d), 0 === _) break e;
        utils$1.arraySet(o, r, n, _, s), a -= _, n += _, d -= _, s += _, i.length -= _;
        break;
      }
      i.mode = TYPE;
      break;
    case TABLE:
      for (; l < 14; ) {
        if (0 === a) break e;
        a--, c2 += r[n++] << l, l += 8;
      }
      if (i.nlen = 257 + (31 & c2), c2 >>>= 5, l -= 5, i.ndist = 1 + (31 & c2), c2 >>>= 5, l -= 5, i.ncode = 4 + (15 & c2), c2 >>>= 4, l -= 4, i.nlen > 286 || i.ndist > 30) {
        e.msg = "too many length or distance symbols", i.mode = BAD;
        break;
      }
      i.have = 0, i.mode = LENLENS;
    case LENLENS:
      for (; i.have < i.ncode; ) {
        for (; l < 3; ) {
          if (0 === a) break e;
          a--, c2 += r[n++] << l, l += 8;
        }
        i.lens[A[i.have++]] = 7 & c2, c2 >>>= 3, l -= 3;
      }
      for (; i.have < 19; ) i.lens[A[i.have++]] = 0;
      if (i.lencode = i.lendyn, i.lenbits = 7, I = { bits: i.lenbits }, b = inflate_table2(CODES, i.lens, 0, 19, i.lencode, 0, i.work, I), i.lenbits = I.bits, b) {
        e.msg = "invalid code lengths set", i.mode = BAD;
        break;
      }
      i.have = 0, i.mode = CODELENS;
    case CODELENS:
      for (; i.have < i.nlen + i.ndist; ) {
        for (; g = (C = i.lencode[c2 & (1 << i.lenbits) - 1]) >>> 16 & 255, v3 = 65535 & C, !((S = C >>> 24) <= l); ) {
          if (0 === a) break e;
          a--, c2 += r[n++] << l, l += 8;
        }
        if (v3 < 16) c2 >>>= S, l -= S, i.lens[i.have++] = v3;
        else {
          if (16 === v3) {
            for (R = S + 2; l < R; ) {
              if (0 === a) break e;
              a--, c2 += r[n++] << l, l += 8;
            }
            if (c2 >>>= S, l -= S, 0 === i.have) {
              e.msg = "invalid bit length repeat", i.mode = BAD;
              break;
            }
            T = i.lens[i.have - 1], _ = 3 + (3 & c2), c2 >>>= 2, l -= 2;
          } else if (17 === v3) {
            for (R = S + 3; l < R; ) {
              if (0 === a) break e;
              a--, c2 += r[n++] << l, l += 8;
            }
            l -= S, T = 0, _ = 3 + (7 & (c2 >>>= S)), c2 >>>= 3, l -= 3;
          } else {
            for (R = S + 7; l < R; ) {
              if (0 === a) break e;
              a--, c2 += r[n++] << l, l += 8;
            }
            l -= S, T = 0, _ = 11 + (127 & (c2 >>>= S)), c2 >>>= 7, l -= 7;
          }
          if (i.have + _ > i.nlen + i.ndist) {
            e.msg = "invalid bit length repeat", i.mode = BAD;
            break;
          }
          for (; _--; ) i.lens[i.have++] = T;
        }
      }
      if (i.mode === BAD) break;
      if (0 === i.lens[256]) {
        e.msg = "invalid code -- missing end-of-block", i.mode = BAD;
        break;
      }
      if (i.lenbits = 9, I = { bits: i.lenbits }, b = inflate_table2(LENS, i.lens, 0, i.nlen, i.lencode, 0, i.work, I), i.lenbits = I.bits, b) {
        e.msg = "invalid literal/lengths set", i.mode = BAD;
        break;
      }
      if (i.distbits = 6, i.distcode = i.distdyn, I = { bits: i.distbits }, b = inflate_table2(DISTS, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, I), i.distbits = I.bits, b) {
        e.msg = "invalid distances set", i.mode = BAD;
        break;
      }
      if (i.mode = LEN_, t === Z_TREES) break e;
    case LEN_:
      i.mode = LEN;
    case LEN:
      if (a >= 6 && d >= 258) {
        e.next_out = s, e.avail_out = d, e.next_in = n, e.avail_in = a, i.hold = c2, i.bits = l, inflate_fast2(e, h), s = e.next_out, o = e.output, d = e.avail_out, n = e.next_in, r = e.input, a = e.avail_in, c2 = i.hold, l = i.bits, i.mode === TYPE && (i.back = -1);
        break;
      }
      for (i.back = 0; g = (C = i.lencode[c2 & (1 << i.lenbits) - 1]) >>> 16 & 255, v3 = 65535 & C, !((S = C >>> 24) <= l); ) {
        if (0 === a) break e;
        a--, c2 += r[n++] << l, l += 8;
      }
      if (g && !(240 & g)) {
        for (f = S, y = g, E = v3; g = (C = i.lencode[E + ((c2 & (1 << f + y) - 1) >> f)]) >>> 16 & 255, v3 = 65535 & C, !(f + (S = C >>> 24) <= l); ) {
          if (0 === a) break e;
          a--, c2 += r[n++] << l, l += 8;
        }
        c2 >>>= f, l -= f, i.back += f;
      }
      if (c2 >>>= S, l -= S, i.back += S, i.length = v3, 0 === g) {
        i.mode = LIT;
        break;
      }
      if (32 & g) {
        i.back = -1, i.mode = TYPE;
        break;
      }
      if (64 & g) {
        e.msg = "invalid literal/length code", i.mode = BAD;
        break;
      }
      i.extra = 15 & g, i.mode = LENEXT;
    case LENEXT:
      if (i.extra) {
        for (R = i.extra; l < R; ) {
          if (0 === a) break e;
          a--, c2 += r[n++] << l, l += 8;
        }
        i.length += c2 & (1 << i.extra) - 1, c2 >>>= i.extra, l -= i.extra, i.back += i.extra;
      }
      i.was = i.length, i.mode = DIST;
    case DIST:
      for (; g = (C = i.distcode[c2 & (1 << i.distbits) - 1]) >>> 16 & 255, v3 = 65535 & C, !((S = C >>> 24) <= l); ) {
        if (0 === a) break e;
        a--, c2 += r[n++] << l, l += 8;
      }
      if (!(240 & g)) {
        for (f = S, y = g, E = v3; g = (C = i.distcode[E + ((c2 & (1 << f + y) - 1) >> f)]) >>> 16 & 255, v3 = 65535 & C, !(f + (S = C >>> 24) <= l); ) {
          if (0 === a) break e;
          a--, c2 += r[n++] << l, l += 8;
        }
        c2 >>>= f, l -= f, i.back += f;
      }
      if (c2 >>>= S, l -= S, i.back += S, 64 & g) {
        e.msg = "invalid distance code", i.mode = BAD;
        break;
      }
      i.offset = v3, i.extra = 15 & g, i.mode = DISTEXT;
    case DISTEXT:
      if (i.extra) {
        for (R = i.extra; l < R; ) {
          if (0 === a) break e;
          a--, c2 += r[n++] << l, l += 8;
        }
        i.offset += c2 & (1 << i.extra) - 1, c2 >>>= i.extra, l -= i.extra, i.back += i.extra;
      }
      if (i.offset > i.dmax) {
        e.msg = "invalid distance too far back", i.mode = BAD;
        break;
      }
      i.mode = MATCH$1;
    case MATCH$1:
      if (0 === d) break e;
      if (_ = h - d, i.offset > _) {
        if ((_ = i.offset - _) > i.whave && i.sane) {
          e.msg = "invalid distance too far back", i.mode = BAD;
          break;
        }
        _ > i.wnext ? (_ -= i.wnext, p = i.wsize - _) : p = i.wnext - _, _ > i.length && (_ = i.length), m = i.window;
      } else m = o, p = s - i.offset, _ = i.length;
      _ > d && (_ = d), d -= _, i.length -= _;
      do {
        o[s++] = m[p++];
      } while (--_);
      0 === i.length && (i.mode = LEN);
      break;
    case LIT:
      if (0 === d) break e;
      o[s++] = i.length, d--, i.mode = LEN;
      break;
    case CHECK:
      if (i.wrap) {
        for (; l < 32; ) {
          if (0 === a) break e;
          a--, c2 |= r[n++] << l, l += 8;
        }
        if (h -= d, e.total_out += h, i.total += h, h && (e.adler = i.check = _flagsInstanceProperty(i) ? crc32(i.check, o, h, s - h) : adler32(i.check, o, h, s - h)), h = d, (_flagsInstanceProperty(i) ? c2 : zswap32(c2)) !== i.check) {
          e.msg = "incorrect data check", i.mode = BAD;
          break;
        }
        c2 = 0, l = 0;
      }
      i.mode = LENGTH;
    case LENGTH:
      if (i.wrap && _flagsInstanceProperty(i)) {
        for (; l < 32; ) {
          if (0 === a) break e;
          a--, c2 += r[n++] << l, l += 8;
        }
        if (c2 !== (4294967295 & i.total)) {
          e.msg = "incorrect length check", i.mode = BAD;
          break;
        }
        c2 = 0, l = 0;
      }
      i.mode = DONE;
    case DONE:
      b = Z_STREAM_END;
      break e;
    case BAD:
      b = Z_DATA_ERROR;
      break e;
    case MEM:
      return Z_MEM_ERROR;
    default:
      return Z_STREAM_ERROR;
  }
  return e.next_out = s, e.avail_out = d, e.next_in = n, e.avail_in = a, i.hold = c2, i.bits = l, (i.wsize || h !== e.avail_out && i.mode < BAD && (i.mode < CHECK || t !== Z_FINISH)) && updatewindow(e, e.output, e.next_out, h - e.avail_out), u -= e.avail_in, h -= e.avail_out, e.total_in += u, e.total_out += h, i.total += h, i.wrap && h && (e.adler = i.check = _flagsInstanceProperty(i) ? crc32(i.check, o, h, e.next_out - h) : adler32(i.check, o, h, e.next_out - h)), e.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === TYPE ? 128 : 0) + (i.mode === LEN_ || i.mode === COPY_ ? 256 : 0), (0 === u && 0 === h || t === Z_FINISH) && b === Z_OK && (b = Z_BUF_ERROR), b;
}
function inflateEnd(e) {
  if (!e || !e.state) return Z_STREAM_ERROR;
  var t = e.state;
  return t.window && (t.window = null), e.state = null, Z_OK;
}
function inflateGetHeader(e, t) {
  var i;
  return e && e.state && 2 & (i = e.state).wrap ? (i.head = t, t.done = false, Z_OK) : Z_STREAM_ERROR;
}
function inflateSetDictionary(e, t) {
  var i, r = t.length;
  return e && e.state ? 0 !== (i = e.state).wrap && i.mode !== DICT ? Z_STREAM_ERROR : i.mode === DICT && adler32(1, t, r, 0) !== i.check ? Z_DATA_ERROR : updatewindow(e, t, r, r) ? (i.mode = MEM, Z_MEM_ERROR) : (i.havedict = 1, Z_OK) : Z_STREAM_ERROR;
}
inflate$3.inflateReset = inflateReset, inflate$3.inflateReset2 = inflateReset2, inflate$3.inflateResetKeep = inflateResetKeep, inflate$3.inflateInit = inflateInit, inflate$3.inflateInit2 = inflateInit2, inflate$3.inflate = inflate$2, inflate$3.inflateEnd = inflateEnd, inflate$3.inflateGetHeader = inflateGetHeader, inflate$3.inflateSetDictionary = inflateSetDictionary, inflate$3.inflateInfo = "pako inflate (from Nodeca project)";
var constants$1 = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
function GZheader$1() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
}
var gzheader = GZheader$1;
var zlib_inflate = inflate$3;
var utils = common;
var strings = strings$2;
var c = constants$1;
var msg = messages;
var ZStream = zstream;
var GZheader = gzheader;
var toString$5 = Object.prototype.toString;
function Inflate(e) {
  if (!(this instanceof Inflate)) return new Inflate(e);
  this.options = utils.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e || {});
  var t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (15 & t.windowBits || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new ZStream(), this.strm.avail_out = 0;
  var i = zlib_inflate.inflateInit2(this.strm, t.windowBits);
  if (i !== c.Z_OK) throw new Error(msg[i]);
  if (this.header = new GZheader(), zlib_inflate.inflateGetHeader(this.strm, this.header), t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = strings.string2buf(t.dictionary) : "[object ArrayBuffer]" === toString$5.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (i = zlib_inflate.inflateSetDictionary(this.strm, t.dictionary)) !== c.Z_OK)) throw new Error(msg[i]);
}
function inflate$1(e, t) {
  var i = new Inflate(t);
  if (i.push(e, true), i.err) throw i.msg || msg[i.err];
  return i.result;
}
function inflateRaw(e, t) {
  return (t = t || {}).raw = true, inflate$1(e, t);
}
Inflate.prototype.push = function(e, t) {
  var i, r, o, n, s, a = this.strm, d = this.options.chunkSize, l = this.options.dictionary, u = false;
  if (this.ended) return false;
  r = t === ~~t ? t : true === t ? c.Z_FINISH : c.Z_NO_FLUSH, "string" == typeof e ? a.input = strings.binstring2buf(e) : "[object ArrayBuffer]" === toString$5.call(e) ? a.input = new Uint8Array(e) : a.input = e, a.next_in = 0, a.avail_in = a.input.length;
  do {
    if (0 === a.avail_out && (a.output = new utils.Buf8(d), a.next_out = 0, a.avail_out = d), (i = zlib_inflate.inflate(a, c.Z_NO_FLUSH)) === c.Z_NEED_DICT && l && (i = zlib_inflate.inflateSetDictionary(this.strm, l)), i === c.Z_BUF_ERROR && true === u && (i = c.Z_OK, u = false), i !== c.Z_STREAM_END && i !== c.Z_OK) return this.onEnd(i), this.ended = true, false;
    a.next_out && (0 !== a.avail_out && i !== c.Z_STREAM_END && (0 !== a.avail_in || r !== c.Z_FINISH && r !== c.Z_SYNC_FLUSH) || ("string" === this.options.to ? (o = strings.utf8border(a.output, a.next_out), n = a.next_out - o, s = strings.buf2string(a.output, o), a.next_out = n, a.avail_out = d - n, n && utils.arraySet(a.output, a.output, o, n, 0), this.onData(s)) : this.onData(utils.shrinkBuf(a.output, a.next_out)))), 0 === a.avail_in && 0 === a.avail_out && (u = true);
  } while ((a.avail_in > 0 || 0 === a.avail_out) && i !== c.Z_STREAM_END);
  return i === c.Z_STREAM_END && (r = c.Z_FINISH), r === c.Z_FINISH ? (i = zlib_inflate.inflateEnd(this.strm), this.onEnd(i), this.ended = true, i === c.Z_OK) : r !== c.Z_SYNC_FLUSH || (this.onEnd(c.Z_OK), a.avail_out = 0, true);
}, Inflate.prototype.onData = function(e) {
  this.chunks.push(e);
}, Inflate.prototype.onEnd = function(e) {
  e === c.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = utils.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
}, inflate$4.Inflate = Inflate, inflate$4.inflate = inflate$1, inflate$4.inflateRaw = inflateRaw, inflate$4.ungzip = inflate$1;
var assign$1 = common.assign;
var deflate = deflate$4;
var inflate = inflate$4;
var constants = constants$1;
var pako = {};
assign$1(pako, deflate, inflate, constants);
var pako_1 = pako;
var pako$1 = getDefaultExportFromCjs(pako_1);
var lockId$1 = 1;
var PromiseLock$1 = class {
  constructor(e) {
    _defineProperty(this, "lockingPromise", Promise.resolve()), _defineProperty(this, "locks", 0), _defineProperty(this, "name", ""), _defineProperty(this, "lockId", void 0), this.lockId = lockId$1++, e && (this.name = e);
  }
  get isLocked() {
    return this.locks > 0;
  }
  lock() {
    let e;
    this.locks += 1;
    const t = new Promise((t2) => {
      e = () => {
        this.locks -= 1, t2();
      };
    }), i = this.lockingPromise.then(() => e);
    return this.lockingPromise = this.lockingPromise.then(() => t), i;
  }
};
var DB_NAME = "VERTC";
var indexedDB$1 = () => window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
var IndexedDBInterface = class _IndexedDBInterface {
  constructor(e) {
    _defineProperty(this, "storeName", void 0), _defineProperty(this, "pendingList", []), this.storeName = e, !isSSR$1() && indexedDB$1() && this._checkAndCreateStore(e);
  }
  async _checkAndCreateStore(e, t) {
    const i = await _IndexedDBInterface._promiseLock.lock();
    if (indexedDB$1().databases) {
      let e2;
      await new Promise((t2) => {
        const i2 = () => indexedDB$1().databases().finally(t2);
        e2 = setInterval(i2, 100), i2();
      }).finally(() => clearInterval(e2));
    }
    return new Promise((r) => {
      _IndexedDBInterface.db && (_IndexedDBInterface.db.close(), delete _IndexedDBInterface.db);
      const o = t ? indexedDB$1().open(DB_NAME, t) : indexedDB$1().open(DB_NAME);
      o.onupgradeneeded = () => {
        o.result.createObjectStore(e);
      }, o.onerror = () => {
        console.error("IndexedDBInterface error", o.error);
      }, o.onsuccess = () => {
        const t2 = o.result;
        _IndexedDBInterface.db = t2;
        try {
          _IndexedDBInterface.db.transaction(this.storeName, "readonly"), this.pendingList.forEach(async (e2) => {
            let { txMode: t3, pendResolve: i2, pendReject: r2 } = e2;
            try {
              i2(await this._getStore(t3));
            } catch (e3) {
              r2();
            }
          }), r();
        } catch (i2) {
          r(this._checkAndCreateStore(e, t2.version + 1));
        } finally {
          i();
        }
      };
    });
  }
  async _getStore(e) {
    const t = await _IndexedDBInterface._promiseLock.lock();
    return new Promise((i, r) => {
      if (!_IndexedDBInterface.db) return this.pendingList.push({ txMode: e, pendResolve: i, pendReject: r }), void t();
      try {
        i(_IndexedDBInterface.db.transaction(this.storeName, e).objectStore(this.storeName));
      } catch (t2) {
        return void this.pendingList.push({ txMode: e, pendResolve: i, pendReject: r });
      } finally {
        t();
      }
    });
  }
  async put2String(e, t) {
    let i;
    try {
      i = JSON.stringify(e);
    } catch (t2) {
      i = e;
    }
    return await this.put(i, t);
  }
  async get4String(e) {
    const t = await this.get(e);
    let i;
    try {
      i = JSON.parse(t);
    } catch (e2) {
      i = t;
    }
    return i;
  }
  async put(e, t) {
    const i = await this._getStore("readwrite");
    return new Promise((r, o) => {
      const n = i.put(e, t);
      n.onsuccess = () => {
        r();
      }, n.onerror = (e2) => {
        o(e2);
      };
    });
  }
  async get(e) {
    const t = await this._getStore("readonly");
    return new Promise((i, r) => {
      const o = t.get(e);
      o.onsuccess = () => {
        i(o.result);
      }, o.onerror = (e2) => {
        r(e2);
      };
    });
  }
  async del(e) {
    const t = await this._getStore("readwrite");
    return new Promise((i, r) => {
      const o = t.delete(e);
      o.onsuccess = () => {
        i();
      }, o.onerror = (e2) => {
        r(e2);
      };
    });
  }
};
_defineProperty(IndexedDBInterface, "db", void 0), _defineProperty(IndexedDBInterface, "state", "init"), _defineProperty(IndexedDBInterface, "_promiseLock", new PromiseLock$1("iDB"));
var $$l = _export;
var $includes = arrayIncludes.includes;
var fails$7 = fails$s;
var BROKEN_ON_SPARSE = fails$7(function() {
  return !Array(1).includes();
});
$$l({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, { includes: function(e) {
  return $includes(this, e, arguments.length > 1 ? arguments[1] : void 0);
} });
var getBuiltInPrototypeMethod$2 = getBuiltInPrototypeMethod$a;
var includes$6 = getBuiltInPrototypeMethod$2("Array", "includes");
var isRegExp = isRegexp;
var $TypeError$7 = TypeError;
var notARegexp = function(e) {
  if (isRegExp(e)) throw new $TypeError$7("The method doesn't accept regular expressions");
  return e;
};
var wellKnownSymbol$9 = wellKnownSymbol$q;
var MATCH = wellKnownSymbol$9("match");
var correctIsRegexpLogic = function(e) {
  var t = /./;
  try {
    "/./"[e](t);
  } catch (i) {
    try {
      return t[MATCH] = false, "/./"[e](t);
    } catch (e2) {
    }
  }
  return false;
};
var $$k = _export;
var uncurryThis$7 = functionUncurryThis;
var notARegExp = notARegexp;
var requireObjectCoercible = requireObjectCoercible$7;
var toString$4 = toString$e;
var correctIsRegExpLogic = correctIsRegexpLogic;
var stringIndexOf = uncurryThis$7("".indexOf);
$$k({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, { includes: function(e) {
  return !!~stringIndexOf(toString$4(requireObjectCoercible(this)), toString$4(notARegExp(e)), arguments.length > 1 ? arguments[1] : void 0);
} });
var getBuiltInPrototypeMethod$1 = getBuiltInPrototypeMethod$a;
var includes$5 = getBuiltInPrototypeMethod$1("String", "includes");
var isPrototypeOf$4 = objectIsPrototypeOf;
var arrayMethod = includes$6;
var stringMethod = includes$5;
var ArrayPrototype$2 = Array.prototype;
var StringPrototype = String.prototype;
var includes$4 = function(e) {
  var t = e.includes;
  return e === ArrayPrototype$2 || isPrototypeOf$4(ArrayPrototype$2, e) && t === ArrayPrototype$2.includes ? arrayMethod : "string" == typeof e || e === StringPrototype || isPrototypeOf$4(StringPrototype, e) && t === StringPrototype.includes ? stringMethod : t;
};
var parent$k = includes$4;
var includes$3 = parent$k;
var parent$j = includes$3;
var includes$2 = parent$j;
var parent$i = includes$2;
var includes$1 = parent$i;
var includes3 = includes$1;
var _includesInstanceProperty = getDefaultExportFromCjs(includes3);
function _objectWithoutPropertiesLoose(e, t) {
  if (null == e) return {};
  var i = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (_includesInstanceProperty(t).call(t, r)) continue;
    i[r] = e[r];
  }
  return i;
}
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var i, r, o = _objectWithoutPropertiesLoose(e, t);
  if (_Object$getOwnPropertySymbols) {
    var n = _Object$getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) i = n[r], _includesInstanceProperty(t).call(t, i) || {}.propertyIsEnumerable.call(e, i) && (o[i] = e[i]);
  }
  return o;
}
var _excluded$5 = ["message"];
function isOutBufferItem(e) {
  return void 0 !== e.report_id;
}
var LongStringReportor = class {
  constructor() {
    _defineProperty(this, "name", "LongStringReportor"), _defineProperty(this, "inBuffer", []), _defineProperty(this, "outBuffer", []);
  }
  push(e) {
    e.message && this.inBuffer.push(_objectSpread2(_objectSpread2({}, e), {}, { message: { id: genUuid$1().slice(0, 3), index: 0, end: true, msg: e.message } }));
  }
  splice(e) {
    const t = [];
    let i = 0;
    for (; this.outBuffer.length; ) {
      const r = JSON.stringify(this.outBuffer[0]).length;
      if (!(r < e)) break;
      e -= r, i += r, t.push(this.outBuffer.shift());
    }
    for (; this.inBuffer[0] && e > 0; ) {
      const r = this.inBuffer[0], { message: o } = r, n = _objectSpread2(_objectSpread2({}, _objectWithoutProperties(r, _excluded$5)), {}, { message: _objectSpread2(_objectSpread2({}, o), {}, { msg: "" }) }), s = JSON.stringify(n).length, a = e - s, d = _objectSpread2({}, n);
      if (a > o.msg.length) d.message.msg = o.msg, this.inBuffer.shift();
      else {
        if (!(a >= 10)) break;
        {
          const e2 = o.msg.slice(0, a);
          d.message.msg = e2, d.message.end = false, this.inBuffer[0].message.msg = o.msg.slice(a), this.inBuffer[0].message.index++;
        }
      }
      const c2 = JSON.stringify(d.message), l = c2.length;
      e -= l + s, i += l + s, t.push(_objectSpread2(_objectSpread2({}, d), {}, { message: c2 }));
    }
    return { payload: t, payloadSize: i };
  }
  unshift(e) {
    this.outBuffer = e.concat(this.outBuffer);
  }
  get() {
    return [...this.outBuffer, ...this.inBuffer.map((e) => _objectSpread2(_objectSpread2({}, e), {}, { message: JSON.stringify(e.message) }))];
  }
  set(e) {
    e.forEach((e2) => {
      isOutBufferItem(e2) ? this.outBuffer.push(e2) : (e2.message || (e2.message = ""), this.inBuffer.push(_objectSpread2(_objectSpread2({}, e2), {}, { message: JSON.parse(e2.message) })));
    }), this.outBuffer = [].concat(this.outBuffer), this.inBuffer = [].concat(this.inBuffer);
  }
  isEmpty() {
    return 0 === this.inBuffer.length && 0 === this.outBuffer.length;
  }
};
var _navigator;
var _window$localStorage$2;
var longStringReportor = new LongStringReportor();
var defaultCommonStats = { product_line: "rtc", report_version: "5", os: "web", user_agent: isSSR$1() ? "" : null === (_navigator = navigator) || void 0 === _navigator ? void 0 : _navigator.userAgent, platform: "web", product: "webrtc", app_state: "active" };
var DEBUG$1 = "undefined" != typeof window && (window.location.search.includes("_rtc_debug_") || (null === (_window$localStorage$2 = window.localStorage) || void 0 === _window$localStorage$2 ? void 0 : _window$localStorage$2.getItem("_rtc_debug_")));
var ReportorDBBuffer = class {
  constructor(e) {
    _defineProperty(this, "_buffer", void 0), this._buffer = new IndexedDBInterface(e);
  }
  async set(e, t) {
    await this._buffer.put2String(e, t);
  }
  async get(e) {
    var t;
    let i = [];
    try {
      i = await this._buffer.get4String(e);
    } catch (e2) {
    }
    return null !== (t = i) && void 0 !== t ? t : [];
  }
};
var Reportor = class {
  constructor() {
    _defineProperty(this, "reportCommon", defaultCommonStats), _defineProperty(this, "reportIds", /* @__PURE__ */ new Map()), _defineProperty(this, "dataBuffer", []), _defineProperty(this, "reportorList", []), _defineProperty(this, "dbBuffer", void 0), _defineProperty(this, "posting", false), _defineProperty(this, "sucSendTimer", void 0), _defineProperty(this, "preSucTime", 0), _defineProperty(this, "errSendTimer", void 0), _defineProperty(this, "errSendDelay", 100), _defineProperty(this, "_logServerUrl", void 0), _defineProperty(this, "_retryCount", 0), _defineProperty(this, "_reportLimit", 5e5), _defineProperty(this, "_disableTimeout", false), isSSR$1() || (window.addEventListener("beforeunload", () => {
      clearTimeout(this.errSendTimer), clearTimeout(this.sucSendTimer), this.send(void 0, true);
    }), document.addEventListener("visibilitychange", () => {
      "visible" === document.visibilityState ? this.setCommonStats({ app_state: "active" }) : "hidden" === document.visibilityState && this.setCommonStats({ app_state: "background" });
    }), DEBUG$1 && (window.__rtc_debug_reportor__ = this)), CoreConfig.on("UPLOAD_REPORT_LIMIT", (e) => {
      this.setReportLimit(e);
    }), CoreConfig.on("ENABLE_REPORT_IDB_BUFFER", (e) => {
      e && this.enableIndexedDBBuffer();
    }), setTimeout(() => {
      this.reportorList.push(consoleReportor), this.reportorList.push(longStringReportor);
    });
  }
  setUrl(e) {
    this._logServerUrl = e;
  }
  setCommonStats(e) {
    this.reportCommon = Object.assign(this.reportCommon, e);
  }
  getCommonStats() {
    return this.reportCommon;
  }
  setReportLimit(e) {
    this._reportLimit = Math.max(e, 5e4), this._reportLimit = Math.min(e, 5e5);
  }
  getReportId(e) {
    var t;
    e = null !== (t = e) && void 0 !== t ? t : "__global__", this.reportIds.has(e) || this.reportIds.set(e, 0);
    let i = this.reportIds.get(e);
    return void 0 === i && (reportGlobalError("no reportId in reportId map with engine-session-id ".concat(e), 0, {}), i = 0), this.reportIds.set(e, i + 1), i;
  }
  push(e) {
    if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) this.send(e);
    else {
      var t;
      const i = null !== (t = e.engine_session_id) && void 0 !== t ? t : "__global__";
      this.reportIds.has(i) || this.reportIds.set(i, 0), this.dataBuffer.push(e), !this.posting && !this.errSendTimer && Date.now() - this.preSucTime > 2e3 && (clearTimeout(this.sucSendTimer), this.send());
    }
  }
  enableIndexedDBBuffer() {
    this.dbBuffer || (this.dbBuffer = new ReportorDBBuffer("ReportorDBBuffer"), this.dbBuffer.get("LogReportor").then((e) => {
      e.forEach((e2) => {
        this.push(e2);
      });
    }), this.reportorList.forEach((e) => {
      var t;
      null === (t = this.dbBuffer) || void 0 === t || t.get(e.name).then((t2) => {
        e.set(t2);
      });
    }));
  }
  backup() {
    try {
      var e;
      null === (e = this.dbBuffer) || void 0 === e || e.set([...this.dataBuffer], "LogReportor"), this.reportorList.forEach((e2) => {
        var t;
        null === (t = this.dbBuffer) || void 0 === t || t.set([...e2.get()], e2.name);
      });
    } catch (e2) {
      reportGlobalError("Error when save log into IDB", -1, e2);
    }
  }
  unshift(e) {
    this.dataBuffer = e[0].concat(this.dataBuffer), this.reportorList.forEach((t, i) => {
      var r;
      t.unshift(null !== (r = e[i + 1]) && void 0 !== r ? r : []);
    });
  }
  _splice() {
    let e = findSizeIndex$1(this.dataBuffer, this._reportLimit);
    0 === e && this.dataBuffer.length > 0 && (this._reportLimit = JSON.stringify(this.dataBuffer[0]).length + 10, e = 1, reportGlobalError("update report limit to ".concat(this._reportLimit), 0, null));
    const t = this.dataBuffer.splice(0, e), i = JSON.stringify(t).length, r = [t];
    let o = this._reportLimit - i;
    return this.reportorList.forEach((e2) => {
      const { payload: t2, payloadSize: i2 } = e2.splice(o);
      t2.forEach((e3) => {
        var t3, i3, r2;
        void 0 === e3.report_id && (e3.report_id = this.getReportId(e3.engine_session_id), !isSSR$1() && window.__onRTCReport && (null === (t3 = (i3 = window).__onRTCReport) || void 0 === t3 || t3.call(i3, null !== (r2 = e3.engine_session_id) && void 0 !== r2 ? r2 : "global", e3, this.getCommonStats())));
      }), r.push(t2), o -= i2;
    }), r;
  }
  async send(e, t) {
    this.backup();
    const i = this.reportorList.reduce((e2, t2) => e2 && t2.isEmpty(), true);
    if (!e && !this.dataBuffer.length && i || !this._logServerUrl) return;
    e || (this.posting = true);
    let r = [];
    e || (r = this._splice());
    const o = DEBUG$1, n = { data: e || _flatInstanceProperty(r).call(r), header: _objectSpread2(_objectSpread2({}, this.reportCommon), {}, { http_retry_count: this._retryCount }), from: "web", os: "web", version: "1" }, s = { method: "POST", body: o ? JSON.stringify(n) : pako$1.gzip(JSON.stringify(n)) };
    if (!this._disableTimeout) try {
      const e2 = new AbortController();
      s.signal = e2.signal, setTimeout(() => {
        e2.abort();
      }, 1e4);
    } catch (e2) {
      console.warn("AbortController is not supported"), this._disableTimeout = true;
    }
    o || (s.headers = { "Content-Encoding": "gzip", "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" });
    let a, d, c2 = null;
    try {
      a = await fetch(this._logServerUrl, s), 200 !== a.status && 304 !== a.status || (c2 = JSON.parse(await a.text()));
    } catch (e2) {
      d = e2;
    }
    e || (this.posting = false), c2 && 0 === c2.StatusCode ? e || t || this.sucSend() : (setTimeout(() => {
      var e2, t2, i2;
      reportGlobalError("reportor post error, resJSON:".concat(null === (e2 = c2) || void 0 === e2 ? void 0 : e2.toString(), " err:").concat(d), null !== (t2 = null === (i2 = a) || void 0 === i2 ? void 0 : i2.status) && void 0 !== t2 ? t2 : -1, d);
    }, 0), e ? this.send(e) : (this.unshift(r), t ? this.send() : this.errSend()));
  }
  _getDataBufferTotalSize() {
    return this.dataBuffer.reduce((e, t) => e + JSON.stringify(t).length, 0);
  }
  sucSend() {
    this.errSendDelay = 100, this._retryCount = 0, this.preSucTime = Date.now();
    const e = this._getDataBufferTotalSize() > 1e6 ? 1e3 : 2e3;
    this.sucSendTimer = setTimeout(() => this.send(), e);
  }
  errSend() {
    this.errSendTimer = setTimeout(() => {
      this.send(), delete this.errSendTimer;
    }, this.errSendDelay), this.errSendDelay *= 2, this._retryCount++;
  }
};
function findSizeIndex$1(e, t) {
  let i = 0;
  for (let r = 0; r < e.length; r++) if (i += JSON.stringify(e[r]).length, i > t) return r;
  return e.length;
}
var commonReportor = new Reportor();
var Monitor = class {
  constructor(e) {
    _defineProperty(this, "modifyIds", { pre_connection: false }), this.id = e;
  }
  report(e, t, i) {
    const r = _objectSpread2(_objectSpread2(_objectSpread2({ event_key: e, rtc_timestamp: Date.now() }, this.modifyIds), t), {}, { report_id: commonReportor.getReportId(this.modifyIds.engine_session_id) });
    var o, n;
    ("object" == typeof i && Object.keys(i).length > 0 && (r.common_extra_info = JSON.stringify(i)), Object.keys(r).forEach((e2) => {
      void 0 !== r[e2] && "" !== r[e2] || delete r[e2];
    }), !isSSR$1() && window.__onRTCReport) && (null === (o = (n = window).__onRTCReport) || void 0 === o || o.call(n, this.modifyIds.engine_session_id, r, commonReportor.getCommonStats()));
    "UT" !== {}.VITE_TEST && commonReportor.push(r);
  }
  reportLog(e) {
    const t = _objectSpread2(_objectSpread2({ event_key: "rtc_invoke_status", sdk_api_name: "console_log", rtc_timestamp: Date.now() }, this.modifyIds), {}, { message: e });
    consoleReportor.push(t);
  }
  reportLongString(e, t) {
    const i = _objectSpread2(_objectSpread2({ event_key: "rtc_invoke_status", sdk_api_name: "sdk_long_string_".concat(e), rtc_timestamp: Date.now() }, this.modifyIds), {}, { message: t });
    longStringReportor.push(i);
  }
  set(e) {
    this.modifyIds = Object.assign(this.modifyIds, e);
  }
  destroy() {
  }
};
var MessageReportor = class _MessageReportor {
  constructor(e) {
    _defineProperty(this, "_preTime", Date.now()), _defineProperty(this, "_one2oneNum", 0), _defineProperty(this, "_one2manyNum", 0), _defineProperty(this, "_one2oneMsgCache", /* @__PURE__ */ new Map()), _defineProperty(this, "_one2manyMsgCache", /* @__PURE__ */ new Map()), _defineProperty(this, "roomId", ""), _defineProperty(this, "userId", ""), _defineProperty(this, "rtsSessionId", ""), _defineProperty(this, "logger", void 0), _defineProperty(this, "serverUrl", "server"), this.id = e, this.logger = new Logger$1("MessageReportor", 1);
  }
  needReport(e) {
    return !!_MessageReportor.config && (Date.now() - this._preTime >= 36e5 && (this._preTime = Date.now(), this._one2oneNum = 0, this._one2manyNum = 0), "one2one" === e && this._one2oneNum < _MessageReportor.config.max_one2one_fpt_per_hour && Math.random() <= _MessageReportor.config.one2one_fpt_ratio / 100 || "one2many" === e && this._one2manyNum < _MessageReportor.config.max_one2many_fpt_per_hour && Math.random() <= _MessageReportor.config.one2many_fpt_ratio / 100);
  }
  cacheP2PMsg(e) {
    var t;
    this._one2oneMsgCache.set(e.msg_id, _objectSpread2({ config_version: (null === (t = _MessageReportor.config) || void 0 === t ? void 0 : t.version) || "" }, e));
  }
  updateP2PMsg(e, t) {
    const i = this._one2oneMsgCache.get(e);
    i && this._one2oneMsgCache.set(e, _objectSpread2(_objectSpread2({}, i), t));
  }
  cacheCustomMsg(e) {
    var t;
    this._one2manyMsgCache.set(e.msg_id, _objectSpread2({ config_version: (null === (t = _MessageReportor.config) || void 0 === t ? void 0 : t.version) || "" }, e));
  }
  updateOne2ManyMsg(e, t) {
    const i = this._one2manyMsgCache.get(e);
    i && this._one2manyMsgCache.set(e, _objectSpread2(_objectSpread2({}, i), t));
  }
  reportP2PMsg(e) {
    const t = this._one2oneMsgCache.get(e);
    var i;
    t && (this.logger.info("reportP2PMsg", t.type, JSON.stringify(t)), null === (i = getMonitor(this.id)) || void 0 === i || i.report("rts_message", t));
  }
  reportOne2ManyMsg(e) {
    const t = this._one2manyMsgCache.get(e);
    var i;
    t && (this.logger.info("reportOne2ManyMsg", t.type, JSON.stringify(t)), null === (i = getMonitor(this.id)) || void 0 === i || i.report("rts_message", t));
  }
  reportMsgRecv(e) {
    var t, i;
    e.config_version = (null === (t = _MessageReportor.config) || void 0 === t ? void 0 : t.version) || "", this.logger.info("reportMsgRecv", e.type, JSON.stringify(e)), null === (i = getMonitor(this.id)) || void 0 === i || i.report("rts_message", e);
  }
  destroy() {
    this._one2manyNum = 0, this._one2oneNum = 0, this._one2manyMsgCache.clear(), this._one2oneMsgCache.clear(), this._preTime = Date.now(), this.roomId = "", this.userId = "", this.rtsSessionId = "";
  }
};
_defineProperty(MessageReportor, "config", void 0);
var _cache = /* @__PURE__ */ new Map();
var setConfig = (e) => {
  new Logger$1("MessageReportor", 1).info("setConfig", "get config: ".concat(JSON.stringify(e))), MessageReportor.config = e;
};
var createRTSMsgReportor = (e) => {
  const t = _cache.get(e) || new MessageReportor(e);
  return _cache.set(e, t), t;
};
var destroyRTSMsgReportor = (e) => {
  const t = _cache.get(e);
  t && (t.destroy(), _cache.delete(e));
};
var setServerUrl = (e, t) => {
  const i = _cache.get(e);
  i && (i.serverUrl = t);
};
var setRoomId = (e, t) => {
  const i = _cache.get(e);
  i && (i.roomId = t || "");
};
var setUserId = (e, t) => {
  const i = _cache.get(e);
  i && (i.userId = t || "");
};
var setRtsSessionId = (e, t) => {
  const i = _cache.get(e);
  i && (i.rtsSessionId = t);
};
var samplingP2PMsg = (e, t) => {
  const i = _cache.get(e);
  if (null != i && i.needReport("one2one")) {
    const e2 = t.to ? "one2one" : "one2server";
    t.enable_report = true, t.report_msg_id = t.id, i.cacheP2PMsg({ rts_session_id: i.rtsSessionId, msg_id: "".concat(t.id), node_role: "src_sdk", from: t.from, to: t.to || i.serverUrl, msg_type: e2, type: e2, rts_room_id: t.room, req_ts: Date.now(), send_ts: Date.now(), ack_ts: Date.now(), msg_size: 0, error_code: 0, recv_msg_ts: 0, fwd_msg_ts: 0, reply_ack_ts: 0, cur_dst_uid: "" });
  }
  return t;
};
var updateP2PMsgReq = (e, t, i) => {
  var r;
  t.enable_report && assertValidMsgId(t.report_msg_id) && (null === (r = _cache.get(e)) || void 0 === r || r.updateP2PMsg("".concat(t.report_msg_id), { send_ts: Date.now(), msg_size: i }));
};
var updateP2PMsgAck = (e, t, i) => {
  if (t.enable_report && assertValidMsgId(t.report_msg_id)) {
    const r = _cache.get(e);
    null == r || r.updateP2PMsg("".concat(t.report_msg_id), { ack_ts: Date.now(), error_code: i }), null == r || r.reportP2PMsg("".concat(t.report_msg_id));
  }
};
var samplingOne2ManyMsg = (e, t, i) => {
  const r = _cache.get(e);
  return null != r && r.needReport("one2many") && (i.enable_report = true, i.report_msg_id = t, r.cacheCustomMsg({ rts_session_id: r.rtsSessionId, msg_id: "".concat(t), node_role: "src_sdk", from: i.clientId, to: r.roomId || i.roomId, msg_type: "one2many", type: "one2many", rts_room_id: r.roomId, req_ts: Date.now(), send_ts: Date.now(), ack_ts: Date.now(), msg_size: 0, error_code: 0, recv_msg_ts: 0, fwd_msg_ts: 0, reply_ack_ts: 0, cur_dst_uid: "" })), i;
};
var updateOne2ManyMsgReq = (e, t, i) => {
  if (t.enable_report && assertValidMsgId(t.report_msg_id)) {
    const r = _cache.get(e);
    r && r.updateOne2ManyMsg("".concat(t.report_msg_id), { send_ts: Date.now(), msg_size: i });
  }
};
var updateOne2ManyMsgAck = (e, t, i) => {
  if (t.enable_report && assertValidMsgId(t.report_msg_id)) {
    const r = _cache.get(e);
    r && (null == r || r.updateOne2ManyMsg("".concat(t.report_msg_id), { ack_ts: Date.now(), error_code: i }), null == r || r.reportOne2ManyMsg("".concat(t.report_msg_id)));
  }
};
var reportP2PMsgRecv = (e, t, i) => {
  if (t.enable_report && assertValidMsgId(t.report_msg_id)) {
    const r = _cache.get(e), o = t.to ? "one2one" : "one2many";
    null == r || r.reportMsgRecv({ rts_session_id: r.rtsSessionId, msg_id: "".concat(t.report_msg_id), msg_size: i.msg_size, node_role: "dst_sdk", msg_type: o, type: o, rts_room_id: t.room, from: t.from, to: t.to || t.room, error_code: 0, recv_msg_ts: i.recv_msg_ts, fwd_msg_ts: i.fwd_msg_ts, reply_ack_ts: Date.now(), cur_dst_uid: t.to ? "" : r.userId, config_version: "", req_ts: 0, send_ts: 0, ack_ts: 0 });
  }
};
var reportOne2ManyMsgRecv = (e, t, i) => {
  if (t.enable_report && assertValidMsgId(t.report_msg_id)) {
    const r = _cache.get(e);
    null == r || r.reportMsgRecv({ rts_session_id: r.rtsSessionId, msg_id: "".concat(t.report_msg_id), msg_size: i.msg_size, node_role: "dst_sdk", msg_type: "one2many", type: "one2many", rts_room_id: t.roomId, from: t.clientId, to: t.roomId, error_code: 0, recv_msg_ts: i.recv_msg_ts, fwd_msg_ts: i.fwd_msg_ts, reply_ack_ts: Date.now(), cur_dst_uid: r.userId, config_version: "", req_ts: 0, send_ts: 0, ack_ts: 0 });
  }
};
var RTSMsgReportor = { _cache, setServerUrl, setConfig, setRtsSessionId, createRTSMsgReportor, destroyRTSMsgReportor, setRoomId, setUserId, samplingP2PMsg, updateP2PMsgReq, updateP2PMsgAck, samplingOne2ManyMsg, reportP2PMsgRecv, updateOne2ManyMsgAck, updateOne2ManyMsgReq, reportOne2ManyMsgRecv };
var MessageStatisticsObserver = class {
  constructor(e) {
    _defineProperty(this, "_timer", void 0), _defineProperty(this, "userMessage", {}), _defineProperty(this, "roomMessage", {}), this.id = e, this._setTimer();
  }
  _setTimer() {
    const e = () => {
      this._reportAndgReset(), clearTimeout(this._timer), this._timer = setTimeout(e, 1e4);
    };
    e();
  }
  _reportAndgReset() {
    (Object.keys(this.userMessage).length || Object.keys(this.roomMessage).length) && (this._report(), this._reset());
  }
  _report() {
    var e;
    null === (e = getMonitor(this.id)) || void 0 === e || e.report("rtc_message_statistics", { dc_user_message: Object.keys(this.userMessage).map((e2) => this.userMessage[e2]), dc_room_message: Object.keys(this.roomMessage).map((e2) => this.roomMessage[e2]), media_server_ip: "" });
  }
  _reset() {
    this.userMessage = {}, this.roomMessage = {};
  }
  _checkInitUserMessage(e, t) {
    this.userMessage["".concat(t, "-").concat(e)] || (this.userMessage["".concat(t, "-").concat(e)] = { dc_peer_user_id: e, dc_send_total: 0, dc_recv_total: 0, dc_send_ack: 0, dc_send_fail: 0, dc_fail_timeout: 0, dc_fail_no_receiver: 0, dc_fail_no_relay_path: 0, dc_cost_time: 0, dc_cost_e2s: 0, dc_cost_s2s: 0, dc_least_time: Number(1 / 0), dc_most_time: 0, dc_cost_peer_s2e: 0, dc_send_ack_100: 0, dc_send_ack_200: 0, dc_send_ack_400: 0, dc_send_ack_1s: 0, dc_message_type: t, dc_send_binary: 0 });
  }
  _sendUserMessage(e, t, i) {
    this._checkInitUserMessage(e, t), this.userMessage["".concat(t, "-").concat(e)].dc_send_total++, i && this.userMessage["".concat(t, "-").concat(e)].dc_send_binary++;
  }
  _recvUserMessage(e, t) {
    this._checkInitUserMessage(e, t), this.userMessage["".concat(t, "-").concat(e)].dc_recv_total++;
  }
  _sendUserFail(e, t, i) {
    const r = this.userMessage["".concat(t, "-").concat(e)];
    r && (r.dc_send_fail++, this._handleUserFail(r, i));
  }
  _handleUserFail(e, t) {
    t && (t.code || t.err) && (["TIME_OUT", "USER_MESSAGE_TIMEOUT"].includes(t.code) ? e.dc_fail_timeout++ : 3 === t.err ? e.dc_fail_no_receiver++ : 4 === t.err ? e.dc_fail_no_relay_path++ : 1 === t.err && e.dc_fail_timeout++);
  }
  _sendUserAck(e, t, i, r, o) {
    const n = this.userMessage["".concat(t, "-").concat(e)];
    n && (n.dc_send_ack++, n.dc_cost_time += i, n.dc_cost_s2s += r || 0, n.dc_cost_peer_s2e += o, n.dc_cost_e2s += i - (r || 0) - o, i / 2 <= 100 ? (n.dc_send_ack_100++, n.dc_send_ack_200++, n.dc_send_ack_400++, n.dc_send_ack_1s++) : i / 2 <= 200 ? (n.dc_send_ack_200++, n.dc_send_ack_400++, n.dc_send_ack_1s++) : i / 2 <= 400 ? (n.dc_send_ack_400++, n.dc_send_ack_1s++) : i / 2 <= 1e3 && n.dc_send_ack_1s++, i < n.dc_least_time && (n.dc_least_time = i), i > n.dc_most_time && (n.dc_most_time = i));
  }
  sendRoomMessage(e, t) {
    this.roomMessage[e] || (this.roomMessage[e] = { dc_room_id: e, dc_send_total: 0, dc_send_ack: 0, dc_cost_time: 0, dc_least_time: Number(1 / 0), dc_most_time: 0, dc_send_fail: 0, dc_send_ack_100: 0, dc_send_ack_200: 0, dc_send_ack_400: 0, dc_send_ack_1s: 0, dc_send_binary: 0 }), this.roomMessage[e].dc_send_total++, t && this.roomMessage[e].dc_send_binary++;
  }
  sendRoomFail(e) {
    const t = this.roomMessage[e];
    t && t.dc_send_fail++;
  }
  sendRoomAck(e, t) {
    const i = this.roomMessage[e];
    i && (i.dc_send_ack++, i.dc_cost_time += t, t < i.dc_least_time && (i.dc_least_time = t), t > i.dc_most_time && (i.dc_most_time = t), t / 2 <= 100 ? (i.dc_send_ack_100++, i.dc_send_ack_200++, i.dc_send_ack_400++, i.dc_send_ack_1s++) : t / 2 <= 200 ? (i.dc_send_ack_200++, i.dc_send_ack_400++, i.dc_send_ack_1s++) : t / 2 <= 400 ? (i.dc_send_ack_400++, i.dc_send_ack_1s++) : t / 2 <= 1e3 && i.dc_send_ack_1s++);
  }
  sendP2PMessage(e, t) {
    this._sendUserMessage(e, "p2p", t);
  }
  recvP2PMessage(e) {
    this._recvUserMessage(e, "p2p");
  }
  sendP2PFail(e, t) {
    this._sendUserFail(e, "p2p", t);
  }
  sendP2PAck(e, t, i, r) {
    this._sendUserAck(e, "p2p", t, i, r);
  }
  sendP2POutRoomMessage(e, t) {
    this._sendUserMessage(e, "p2p_outside_room", t);
  }
  recvP2POutRoomMessage(e) {
    this._recvUserMessage(e, "p2p_outside_room");
  }
  sendP2POutRoomFail(e, t) {
    this._sendUserFail(e, "p2p_outside_room", t);
  }
  sendP2POutRoomAck(e, t, i, r) {
    this._sendUserAck(e, "p2p_outside_room", t, i, r);
  }
  sendP2serverMessage(e) {
    this._sendUserMessage("", "p2server", e);
  }
  sendP2serverFail(e) {
    this._sendUserFail("", "p2server", e);
  }
  sendP2serveAck(e, t, i) {
    this._sendUserAck("", "p2server", e, t, i);
  }
  countP2PMessage(e, t, i, r, o) {
    this.sendP2PMessage(t, i), e ? this.sendP2PAck(t, Date.now() - r, o.s2s_time || 0, o.s2e_time || 0) : this.sendP2PFail(t, o);
  }
  countRoomMessage(e, t, i, r) {
    this.sendRoomMessage(t, i), e ? this.sendRoomAck(t, Date.now() - r) : this.sendRoomFail(t);
  }
  countUserMessageOutsideRoom(e, t, i, r, o) {
    this.sendP2POutRoomMessage(t, i), e ? this.sendP2POutRoomAck(t, Date.now() - r, o.s2s_time, o.s2e_time) : this.sendP2POutRoomFail(t, o);
  }
  countServerMessage(e, t, i, r) {
    this.sendP2serverMessage(t), e ? (r = r || {}, this.sendP2serveAck(Date.now() - i, r.s2s_time || 0, r.s2e_time || 0)) : this.sendP2serverFail(r);
  }
  destroy() {
    this._reset(), clearTimeout(this._timer);
  }
};
var setGlobalStats = (e) => {
  commonReportor.setCommonStats(e);
};
var setReportUrl = (e) => {
  commonReportor.setUrl(e);
};
var globalMonitor = new Monitor("global");
var reportGlobalApiCall = (e, t, i) => {
  globalMonitor.report("rtc_sdk_api_call", { sdk_api_name: e, error_code: t, message: i });
};
var reportGlobalCallback = (e, t, i) => {
  globalMonitor.report("rtc_sdk_callback", { sdk_callback_name: e, error_code: t, message: i });
};
var reportGlobalError = (e, t, i) => {
  globalMonitor.report("rtc_error", { message: e, error_code: t }, i);
};
var reportGlobalInvokeStatus = function(e, t) {
  let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "", o = arguments.length > 4 ? arguments[4] : void 0;
  globalMonitor.report("rtc_invoke_status", { sdk_api_name: e, message: t, error_code: i, stream_id: r, elapse: 0 }, o);
};
function reportGlobalLog(e) {
  globalMonitor.reportLog(e);
}
var monitorMap = /* @__PURE__ */ new Map();
var getMonitor = (e) => monitorMap.get(e);
var createMonitor = (e, t) => {
  const i = new Monitor(e);
  return i.set(_objectSpread2(_objectSpread2({}, t), {}, { engine_session_id: genUuid$1() })), i.report("sdk_init_engine", { start: Date.now(), type: "begin" }), monitorMap.set(e, i), i;
};
var destroyMonitor = (e) => {
  e.report("sdk_init_engine", { start: Date.now(), type: "end" }), monitorMap.delete(e.id);
};
var apiReportCache = /* @__PURE__ */ new Map();
function reportRtcSdkApi() {
  let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  t = Object.assign({ debounce: 0 }, t);
  const { debounce: i, debounceTag: r } = t;
  function o(e2, t2, r2, o2) {
    if (!i) return t2(...r2);
    {
      const n = "".concat(o2, "_").concat(e2), s = apiReportCache.get(n);
      clearTimeout(s);
      const a = setTimeout(() => {
        t2(...r2);
      }, i);
      apiReportCache.set(n, a);
    }
  }
  return function(t2, i2, n) {
    if ("function" == typeof n.value) {
      const t3 = n.value;
      n.value = function() {
        for (var n2, s, a = arguments.length, d = new Array(a), c2 = 0; c2 < a; c2++) d[c2] = arguments[c2];
        const l = this.engineId || this.id, u = genUuid$1(), h = {};
        var _, p;
        (e.forEach((e2, t4) => {
          h[e2] = d[t4];
        }), "joinRoom" === i2) && (null === (_ = getMonitor(l)) || void 0 === _ || _.set({ room_id: d[1], user_id: null === (p = d[2]) || void 0 === p ? void 0 : p.userId }));
        let m, S = "";
        if (r) try {
          S = r(...d);
        } catch (e2) {
        }
        o(i2, reportRtcSdkApiCall, [l, i2, d, h, { event_session_id: u }], "start_".concat(S));
        try {
          m = t3.apply(this, d);
        } catch (e2) {
          throw o(i2, reportRtcSdkCallback, [l, i2, e2.message, e2.code || -1, { event_session_id: u }], "end_".concat(S)), e2;
        }
        return "function" == typeof (null === (n2 = m) || void 0 === n2 ? void 0 : n2.then) ? m.then((e2) => (o(i2, reportRtcSdkCallback, [l, i2, [null != e2 ? e2 : {}], 0, { event_session_id: u }], "end_".concat(S)), e2)).catch((e2) => {
          throw o(i2, reportRtcSdkCallback, [l, i2, e2.message, e2.code, { event_session_id: u }], "end_".concat(S)), e2;
        }) : (o(i2, reportRtcSdkCallback, [l, i2, [null !== (s = m) && void 0 !== s ? s : {}], 0, { event_session_id: u }], "end_".concat(S)), m);
      };
    }
  };
}
var reportRtcSdkApiCall = function(e, t, i, r) {
  var o;
  let n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
  const s = _objectSpread2({ sdk_api_name: t, message: JSON.stringify(reportParamsCheck(i)), error_code: 0 }, n);
  null === (o = getMonitor(e)) || void 0 === o || o.report("rtc_sdk_api_call", s, r);
};
var reportRtcSdkCallback = function(e, t, i) {
  var r;
  let o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
  const n = _objectSpread2({ sdk_callback_name: t, error_code: arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, message: JSON.stringify(Array.isArray(i) ? reportParamsCheck(i) : i) }, o);
  null === (r = getMonitor(e)) || void 0 === r || r.report("rtc_sdk_callback", n);
};
var reportRtcInvokeStatus = function(e, t, i) {
  var r;
  let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "", s = arguments.length > 5 ? arguments[5] : void 0;
  null === (r = getMonitor(e)) || void 0 === r || r.report("rtc_invoke_status", { sdk_api_name: t, message: i, error_code: o, stream_id: n, elapse: 0 }, s);
};
var maxBinaryLength = 10;
function reportParamsCheck(e) {
  const t = (e2) => {
    if (null != e2 && e2._reportName) return e2._reportName;
    if (e2 instanceof HTMLElement) return e2.toString();
    if (e2 instanceof ArrayBuffer || ArrayBuffer.isView(e2)) {
      const t2 = ArrayBuffer.isView(e2) ? e2.buffer : e2, r = t2.byteLength;
      let o = [];
      if (r > maxBinaryLength) {
        var i;
        const e3 = new DataView(t2), n = Array.from({ length: maxBinaryLength / 2 }).map((t3, i2) => e3.getUint8(i2)), s = _reverseInstanceProperty(i = Array.from({ length: maxBinaryLength / 2 }).map((e4, t3) => r - 1 - t3)).call(i).map((t3) => e3.getUint8(t3));
        o = [...n, "...", ...s];
      } else o = Array.from(new Uint8Array(t2));
      return "".concat(e2.constructor.name, "(").concat(r, ") [").concat(o.join(", "), "]");
    }
    if (e2 instanceof ImageData) return "ImageData";
    if (Array.isArray(e2)) return e2.map(t);
    if (["[object Object]", "[object MediaStreamTrack]"].includes(Object.prototype.toString.call(e2))) {
      const i2 = {};
      for (const r in e2) i2[r] = t(e2[r]);
      return i2;
    }
    return e2 instanceof Function ? "[User Function]" : e2;
  };
  return e.map(t);
}
var ENABLE_CONSOLE_UPLOAD = "undefined" != typeof window && window.location.search.includes("_rtc_upload_console_");
var ConsoleReportor = class {
  constructor() {
    _defineProperty(this, "name", "ConsoleReportor"), _defineProperty(this, "_uuid", "".concat(Math.floor(899 * Math.random()) + 100)), _defineProperty(this, "_consoleReportId", 0), _defineProperty(this, "_engineReportIdMap", /* @__PURE__ */ new Map()), _defineProperty(this, "_enabled", "NULL"), _defineProperty(this, "_consoleCutLength", CoreConfig.getParameter("UPLOAD_CONSOLE_LENGTH_CUT")), _defineProperty(this, "buffer", []), ENABLE_CONSOLE_UPLOAD && setTimeout(() => {
      this.switchOn();
    }, 0), CoreConfig.on("UPLOAD_CONSOLE_ON", (e) => {
      e ? this.switchOn() : this.turnOff();
    }), CoreConfig.on("UPLOAD_CONSOLE_LENGTH_CUT", (e) => {
      this._consoleCutLength = e;
    });
  }
  get enabled() {
    return "OFF" !== this._enabled;
  }
  switchOn() {
    "NULL" === this._enabled && (console.log("[LoggerReportor.constructor] console upload switch ON"), this._enabled = "ON");
  }
  turnOff() {
    "NULL" === this._enabled && (console.log("[LoggerReportor.constructor] console upload switch OFF"), this._enabled = "OFF", this.buffer = []);
  }
  getEngineConsoleId(e) {
    var t;
    const i = null !== (t = this._engineReportIdMap.get(e)) && void 0 !== t ? t : 0;
    return this._engineReportIdMap.set(e, i + 1), i;
  }
  report(e, t, i, r, o, n, s, a, d) {
    if ("OFF" === this._enabled) return;
    const c2 = getMonitor(t), l = this._consoleReportId++, u = this.getEngineConsoleId(t), h = shallowJson(d, this._consoleCutLength), _ = [...d], p = "".concat(a).replace(/%o|%s/gi, () => shallowJson([_.shift()], this._consoleCutLength)), m = "[".concat(this._uuid, "-").concat(l, "][").concat(t, "-").concat(u, "]-").concat(i, "-").concat(e, "[").concat(r, "]").concat(o, "[").concat(n, ".").concat(s, "] ").concat(p, " ").concat(h);
    c2 ? c2.reportLog(m) : reportGlobalLog(m);
  }
  push(e) {
    "OFF" !== this._enabled && this.buffer.push(e);
  }
  splice(e) {
    if ("ON" !== this._enabled) return { payload: [], payloadSize: 0 };
    const { index: t, size: i } = findSizeIndex(this.buffer, e);
    return { payload: this.buffer.splice(0, t), payloadSize: i };
  }
  unshift(e) {
    this.buffer = e.concat(this.buffer);
  }
  get() {
    return this.buffer;
  }
  set(e) {
    this.buffer = e.concat(this.buffer);
  }
  isEmpty() {
    return "OFF" === this._enabled || 0 === this.buffer.length;
  }
};
function shallowJson(e, t) {
  return e.map((e2) => {
    let i = "";
    try {
      if ("string" == typeof e2) return e2;
      if (void 0 === e2) return "undefined";
      if (null === e2) return "null";
      if (e2 instanceof MediaStreamTrack) return mediaTrackStringify(e2);
      if (e2 instanceof MediaStream) return mediaStreamStringify(e2);
      if (e2 instanceof RTCRtpSender) return mediaSenderStringify(e2);
      if (e2 instanceof RTCRtpReceiver) return mediaReceiverStringify(e2);
      if (e2 instanceof RTCRtpTransceiver) return mediaTransceiverStringify(e2);
      i = JSON.stringify(e2);
    } catch (t2) {
      i = e2.toString();
    }
    return i && i.length >= t && (i = i.slice(0, t)), i;
  }).join(", ");
}
function findSizeIndex(e, t) {
  let i = 0;
  for (let r = 0; r < e.length; r++) {
    const o = JSON.stringify(e[r]).length;
    if (i += o, i > t) return { index: r, size: i - o };
  }
  return { index: e.length, size: i };
}
var _window$localStorage$1;
var consoleReportor = new ConsoleReportor();
var colorMap = { DEBUG: "rgba(0, 0, 0, 0)", " INFO": "rgba(93, 173, 226, 0)", " WARN": "rgba(255, 119, 0, 0.3)", ERROR: "rgba(255, 0, 0, 0.3)", " SUCC": "rgba(0, 119, 0, 0.3)" };
var DEBUG = "undefined" != typeof window && (window.location.search.includes("_rtc_debug_") || (null === (_window$localStorage$1 = window.localStorage) || void 0 === _window$localStorage$1 ? void 0 : _window$localStorage$1.getItem("_rtc_debug_")));
var Logger = class {
  constructor(e, t) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "global";
    _defineProperty(this, "indent", void 0), _defineProperty(this, "module", void 0), _defineProperty(this, "_engineId", void 0), this.module = e, this.indent = t, this._engineId = i;
  }
  _print(e, t) {
    for (var i = arguments.length, r = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++) r[o - 2] = arguments[o];
    const n = r.shift();
    try {
      const e2 = [...r], i2 = "".concat(n).replace(/%o/gi, () => {
        const t2 = e2.shift();
        return JSON.stringify(t2);
      });
      iDB.set("".concat("[VERTC]", "[").concat(this.module, ".").concat(t, "] ").concat(i2, " ").concat(e2.map((e3) => JSON.stringify(e3)).join(", ")));
    } catch (e2) {
    }
    let s = "";
    for (let e2 = 0; e2 < this.indent; e2++) s += "    ";
    const a = getTimestamp();
    consoleReportor.report("[VERTC]", this._engineId, a, e, s, this.module, t, n, r), DEBUG && console.log("%c".concat(a, "-").concat("[VERTC]", "%c[").concat(e, "]%c").concat(s, "[").concat(this.module, ".").concat(t, "] ").concat(n), "color:".concat("#0050b3", ";"), "background-color:".concat(colorMap[e], ";"), "color:".concat("#0050b3", ";"), ...r);
  }
  print(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    this._print(" INFO", e, ...i);
  }
  debug(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    this._print("DEBUG", e, ...i);
  }
  info(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    this._print(" INFO", e, ...i);
  }
  warn(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    this._print(" WARN", e, ...i);
  }
  error(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    this._print("ERROR", e, ...i);
  }
  success(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    this._print(" SUCC", e, ...i);
  }
};
var getTimestamp = () => {
  const e = /* @__PURE__ */ new Date();
  return "".concat(e.toTimeString().split(" ")[0], ":").concat(e.getMilliseconds().toString().padStart(3, "0"));
};
var _userAgentString$matc;
var _userAgentString$matc2;
var _ref;
var _userAgentString$matc3;
var _userAgentString$matc4;
var Logger$1 = Logger;
var isSSR = () => "undefined" == typeof window;
var userAgentString = isSSR() ? "" : window.navigator.userAgent;
function getBrowser() {
  let e = "none";
  return isSSR() || (null !== userAgentString.match("Firefox") ? e = "mozilla" : null !== userAgentString.match("Chrome") ? (e = "chrome-stable", null !== userAgentString.match("Electron") && (e = "electron")) : (null !== userAgentString.match("Safari") || null !== userAgentString.match("AppleWebKit")) && (e = "safari")), e;
}
var isFirefox = "mozilla" === getBrowser();
var isSafari = "safari" === getBrowser();
var isChrome = "chrome-stable" === getBrowser();
var isCriOS = !isSSR() && /CriOS/i.test(userAgentString);
var isEdgeForDesktop = !isSSR() && /Edg\//i.test(userAgentString);
var isEdgeForAndroid = !isSSR() && /EdgA/i.test(userAgentString);
var isEdgeForIOS = !isSSR() && /EdgiOS/i.test(userAgentString);
var isEdge = isEdgeForDesktop || isEdgeForAndroid || isEdgeForIOS;
var isDingTalk = !isSSR() && /DingTalk/i.test(navigator.userAgent);
var isOpera = !isSSR() && /OPR\//.test(navigator.userAgent);
var isIPad = !isSSR() && (!!/(iPad)/i.exec(userAgentString) || /Macintosh/i.test(userAgentString) && "ontouchend" in document);
var isMac = !isSSR() && /Macintosh/i.test(userAgentString);
var isWeChat = !isSSR() && /MicroMessenger/i.test(userAgentString);
var isMobile = !isSSR() && userAgentString.toLowerCase().includes("mobile");
var isIOS = !isSSR() && !!/(iPhone|iPad|iPod)/i.exec(userAgentString);
var isAndroid = !isSSR() && /Android/i.test(userAgentString);
var isWindows = !isSSR() && /Windows/i.test(userAgentString);
var isOpenHarmony = !isSSR() && /OpenHarmony/i.test(userAgentString);
var sv = 0;
var sv2 = "0";
var v = !isSSR() && (null === (_userAgentString$matc = userAgentString.match(/version\/(\d+)/i)) || void 0 === _userAgentString$matc ? void 0 : _userAgentString$matc[1]);
var _navigator$userAgent$;
isSafari && v && (sv = Number(v), sv2 = null === (_navigator$userAgent$ = navigator.userAgent.match(/version\/(\d+\.\d+)/i)) || void 0 === _navigator$userAgent$ ? void 0 : _navigator$userAgent$[1]);
var v2 = !isSSR() && (null === (_userAgentString$matc2 = userAgentString.match(/Firefox\/(\d+)/i)) || void 0 === _userAgentString$matc2 ? void 0 : _userAgentString$matc2[1]);
isFirefox && v2 && (sv = Number(v2));
var safariVersion = sv;
var firefoxVersion = sv;
var safariMinorVersion = sv2;
var iOSVersion = null !== (_ref = !isSSR() && (null === (_userAgentString$matc3 = userAgentString.match(/ ([\d_]+) like Mac OS X/i)) || void 0 === _userAgentString$matc3 || null === (_userAgentString$matc3 = _userAgentString$matc3[1]) || void 0 === _userAgentString$matc3 ? void 0 : _userAgentString$matc3.split("_").map((e) => parseInt(e)))) && void 0 !== _ref ? _ref : [];
var cv = 0;
var cvs = !isSSR() && (null === (_userAgentString$matc4 = userAgentString.match(/Chrome\/(\d+)/i)) || void 0 === _userAgentString$matc4 ? void 0 : _userAgentString$matc4[1]);
cvs && (cv = Number(cvs));
var chromeVersion = cv;
var PLATFORM_KEY = "VolcEngine";
var RTC_DEVICE_ID = "RTC_DEVICE_ID";
var RTC_ACCESS_NODE = "RTC_ACCESS_NODE";
var RTC_ACCESS_URLS = "RTC_ACCESS_URLS";
var ENGINE_WEB_CONFIG = "ENGINE_WEB_CONFIG";
var SERVER_CONFIG = "SERVER_CONFIG";
var Cache = class {
  get(e) {
    const t = localStorage.getItem(e);
    if (!t) return null;
    try {
      const i = JSON.parse(t);
      return i.ttl > 0 && Date.now() - i.saveTime > i.ttl ? (this.delete(e), null) : i.message;
    } catch (e2) {
      return null;
    }
  }
  set(e, t) {
    const i = { ttl: arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1, saveTime: Date.now(), message: t };
    try {
      return localStorage.setItem(e, JSON.stringify(i)), true;
    } catch (e2) {
      return false;
    }
  }
  getTtl(e) {
    const t = localStorage.getItem(e);
    if (!t) return null;
    try {
      return JSON.parse(t).ttl;
    } catch (e2) {
      return null;
    }
  }
  delete(e) {
    try {
      return localStorage.removeItem(e), true;
    } catch (e2) {
      return false;
    }
  }
};
var SDKCache = class extends Cache {
  constructor() {
    super(...arguments), _defineProperty(this, "_accessVersion", "v2");
  }
  getDeviceId() {
    if (isSSR()) return "";
    let e = this.get(RTC_DEVICE_ID);
    return e && !/^[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}$/.test(e) || (e = randomNum(16)), this.setDeviceId(e), e;
  }
  setDeviceId(e) {
    return setGlobalStats({ device_id: e }), this.set(RTC_DEVICE_ID, e), e;
  }
  getAccessKey(e) {
    return "".concat(RTC_ACCESS_NODE, "_").concat(e, "-").concat(PLATFORM_KEY, "-").concat(this._accessVersion);
  }
  getAccessNode(e) {
    return this.get(this.getAccessKey(e));
  }
  setAccessNode(e, t, i) {
    return this.set(this.getAccessKey(e), t, 1e3 * i);
  }
  deleteAccessNode(e, t) {
    let i = this.getAccessNode(e);
    const r = this.getTtl(this.getAccessKey(e));
    Array.isArray(i) && i.length > 0 && (i = i.filter((e2) => e2.mediaID !== t.mediaID && e2.msgKey !== t.msgKey), i.length > 0 ? this.setAccessNode(e, i, r || 0) : this.clearAccessNode(e));
  }
  clearAccessNode(e) {
    if (e) this.delete(this.getAccessKey(e));
    else for (const e2 in localStorage) e2.startsWith(RTC_ACCESS_NODE) && localStorage.removeItem(e2);
  }
  getAccessUrls() {
    return this.get("".concat(RTC_ACCESS_URLS, "-").concat(PLATFORM_KEY));
  }
  setAccessUrls(e) {
    const t = e.map((e2) => {
      let { host: t2, path: i } = e2;
      return "https://".concat(t2).concat(i);
    });
    return this.set("".concat(RTC_ACCESS_URLS, "-").concat(PLATFORM_KEY), t);
  }
  clearAccessUrls() {
    this.delete("".concat(RTC_ACCESS_URLS, "-").concat(PLATFORM_KEY));
  }
  getEngineWebConfig(e, t) {
    var i;
    const r = "".concat(e, "_").concat(t, "_").concat(this.getDeviceId()), o = this.get(ENGINE_WEB_CONFIG), n = (null == o || null === (i = o.find((e2) => e2.key === r)) || void 0 === i ? void 0 : i.config) || {};
    return Object.assign({}, getParameter("ENGINE_WEB_CONFIG"), n);
  }
  setEngineWebConfig(e, t, i) {
    if (!i) return;
    const r = "".concat(e, "_").concat(t, "_").concat(this.getDeviceId());
    let o = this.get(ENGINE_WEB_CONFIG) || [];
    return o = o.filter((e2) => e2.key !== r), o.push({ key: r, config: i }), this.set(ENGINE_WEB_CONFIG, o.slice(-5));
  }
  getServerConfig(e) {
    var t;
    const i = "".concat(e), r = this.get(SERVER_CONFIG);
    return (null == r || null === (t = r.find((e2) => e2.key === i)) || void 0 === t ? void 0 : t.config) || {};
  }
  setServerConfig(e, t) {
    if (!t) return;
    const i = "".concat(e);
    let r = this.get(SERVER_CONFIG) || [];
    return r = r.filter((e2) => e2.key !== i), r.push({ key: i, config: t }), this.set(SERVER_CONFIG, r.slice(-5));
  }
};
var sdkCache = new SDKCache();
var logger$b = new Logger$1("JoinRoomConfig", 0);
var JoinRoomConfig = class _JoinRoomConfig {
  constructor(e) {
    _defineProperty(this, "_useTcpAfterJoinTimeout", _JoinRoomConfig.DEFAULT_CONF.useTcpAfterJoinTimeout), _defineProperty(this, "_joinWithTcpOnly", _JoinRoomConfig.DEFAULT_CONF.joinWithTcpOnly), _defineProperty(this, "_joinWithTcpOnlyDelay", _JoinRoomConfig.DEFAULT_CONF.joinWithTcpOnlyDelay), _defineProperty(this, "_blackBrowserRegexList", []), this._engineId = e, location.search.indexOf("__rtc_tcp_only__") > -1 && (this._joinWithTcpOnly = true, this._joinWithTcpOnlyDelay = 0), this._report();
  }
  static setDefaulConf(e) {
    let { useTcpAfterJoinTimeout: t, joinWithTcpOnly: i, joinWithTcpOnlyDelay: r } = e;
    return "boolean" == typeof t && (_JoinRoomConfig.DEFAULT_CONF.useTcpAfterJoinTimeout = t), "boolean" == typeof i && (_JoinRoomConfig.DEFAULT_CONF.joinWithTcpOnly = i), "number" == typeof r && (_JoinRoomConfig.DEFAULT_CONF.joinWithTcpOnlyDelay = Math.max(0, r)), _JoinRoomConfig.DEFAULT_CONF;
  }
  get useTcpAfterJoinTimeout() {
    return this._useTcpAfterJoinTimeout;
  }
  get useTcpJoin() {
    return this._joinWithTcpOnly;
  }
  get useTcpJoinDelay() {
    return this._joinWithTcpOnlyDelay;
  }
  isBlackBrower() {
    return this._blackBrowserRegexList.find((e) => new RegExp(e).test(navigator.userAgent));
  }
  setServerConfig(e) {
    var t, i, r;
    let o = false;
    "boolean" == typeof (null == e || null === (t = e.use_tcp_after_join_timeout) || void 0 === t ? void 0 : t.enable) && (this._useTcpAfterJoinTimeout = e.use_tcp_after_join_timeout.enable, o = true), "boolean" == typeof (null == e || null === (i = e.join_with_tcp_only) || void 0 === i ? void 0 : i.enable) && (this._joinWithTcpOnly = e.join_with_tcp_only.enable, o = true), "number" == typeof (null == e || null === (r = e.join_with_tcp_only) || void 0 === r ? void 0 : r.delay_ms) && (this._joinWithTcpOnlyDelay = e.join_with_tcp_only.delay_ms, o = true), e && Array.isArray(e.black_browser_regex_list) && (this._blackBrowserRegexList = e.black_browser_regex_list, o = true), o && this._report();
  }
  toString() {
    return JSON.stringify({ use_tcp_after_join_timeout: this._useTcpAfterJoinTimeout, join_with_tcp_only: this._joinWithTcpOnly, join_with_tcp_only_delay: this._joinWithTcpOnlyDelay, black_browser_regex_list: this._blackBrowserRegexList });
  }
  _report() {
    logger$b.print("_report", this.toString()), reportRtcInvokeStatus(this._engineId, "web_join_room_config", this.toString());
  }
};
_defineProperty(JoinRoomConfig, "DEFAULT_CONF", { useTcpAfterJoinTimeout: true, joinWithTcpOnly: false, joinWithTcpOnlyDelay: 5e3 });
var ErrorCode = ((e) => (e.INVALID_ENGINE = "INVALID_ENGINE", e.INVALID_PARAMS = "INVALID_PARAMS", e.INVOKED_BEFORE_JOIN_ROOM = "INVOKED_BEFORE_JOIN_ROOM", e.INVALID_TOKEN = "INVALID_TOKEN", e.JOIN_ROOM_FAILED = "JOIN_ROOM_FAILED", e.UPDATE_TOKEN_WITH_INVALID_TOKEN = "UPDATE_TOKEN_WITH_INVALID_TOKEN", e.UPDATE_TOKEN_BEFORE_JOIN = "UPDATE_TOKEN_BEFORE_JOIN", e.REPEAT_JOIN = "REPEAT_JOIN", e.REPEAT_PUBLISH = "REPEAT_PUBLISH", e.REPEAT_PUSH = "REPEAT_PUSH", e.REPEAT_PLAY = "REPEAT_PLAY", e.PUBLISH_BEFORE_JOIN = "PUBLISH_BEFORE_JOIN", e.UNPUBLISH_BEFORE_JOIN = "UNPUBLISH_BEFORE_JOIN", e.SUBSCRIBE_BEFORE_JOIN = "SUBSCRIBE_BEFORE_JOIN", e.UNSUBSCRIBE_BEFORE_JOIN = "UNSUBSCRIBE_BEFORE_JOIN", e.NO_PUBLISH_PERMISSION = "NO_PUBLISH_PERMISSION", e.STREAM_NOT_EXIST = "STREAM_NOT_EXIST", e.EMPTY_STREAM = "EMPTY_STREAM", e.NOT_CONNECTED_YET = "NOT_CONNECTED_YET", e.IM_BEFORE_JOIN = "IM_BEFORE_JOIN", e.USER_NOT_EXIST = "USER_NOT_EXIST", e.ALREADY_IN_ROOM = "ALREADY_IN_ROOM", e.KICKED_OUT = "KICKED_OUT", e.ROOM_DISMISS = "ROOM_DISMISS", e.TOKEN_EXPIRED = "TOKEN_EXPIRED", e.TOKEN_NO_PUBLISH_PERMISSION = "TOKEN_NO_PUBLISH_PERMISSION", e.TOKEN_NO_SUBSCRIBE_PERMISSION = "TOKEN_NO_SUBSCRIBE_PERMISSION", e.DUPLICATE_LOGIN = "DUPLICATE_LOGIN", e.INVOKED_BEFORE_CAPTURE = "INVOKED_BEFORE_CAPTURE", e.REPEAT_CAPTURE = "REPEAT_CAPTURE", e.GET_VIDEO_TRACK_FAILED = "GET_VIDEO_TRACK_FAILED", e.GET_AUDIO_TRACK_FAILED = "GET_AUDIO_TRACK_FAILED", e.GET_SCREEN_TRACK_FAILED = "GET_SCREEN_TRACK_FAILED", e.STREAM_TYPE_NOT_MATCH = "STREAM_TYPE_NOT_MATCH", e.CANT_FIND_DOM = "CANT_FIND_DOM", e.INVALID_DEVICE_ID = "INVALID_DEVICE_ID", e.NO_PERMISSION = "NO_PERMISSION", e.NOT_SUPPORTED = "NOT_SUPPORTED", e.INTERRUPT = "INTERRUPT", e.ICE_SERVER_WRONG = "ICE_SERVER_WRONG", e.ESTABLISH_DATACHANNEL_FAILED = "ESTABLISH_DATACHANNEL_FAILED", e.LOAD_RESOURCES_FAILED = "LOAD_RESOURCES_FAILED", e.SIGNALING_CHANNEL_NOT_OPEN = "SIGNALING_CHANNEL_NOT_OPEN", e.TIME_OUT = "TIME_OUT", e.REFUSE_OPERATION_IN_DISCONNECT = "REFUSE_OPERATION_IN_DISCONNECT", e.ADD_TRANSCEIVER_FAILED = "ADD_TRANSCEIVER_FAILED", e.UPDATE_TRACK_FAILED = "UPDATE_TRACK_FAILED", e.PUBLISH_FAILED = "PUBLISH_FAILED", e.UNPUBLISH_FAILED = "UNPUBLISH_FAILED", e.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e.OPERATION_CANCEL = "OPERATION_CANCEL", e.START_CLOUD_PROXY_AFTER_JOIN = "START_CLOUD_PROXY_AFTER_JOIN", e.STOP_CLOUD_PROXY_BEFORE_LEAVE = "STOP_CLOUD_PROXY_BEFORE_LEAVE", e.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e.REPEAT_DEVICE_TEST = "REPEAT_DEVICE_TEST", e.AUDIO_DEVICE_TEST_FAILED = "AUDIO_DEVICE_RECORD_FAILED", e.ALREADY_LOGIN = "ALREADY_LOGIN", e.LOGIN_FAILED = "LOGIN_FAILED", e.NOT_LOGIN = "NOT_LOGIN", e.RTM_DUPLICATE_LOGIN = "RTM_DUPLICATE_LOGIN", e.RTM_TOKEN_ERROR = "RTM_TOKEN_ERROR", e.USER_MESSAGE_TIMEOUT = "USER_MESSAGE_TIMEOUT", e.USER_MESSAGE_BROKEN = "USER_MESSAGE_BROKEN", e.USER_MESSAGE_NO_RECEIVER = "USER_MESSAGE_NO_RECEIVER", e.USER_MESSAGE_NO_RELAYPATH = "USER_MESSAGE_NO_RELAYPATH", e.USER_MESSAGE_EXCEED_QPS = "USER_MESSAGE_EXCEED_QPS", e.USER_MESSAGE_SEND_TO_SERVER_ERROR = "USER_MESSAGE_SEND_TO_SERVER_ERROR", e.USER_MESSAGE_SERVER_RESPONSE_ERROR = "USER_MESSAGE_SERVER_RESPONSE_ERROR", e.USER_MESSAGE_NOT_JOIN = "USER_MESSAGE_NOT_JOIN", e.USER_MESSAGE_INIT = "USER_MESSAGE_INIT", e.USER_MESSAGE_NO_CONNECTION = "USER_MESSAGE_NO_CONNECTION", e.USER_MESSAGE_NOT_LOGIN = "USER_MESSAGE_NOT_LOGIN", e.USER_MESSAGE_SERVER_PARAMS_NOTSET = "USER_MESSAGE_SERVER_PARAMS_NOTSET", e.USER_MESSAGE_UNKNOWN = "USER_MESSAGE_UNKNOWN", e.START_PUBLIC_STREAM_BEFORE_JOIN = "START_PUBLIC_STREAM_BEFORE_JOIN", e.RECONNECT_FAILED = "RECONNECT_FAILED", e.SUBTITLE_ALREADY_ON = "SUBTITLE_ALREADY_ON", e.SUBTITLE_NOT_TURNED_ON = "SUBTITLE_NOT_TURNED_ON", e.SUBTITLE_ERR_POSTPROCESS = "SUBTITLE_ERR_POSTPROCESS", e.SUBTITLE_ERR_CONNECTION_ERROR = "SUBTITLE_ERR_CONNECTION_ERROR", e.SUBTITLE_ERR_PROCESS_ERROR = "SUBTITLE_ERR_PROCESS_ERROR", e.SUBTITLE_ERR_UNKNOWN = "SUBTITLE_ERR_UNKNOWN", e.UNEXPECTED_INVOKE_FORWARD_STREAM = "UNEXPECTED_INVOKE_FORWARD_STREAM", e.ROOM_FORBIDDEN = "ROOM_FORBIDDEN", e.USER_FORBIDDEN = "USER_FORBIDDEN", e.ERR_ELECTRON_IS_NULL = "ERR_ELECTRON_IS_NULL", e.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e.SET_SIMULCAST_FAILED = "SET_SIMULCAST_FAILED", e.MIXING_OLD_AND_NEW_APIS = "MIXING_OLD_AND_NEW_APIS", e.WTN_PUSH_FAILED = "WTN_PUSH_FAILED", e.WTN_PLAY_FAILED = "WTN_PLAY_FAILED", e.NOT_ALLOWED_IN_RTS_ROOM = "NOT_ALLOWED_IN_RTS_ROOM", e.NOT_ALLOWED_IN_RESTRICTED_MODE = "NOT_ALLOWED_IN_RESTRICTED_MODE", e))(ErrorCode || {});
var AudioMixingError = ((e) => (e[e.AUDIO_MIXING_ERROR_OK = 0] = "AUDIO_MIXING_ERROR_OK", e[e.AUDIO_MIXING_ERROR_PRELOAD_FAILED = 1] = "AUDIO_MIXING_ERROR_PRELOAD_FAILED", e[e.AUDIO_MIXING_ERROR_START_FAILED = 2] = "AUDIO_MIXING_ERROR_START_FAILED", e[e.AUDIO_MIXING_ERROR_ID_NOT_FOUND = 3] = "AUDIO_MIXING_ERROR_ID_NOT_FOUND", e[e.AUDIO_MIXING_ERROR_SET_POSITION_FAILED = 4] = "AUDIO_MIXING_ERROR_SET_POSITION_FAILED", e[e.AUDIO_MIXING_ERROR_INVALID_VOLUME = 5] = "AUDIO_MIXING_ERROR_INVALID_VOLUME", e[e.AUDIO_MIXING_ERROR_LOAD_CONFLICT = 6] = "AUDIO_MIXING_ERROR_LOAD_CONFLICT", e[e.AUDIO_MIXING_ERROR_ID_TYPE_NOT_MATCH = 7] = "AUDIO_MIXING_ERROR_ID_TYPE_NOT_MATCH", e[e.AUDIO_MIXING_ERROR_ID_TYPE_INVALID_PITCH = 8] = "AUDIO_MIXING_ERROR_ID_TYPE_INVALID_PITCH", e[e.AUDIO_MIXING_ERROR_INVALID_AUDIO_TRACK = 9] = "AUDIO_MIXING_ERROR_INVALID_AUDIO_TRACK", e))(AudioMixingError || {});
var SDKError = class _SDKError extends Error {
  constructor(e, t, i) {
    super(t), _defineProperty(this, "code", void 0), _defineProperty(this, "message", void 0), _defineProperty(this, "error", void 0), this.code = e, this.message = t, this.error = i, Object.setPrototypeOf(this, _SDKError.prototype);
  }
  toString() {
    return "SDKError: ".concat(this.code, " ").concat(this.message);
  }
};
var EngineEventsTypes = ((e) => (e.onTrackEnded = "onTrackEnded", e.onTrackMute = "onTrackMute", e.onTrackUnmute = "onTrackUnmute", e.onPlayerEvent = "onPlayerEvent", e.onAutoplayFailed = "onAutoplayFailed", e.onUserJoined = "onUserJoined", e.onUserLeave = "onUserLeave", e.onConnectionStateChanged = "onConnectionStateChanged", e.onUserPublishStream = "onUserPublishStream", e.onUserUnpublishStream = "onUserUnpublishStream", e.onUserPublishScreen = "onUserPublishScreen", e.onUserUnpublishScreen = "onUserUnpublishScreen", e.onRoomMessageReceived = "onRoomMessageReceived", e.onRoomBinaryMessageReceived = "onRoomBinaryMessageReceived", e.onUserMessageReceived = "onUserMessageReceived", e.onUserBinaryMessageReceived = "onUserBinaryMessageReceived", e.onVideoFirstFrameRendered = "onVideoFirstFrameRendered", e.onVideoFirstFrameDecoded = "onVideoFirstFrameDecoded", e.onRemoteVideoFirstFrame = "onRemoteVideoFirstFrame", e.onAudioFirstFrameDecoded = "onAudioFirstFrameDecoded", e.onRemoteAudioFirstFrame = "onRemoteAudioFirstFrame", e.onFirstPublicStreamVideoFrameRendered = "onFirstPublicStreamVideoFrameRendered", e.onFirstPublicStreamVideoFrameDecoded = "onFirstPublicStreamVideoFrameDecoded", e.onFirstPublicStreamAudioFrameDecoded = "onFirstPublicStreamAudioFrameDecoded", e.onVideoDeviceStateChanged = "onVideoDeviceStateChanged", e.onAudioDeviceStateChanged = "onAudioDeviceStateChanged", e.onRemoteStreamStats = "onRemoteStreamStats", e.onPublicStreamStats = "onPublicStreamStats", e.onLocalStreamStats = "onLocalStreamStats", e.onAudioVolumeIndication = "onAudioVolumeIndication", e.onLocalAudioPropertiesReport = "onLocalAudioPropertiesReport", e.onRemoteAudioPropertiesReport = "onRemoteAudioPropertiesReport", e.onActiveSpeaker = "onActiveSpeaker", e.onAudioPlaybackDeviceChanged = "onAudioPlaybackDeviceChanged", e.onUserStartVideoCapture = "onUserStartVideoCapture", e.onUserStopVideoCapture = "onUserStopVideoCapture", e.onUserStartAudioCapture = "onUserStartAudioCapture", e.onUserStopAudioCapture = "onUserStopAudioCapture", e.onAutoPublishResult = "onAutoPublishResult", e.onAutoSubscribeResult = "onAutoSubscribeResult", e.onLiveTranscodingResult = "onLiveTranscodingResult", e.onStreamMixingEvent = "onStreamMixingEvent", e.onAudioPlaybackDeviceTestVolume = "onAudioPlaybackDeviceTestVolume", e.onSEIMessageReceived = "onSEIMessageReceived", e.onError = "onError", e.onAudioMixingStateChanged = "onAudioMixingStateChanged", e.onUserMessageReceivedOutsideRoom = "onUserMessageReceivedOutsideRoom", e.onUserBinaryMessageReceivedOutsideRoom = "onUserBinaryMessageReceivedOutsideRoom", e.onTokenWillExpire = "onTokenWillExpire", e.onTokenPublishPrivilegeWillExpire = "onTokenPublishPrivilegeWillExpire", e.onTokenPublishPrivilegeDidExpired = "onTokenPublishPrivilegeDidExpired", e.onTokenSubscribePrivilegeWillExpire = "onTokenSubscribePrivilegeWillExpire", e.onTokenSubscribePrivilegeDidExpired = "onTokenSubscribePrivilegeDidExpired", e.onCloudProxyConnected = "onCloudProxyConnected", e.onPushPublicStreamResult = "onPushPublicStreamResult", e.onPublicStreamSEIMessageReceived = "onPublicStreamSEIMessageReceived", e.onNetworkQuality = "onNetworkQuality", e.onSimulcastSubscribeFallback = "onSimulcastSubscribeFallback", e.onRemoteVideoSizeChanged = "onRemoteVideoSizeChanged", e.onVideoStreamBanned = "onVideoStreamBanned", e.onAudioStreamBanned = "onAudioStreamBanned", e.onLocalVideoSizeChanged = "onLocalVideoSizeChanged", e.onSubtitleStateChanged = "onSubtitleStateChanged", e.onSubtitleMessageReceived = "onSubtitleMessageReceived", e.onServerParamsSetResult = "onServerParamsSetResult", e.onLocalStreamTrackChangedByExtension = "onLocalStreamTrackChangedByExtension", e.onVendorConnectionStateChanged = "onVendorConnectionStateChanged", e.onForwardStreamError = "onForwardStreamError", e.onRejoinWithTcp = "onRejoinWithTcp", e.onIceConnectWithTcp = "onIceConnectWithTcp", e.onPublishRetry = "onPublishRetry", e.onSubscribeRetry = "onSubscribeRetry", e.onPublishResult = "onPublishResult", e.onSubscribeResult = "onSubscribeResult", e.onSEIStreamUpdate = "onSEIStreamUpdate", e))(EngineEventsTypes || {});
function checkBoolean(e, t) {
  if ("boolean" != typeof e) throw new SDKError(ErrorCode.INVALID_PARAMS, "Invalid ".concat(t, ": The value should be boolean type."));
}
var checkVideoFrameCallback = () => !isSSR$1() && "function" == typeof HTMLVideoElement.prototype.requestVideoFrameCallback;
function checkNumber(e, t) {
  let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number.POSITIVE_INFINITY;
  if (e < i || e > r || "number" != typeof e) {
    throw new SDKError(ErrorCode.INVALID_PARAMS, "Invalid ".concat(t, ": the value range is [").concat(i, ", ").concat(r, "]. integer only"));
  }
}
function checkString(e, t) {
  let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number.POSITIVE_INFINITY;
  if (null == e) throw new SDKError(ErrorCode.INVALID_PARAMS, "".concat(t, " cannot be empty"));
  if (!isValidString(e, i, r)) throw new SDKError(ErrorCode.INVALID_PARAMS, "Invalid ".concat(t, ": The value should be string type. Length of the string: [").concat(i, ",").concat(r, "]"));
}
function checkEnum(e, t, i) {
  if (!i.includes(e)) throw new SDKError(ErrorCode.INVALID_PARAMS, "Invalid ".concat(t, ": The value can only be set as ").concat(JSON.stringify(i)));
}
function checkMediaStreamTrack(e) {
  if (!(e instanceof MediaStreamTrack)) throw new SDKError(ErrorCode.INVALID_PARAMS, "Invalid track, The value should be MediaStreamTrack type.");
}
function checkEmpty(e, t) {
  if (isEmpty(e)) throw new SDKError(ErrorCode.INVALID_PARAMS, "Invalid ".concat(t, ", should not be empty"));
}
function checkArray(e, t) {
  if (!Array.isArray(e)) throw new SDKError(ErrorCode.INVALID_PARAMS, "Invalid ".concat(t, ", should be array"));
}
function checkArrayBuffer(e, t) {
  if (!(e instanceof ArrayBuffer)) throw new SDKError(ErrorCode.INVALID_PARAMS, "Invalid ".concat(t, ", should be ArrayBuffer"));
}
function checkSupportedConstraints(e) {
  try {
    const t = navigator.mediaDevices.getSupportedConstraints();
    for (const i of Object.keys(e)) t[i] || delete e[i];
  } catch (e2) {
  }
}
function isValidString(e) {
  let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.POSITIVE_INFINITY;
  return "string" == typeof e && e.length <= i && e.length >= t;
}
function isEmpty(e) {
  return null == e;
}
function checkRoomId(e) {
  if ("string" != typeof e || !/^[a-zA-Z0-9@._-]{1,128}$/.test(e)) throw new SDKError(ErrorCode.INVALID_PARAMS, "The RoomId must be within 128 bytes. The supported characters: a-z,A-Z,0-9,@,-,_,.");
}
function checkUserId(e) {
  if ("string" != typeof e || !/^[a-zA-Z0-9@._-]{1,128}$/.test(e)) throw new SDKError(ErrorCode.INVALID_PARAMS, "The userId must be within 128 bytes. The supported characters: a-z,A-Z,0-9,@,-,_,.");
}
function checkPublicStreamId(e) {
  if ("string" != typeof e || !/^[a-zA-Z0-9@._-]{1,128}$/.test(e)) throw new SDKError(ErrorCode.INVALID_PARAMS, "The publicStreamId must be within 128 bytes. The supported characters: a-z,A-Z,0-9,@,-,_,.");
}
function illegalBusinessId(e) {
  return "string" != typeof e;
}
function checkUserInfo(e) {
  checkEmpty(e, "userInfo"), checkUserId(e.userId), isEmpty(e.extraInfo) || checkString(e.extraInfo, "userInfo.extraInfo", 1, 200);
}
function checkRoomConfig(e) {
  checkEmpty(e, "roomConfig"), checkBoolean(e.isAutoPublish, "roomConfig.isAutoPublish"), checkBoolean(e.isAutoSubscribeAudio, "roomConfig.isAutoSubscribeAudio"), checkBoolean(e.isAutoSubscribeVideo, "roomConfig.isAutoSubscribeVideo"), isEmpty(e.roomProfileType) || checkEnum(e.roomProfileType, "roomConfig", [RoomProfileType.communication, RoomProfileType.chat, RoomProfileType.chatRoom, RoomProfileType.coHost, RoomProfileType.meeting, RoomProfileType.classRoom]);
}
function checkVideoPlayerOption(e) {
  checkEmpty(e, "videoPlayerOption");
}
function checkBufferSize(e) {
  var t, i;
  let r, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64;
  if (!e || 0 === (null == e ? void 0 : e.byteLength)) throw new SDKError(ErrorCode.INVALID_PARAMS, "The message cannot be empty");
  if (e instanceof ArrayBuffer) r = e;
  else {
    if ("string" != typeof e) throw new SDKError(ErrorCode.INVALID_PARAMS, "The message must be string or ArrayBuffer");
    r = Utils.str2ab(e);
  }
  if ((null === (t = r) || void 0 === t ? void 0 : t.byteLength) > 1024 * o) throw new SDKError(ErrorCode.INVALID_PARAMS, "The message length must be less than ".concat(o, "KB"));
  return null !== (i = r.byteLength) && void 0 !== i ? i : 0;
}
function isReportCallback(e) {
  const t = getParameter("FORCE_ENABLED_REPORT_CALLBACKS");
  if (null != t && t.includes(e)) return true;
  if (e === EngineEventsTypes.onRemoteStreamStats) {
    if (!!getParameter("UPLOAD_REMOTE_STATS")) return true;
  }
  return ![EngineEventsTypes.onRemoteStreamStats, EngineEventsTypes.onLocalStreamStats, EngineEventsTypes.onAudioVolumeIndication, EngineEventsTypes.onLocalAudioPropertiesReport, EngineEventsTypes.onRemoteAudioPropertiesReport].includes(e);
}
function checkRemoteConfig(e) {
  if ("number" != typeof (null == e ? void 0 : e.width) || "number" != typeof (null == e ? void 0 : e.height)) throw new SDKError(ErrorCode.INVALID_PARAMS, "remoteVideoConfig must contain width, height, frameRate");
}
function checkConstrainULongg(e, t) {
  if ("number" == typeof e && !Number.isNaN(e) && e >= 1) return;
  const i = e;
  if (!(null != i && i.min || null != i && i.max || null != i && i.exact || null != i && i.ideal)) throw new SDKError(ErrorCode.INVALID_PARAMS, "".concat(t, " is not a valid ConstrainULong"));
}
function checkVideoEncoderConfig(e) {
  checkArray(e, "videoEncoderConfig");
  for (const t of e) checkEmpty(t, "videoEncoderConfigItem"), checkNumber(null == t ? void 0 : t.maxKbps, "maxKbps"), checkConstrainULongg(null == t ? void 0 : t.width, "width"), checkConstrainULongg(null == t ? void 0 : t.height, "height"), checkConstrainULongg(null == t ? void 0 : t.frameRate, "frameRate");
}
function numberRangeGuide(e, t) {
  let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.NEGATIVE_INFINITY, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number.POSITIVE_INFINITY;
  return checkNumber(e, t, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY), e = (e = e > i ? e : i) < r ? e : r;
}
function checkAudioAndVideoDeviceId(e, t) {
  let i;
  return isEmpty(t) || checkString(t, "videoDeviceId"), isEmpty(e) || ("string" == typeof e ? (checkString(e, "audioDeviceId"), i = e) : (i = null == e ? void 0 : e.audioDeviceId, t = null == e ? void 0 : e.videoDeviceId, checkString(i, "audioDeviceId"), checkString(t, "videoDeviceId"))), { audioDeviceId: i, videoDeviceId: t };
}
var ExtendMediaType = ((e) => (e[e.NONE = 0] = "NONE", e))(ExtendMediaType || {});
var $$j = _export;
var globalThis$h = globalThis_1;
$$j({ global: true, forced: globalThis$h.globalThis !== globalThis$h }, { globalThis: globalThis$h });
var globalThis$g = globalThis_1;
var parent$h = globalThis$g;
var globalThis$f = parent$h;
var parent$g = globalThis$f;
var globalThis$e = parent$g;
var parent$f = globalThis$e;
var globalThis$d = parent$f;
var globalThis$c = globalThis$d;
var globalThis$b = globalThis$c;
var _globalThis = getDefaultExportFromCjs(globalThis$b);
var VideoCodecName = ((e) => (e.H264 = "H264", e.VP8 = "VP8", e.ByteVC1 = "ByteVC1", e))(VideoCodecName || {});
var isSupported = async () => {
  try {
    return !(isSSR() || !window.RTCPeerConnection || !window.RTCPeerConnection.prototype.addTransceiver || !window.RTCPeerConnection.prototype.createDataChannel) && (await isH264DecodeSupported() && await isH264EncodeSupported());
  } catch (e) {
    return false;
  }
};
var internalGetSupportedCodecs = async () => {
  const e = [];
  return await isH265DecodeSupported() && await isH265EncodeSupported() && e.push(VideoCodecName.ByteVC1), await isH264DecodeSupported() && await isH264EncodeSupported() && e.push(VideoCodecName.H264), await isVP8DecodeSupported() && await isVP8EncodeSupported() && e.push(VideoCodecName.VP8), e;
};
var getSupportedCodecs = async () => (await internalGetSupportedCodecs()).map((e) => e === VideoCodecName.ByteVC1 ? "H265" : e.toUpperCase());
var hasHardwareEncodeProfile = () => {
  let e = false;
  if ("function" == typeof RTCRtpSender.getCapabilities) {
    const { codecs: t } = RTCRtpSender.getCapabilities("video") || {};
    t && t.length > 0 && t.forEach((t2) => {
      var i, r;
      (null !== (i = null == t2 || null === (r = t2.sdpFmtpLine) || void 0 === r ? void 0 : r.indexOf("profile-level-id=42001f")) && void 0 !== i ? i : -1) > -1 && (e = true);
    });
  }
  return e;
};
var codecsSupportMap = {};
function supportH264(e) {
  const t = e.split("\n");
  let i = false;
  for (const e2 of t) if (e2.includes("level-asymmetry-allowed=1") && e2.includes("packetization-mode=1") && e2.includes("profile-level-id=42e0")) {
    i = true;
    break;
  }
  if (i) {
    const e2 = navigator.userAgent.toLowerCase();
    let t2 = false;
    const i2 = [/miuibrowser/, /70.*HeyTapBrowser/i];
    for (const r of i2) r.test(e2) && (t2 = true);
    return !t2;
  }
  return false;
}
var createOfferSdp = async (e) => {
  const t = new RTCPeerConnection();
  t.addTransceiver("video", { direction: e });
  const i = await t.createOffer();
  return t.close(), i.sdp.toLowerCase();
};
var checkCodecsEncodeSupport = async () => {
  let e = await createOfferSdp("sendonly");
  return navigator.userAgent.includes("VivoBrowser") && (e = await createOfferSdp("sendonly")), codecsSupportMap.h264encode = supportH264(e), codecsSupportMap.vp8encode = e.indexOf("vp8") > -1, codecsSupportMap.h265encode = e.indexOf("h265") > -1, codecsSupportMap;
};
var checkCodecsDecodeSupport = async () => {
  let e = await createOfferSdp("recvonly");
  return navigator.userAgent.includes("VivoBrowser") && (e = await createOfferSdp("recvonly")), codecsSupportMap.h264decode = supportH264(e), codecsSupportMap.vp8decode = e.indexOf("vp8") > -1, codecsSupportMap.h265decode = e.indexOf("h265") > -1, codecsSupportMap;
};
var isH264EncodeSupported = async () => {
  if (void 0 === codecsSupportMap.h264encode) try {
    await checkCodecsEncodeSupport();
  } catch (e) {
    return false;
  }
  return codecsSupportMap.h264encode || false;
};
var isH264DecodeSupported = async () => {
  if (void 0 === codecsSupportMap.h264decode) try {
    await checkCodecsDecodeSupport();
  } catch (e) {
    return false;
  }
  return codecsSupportMap.h264decode || false;
};
var isVP8EncodeSupported = async () => {
  if (void 0 === codecsSupportMap.vp8encode) try {
    await checkCodecsEncodeSupport();
  } catch (e) {
    return false;
  }
  return codecsSupportMap.vp8encode || false;
};
var isVP8DecodeSupported = async () => {
  if (void 0 === codecsSupportMap.vp8decode) try {
    await checkCodecsDecodeSupport();
  } catch (e) {
    return false;
  }
  return codecsSupportMap.vp8decode || false;
};
var isH265EncodeSupported = async () => {
  if (void 0 === codecsSupportMap.h265encode) try {
    await checkCodecsEncodeSupport();
  } catch (e) {
    return false;
  }
  return codecsSupportMap.h265encode || false;
};
var isH265DecodeSupported = async () => {
  if (void 0 === codecsSupportMap.h265decode) try {
    await checkCodecsDecodeSupport();
  } catch (e) {
    return false;
  }
  return codecsSupportMap.h265decode || false;
};
var isEncodedTransformSupported = () => "undefined" != typeof TransformStream && "undefined" != typeof RTCRtpSender && "undefined" != typeof RTCRtpReceiver && "undefined" != typeof RTCRtpScriptTransform && "transform" in RTCRtpSender.prototype && "transform" in RTCRtpReceiver.prototype && isWorkerSupported() && isMessageChannelSupported();
var isLegacyEncodedTransformSupported = () => "undefined" != typeof TransformStream && "undefined" != typeof RTCRtpSender && "undefined" != typeof RTCRtpReceiver && void 0 !== RTCRtpSender.prototype.createEncodedStreams && void 0 !== RTCRtpReceiver.prototype.createEncodedStreams;
var isWebAudioSupported = () => isMac ? isChrome && chromeVersion >= 70 || isFirefox && firefoxVersion >= 80 || isSafari && safariVersion >= 14 : isWindows ? isChrome && chromeVersion >= 70 || isFirefox && firefoxVersion >= 80 : isIOS ? iOSVersion[0] >= 14 : !(!isAndroid && !isOpenHarmony) && (isChrome && chromeVersion >= 86);
var isStatsCallbackSupport = isChrome && chromeVersion <= 114;
var isTransportCCSupport = !isFirefox || firefoxVersion >= 96;
var isRRTRSupported = !(isSafari && safariVersion <= 14);
var unsupportedSimultaneousCapture = isAndroid && isChrome || isIOS && iOSVersion[0] >= 16;
var isSimulcastSupported = () => !isFirefox && !isOpera && 14 !== (null == iOSVersion ? void 0 : iOSVersion[0]);
var isComputePressureSupported = void 0 !== _globalThis && "PressureObserver" in _globalThis;
var isWorkerSupported = () => "undefined" != typeof window && window.Worker;
var notSupport48k = isSafari && safariVersion <= 14;
var is48kSupported = !notSupport48k;
var isMessageChannelSupported = () => "undefined" != typeof MessageChannel;
var notSupportConstraintInGetDisplayMedia = isSafari && ((null == safariMinorVersion ? void 0 : safariMinorVersion.includes("16.1")) || (null == safariMinorVersion ? void 0 : safariMinorVersion.includes("16.2")) || (null == safariMinorVersion ? void 0 : safariMinorVersion.includes("16.3")));
var isConstraintInGetDisplayMediaSupported = !notSupportConstraintInGetDisplayMedia;
var _window;
var internalAccessDomains = "rtc-access-ag.bytedance.com,rtc-access.bytedance.com,rtc-access2-hl.bytedance.com,rtcg-access.bytevcloud.com".split(",");
function getFullAccessUrl() {
  let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
  return e ? (/^https?:\/\/.+/.test(e) || (e = "https://".concat(e)), "".concat(e, "/dispatch/v1/AccessInfo?Action=GetAccessInfo")) : "";
}
function getFullLogServerUrl() {
  let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
  return e ? (/^https?:\/\/.+/.test(e) || (e = "https://".concat(e)), "".concat(e, "/video/v1/webrtc_log/")) : "";
}
var domesticLogServerUrl = "https://web-log-report.rtc.volcvideo.com/video/v1/webrtc_log/";
var overseasLogServerUrl = "https://web-log-report.volcvideos.com/video/v1/webrtc_log/";
var configDomains = "common.rtc.volcvideo.com,rtcg.volcvideos.com".split(",");
var Config2 = { VERSION: "4.66.30", ICE_CONFIG_REQUEST_URLS_INTERNAL: internalAccessDomains.map(getFullAccessUrl), ICE_CONFIG_REQUEST_URLS: [], EXPECTED_ADDR: "", LOG_SERVER_URL: domesticLogServerUrl, CONFIG_REQUEST_DOMAINS: configDomains, DEVICE_ID: "", OVERSEA: false, PLATFORM: "", PRODUCT: "", FORCE_ENABLED_REPORT_CALLBACKS: [], SKIP_WEB_AUDIO_IN_TRACK: false, ENFORCE_WEB_AUDIO_SUPPORTED: false, AUDIO_STALL: true, VIDEO_STALL: true, VIDEO_STALL_100MS: false, STATS_SCALLBACK_SUPPORT: true, JOIN_ROOM_CONFIG: JoinRoomConfig.DEFAULT_CONF, SIGNAL_COMPRESSION: true, SIGNAL_CROP_JOINROOM: true, VIDEO_STALL_DATA: 500, AUDIO_STALL_DATA: 200, IOS_SAFARI_ORIENTATION: false, BLACK_FRAME_LIFETIME: 6e4, FALLBACK_ENCODE_CODEC: "", SEI_TIME_OUT: 2e3, SEI_COUNT_FPS: 1, PRE_ICE: false, STATS_LOOP_INTERVAL: 1e3, HIDDEN_STATS: false, UPLOAD_REMOTE_STATS: ExtendMediaType.NONE, SDK_CODEC_NEGOTIATION: true, AUDIO_CODEC: "OPUS", DISABLE_ENCODED_TRANSFORM: false, SKIP_SEI_FILTER: false, AREA_CODE: "", DISABLE_COMPUTE_PRESSURE: false, SEND_MESSAGE_SYNC: false, H264_HW_ENCODER: false, GPU_URL: "", ENABLE_FALLBACK_HANDLER: false, ENABLE_STANDARD_HANDLER: isStandardModeEnableByDefault(), PC_KILLSWITCH: {}, ENABLE_PLAY_AFTER_CLICK: false, AUTOPLAY_WORKAROUND: true, ENGINE_WEB_CONFIG: {}, DISABLE_IOS_MUTE_WORKAROUND: false };
var originalSetRemoteDescription = "undefined" == typeof window ? () => Promise.resolve() : null === (_window = window) || void 0 === _window || null === (_window = _window.RTCPeerConnection) || void 0 === _window ? void 0 : _window.prototype.setRemoteDescription;
function setParameter(e, t) {
  if (reportGlobalApiCall("setParameter", 0, "key: ".concat(e, ", value: ").concat(t)), "VERSION" === e) return;
  if ("H264_HW_ENCODER" === e) {
    if (Config2.H264_HW_ENCODER = !!t, t) {
      hasHardwareEncodeProfile() ? (reportGlobalApiCall("setParameter", 0, "key: ".concat(e, ", value: ").concat(t, " is executed as it met 42001f")), RTCPeerConnection.prototype.setRemoteDescription = function(e2) {
        var t2;
        return originalSetRemoteDescription.call(this, { type: e2.type, sdp: null === (t2 = e2.sdp) || void 0 === t2 ? void 0 : _replaceAllInstanceProperty(t2).call(t2, "42e01f", "42001f") });
      }) : reportGlobalApiCall("setParameter", 0, "key: ".concat(e, ", value: ").concat(t, " fails as sdp contains no 42001f"));
    } else RTCPeerConnection.prototype.setRemoteDescription = originalSetRemoteDescription;
    return;
  }
  if ("GPU_URL" === e) return void (Config2.GPU_URL = t);
  if ("JOIN_ROOM_CONFIG" === e) return JoinRoomConfig.setDefaulConf(t);
  if ("ICE_CONFIG_REQUEST_URLS" === e) {
    const e2 = "string" == typeof t ? [t] : t;
    return Config2.ICE_CONFIG_REQUEST_URLS = e2.map(getFullAccessUrl), sdkCache.clearAccessUrls(), void sdkCache.clearAccessNode();
  }
  if ("VIDEO_STALL_DATA" === e) return void (Config2.VIDEO_STALL_DATA = Math.max(500, Number(t)));
  if ("AUDIO_STALL_DATA" === e) return void (Config2.AUDIO_STALL_DATA = Math.max(200, Number(t)));
  if ("VIDEO_STALL_100MS" === e) return void (Config2.VIDEO_STALL_100MS = checkVideoFrameCallback() && !!t);
  if ("PLATFORM" === e && "string" == typeof t) return void setGlobalStats({ platform: t });
  if ("PRODUCT" === e && "string" == typeof t) return void setGlobalStats({ product: t });
  if ("FORCE_ENABLED_REPORT_CALLBACKS" === e) {
    const e2 = "string" == typeof t ? [t] : t;
    return void (Config2.FORCE_ENABLED_REPORT_CALLBACKS = e2);
  }
  if ("LOG_SERVER_URL" === e) {
    const e2 = t === LogChannel.overseas ? overseasLogServerUrl : t === LogChannel.domestic ? domesticLogServerUrl : "string" == typeof t ? t : void 0;
    e2 && (Config2.LOG_SERVER_URL = e2, setReportUrl(e2));
  } else if ("OVERSEA" === e) return setGlobalStats({ extra_is_oversea: t ? "1" : "0" }), void (Config2.OVERSEA = t);
  if ("CONFIG_REQUEST_DOMAINS" === e && Array.isArray(t) && t.length > 0) return void (Config2.CONFIG_REQUEST_DOMAINS = t);
  if ("SEI_TIME_OUT" === e && "number" != typeof t) return;
  if ("SEI_COUNT_FPS" === e && "number" != typeof t) return;
  if ("UPLOAD_REMOTE_STATS" === e && "string" == typeof t) {
    const e2 = t.split(",").map((e3) => _trimInstanceProperty(e3).call(e3)).reduce((e3, t2) => "video" === t2 ? e3 | MediaType$1.VIDEO : "audio" === t2 ? e3 | MediaType$1.AUDIO : e3, ExtendMediaType.NONE);
    return void (Config2.UPLOAD_REMOTE_STATS = e2);
  }
  if ("AINR_URLS" === e && "string" == typeof t) try {
    const { gulpUrl: e2, wasmUrl: i, type5ModelUrl: r, type6ModelUrl: o } = JSON.parse(t);
    return void (Config2.AINR_URLS = { gulpUrl: e2, wasmUrl: i, type5ModelUrl: r, type6ModelUrl: o });
  } catch (e2) {
    console.error(e2);
  }
  "DEVICE_ID" === e && sdkCache.setDeviceId(t);
  CoreConfig.getKeys().includes(e) ? CoreConfig.setParameter(e, t) : Reflect.set(Config2, e, t);
}
function getParameter(e) {
  return "DEVICE_ID" === e ? sdkCache.getDeviceId() : Config2[e];
}
function getPublicStreamControlMessage(e, t, i) {
  var r, o, n, s, a, d, c2, l;
  return { type: "publicstream", action: t, publicStreamID: e, publicStreamMeta: { audio: {}, video: { fps: (null === (r = i.video) || void 0 === r ? void 0 : r.fps) || 15, bitrate: 1e3 * ((null === (o = i.video) || void 0 === o ? void 0 : o.kBitRate) || 40), width: (null === (n = i.video) || void 0 === n ? void 0 : n.width) || 640, height: (null === (s = i.video) || void 0 === s ? void 0 : s.height) || 360 }, layout: { layoutMode: 2, interpolationMode: (null === (a = i.layout) || void 0 === a ? void 0 : a.interpolationMode) || PublicInterpolationMode.PREV_FRAME, canvas: { bgColor: (null === (d = i.layout) || void 0 === d ? void 0 : d.backgroundColor) || "#000000", bgImage: (null === (c2 = i.layout) || void 0 === c2 ? void 0 : c2.backgroundImage) || "" }, regions: (null === (l = i.layout) || void 0 === l || null === (l = l.regions) || void 0 === l ? void 0 : l.map((e2) => ({ roomId: e2.roomId, userId: e2.userId, alterImage: e2.alertImage || "", alpha: !e2.alpha || Number(e2.alpha) > 1 || Number(e2.alpha) <= 0 ? 1 : Number(e2.alpha), x: !e2.x || Number(e2.x) >= 1 || Number(e2.x) < 0 ? 0 : Number(e2.x), y: !e2.y || Number(e2.y) >= 1 || Number(e2.y) < 0 ? 0 : Number(e2.y), w: !e2.w || Number(e2.w) > 1 || Number(e2.w) <= 0 ? 1 : Number(e2.w), h: !e2.h || Number(e2.h) > 1 || Number(e2.h) <= 0 ? 1 : Number(e2.h), zorder: !e2.zorder || Number(e2.zorder) < 0 || Number(e2.zorder) > 100 ? 0 : Number(e2.zorder), renderMode: void 0 === e2.renderMode ? 1 : e2.renderMode, streamType: e2.isScreenStream ? 1 : 0, mediaType: e2.mediaType || 0, sourceCrop: e2.sourceCrop }))) || [] } } };
}
var videoEncoderAutoConfigList = [];
function getVideoEncoderAutoConfigList() {
  return videoEncoderAutoConfigList;
}
function setVideoEncoderAutoConfigList(e) {
  videoEncoderAutoConfigList = e;
}
var autoResetVideoEncoderConfig = (e, t) => {
  const i = getVideoEncoderAutoConfigList();
  if (!i.length) return;
  const r = e[0], o = t.width || constraints2number(r.width), n = t.height || constraints2number(r.height), s = o * n;
  if (constraints2number(r.width) * constraints2number(r.height) <= s) return;
  let a, d, c2 = i[0];
  i.forEach((e2) => {
    const t2 = constraints2number(e2.width) * constraints2number(e2.height);
    a || (s < t2 ? a = e2 : c2 = e2);
  }), d = a && constraints2number(a.width) * constraints2number(a.height) - s < s - constraints2number(c2.width) * constraints2number(c2.height) ? Object.assign({}, a) : Object.assign({}, c2);
  const l = e.filter((e2) => !(d && constraints2number(e2.width) * constraints2number(e2.height) >= s) || (d.maxKbps = Math.min(e2.maxKbps, d.maxKbps), false));
  return l.unshift({ width: o, height: n, frameRate: t.frameRate ? Math.round(t.frameRate) : l[0].frameRate, maxKbps: d.maxKbps }), l;
};
var defaultVideoEncoderConfig = { width: 640, height: 480, frameRate: 15, maxKbps: 600 };
var defaultScreenEncoderConfig = { width: 1920, height: 1080, frameRate: 15, maxKbps: 3e3 };
function isStandardModeEnableByDefault() {
  return (isChrome || isEdge) && !isIOS;
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
var byteToHex = [];
for (let e = 0; e < 256; ++e) byteToHex.push((e + 256).toString(16).slice(1));
function unsafeStringify(e) {
  let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
  return byteToHex[e[t + 0]] + byteToHex[e[t + 1]] + byteToHex[e[t + 2]] + byteToHex[e[t + 3]] + "-" + byteToHex[e[t + 4]] + byteToHex[e[t + 5]] + "-" + byteToHex[e[t + 6]] + byteToHex[e[t + 7]] + "-" + byteToHex[e[t + 8]] + byteToHex[e[t + 9]] + "-" + byteToHex[e[t + 10]] + byteToHex[e[t + 11]] + byteToHex[e[t + 12]] + byteToHex[e[t + 13]] + byteToHex[e[t + 14]] + byteToHex[e[t + 15]];
}
var randomUUID = "undefined" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = { randomUUID };
function v4(e, t, i) {
  if (native.randomUUID && !t && !e) return native.randomUUID();
  const r = (e = e || {}).random || (e.rng || rng)();
  if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
    i = i || 0;
    for (let e2 = 0; e2 < 16; ++e2) t[i + e2] = r[e2];
    return t;
  }
  return unsafeStringify(r);
}
var libTypedarrays = { exports: {} };
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var hasRequiredCore;
var core = { exports: {} };
var __viteBrowserExternal = new Proxy({}, { get(e, t) {
  throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${t}" in client code.  See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
} });
var __viteBrowserExternal$1 = Object.freeze({ __proto__: null, default: __viteBrowserExternal });
var require$$0 = getAugmentedNamespace(__viteBrowserExternal$1);
function requireCore() {
  return hasRequiredCore || (hasRequiredCore = 1, core.exports = (e = e || function(e2, t) {
    var i;
    if ("undefined" != typeof window && window.crypto && (i = window.crypto), "undefined" != typeof self && self.crypto && (i = self.crypto), void 0 !== _globalThis && _globalThis.crypto && (i = _globalThis.crypto), !i && "undefined" != typeof window && window.msCrypto && (i = window.msCrypto), !i && void 0 !== commonjsGlobal && commonjsGlobal.crypto && (i = commonjsGlobal.crypto), !i && "function" == typeof commonjsRequire) try {
      i = require$$0;
    } catch (e3) {
    }
    var r = function() {
      if (i) {
        if ("function" == typeof i.getRandomValues) try {
          return i.getRandomValues(new Uint32Array(1))[0];
        } catch (e3) {
        }
        if ("function" == typeof i.randomBytes) try {
          return i.randomBytes(4).readInt32LE();
        } catch (e3) {
        }
      }
      throw new Error("Native crypto module could not be used to get secure random number.");
    }, o = Object.create || /* @__PURE__ */ function() {
      function e3() {
      }
      return function(t2) {
        var i2;
        return e3.prototype = t2, i2 = new e3(), e3.prototype = null, i2;
      };
    }(), n = {}, s = n.lib = {}, a = s.Base = { extend: function(e3) {
      var t2 = o(this);
      return e3 && t2.mixIn(e3), t2.hasOwnProperty("init") && this.init !== t2.init || (t2.init = function() {
        t2.$super.init.apply(this, arguments);
      }), t2.init.prototype = t2, t2.$super = this, t2;
    }, create: function() {
      var e3 = this.extend();
      return e3.init.apply(e3, arguments), e3;
    }, init: function() {
    }, mixIn: function(e3) {
      for (var t2 in e3) e3.hasOwnProperty(t2) && (this[t2] = e3[t2]);
      e3.hasOwnProperty("toString") && (this.toString = e3.toString);
    }, clone: function() {
      return this.init.prototype.extend(this);
    } }, d = s.WordArray = a.extend({ init: function(e3, i2) {
      e3 = this.words = e3 || [], this.sigBytes = i2 != t ? i2 : 4 * e3.length;
    }, toString: function(e3) {
      return (e3 || l).stringify(this);
    }, concat: function(e3) {
      var t2 = this.words, i2 = e3.words, r2 = this.sigBytes, o2 = e3.sigBytes;
      if (this.clamp(), r2 % 4) for (var n2 = 0; n2 < o2; n2++) {
        var s2 = i2[n2 >>> 2] >>> 24 - n2 % 4 * 8 & 255;
        t2[r2 + n2 >>> 2] |= s2 << 24 - (r2 + n2) % 4 * 8;
      }
      else for (var a2 = 0; a2 < o2; a2 += 4) t2[r2 + a2 >>> 2] = i2[a2 >>> 2];
      return this.sigBytes += o2, this;
    }, clamp: function() {
      var t2 = this.words, i2 = this.sigBytes;
      t2[i2 >>> 2] &= 4294967295 << 32 - i2 % 4 * 8, t2.length = e2.ceil(i2 / 4);
    }, clone: function() {
      var e3 = a.clone.call(this);
      return e3.words = this.words.slice(0), e3;
    }, random: function(e3) {
      for (var t2 = [], i2 = 0; i2 < e3; i2 += 4) t2.push(r());
      return new d.init(t2, e3);
    } }), c2 = n.enc = {}, l = c2.Hex = { stringify: function(e3) {
      for (var t2 = e3.words, i2 = e3.sigBytes, r2 = [], o2 = 0; o2 < i2; o2++) {
        var n2 = t2[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255;
        r2.push((n2 >>> 4).toString(16)), r2.push((15 & n2).toString(16));
      }
      return r2.join("");
    }, parse: function(e3) {
      for (var t2 = e3.length, i2 = [], r2 = 0; r2 < t2; r2 += 2) i2[r2 >>> 3] |= parseInt(e3.substr(r2, 2), 16) << 24 - r2 % 8 * 4;
      return new d.init(i2, t2 / 2);
    } }, u = c2.Latin1 = { stringify: function(e3) {
      for (var t2 = e3.words, i2 = e3.sigBytes, r2 = [], o2 = 0; o2 < i2; o2++) {
        var n2 = t2[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255;
        r2.push(String.fromCharCode(n2));
      }
      return r2.join("");
    }, parse: function(e3) {
      for (var t2 = e3.length, i2 = [], r2 = 0; r2 < t2; r2++) i2[r2 >>> 2] |= (255 & e3.charCodeAt(r2)) << 24 - r2 % 4 * 8;
      return new d.init(i2, t2);
    } }, h = c2.Utf8 = { stringify: function(e3) {
      try {
        return decodeURIComponent(escape(u.stringify(e3)));
      } catch (e4) {
        throw new Error("Malformed UTF-8 data");
      }
    }, parse: function(e3) {
      return u.parse(unescape(encodeURIComponent(e3)));
    } }, _ = s.BufferedBlockAlgorithm = a.extend({ reset: function() {
      this._data = new d.init(), this._nDataBytes = 0;
    }, _append: function(e3) {
      "string" == typeof e3 && (e3 = h.parse(e3)), this._data.concat(e3), this._nDataBytes += e3.sigBytes;
    }, _process: function(t2) {
      var i2, r2 = this._data, o2 = r2.words, n2 = r2.sigBytes, s2 = this.blockSize, a2 = n2 / (4 * s2), c3 = (a2 = t2 ? e2.ceil(a2) : e2.max((0 | a2) - this._minBufferSize, 0)) * s2, l2 = e2.min(4 * c3, n2);
      if (c3) {
        for (var u2 = 0; u2 < c3; u2 += s2) this._doProcessBlock(o2, u2);
        i2 = o2.splice(0, c3), r2.sigBytes -= l2;
      }
      return new d.init(i2, l2);
    }, clone: function() {
      var e3 = a.clone.call(this);
      return e3._data = this._data.clone(), e3;
    }, _minBufferSize: 0 });
    s.Hasher = _.extend({ cfg: a.extend(), init: function(e3) {
      this.cfg = this.cfg.extend(e3), this.reset();
    }, reset: function() {
      _.reset.call(this), this._doReset();
    }, update: function(e3) {
      return this._append(e3), this._process(), this;
    }, finalize: function(e3) {
      return e3 && this._append(e3), this._doFinalize();
    }, blockSize: 16, _createHelper: function(e3) {
      return function(t2, i2) {
        return new e3.init(i2).finalize(t2);
      };
    }, _createHmacHelper: function(e3) {
      return function(t2, i2) {
        return new p.HMAC.init(e3, i2).finalize(t2);
      };
    } });
    var p = n.algo = {};
    return n;
  }(Math), e)), core.exports;
  var e;
}
!function() {
  var e;
  libTypedarrays.exports = (e = requireCore(), function() {
    if ("function" == typeof ArrayBuffer) {
      var t = e.lib.WordArray, i = t.init, r = t.init = function(e2) {
        if (e2 instanceof ArrayBuffer && (e2 = new Uint8Array(e2)), (e2 instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && e2 instanceof Uint8ClampedArray || e2 instanceof Int16Array || e2 instanceof Uint16Array || e2 instanceof Int32Array || e2 instanceof Uint32Array || e2 instanceof Float32Array || e2 instanceof Float64Array) && (e2 = new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength)), e2 instanceof Uint8Array) {
          for (var t2 = e2.byteLength, r2 = [], o = 0; o < t2; o++) r2[o >>> 2] |= e2[o] << 24 - o % 4 * 8;
          i.call(this, r2, t2);
        } else i.apply(this, arguments);
      };
      r.prototype = t;
    }
  }(), e.lib.WordArray);
}();
var hasRequiredEncBase64;
var libTypedarraysExports = libTypedarrays.exports;
var WordArray = getDefaultExportFromCjs(libTypedarraysExports);
var aes = { exports: {} };
var encBase64 = { exports: {} };
function requireEncBase64() {
  return hasRequiredEncBase64 || (hasRequiredEncBase64 = 1, encBase64.exports = (e = requireCore(), function() {
    var t = e, i = t.lib.WordArray;
    function r(e2, t2, r2) {
      for (var o = [], n = 0, s = 0; s < t2; s++) if (s % 4) {
        var a = r2[e2.charCodeAt(s - 1)] << s % 4 * 2 | r2[e2.charCodeAt(s)] >>> 6 - s % 4 * 2;
        o[n >>> 2] |= a << 24 - n % 4 * 8, n++;
      }
      return i.create(o, n);
    }
    t.enc.Base64 = { stringify: function(e2) {
      var t2 = e2.words, i2 = e2.sigBytes, r2 = this._map;
      e2.clamp();
      for (var o = [], n = 0; n < i2; n += 3) for (var s = (t2[n >>> 2] >>> 24 - n % 4 * 8 & 255) << 16 | (t2[n + 1 >>> 2] >>> 24 - (n + 1) % 4 * 8 & 255) << 8 | t2[n + 2 >>> 2] >>> 24 - (n + 2) % 4 * 8 & 255, a = 0; a < 4 && n + 0.75 * a < i2; a++) o.push(r2.charAt(s >>> 6 * (3 - a) & 63));
      var d = r2.charAt(64);
      if (d) for (; o.length % 4; ) o.push(d);
      return o.join("");
    }, parse: function(e2) {
      var t2 = e2.length, i2 = this._map, o = this._reverseMap;
      if (!o) {
        o = this._reverseMap = [];
        for (var n = 0; n < i2.length; n++) o[i2.charCodeAt(n)] = n;
      }
      var s = i2.charAt(64);
      if (s) {
        var a = e2.indexOf(s);
        -1 !== a && (t2 = a);
      }
      return r(e2, t2, o);
    }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };
  }(), e.enc.Base64)), encBase64.exports;
  var e;
}
var hasRequiredMd5;
var md5 = { exports: {} };
function requireMd5() {
  return hasRequiredMd5 || (hasRequiredMd5 = 1, md5.exports = (e = requireCore(), function(t) {
    var i = e, r = i.lib, o = r.WordArray, n = r.Hasher, s = i.algo, a = [];
    !function() {
      for (var e2 = 0; e2 < 64; e2++) a[e2] = 4294967296 * t.abs(t.sin(e2 + 1)) | 0;
    }();
    var d = s.MD5 = n.extend({ _doReset: function() {
      this._hash = new o.init([1732584193, 4023233417, 2562383102, 271733878]);
    }, _doProcessBlock: function(e2, t2) {
      for (var i2 = 0; i2 < 16; i2++) {
        var r2 = t2 + i2, o2 = e2[r2];
        e2[r2] = 16711935 & (o2 << 8 | o2 >>> 24) | 4278255360 & (o2 << 24 | o2 >>> 8);
      }
      var n2 = this._hash.words, s2 = e2[t2 + 0], d2 = e2[t2 + 1], _ = e2[t2 + 2], p = e2[t2 + 3], m = e2[t2 + 4], S = e2[t2 + 5], g = e2[t2 + 6], v3 = e2[t2 + 7], f = e2[t2 + 8], y = e2[t2 + 9], E = e2[t2 + 10], T = e2[t2 + 11], b = e2[t2 + 12], I = e2[t2 + 13], R = e2[t2 + 14], C = e2[t2 + 15], P = n2[0], A = n2[1], O = n2[2], k = n2[3];
      P = c2(P, A, O, k, s2, 7, a[0]), k = c2(k, P, A, O, d2, 12, a[1]), O = c2(O, k, P, A, _, 17, a[2]), A = c2(A, O, k, P, p, 22, a[3]), P = c2(P, A, O, k, m, 7, a[4]), k = c2(k, P, A, O, S, 12, a[5]), O = c2(O, k, P, A, g, 17, a[6]), A = c2(A, O, k, P, v3, 22, a[7]), P = c2(P, A, O, k, f, 7, a[8]), k = c2(k, P, A, O, y, 12, a[9]), O = c2(O, k, P, A, E, 17, a[10]), A = c2(A, O, k, P, T, 22, a[11]), P = c2(P, A, O, k, b, 7, a[12]), k = c2(k, P, A, O, I, 12, a[13]), O = c2(O, k, P, A, R, 17, a[14]), P = l(P, A = c2(A, O, k, P, C, 22, a[15]), O, k, d2, 5, a[16]), k = l(k, P, A, O, g, 9, a[17]), O = l(O, k, P, A, T, 14, a[18]), A = l(A, O, k, P, s2, 20, a[19]), P = l(P, A, O, k, S, 5, a[20]), k = l(k, P, A, O, E, 9, a[21]), O = l(O, k, P, A, C, 14, a[22]), A = l(A, O, k, P, m, 20, a[23]), P = l(P, A, O, k, y, 5, a[24]), k = l(k, P, A, O, R, 9, a[25]), O = l(O, k, P, A, p, 14, a[26]), A = l(A, O, k, P, f, 20, a[27]), P = l(P, A, O, k, I, 5, a[28]), k = l(k, P, A, O, _, 9, a[29]), O = l(O, k, P, A, v3, 14, a[30]), P = u(P, A = l(A, O, k, P, b, 20, a[31]), O, k, S, 4, a[32]), k = u(k, P, A, O, f, 11, a[33]), O = u(O, k, P, A, T, 16, a[34]), A = u(A, O, k, P, R, 23, a[35]), P = u(P, A, O, k, d2, 4, a[36]), k = u(k, P, A, O, m, 11, a[37]), O = u(O, k, P, A, v3, 16, a[38]), A = u(A, O, k, P, E, 23, a[39]), P = u(P, A, O, k, I, 4, a[40]), k = u(k, P, A, O, s2, 11, a[41]), O = u(O, k, P, A, p, 16, a[42]), A = u(A, O, k, P, g, 23, a[43]), P = u(P, A, O, k, y, 4, a[44]), k = u(k, P, A, O, b, 11, a[45]), O = u(O, k, P, A, C, 16, a[46]), P = h(P, A = u(A, O, k, P, _, 23, a[47]), O, k, s2, 6, a[48]), k = h(k, P, A, O, v3, 10, a[49]), O = h(O, k, P, A, R, 15, a[50]), A = h(A, O, k, P, S, 21, a[51]), P = h(P, A, O, k, b, 6, a[52]), k = h(k, P, A, O, p, 10, a[53]), O = h(O, k, P, A, E, 15, a[54]), A = h(A, O, k, P, d2, 21, a[55]), P = h(P, A, O, k, f, 6, a[56]), k = h(k, P, A, O, C, 10, a[57]), O = h(O, k, P, A, g, 15, a[58]), A = h(A, O, k, P, I, 21, a[59]), P = h(P, A, O, k, m, 6, a[60]), k = h(k, P, A, O, T, 10, a[61]), O = h(O, k, P, A, _, 15, a[62]), A = h(A, O, k, P, y, 21, a[63]), n2[0] = n2[0] + P | 0, n2[1] = n2[1] + A | 0, n2[2] = n2[2] + O | 0, n2[3] = n2[3] + k | 0;
    }, _doFinalize: function() {
      var e2 = this._data, i2 = e2.words, r2 = 8 * this._nDataBytes, o2 = 8 * e2.sigBytes;
      i2[o2 >>> 5] |= 128 << 24 - o2 % 32;
      var n2 = t.floor(r2 / 4294967296), s2 = r2;
      i2[15 + (o2 + 64 >>> 9 << 4)] = 16711935 & (n2 << 8 | n2 >>> 24) | 4278255360 & (n2 << 24 | n2 >>> 8), i2[14 + (o2 + 64 >>> 9 << 4)] = 16711935 & (s2 << 8 | s2 >>> 24) | 4278255360 & (s2 << 24 | s2 >>> 8), e2.sigBytes = 4 * (i2.length + 1), this._process();
      for (var a2 = this._hash, d2 = a2.words, c3 = 0; c3 < 4; c3++) {
        var l2 = d2[c3];
        d2[c3] = 16711935 & (l2 << 8 | l2 >>> 24) | 4278255360 & (l2 << 24 | l2 >>> 8);
      }
      return a2;
    }, clone: function() {
      var e2 = n.clone.call(this);
      return e2._hash = this._hash.clone(), e2;
    } });
    function c2(e2, t2, i2, r2, o2, n2, s2) {
      var a2 = e2 + (t2 & i2 | ~t2 & r2) + o2 + s2;
      return (a2 << n2 | a2 >>> 32 - n2) + t2;
    }
    function l(e2, t2, i2, r2, o2, n2, s2) {
      var a2 = e2 + (t2 & r2 | i2 & ~r2) + o2 + s2;
      return (a2 << n2 | a2 >>> 32 - n2) + t2;
    }
    function u(e2, t2, i2, r2, o2, n2, s2) {
      var a2 = e2 + (t2 ^ i2 ^ r2) + o2 + s2;
      return (a2 << n2 | a2 >>> 32 - n2) + t2;
    }
    function h(e2, t2, i2, r2, o2, n2, s2) {
      var a2 = e2 + (i2 ^ (t2 | ~r2)) + o2 + s2;
      return (a2 << n2 | a2 >>> 32 - n2) + t2;
    }
    i.MD5 = n._createHelper(d), i.HmacMD5 = n._createHmacHelper(d);
  }(Math), e.MD5)), md5.exports;
  var e;
}
var hasRequiredSha1;
var evpkdf = { exports: {} };
var sha1 = { exports: {} };
function requireSha1() {
  return hasRequiredSha1 || (hasRequiredSha1 = 1, sha1.exports = (a = requireCore(), t = (e = a).lib, i = t.WordArray, r = t.Hasher, o = e.algo, n = [], s = o.SHA1 = r.extend({ _doReset: function() {
    this._hash = new i.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
  }, _doProcessBlock: function(e2, t2) {
    for (var i2 = this._hash.words, r2 = i2[0], o2 = i2[1], s2 = i2[2], a2 = i2[3], d = i2[4], c2 = 0; c2 < 80; c2++) {
      if (c2 < 16) n[c2] = 0 | e2[t2 + c2];
      else {
        var l = n[c2 - 3] ^ n[c2 - 8] ^ n[c2 - 14] ^ n[c2 - 16];
        n[c2] = l << 1 | l >>> 31;
      }
      var u = (r2 << 5 | r2 >>> 27) + d + n[c2];
      u += c2 < 20 ? 1518500249 + (o2 & s2 | ~o2 & a2) : c2 < 40 ? 1859775393 + (o2 ^ s2 ^ a2) : c2 < 60 ? (o2 & s2 | o2 & a2 | s2 & a2) - 1894007588 : (o2 ^ s2 ^ a2) - 899497514, d = a2, a2 = s2, s2 = o2 << 30 | o2 >>> 2, o2 = r2, r2 = u;
    }
    i2[0] = i2[0] + r2 | 0, i2[1] = i2[1] + o2 | 0, i2[2] = i2[2] + s2 | 0, i2[3] = i2[3] + a2 | 0, i2[4] = i2[4] + d | 0;
  }, _doFinalize: function() {
    var e2 = this._data, t2 = e2.words, i2 = 8 * this._nDataBytes, r2 = 8 * e2.sigBytes;
    return t2[r2 >>> 5] |= 128 << 24 - r2 % 32, t2[14 + (r2 + 64 >>> 9 << 4)] = Math.floor(i2 / 4294967296), t2[15 + (r2 + 64 >>> 9 << 4)] = i2, e2.sigBytes = 4 * t2.length, this._process(), this._hash;
  }, clone: function() {
    var e2 = r.clone.call(this);
    return e2._hash = this._hash.clone(), e2;
  } }), e.SHA1 = r._createHelper(s), e.HmacSHA1 = r._createHmacHelper(s), a.SHA1)), sha1.exports;
  var e, t, i, r, o, n, s, a;
}
var hasRequiredHmac;
var hasRequiredEvpkdf;
var hmac = { exports: {} };
function requireHmac() {
  return hasRequiredHmac || (hasRequiredHmac = 1, hmac.exports = (e = requireCore(), i = (t = e).lib.Base, r = t.enc.Utf8, void (t.algo.HMAC = i.extend({ init: function(e2, t2) {
    e2 = this._hasher = new e2.init(), "string" == typeof t2 && (t2 = r.parse(t2));
    var i2 = e2.blockSize, o = 4 * i2;
    t2.sigBytes > o && (t2 = e2.finalize(t2)), t2.clamp();
    for (var n = this._oKey = t2.clone(), s = this._iKey = t2.clone(), a = n.words, d = s.words, c2 = 0; c2 < i2; c2++) a[c2] ^= 1549556828, d[c2] ^= 909522486;
    n.sigBytes = s.sigBytes = o, this.reset();
  }, reset: function() {
    var e2 = this._hasher;
    e2.reset(), e2.update(this._iKey);
  }, update: function(e2) {
    return this._hasher.update(e2), this;
  }, finalize: function(e2) {
    var t2 = this._hasher, i2 = t2.finalize(e2);
    return t2.reset(), t2.finalize(this._oKey.clone().concat(i2));
  } })))), hmac.exports;
  var e, t, i, r;
}
function requireEvpkdf() {
  return hasRequiredEvpkdf || (hasRequiredEvpkdf = 1, evpkdf.exports = (a = requireCore(), requireSha1(), requireHmac(), t = (e = a).lib, i = t.Base, r = t.WordArray, o = e.algo, n = o.MD5, s = o.EvpKDF = i.extend({ cfg: i.extend({ keySize: 4, hasher: n, iterations: 1 }), init: function(e2) {
    this.cfg = this.cfg.extend(e2);
  }, compute: function(e2, t2) {
    for (var i2, o2 = this.cfg, n2 = o2.hasher.create(), s2 = r.create(), a2 = s2.words, d = o2.keySize, c2 = o2.iterations; a2.length < d; ) {
      i2 && n2.update(i2), i2 = n2.update(e2).finalize(t2), n2.reset();
      for (var l = 1; l < c2; l++) i2 = n2.finalize(i2), n2.reset();
      s2.concat(i2);
    }
    return s2.sigBytes = 4 * d, s2;
  } }), e.EvpKDF = function(e2, t2, i2) {
    return s.create(i2).compute(e2, t2);
  }, a.EvpKDF)), evpkdf.exports;
  var e, t, i, r, o, n, s, a;
}
var hasRequiredCipherCore;
var cipherCore = { exports: {} };
function requireCipherCore() {
  return hasRequiredCipherCore || (hasRequiredCipherCore = 1, cipherCore.exports = (e = requireCore(), requireEvpkdf(), void (e.lib.Cipher || function(t) {
    var i = e, r = i.lib, o = r.Base, n = r.WordArray, s = r.BufferedBlockAlgorithm, a = i.enc;
    a.Utf8;
    var d = a.Base64, c2 = i.algo.EvpKDF, l = r.Cipher = s.extend({ cfg: o.extend(), createEncryptor: function(e2, t2) {
      return this.create(this._ENC_XFORM_MODE, e2, t2);
    }, createDecryptor: function(e2, t2) {
      return this.create(this._DEC_XFORM_MODE, e2, t2);
    }, init: function(e2, t2, i2) {
      this.cfg = this.cfg.extend(i2), this._xformMode = e2, this._key = t2, this.reset();
    }, reset: function() {
      s.reset.call(this), this._doReset();
    }, process: function(e2) {
      return this._append(e2), this._process();
    }, finalize: function(e2) {
      return e2 && this._append(e2), this._doFinalize();
    }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: /* @__PURE__ */ function() {
      function e2(e3) {
        return "string" == typeof e3 ? f : g;
      }
      return function(t2) {
        return { encrypt: function(i2, r2, o2) {
          return e2(r2).encrypt(t2, i2, r2, o2);
        }, decrypt: function(i2, r2, o2) {
          return e2(r2).decrypt(t2, i2, r2, o2);
        } };
      };
    }() });
    r.StreamCipher = l.extend({ _doFinalize: function() {
      return this._process(true);
    }, blockSize: 1 });
    var u = i.mode = {}, h = r.BlockCipherMode = o.extend({ createEncryptor: function(e2, t2) {
      return this.Encryptor.create(e2, t2);
    }, createDecryptor: function(e2, t2) {
      return this.Decryptor.create(e2, t2);
    }, init: function(e2, t2) {
      this._cipher = e2, this._iv = t2;
    } }), _ = u.CBC = function() {
      var e2 = h.extend();
      function i2(e3, i3, r2) {
        var o2, n2 = this._iv;
        n2 ? (o2 = n2, this._iv = t) : o2 = this._prevBlock;
        for (var s2 = 0; s2 < r2; s2++) e3[i3 + s2] ^= o2[s2];
      }
      return e2.Encryptor = e2.extend({ processBlock: function(e3, t2) {
        var r2 = this._cipher, o2 = r2.blockSize;
        i2.call(this, e3, t2, o2), r2.encryptBlock(e3, t2), this._prevBlock = e3.slice(t2, t2 + o2);
      } }), e2.Decryptor = e2.extend({ processBlock: function(e3, t2) {
        var r2 = this._cipher, o2 = r2.blockSize, n2 = e3.slice(t2, t2 + o2);
        r2.decryptBlock(e3, t2), i2.call(this, e3, t2, o2), this._prevBlock = n2;
      } }), e2;
    }(), p = (i.pad = {}).Pkcs7 = { pad: function(e2, t2) {
      for (var i2 = 4 * t2, r2 = i2 - e2.sigBytes % i2, o2 = r2 << 24 | r2 << 16 | r2 << 8 | r2, s2 = [], a2 = 0; a2 < r2; a2 += 4) s2.push(o2);
      var d2 = n.create(s2, r2);
      e2.concat(d2);
    }, unpad: function(e2) {
      var t2 = 255 & e2.words[e2.sigBytes - 1 >>> 2];
      e2.sigBytes -= t2;
    } };
    r.BlockCipher = l.extend({ cfg: l.cfg.extend({ mode: _, padding: p }), reset: function() {
      var e2;
      l.reset.call(this);
      var t2 = this.cfg, i2 = t2.iv, r2 = t2.mode;
      this._xformMode == this._ENC_XFORM_MODE ? e2 = r2.createEncryptor : (e2 = r2.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == e2 ? this._mode.init(this, i2 && i2.words) : (this._mode = e2.call(r2, this, i2 && i2.words), this._mode.__creator = e2);
    }, _doProcessBlock: function(e2, t2) {
      this._mode.processBlock(e2, t2);
    }, _doFinalize: function() {
      var e2, t2 = this.cfg.padding;
      return this._xformMode == this._ENC_XFORM_MODE ? (t2.pad(this._data, this.blockSize), e2 = this._process(true)) : (e2 = this._process(true), t2.unpad(e2)), e2;
    }, blockSize: 4 });
    var m = r.CipherParams = o.extend({ init: function(e2) {
      this.mixIn(e2);
    }, toString: function(e2) {
      return (e2 || this.formatter).stringify(this);
    } }), S = (i.format = {}).OpenSSL = { stringify: function(e2) {
      var t2 = e2.ciphertext, i2 = e2.salt;
      return (i2 ? n.create([1398893684, 1701076831]).concat(i2).concat(t2) : t2).toString(d);
    }, parse: function(e2) {
      var t2, i2 = d.parse(e2), r2 = i2.words;
      return 1398893684 == r2[0] && 1701076831 == r2[1] && (t2 = n.create(r2.slice(2, 4)), r2.splice(0, 4), i2.sigBytes -= 16), m.create({ ciphertext: i2, salt: t2 });
    } }, g = r.SerializableCipher = o.extend({ cfg: o.extend({ format: S }), encrypt: function(e2, t2, i2, r2) {
      r2 = this.cfg.extend(r2);
      var o2 = e2.createEncryptor(i2, r2), n2 = o2.finalize(t2), s2 = o2.cfg;
      return m.create({ ciphertext: n2, key: i2, iv: s2.iv, algorithm: e2, mode: s2.mode, padding: s2.padding, blockSize: e2.blockSize, formatter: r2.format });
    }, decrypt: function(e2, t2, i2, r2) {
      return r2 = this.cfg.extend(r2), t2 = this._parse(t2, r2.format), e2.createDecryptor(i2, r2).finalize(t2.ciphertext);
    }, _parse: function(e2, t2) {
      return "string" == typeof e2 ? t2.parse(e2, this) : e2;
    } }), v3 = (i.kdf = {}).OpenSSL = { execute: function(e2, t2, i2, r2, o2) {
      if (r2 || (r2 = n.random(8)), o2) s2 = c2.create({ keySize: t2 + i2, hasher: o2 }).compute(e2, r2);
      else var s2 = c2.create({ keySize: t2 + i2 }).compute(e2, r2);
      var a2 = n.create(s2.words.slice(t2), 4 * i2);
      return s2.sigBytes = 4 * t2, m.create({ key: s2, iv: a2, salt: r2 });
    } }, f = r.PasswordBasedCipher = g.extend({ cfg: g.cfg.extend({ kdf: v3 }), encrypt: function(e2, t2, i2, r2) {
      var o2 = (r2 = this.cfg.extend(r2)).kdf.execute(i2, e2.keySize, e2.ivSize, r2.salt, r2.hasher);
      r2.iv = o2.iv;
      var n2 = g.encrypt.call(this, e2, t2, o2.key, r2);
      return n2.mixIn(o2), n2;
    }, decrypt: function(e2, t2, i2, r2) {
      r2 = this.cfg.extend(r2), t2 = this._parse(t2, r2.format);
      var o2 = r2.kdf.execute(i2, e2.keySize, e2.ivSize, t2.salt, r2.hasher);
      return r2.iv = o2.iv, g.decrypt.call(this, e2, t2, o2.key, r2);
    } });
  }()))), cipherCore.exports;
  var e;
}
!function() {
  var e;
  aes.exports = (e = requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore(), function() {
    var t = e, i = t.lib.BlockCipher, r = t.algo, o = [], n = [], s = [], a = [], d = [], c2 = [], l = [], u = [], h = [], _ = [];
    !function() {
      for (var e2 = [], t2 = 0; t2 < 256; t2++) e2[t2] = t2 < 128 ? t2 << 1 : t2 << 1 ^ 283;
      var i2 = 0, r2 = 0;
      for (t2 = 0; t2 < 256; t2++) {
        var p2 = r2 ^ r2 << 1 ^ r2 << 2 ^ r2 << 3 ^ r2 << 4;
        p2 = p2 >>> 8 ^ 255 & p2 ^ 99, o[i2] = p2, n[p2] = i2;
        var m2 = e2[i2], S = e2[m2], g = e2[S], v3 = 257 * e2[p2] ^ 16843008 * p2;
        s[i2] = v3 << 24 | v3 >>> 8, a[i2] = v3 << 16 | v3 >>> 16, d[i2] = v3 << 8 | v3 >>> 24, c2[i2] = v3, v3 = 16843009 * g ^ 65537 * S ^ 257 * m2 ^ 16843008 * i2, l[p2] = v3 << 24 | v3 >>> 8, u[p2] = v3 << 16 | v3 >>> 16, h[p2] = v3 << 8 | v3 >>> 24, _[p2] = v3, i2 ? (i2 = m2 ^ e2[e2[e2[g ^ m2]]], r2 ^= e2[e2[r2]]) : i2 = r2 = 1;
      }
    }();
    var p = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], m = r.AES = i.extend({ _doReset: function() {
      if (!this._nRounds || this._keyPriorReset !== this._key) {
        for (var e2 = this._keyPriorReset = this._key, t2 = e2.words, i2 = e2.sigBytes / 4, r2 = 4 * ((this._nRounds = i2 + 6) + 1), n2 = this._keySchedule = [], s2 = 0; s2 < r2; s2++) s2 < i2 ? n2[s2] = t2[s2] : (c3 = n2[s2 - 1], s2 % i2 ? i2 > 6 && s2 % i2 == 4 && (c3 = o[c3 >>> 24] << 24 | o[c3 >>> 16 & 255] << 16 | o[c3 >>> 8 & 255] << 8 | o[255 & c3]) : (c3 = o[(c3 = c3 << 8 | c3 >>> 24) >>> 24] << 24 | o[c3 >>> 16 & 255] << 16 | o[c3 >>> 8 & 255] << 8 | o[255 & c3], c3 ^= p[s2 / i2 | 0] << 24), n2[s2] = n2[s2 - i2] ^ c3);
        for (var a2 = this._invKeySchedule = [], d2 = 0; d2 < r2; d2++) {
          if (s2 = r2 - d2, d2 % 4) var c3 = n2[s2];
          else c3 = n2[s2 - 4];
          a2[d2] = d2 < 4 || s2 <= 4 ? c3 : l[o[c3 >>> 24]] ^ u[o[c3 >>> 16 & 255]] ^ h[o[c3 >>> 8 & 255]] ^ _[o[255 & c3]];
        }
      }
    }, encryptBlock: function(e2, t2) {
      this._doCryptBlock(e2, t2, this._keySchedule, s, a, d, c2, o);
    }, decryptBlock: function(e2, t2) {
      var i2 = e2[t2 + 1];
      e2[t2 + 1] = e2[t2 + 3], e2[t2 + 3] = i2, this._doCryptBlock(e2, t2, this._invKeySchedule, l, u, h, _, n), i2 = e2[t2 + 1], e2[t2 + 1] = e2[t2 + 3], e2[t2 + 3] = i2;
    }, _doCryptBlock: function(e2, t2, i2, r2, o2, n2, s2, a2) {
      for (var d2 = this._nRounds, c3 = e2[t2] ^ i2[0], l2 = e2[t2 + 1] ^ i2[1], u2 = e2[t2 + 2] ^ i2[2], h2 = e2[t2 + 3] ^ i2[3], _2 = 4, p2 = 1; p2 < d2; p2++) {
        var m2 = r2[c3 >>> 24] ^ o2[l2 >>> 16 & 255] ^ n2[u2 >>> 8 & 255] ^ s2[255 & h2] ^ i2[_2++], S = r2[l2 >>> 24] ^ o2[u2 >>> 16 & 255] ^ n2[h2 >>> 8 & 255] ^ s2[255 & c3] ^ i2[_2++], g = r2[u2 >>> 24] ^ o2[h2 >>> 16 & 255] ^ n2[c3 >>> 8 & 255] ^ s2[255 & l2] ^ i2[_2++], v3 = r2[h2 >>> 24] ^ o2[c3 >>> 16 & 255] ^ n2[l2 >>> 8 & 255] ^ s2[255 & u2] ^ i2[_2++];
        c3 = m2, l2 = S, u2 = g, h2 = v3;
      }
      m2 = (a2[c3 >>> 24] << 24 | a2[l2 >>> 16 & 255] << 16 | a2[u2 >>> 8 & 255] << 8 | a2[255 & h2]) ^ i2[_2++], S = (a2[l2 >>> 24] << 24 | a2[u2 >>> 16 & 255] << 16 | a2[h2 >>> 8 & 255] << 8 | a2[255 & c3]) ^ i2[_2++], g = (a2[u2 >>> 24] << 24 | a2[h2 >>> 16 & 255] << 16 | a2[c3 >>> 8 & 255] << 8 | a2[255 & l2]) ^ i2[_2++], v3 = (a2[h2 >>> 24] << 24 | a2[c3 >>> 16 & 255] << 16 | a2[l2 >>> 8 & 255] << 8 | a2[255 & u2]) ^ i2[_2++], e2[t2] = m2, e2[t2 + 1] = S, e2[t2 + 2] = g, e2[t2 + 3] = v3;
    }, keySize: 8 });
    t.AES = i._createHelper(m);
  }(), e.AES);
}();
var aesExports = aes.exports;
var encHex$1 = { exports: {} };
encHex$1.exports = requireCore().enc.Hex;
var encHexExports = encHex$1.exports;
var encHex = getDefaultExportFromCjs(encHexExports);
var modeCtr = { exports: {} };
!function() {
  var e, t, i;
  modeCtr.exports = (i = requireCore(), requireCipherCore(), i.mode.CTR = (e = i.lib.BlockCipherMode.extend(), t = e.Encryptor = e.extend({ processBlock: function(e2, t2) {
    var i2 = this._cipher, r = i2.blockSize, o = this._iv, n = this._counter;
    o && (n = this._counter = o.slice(0), this._iv = void 0);
    var s = n.slice(0);
    i2.encryptBlock(s, 0), n[r - 1] = n[r - 1] + 1 | 0;
    for (var a = 0; a < r; a++) e2[t2 + a] ^= s[a];
  } }), e.Decryptor = t, e), i.mode.CTR);
}();
var modeCtrExports = modeCtr.exports;
var ModeCTR = getDefaultExportFromCjs(modeCtrExports);
var padNopadding = { exports: {} };
!function() {
  var e;
  padNopadding.exports = (e = requireCore(), requireCipherCore(), e.pad.NoPadding = { pad: function() {
  }, unpad: function() {
  } }, e.pad.NoPadding);
}();
var _window$localStorage;
var padNopaddingExports = padNopadding.exports;
var PadNoPadding = getDefaultExportFromCjs(padNopaddingExports);
var textDecoder = new TextDecoder();
var textEncoder = new TextEncoder();
var gpuInfo;
var genUuid = () => v4();
var getServerNow = () => Date.now();
function concatenate(e) {
  let t = 0;
  for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) r[o - 1] = arguments[o];
  for (const e2 of r) t += e2.length;
  const n = new e(t);
  let s = 0;
  for (const e2 of r) n.set(e2, s), s += e2.length;
  return n;
}
var Utils = class _Utils {
  static token2auth(e, t, i, r) {
    return r ? "Bearer ".concat(r) : "Basic ".concat(_Utils.createUnsafeToken(e, t, i));
  }
  static createUnsafeToken(e, t, i) {
    return window.btoa([e, t, i].filter((e2) => null !== e2).join(":"));
  }
  static merge() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    for (const [i, r] of Object.entries(e)) null !== r && "object" == typeof r ? _Utils.merge(e[i], t[i]) : void 0 !== t[i] && (e[i] = t[i]);
  }
  static ab2str(e) {
    return textDecoder.decode(e);
  }
  static ab2obj(e) {
    try {
      const t = _Utils.ab2str(e);
      return JSON.parse(t);
    } catch (e2) {
      return {};
    }
  }
  static str2ab(e) {
    return textEncoder.encode(e).buffer;
  }
  static async ab2b64str(e) {
    if (getParameter("SEND_MESSAGE_SYNC")) {
      const t = String.fromCharCode.apply(null, new Uint8Array(e));
      return window.btoa(t);
    }
    return (await new Promise((t) => {
      const i = new FileReader();
      i.onload = () => t(i.result), i.readAsDataURL(new Blob([e]));
    })).split(",", 2)[1];
  }
  static async b64str2ab(e, t) {
    return fetch("data:application/octet;base64,".concat(e)).then((e2) => e2.arrayBuffer()).catch((i) => {
      throw t && t.report("rtc_error", { error_code: 2001, message: "".concat(i.message, " -> ").concat(e) }), i;
    });
  }
};
function wait(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function createRandomId() {
  const e = Number("".concat(Math.random()).slice(-7).padEnd(7, "0")).toString(2).padEnd(28, "1").split(""), t = [];
  for (; e.length; ) t.push(e.splice(0, 7));
  return t.map((e2, i) => {
    const r = i === t.length - 1 ? "0" : "1";
    return Number.parseInt(r + e2.join(""), 2);
  });
}
var genEventSessionId = () => Math.floor(65535 * Math.random());
function isByteId(e) {
  return !(128 & ~e);
}
function isRttMessage(e) {
  return "string" == typeof e && e.indexOf("__web__rtc__rtt__") > -1;
}
function randomNum(e) {
  let t = "";
  for (let i = 0; i < e; i++) t += Math.floor(10 * Math.random());
  return t;
}
var defaultSdp;
var createDefaultSdp = async function() {
  let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
  if (defaultSdp) return defaultSdp;
  const t = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: "all", bundlePolicy: "max-bundle", rtcpMuxPolicy: "require", sdpSemantics: "unified-plan" });
  t.createDataChannel("default"), t.addTransceiver("audio", { direction: "recvonly" }), t.addTransceiver("video", { direction: "recvonly" }), e && (t.addTransceiver("audio", { direction: "sendonly" }), t.addTransceiver("video", { direction: "sendonly" }));
  const i = await t.createOffer();
  return t.close(), defaultSdp = i.sdp, i.sdp;
};
var promiseAny = (e) => new Promise((t, i) => {
  let r = (e = Array.isArray(e) ? e : []).length;
  const o = [];
  0 === r ? i([]) : e.forEach((e2) => {
    e2.then((e3) => {
      t(e3);
    }, (e3) => {
      r--, o.push(e3), 0 === r && i(o);
    });
  });
});
function getNonlinearVolume(e) {
  return Number(Math.max(-127, 10 * Math.log10(Math.pow(e / 255, 2))).toFixed(2));
}
function audioInMediaType(e) {
  return (e & MediaType$1.AUDIO) === MediaType$1.AUDIO;
}
function videoInMediaType(e) {
  return (e & MediaType$1.VIDEO) === MediaType$1.VIDEO;
}
function getPublicStats(e) {
  const t = {};
  return Object.keys(e).forEach((i) => {
    "object" == typeof e[i] ? t[i] = getPublicStats(e[i]) : i.startsWith("_") && !getParameter("HIDDEN_STATS") || (t[i] = e[i]);
  }), t;
}
function splitPublicStreamSei(e) {
  const t = new DataView(e.buffer);
  if (t.byteLength <= 4 || 65535 !== t.getUint16(0)) return { seiCount: 1, seis: [e] };
  const i = { seiCount: 0, seis: [] };
  let r = false, o = 2;
  for (; o < t.byteLength; ) {
    const n = t.getUint16(o);
    if (o += 2, t.byteLength - o < n) {
      r = true;
      break;
    }
    const s = new Uint8Array(e.buffer, o, n);
    if (o += n, t.byteLength - o > 0 && t.byteLength - o <= 2) {
      r = true;
      break;
    }
    i.seiCount++, i.seis.push(s);
  }
  return r && (i.seiCount = 1, i.seis = [e]), i;
}
function isUndefined(e) {
  return void 0 === e;
}
function warnDeprecatedApi(e) {
  return function(t, i, r) {
    const o = r.value;
    r.value = function() {
      console.warn("[RTC WebSDK]: Api: ".concat(i, " has been abandoned from version ").concat(e));
      for (var t2 = arguments.length, r2 = new Array(t2), n = 0; n < t2; n++) r2[n] = arguments[n];
      return o.apply(this, r2);
    };
  };
}
function warnDevelopers(e) {
  console.warn("[RTC WebSDK]: ".concat(e));
}
function constraints2number(e) {
  return "number" == typeof e ? e : "number" == typeof (null == e ? void 0 : e.exact) ? e.exact : "number" == typeof (null == e ? void 0 : e.ideal) ? e.ideal : "number" == typeof (null == e ? void 0 : e.max) ? e.max : "number" == typeof (null == e ? void 0 : e.min) ? e.min : 1;
}
function setJoinRoomInfo(e, t, i) {
  if ("function" == typeof i.value) {
    const e2 = i.value;
    i.value = function() {
      var t2;
      const i2 = getMonitor(this.id);
      for (var r = arguments.length, o = new Array(r), n = 0; n < r; n++) o[n] = arguments[n];
      return null == i2 || i2.set({ room_id: o[1], user_id: null === (t2 = o[2]) || void 0 === t2 ? void 0 : t2.userId }), e2.apply(this, o);
    };
  }
}
var MAX_MESSAGE_ID = Math.pow(2, 15);
var MessageId = class {
  constructor() {
    _defineProperty(this, "_id", void 0), this._id = Math.ceil(Math.random() * MAX_MESSAGE_ID);
  }
  getMessageId() {
    return ++this._id > MAX_MESSAGE_ID && (this._id = 0), this._id;
  }
};
function filterUndefined(e) {
  const t = {};
  return Object.keys(e).forEach((i) => {
    void 0 !== e[i] && (t[i] = e[i]);
  }), t;
}
var isDebuggerMode = "undefined" != typeof window && (window.location.search.includes("_rtc_debug_") || !(null === (_window$localStorage = window.localStorage) || void 0 === _window$localStorage || !_window$localStorage.getItem("_rtc_debug_")));
function base64ToUint8(e) {
  const t = atob(e), i = t.length, r = new Uint8Array(i);
  for (let e2 = 0; e2 < i; e2++) r[e2] = t.charCodeAt(e2);
  return r;
}
function uint8ToBase64(e) {
  let t = "";
  const i = e.byteLength;
  for (let r = 0; r < i; r++) t += String.fromCharCode(e[r]);
  return btoa(t);
}
function aesCtrEncrypt(e, t, i) {
  const r = uint8ArrayToWordArray(e), o = uint8ArrayToWordArray(t), n = uint8ArrayToWordArray(i);
  return wordArrayToUint8Array(aesExports.encrypt(r, o, { iv: n, mode: ModeCTR, padding: PadNoPadding }).ciphertext);
}
function wordArrayToUint8Array(e) {
  const t = e.toString(encHex), i = new Uint8Array(t.length / 2);
  for (let e2 = 0; e2 < t.length; e2 += 2) i[e2 / 2] = parseInt(t.substr(e2, 2), 16);
  return i;
}
function uint8ArrayToWordArray(e) {
  const t = [];
  for (let i = 0; i < e.length; i += 4) t.push(e[i] << 24 | (e[i + 1] || 0) << 16 | (e[i + 2] || 0) << 8 | (e[i + 3] || 0));
  return WordArray.create(t, e.length);
}
function getGpuInfo() {
  return gpuInfo || (gpuInfo = _getGpuInfo()), gpuInfo;
}
function _getGpuInfo() {
  let e = document.createElement("canvas"), t = e.getContext("webgl") || e.getContext("experimental-webgl");
  if (!t) return { renderer: "unknown(WebGLRenderingContext not existed)", vendor: "unknown(WebGLRenderingContext not existed)" };
  const i = t.getExtension("WEBGL_debug_renderer_info");
  if (!i) return { renderer: "unknown(info not existed)", vendor: "unknown(info not existed)" };
  const r = t.getParameter(i.UNMASKED_RENDERER_WEBGL), o = t.getParameter(i.UNMASKED_VENDOR_WEBGL);
  return e && e.parentNode && e.parentNode.removeChild(e), e = void 0, t = void 0, { renderer: r, vendor: o };
}
function getErrorString(e) {
  var t, i;
  return e instanceof Error && e.code ? "".concat(e, " | native.name=").concat(null === (t = e.error) || void 0 === t ? void 0 : t.name, " native.message=").concat(null === (i = e.error) || void 0 === i ? void 0 : i.message) : e instanceof Error ? "NativeError: ".concat(e.name, " ").concat(e.message) : "UnknownError: ".concat(e);
}
var _window$RTCPeerConnec;
var _window$RTCDataChanne;
var _window$MediaStreamTr;
var _window$MediaStream;
var _window$HTMLAudioElem;
var _window$HTMLVideoElem;
var _window$HTMLMediaElem;
var _window$AudioContext$;
var _window$AudioContext;
var _window$webkitAudioCo;
var _window$BaseAudioCont;
var _window$AudioNode;
var detectorResults = {};
function getObjectFunctions(e, t) {
  if (!e) return [];
  return Object.getOwnPropertyNames(e).filter((t2) => {
    if ("peerIdentity" === t2) return false;
    try {
      return "function" == typeof e[t2] || void 0 === e[t2];
    } catch (e2) {
      return false;
    }
  }).map((i) => ({ obj: e, prefix: t, attr: i }));
}
function isNativeCode(e, t) {
  try {
    return e[t].toString().includes("[native code]") ? "native" : "non-native";
  } catch (e2) {
    return "untouchable";
  }
}
var detectorList = ("undefined" != typeof window ? [[null === (_window$RTCPeerConnec = window.RTCPeerConnection) || void 0 === _window$RTCPeerConnec ? void 0 : _window$RTCPeerConnec.prototype, "RTCPeerConnection.prototype"], [window.RTCPeerConnection, "RTCPeerConnection"], [null === (_window$RTCDataChanne = window.RTCDataChannel) || void 0 === _window$RTCDataChanne ? void 0 : _window$RTCDataChanne.prototype, "RTCDataChannel.prototype"], [window.RTCDataChannel, "RTCDataChannel"], [null === (_window$MediaStreamTr = window.MediaStreamTrack) || void 0 === _window$MediaStreamTr ? void 0 : _window$MediaStreamTr.prototype, "MediaStreamTrack.prototype"], [window.MediaStreamTrack, "MediaStreamTrack"], [null === (_window$MediaStream = window.MediaStream) || void 0 === _window$MediaStream ? void 0 : _window$MediaStream.prototype, "MediaStream.prototype"], [window.MediaStream, "MediaStream"], [null === (_window$HTMLAudioElem = window.HTMLAudioElement) || void 0 === _window$HTMLAudioElem ? void 0 : _window$HTMLAudioElem.prototype, "HTMLAudioElement.prototype"], [null === (_window$HTMLVideoElem = window.HTMLVideoElement) || void 0 === _window$HTMLVideoElem ? void 0 : _window$HTMLVideoElem.prototype, "HTMLVideoElement.prototype"], [null === (_window$HTMLMediaElem = window.HTMLMediaElement) || void 0 === _window$HTMLMediaElem ? void 0 : _window$HTMLMediaElem.prototype, "HTMLMediaElement.prototype"], [null !== (_window$AudioContext$ = null === (_window$AudioContext = window.AudioContext) || void 0 === _window$AudioContext ? void 0 : _window$AudioContext.prototype) && void 0 !== _window$AudioContext$ ? _window$AudioContext$ : null === (_window$webkitAudioCo = window.webkitAudioContext) || void 0 === _window$webkitAudioCo ? void 0 : _window$webkitAudioCo.prototype, "AudioContext.prototype"], [null === (_window$BaseAudioCont = window.BaseAudioContext) || void 0 === _window$BaseAudioCont ? void 0 : _window$BaseAudioCont.prototype, "BaseAudioContext.prototype"], [null === (_window$AudioNode = window.AudioNode) || void 0 === _window$AudioNode ? void 0 : _window$AudioNode.prototype, "AudioNode.prototype"], [window.navigator.mediaDevices, "navigator.mediaDevices"], [window.console, "console"]] : []).reduce((e, t) => {
  let [i, r] = t;
  return e.concat(getObjectFunctions(i, r));
}, []);
"undefined" != typeof window && detectorList.push({ obj: window.navigator.mediaDevices, prefix: "navigator.mediaDevices", attr: "getUserMedia" }, { obj: window.navigator.mediaDevices, prefix: "navigator.mediaDevices", attr: "getDisplayMedia" }, { obj: window.navigator.mediaDevices, prefix: "navigator.mediaDevices", attr: "enumerateDevices" }, { obj: window.navigator.mediaDevices, prefix: "navigator.mediaDevices", attr: "getSupportedConstraints" });
for (const { obj: e, prefix: t, attr: i } of detectorList) {
  const r = "".concat(t, ".").concat(i);
  detectorResults[r] = isNativeCode(e, i);
}
isDebuggerMode && console.log("RTC_AMBULANCE", detectorResults);
var filtedResult = Object.entries(detectorResults).filter((e) => {
  let [t, i] = e;
  return "non-native" === i;
}).map((e) => {
  let [t, i] = e;
  return t;
});
Object.keys(filtedResult).length && console.warn("RTC_AMBULANCE", "have non-native code:\n", filtedResult.join("\n"));
var logDisabled_ = true;
var deprecationWarnings_ = true;
function extractVersion(e, t, i) {
  const r = e.match(t);
  return r && r.length >= i && parseInt(r[i], 10);
}
function wrapPeerConnectionEvent(e, t, i) {
  if (!e.RTCPeerConnection) return;
  const r = e.RTCPeerConnection.prototype, o = r.addEventListener;
  r.addEventListener = function(e2, r2) {
    if (e2 !== t) return o.apply(this, arguments);
    const n2 = (e3) => {
      const t2 = i(e3);
      t2 && (r2.handleEvent ? r2.handleEvent(t2) : r2(t2));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = /* @__PURE__ */ new Map()), this._eventMap[t].set(r2, n2), o.apply(this, [e2, n2]);
  };
  const n = r.removeEventListener;
  r.removeEventListener = function(e2, i2) {
    if (e2 !== t || !this._eventMap || !this._eventMap[t]) return n.apply(this, arguments);
    if (!this._eventMap[t].has(i2)) return n.apply(this, arguments);
    const r2 = this._eventMap[t].get(i2);
    return this._eventMap[t].delete(i2), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, n.apply(this, [e2, r2]);
  }, Object.defineProperty(r, "on" + t, { get() {
    return this["_on" + t];
  }, set(e2) {
    this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e2 && this.addEventListener(t, this["_on" + t] = e2);
  }, enumerable: true, configurable: true });
}
function disableLog(e) {
  return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (logDisabled_ = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function disableWarnings(e) {
  return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (deprecationWarnings_ = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"));
}
function log() {
  if ("object" == typeof window) {
    if (logDisabled_) return;
    "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
  }
}
function deprecated(e, t) {
  deprecationWarnings_ && console.warn(e + " is deprecated, please use " + t + " instead.");
}
function detectBrowser(e) {
  const t = { browser: null, version: null };
  if (void 0 === e || !e.navigator || !e.navigator.userAgent) return t.browser = "Not a browser.", t;
  const { navigator: i } = e;
  if (i.mozGetUserMedia) t.browser = "firefox", t.version = extractVersion(i.userAgent, /Firefox\/(\d+)\./, 1);
  else if (i.webkitGetUserMedia || false === e.isSecureContext && e.webkitRTCPeerConnection) t.browser = "chrome", t.version = extractVersion(i.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  else {
    if (!e.RTCPeerConnection || !i.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t;
    t.browser = "safari", t.version = extractVersion(i.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype;
  }
  return t;
}
function isObject$4(e) {
  return "[object Object]" === Object.prototype.toString.call(e);
}
function compactObject(e) {
  return isObject$4(e) ? Object.keys(e).reduce(function(t, i) {
    const r = isObject$4(e[i]), o = r ? compactObject(e[i]) : e[i], n = r && !Object.keys(o).length;
    return void 0 === o || n ? t : Object.assign(t, { [i]: o });
  }, {}) : e;
}
function walkStats(e, t, i) {
  t && !i.has(t.id) && (i.set(t.id, t), Object.keys(t).forEach((r) => {
    r.endsWith("Id") ? walkStats(e, e.get(t[r]), i) : r.endsWith("Ids") && t[r].forEach((t2) => {
      walkStats(e, e.get(t2), i);
    });
  }));
}
function filterStats(e, t, i) {
  const r = i ? "outbound-rtp" : "inbound-rtp", o = /* @__PURE__ */ new Map();
  if (null === t) return o;
  const n = [];
  return e.forEach((e2) => {
    "track" === e2.type && e2.trackIdentifier === t.id && n.push(e2);
  }), n.forEach((t2) => {
    e.forEach((i2) => {
      i2.type === r && i2.trackId === t2.id && walkStats(e, i2, o);
    });
  }), o;
}
var logging = log;
function shimGetUserMedia$2(e, t) {
  const i = e && e.navigator;
  if (!i.mediaDevices) return;
  const r = function(e2) {
    if ("object" != typeof e2 || e2.mandatory || e2.optional) return e2;
    const t2 = {};
    return Object.keys(e2).forEach((i2) => {
      if ("require" === i2 || "advanced" === i2 || "mediaSource" === i2) return;
      const r2 = "object" == typeof e2[i2] ? e2[i2] : { ideal: e2[i2] };
      void 0 !== r2.exact && "number" == typeof r2.exact && (r2.min = r2.max = r2.exact);
      const o2 = function(e3, t3) {
        return e3 ? e3 + t3.charAt(0).toUpperCase() + t3.slice(1) : "deviceId" === t3 ? "sourceId" : t3;
      };
      if (void 0 !== r2.ideal) {
        t2.optional = t2.optional || [];
        let e3 = {};
        "number" == typeof r2.ideal ? (e3[o2("min", i2)] = r2.ideal, t2.optional.push(e3), e3 = {}, e3[o2("max", i2)] = r2.ideal, t2.optional.push(e3)) : (e3[o2("", i2)] = r2.ideal, t2.optional.push(e3));
      }
      void 0 !== r2.exact && "number" != typeof r2.exact ? (t2.mandatory = t2.mandatory || {}, t2.mandatory[o2("", i2)] = r2.exact) : ["min", "max"].forEach((e3) => {
        void 0 !== r2[e3] && (t2.mandatory = t2.mandatory || {}, t2.mandatory[o2(e3, i2)] = r2[e3]);
      });
    }), e2.advanced && (t2.optional = (t2.optional || []).concat(e2.advanced)), t2;
  }, o = function(e2, o2) {
    if (t.version >= 61) return o2(e2);
    if ((e2 = JSON.parse(JSON.stringify(e2))) && "object" == typeof e2.audio) {
      const t2 = function(e3, t3, i2) {
        t3 in e3 && !(i2 in e3) && (e3[i2] = e3[t3], delete e3[t3]);
      };
      t2((e2 = JSON.parse(JSON.stringify(e2))).audio, "autoGainControl", "googAutoGainControl"), t2(e2.audio, "noiseSuppression", "googNoiseSuppression"), e2.audio = r(e2.audio);
    }
    if (e2 && "object" == typeof e2.video) {
      let n2 = e2.video.facingMode;
      n2 = n2 && ("object" == typeof n2 ? n2 : { ideal: n2 });
      const s = t.version < 66;
      if (n2 && ("user" === n2.exact || "environment" === n2.exact || "user" === n2.ideal || "environment" === n2.ideal) && (!i.mediaDevices.getSupportedConstraints || !i.mediaDevices.getSupportedConstraints().facingMode || s)) {
        let t2;
        if (delete e2.video.facingMode, "environment" === n2.exact || "environment" === n2.ideal ? t2 = ["back", "rear"] : "user" !== n2.exact && "user" !== n2.ideal || (t2 = ["front"]), t2) return i.mediaDevices.enumerateDevices().then((i2) => {
          let s2 = (i2 = i2.filter((e3) => "videoinput" === e3.kind)).find((e3) => t2.some((t3) => e3.label.toLowerCase().includes(t3)));
          return !s2 && i2.length && t2.includes("back") && (s2 = i2[i2.length - 1]), s2 && (e2.video.deviceId = n2.exact ? { exact: s2.deviceId } : { ideal: s2.deviceId }), e2.video = r(e2.video), logging("chrome: " + JSON.stringify(e2)), o2(e2);
        });
      }
      e2.video = r(e2.video);
    }
    return logging("chrome: " + JSON.stringify(e2)), o2(e2);
  }, n = function(e2) {
    return t.version >= 64 ? e2 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e2.name] || e2.name, message: e2.message, constraint: e2.constraint || e2.constraintName, toString() {
      return this.name + (this.message && ": ") + this.message;
    } };
  };
  if (i.getUserMedia = (function(e2, t2, r2) {
    o(e2, (e3) => {
      i.webkitGetUserMedia(e3, t2, (e4) => {
        r2 && r2(n(e4));
      });
    });
  }).bind(i), i.mediaDevices.getUserMedia) {
    const e2 = i.mediaDevices.getUserMedia.bind(i.mediaDevices);
    i.mediaDevices.getUserMedia = function(t2) {
      return o(t2, (t3) => e2(t3).then((e3) => {
        if (t3.audio && !e3.getAudioTracks().length || t3.video && !e3.getVideoTracks().length) throw e3.getTracks().forEach((e4) => {
          e4.stop();
        }), new DOMException("", "NotFoundError");
        return e3;
      }, (e3) => Promise.reject(n(e3))));
    };
  }
}
function shimGetDisplayMedia$1(e, t) {
  e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function(i) {
    return t(i).then((t2) => {
      const r = i.video && i.video.width, o = i.video && i.video.height, n = i.video && i.video.frameRate;
      return i.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t2, maxFrameRate: n || 3 } }, r && (i.video.mandatory.maxWidth = r), o && (i.video.mandatory.maxHeight = o), e.navigator.mediaDevices.getUserMedia(i);
    });
  } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
}
function shimMediaStream(e) {
  e.MediaStream = e.MediaStream || e.webkitMediaStream;
}
function shimOnTrack$1(e) {
  if ("object" == typeof e && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) {
    Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get() {
      return this._ontrack;
    }, set(e2) {
      this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e2);
    }, enumerable: true, configurable: true });
    const t = e.RTCPeerConnection.prototype.setRemoteDescription;
    e.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (t2) => {
        t2.stream.addEventListener("addtrack", (i) => {
          let r;
          r = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e2) => e2.track && e2.track.id === i.track.id) : { track: i.track };
          const o = new Event("track");
          o.track = i.track, o.receiver = r, o.transceiver = { receiver: r }, o.streams = [t2.stream], this.dispatchEvent(o);
        }), t2.stream.getTracks().forEach((i) => {
          let r;
          r = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e2) => e2.track && e2.track.id === i.id) : { track: i };
          const o = new Event("track");
          o.track = i, o.receiver = r, o.transceiver = { receiver: r }, o.streams = [t2.stream], this.dispatchEvent(o);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments);
    };
  } else wrapPeerConnectionEvent(e, "track", (e2) => (e2.transceiver || Object.defineProperty(e2, "transceiver", { value: { receiver: e2.receiver } }), e2));
}
function shimGetSendersWithDtmf(e) {
  if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
    const t = function(e2, t2) {
      return { track: t2, get dtmf() {
        return void 0 === this._dtmf && ("audio" === t2.kind ? this._dtmf = e2.createDTMFSender(t2) : this._dtmf = null), this._dtmf;
      }, _pc: e2 };
    };
    if (!e.RTCPeerConnection.prototype.getSenders) {
      e.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      const i2 = e.RTCPeerConnection.prototype.addTrack;
      e.RTCPeerConnection.prototype.addTrack = function(e2, r3) {
        let o = i2.apply(this, arguments);
        return o || (o = t(this, e2), this._senders.push(o)), o;
      };
      const r2 = e.RTCPeerConnection.prototype.removeTrack;
      e.RTCPeerConnection.prototype.removeTrack = function(e2) {
        r2.apply(this, arguments);
        const t2 = this._senders.indexOf(e2);
        -1 !== t2 && this._senders.splice(t2, 1);
      };
    }
    const i = e.RTCPeerConnection.prototype.addStream;
    e.RTCPeerConnection.prototype.addStream = function(e2) {
      this._senders = this._senders || [], i.apply(this, [e2]), e2.getTracks().forEach((e3) => {
        this._senders.push(t(this, e3));
      });
    };
    const r = e.RTCPeerConnection.prototype.removeStream;
    e.RTCPeerConnection.prototype.removeStream = function(e2) {
      this._senders = this._senders || [], r.apply(this, [e2]), e2.getTracks().forEach((e3) => {
        const t2 = this._senders.find((t3) => t3.track === e3);
        t2 && this._senders.splice(this._senders.indexOf(t2), 1);
      });
    };
  } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) {
    const t = e.RTCPeerConnection.prototype.getSenders;
    e.RTCPeerConnection.prototype.getSenders = function() {
      const e2 = t.apply(this, []);
      return e2.forEach((e3) => e3._pc = this), e2;
    }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get() {
      return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
    } });
  }
}
function shimGetStats(e) {
  if (!e.RTCPeerConnection) return;
  const t = e.RTCPeerConnection.prototype.getStats;
  e.RTCPeerConnection.prototype.getStats = function() {
    const [e2, i, r] = arguments;
    if (arguments.length > 0 && "function" == typeof e2) return t.apply(this, arguments);
    if (0 === t.length && (0 === arguments.length || "function" != typeof e2)) return t.apply(this, []);
    const o = function(e3) {
      const t2 = {};
      return e3.result().forEach((e4) => {
        const i2 = { id: e4.id, timestamp: e4.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e4.type] || e4.type };
        e4.names().forEach((t3) => {
          i2[t3] = e4.stat(t3);
        }), t2[i2.id] = i2;
      }), t2;
    }, n = function(e3) {
      return new Map(Object.keys(e3).map((t2) => [t2, e3[t2]]));
    };
    if (arguments.length >= 2) {
      const r2 = function(e3) {
        i(n(o(e3)));
      };
      return t.apply(this, [r2, e2]);
    }
    return new Promise((e3, i2) => {
      t.apply(this, [function(t2) {
        e3(n(o(t2)));
      }, i2]);
    }).then(i, r);
  };
}
function shimSenderReceiverGetStats(e) {
  if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;
  if (!("getStats" in e.RTCRtpSender.prototype)) {
    const t2 = e.RTCPeerConnection.prototype.getSenders;
    t2 && (e.RTCPeerConnection.prototype.getSenders = function() {
      const e2 = t2.apply(this, []);
      return e2.forEach((e3) => e3._pc = this), e2;
    });
    const i = e.RTCPeerConnection.prototype.addTrack;
    i && (e.RTCPeerConnection.prototype.addTrack = function() {
      const e2 = i.apply(this, arguments);
      return e2._pc = this, e2;
    }), e.RTCRtpSender.prototype.getStats = function() {
      const e2 = this;
      return this._pc.getStats().then((t3) => filterStats(t3, e2.track, true));
    };
  }
  if (!("getStats" in e.RTCRtpReceiver.prototype)) {
    const t2 = e.RTCPeerConnection.prototype.getReceivers;
    t2 && (e.RTCPeerConnection.prototype.getReceivers = function() {
      const e2 = t2.apply(this, []);
      return e2.forEach((e3) => e3._pc = this), e2;
    }), wrapPeerConnectionEvent(e, "track", (e2) => (e2.receiver._pc = e2.srcElement, e2)), e.RTCRtpReceiver.prototype.getStats = function() {
      const e2 = this;
      return this._pc.getStats().then((t3) => filterStats(t3, e2.track, false));
    };
  }
  if (!("getStats" in e.RTCRtpSender.prototype) || !("getStats" in e.RTCRtpReceiver.prototype)) return;
  const t = e.RTCPeerConnection.prototype.getStats;
  e.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {
      const e2 = arguments[0];
      let t2, i, r;
      return this.getSenders().forEach((i2) => {
        i2.track === e2 && (t2 ? r = true : t2 = i2);
      }), this.getReceivers().forEach((t3) => (t3.track === e2 && (i ? r = true : i = t3), t3.track === e2)), r || t2 && i ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t2 ? t2.getStats() : i ? i.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return t.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(e) {
  e.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e2) => this._shimmedLocalStreams[e2][0]);
  };
  const t = e.RTCPeerConnection.prototype.addTrack;
  e.RTCPeerConnection.prototype.addTrack = function(e2, i2) {
    if (!i2) return t.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const r2 = t.apply(this, arguments);
    return this._shimmedLocalStreams[i2.id] ? -1 === this._shimmedLocalStreams[i2.id].indexOf(r2) && this._shimmedLocalStreams[i2.id].push(r2) : this._shimmedLocalStreams[i2.id] = [i2, r2], r2;
  };
  const i = e.RTCPeerConnection.prototype.addStream;
  e.RTCPeerConnection.prototype.addStream = function(e2) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e2.getTracks().forEach((e3) => {
      if (this.getSenders().find((t3) => t3.track === e3)) throw new DOMException("Track already exists.", "InvalidAccessError");
    });
    const t2 = this.getSenders();
    i.apply(this, arguments);
    const r2 = this.getSenders().filter((e3) => -1 === t2.indexOf(e3));
    this._shimmedLocalStreams[e2.id] = [e2].concat(r2);
  };
  const r = e.RTCPeerConnection.prototype.removeStream;
  e.RTCPeerConnection.prototype.removeStream = function(e2) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e2.id], r.apply(this, arguments);
  };
  const o = e.RTCPeerConnection.prototype.removeTrack;
  e.RTCPeerConnection.prototype.removeTrack = function(e2) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e2 && Object.keys(this._shimmedLocalStreams).forEach((t2) => {
      const i2 = this._shimmedLocalStreams[t2].indexOf(e2);
      -1 !== i2 && this._shimmedLocalStreams[t2].splice(i2, 1), 1 === this._shimmedLocalStreams[t2].length && delete this._shimmedLocalStreams[t2];
    }), o.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(e, t) {
  if (!e.RTCPeerConnection) return;
  if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return shimAddTrackRemoveTrackWithNative(e);
  const i = e.RTCPeerConnection.prototype.getLocalStreams;
  e.RTCPeerConnection.prototype.getLocalStreams = function() {
    const e2 = i.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, e2.map((e3) => this._reverseStreams[e3.id]);
  };
  const r = e.RTCPeerConnection.prototype.addStream;
  e.RTCPeerConnection.prototype.addStream = function(t2) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t2.getTracks().forEach((e2) => {
      if (this.getSenders().find((t3) => t3.track === e2)) throw new DOMException("Track already exists.", "InvalidAccessError");
    }), !this._reverseStreams[t2.id]) {
      const i2 = new e.MediaStream(t2.getTracks());
      this._streams[t2.id] = i2, this._reverseStreams[i2.id] = t2, t2 = i2;
    }
    r.apply(this, [t2]);
  };
  const o = e.RTCPeerConnection.prototype.removeStream;
  function n(e2, t2) {
    let i2 = t2.sdp;
    return Object.keys(e2._reverseStreams || []).forEach((t3) => {
      const r2 = e2._reverseStreams[t3], o2 = e2._streams[r2.id];
      i2 = i2.replace(new RegExp(o2.id, "g"), r2.id);
    }), new RTCSessionDescription({ type: t2.type, sdp: i2 });
  }
  e.RTCPeerConnection.prototype.removeStream = function(e2) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, o.apply(this, [this._streams[e2.id] || e2]), delete this._reverseStreams[this._streams[e2.id] ? this._streams[e2.id].id : e2.id], delete this._streams[e2.id];
  }, e.RTCPeerConnection.prototype.addTrack = function(t2, i2) {
    if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    const r2 = [].slice.call(arguments, 1);
    if (1 !== r2.length || !r2[0].getTracks().find((e2) => e2 === t2)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    if (this.getSenders().find((e2) => e2.track === t2)) throw new DOMException("Track already exists.", "InvalidAccessError");
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    const o2 = this._streams[i2.id];
    if (o2) o2.addTrack(t2), Promise.resolve().then(() => {
      this.dispatchEvent(new Event("negotiationneeded"));
    });
    else {
      const r3 = new e.MediaStream([t2]);
      this._streams[i2.id] = r3, this._reverseStreams[r3.id] = i2, this.addStream(r3);
    }
    return this.getSenders().find((e2) => e2.track === t2);
  }, ["createOffer", "createAnswer"].forEach(function(t2) {
    const i2 = e.RTCPeerConnection.prototype[t2], r2 = { [t2]() {
      const e2 = arguments;
      return arguments.length && "function" == typeof arguments[0] ? i2.apply(this, [(t3) => {
        const i3 = n(this, t3);
        e2[0].apply(null, [i3]);
      }, (t3) => {
        e2[1] && e2[1].apply(null, t3);
      }, arguments[2]]) : i2.apply(this, arguments).then((e3) => n(this, e3));
    } };
    e.RTCPeerConnection.prototype[t2] = r2[t2];
  });
  const s = e.RTCPeerConnection.prototype.setLocalDescription;
  e.RTCPeerConnection.prototype.setLocalDescription = function() {
    return arguments.length && arguments[0].type ? (arguments[0] = function(e2, t2) {
      let i2 = t2.sdp;
      return Object.keys(e2._reverseStreams || []).forEach((t3) => {
        const r2 = e2._reverseStreams[t3], o2 = e2._streams[r2.id];
        i2 = i2.replace(new RegExp(r2.id, "g"), o2.id);
      }), new RTCSessionDescription({ type: t2.type, sdp: i2 });
    }(this, arguments[0]), s.apply(this, arguments)) : s.apply(this, arguments);
  };
  const a = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get() {
    const e2 = a.get.apply(this);
    return "" === e2.type ? e2 : n(this, e2);
  } }), e.RTCPeerConnection.prototype.removeTrack = function(e2) {
    if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    if (!e2._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (!(e2._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    let t2;
    this._streams = this._streams || {}, Object.keys(this._streams).forEach((i2) => {
      this._streams[i2].getTracks().find((t3) => e2.track === t3) && (t2 = this._streams[i2]);
    }), t2 && (1 === t2.getTracks().length ? this.removeStream(this._reverseStreams[t2.id]) : t2.removeTrack(e2.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function shimPeerConnection$1(e, t) {
  !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t2) {
    const i = e.RTCPeerConnection.prototype[t2], r = { [t2]() {
      return arguments[0] = new ("addIceCandidate" === t2 ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments);
    } };
    e.RTCPeerConnection.prototype[t2] = r[t2];
  });
}
function fixNegotiationNeeded(e, t) {
  wrapPeerConnectionEvent(e, "negotiationneeded", (e2) => {
    const i = e2.target;
    if (!(t.version < 72 || i.getConfiguration && "plan-b" === i.getConfiguration().sdpSemantics) || "stable" === i.signalingState) return e2;
  });
}
var chromeShim = Object.freeze({ __proto__: null, fixNegotiationNeeded, shimAddTrackRemoveTrack, shimAddTrackRemoveTrackWithNative, shimGetDisplayMedia: shimGetDisplayMedia$1, shimGetSendersWithDtmf, shimGetStats, shimGetUserMedia: shimGetUserMedia$2, shimMediaStream, shimOnTrack: shimOnTrack$1, shimPeerConnection: shimPeerConnection$1, shimSenderReceiverGetStats });
function shimGetUserMedia$1(e, t) {
  const i = e && e.navigator, r = e && e.MediaStreamTrack;
  if (i.getUserMedia = function(e2, t2, r2) {
    deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i.mediaDevices.getUserMedia(e2).then(t2, r2);
  }, !(t.version > 55 && "autoGainControl" in i.mediaDevices.getSupportedConstraints())) {
    const e2 = function(e3, t3, i2) {
      t3 in e3 && !(i2 in e3) && (e3[i2] = e3[t3], delete e3[t3]);
    }, t2 = i.mediaDevices.getUserMedia.bind(i.mediaDevices);
    if (i.mediaDevices.getUserMedia = function(i2) {
      return "object" == typeof i2 && "object" == typeof i2.audio && (i2 = JSON.parse(JSON.stringify(i2)), e2(i2.audio, "autoGainControl", "mozAutoGainControl"), e2(i2.audio, "noiseSuppression", "mozNoiseSuppression")), t2(i2);
    }, r && r.prototype.getSettings) {
      const t3 = r.prototype.getSettings;
      r.prototype.getSettings = function() {
        const i2 = t3.apply(this, arguments);
        return e2(i2, "mozAutoGainControl", "autoGainControl"), e2(i2, "mozNoiseSuppression", "noiseSuppression"), i2;
      };
    }
    if (r && r.prototype.applyConstraints) {
      const t3 = r.prototype.applyConstraints;
      r.prototype.applyConstraints = function(i2) {
        return "audio" === this.kind && "object" == typeof i2 && (i2 = JSON.parse(JSON.stringify(i2)), e2(i2, "autoGainControl", "mozAutoGainControl"), e2(i2, "noiseSuppression", "mozNoiseSuppression")), t3.apply(this, [i2]);
      };
    }
  }
}
function shimGetDisplayMedia(e, t) {
  e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function(i) {
    if (!i || !i.video) {
      const e2 = new DOMException("getDisplayMedia without video constraints is undefined");
      return e2.name = "NotFoundError", e2.code = 8, Promise.reject(e2);
    }
    return true === i.video ? i.video = { mediaSource: t } : i.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(i);
  });
}
function shimOnTrack(e) {
  "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() {
    return { receiver: this.receiver };
  } });
}
function shimPeerConnection(e, t) {
  if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;
  !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t2) {
    const i2 = e.RTCPeerConnection.prototype[t2], r2 = { [t2]() {
      return arguments[0] = new ("addIceCandidate" === t2 ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i2.apply(this, arguments);
    } };
    e.RTCPeerConnection.prototype[t2] = r2[t2];
  });
  const i = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, r = e.RTCPeerConnection.prototype.getStats;
  e.RTCPeerConnection.prototype.getStats = function() {
    const [e2, o, n] = arguments;
    return r.apply(this, [e2 || null]).then((e3) => {
      if (t.version < 53 && !o) try {
        e3.forEach((e4) => {
          e4.type = i[e4.type] || e4.type;
        });
      } catch (t2) {
        if ("TypeError" !== t2.name) throw t2;
        e3.forEach((t3, r2) => {
          e3.set(r2, Object.assign({}, t3, { type: i[t3.type] || t3.type }));
        });
      }
      return e3;
    }).then(o, n);
  };
}
function shimSenderGetStats(e) {
  if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
  if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return;
  const t = e.RTCPeerConnection.prototype.getSenders;
  t && (e.RTCPeerConnection.prototype.getSenders = function() {
    const e2 = t.apply(this, []);
    return e2.forEach((e3) => e3._pc = this), e2;
  });
  const i = e.RTCPeerConnection.prototype.addTrack;
  i && (e.RTCPeerConnection.prototype.addTrack = function() {
    const e2 = i.apply(this, arguments);
    return e2._pc = this, e2;
  }), e.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(e) {
  if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
  if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return;
  const t = e.RTCPeerConnection.prototype.getReceivers;
  t && (e.RTCPeerConnection.prototype.getReceivers = function() {
    const e2 = t.apply(this, []);
    return e2.forEach((e3) => e3._pc = this), e2;
  }), wrapPeerConnectionEvent(e, "track", (e2) => (e2.receiver._pc = e2.srcElement, e2)), e.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(e) {
  e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function(e2) {
    deprecated("removeStream", "removeTrack"), this.getSenders().forEach((t) => {
      t.track && e2.getTracks().includes(t.track) && this.removeTrack(t);
    });
  });
}
function shimRTCDataChannel(e) {
  e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel);
}
function shimAddTransceiver(e) {
  if ("object" != typeof e || !e.RTCPeerConnection) return;
  const t = e.RTCPeerConnection.prototype.addTransceiver;
  t && (e.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    let e2 = arguments[1] && arguments[1].sendEncodings;
    void 0 === e2 && (e2 = []), e2 = [...e2];
    const i = e2.length > 0;
    i && e2.forEach((e3) => {
      if ("rid" in e3) {
        if (!/^[a-z0-9]{0,16}$/i.test(e3.rid)) throw new TypeError("Invalid RID value provided.");
      }
      if ("scaleResolutionDownBy" in e3 && !(parseFloat(e3.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in e3 && !(parseFloat(e3.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0");
    });
    const r = t.apply(this, arguments);
    if (i) {
      const { sender: t2 } = r, i2 = t2.getParameters();
      (!("encodings" in i2) || 1 === i2.encodings.length && 0 === Object.keys(i2.encodings[0]).length) && (i2.encodings = e2, t2.sendEncodings = e2, this.setParametersPromises.push(t2.setParameters(i2).then(() => {
        delete t2.sendEncodings;
      }).catch(() => {
        delete t2.sendEncodings;
      })));
    }
    return r;
  });
}
function shimGetParameters(e) {
  if ("object" != typeof e || !e.RTCRtpSender) return;
  const t = e.RTCRtpSender.prototype.getParameters;
  t && (e.RTCRtpSender.prototype.getParameters = function() {
    const e2 = t.apply(this, arguments);
    return "encodings" in e2 || (e2.encodings = [].concat(this.sendEncodings || [{}])), e2;
  });
}
function shimCreateOffer(e) {
  if ("object" != typeof e || !e.RTCPeerConnection) return;
  const t = e.RTCPeerConnection.prototype.createOffer;
  e.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : t.apply(this, arguments);
  };
}
function shimCreateAnswer(e) {
  if ("object" != typeof e || !e.RTCPeerConnection) return;
  const t = e.RTCPeerConnection.prototype.createAnswer;
  e.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : t.apply(this, arguments);
  };
}
var firefoxShim = Object.freeze({ __proto__: null, shimAddTransceiver, shimCreateAnswer, shimCreateOffer, shimGetDisplayMedia, shimGetParameters, shimGetUserMedia: shimGetUserMedia$1, shimOnTrack, shimPeerConnection, shimRTCDataChannel, shimReceiverGetStats, shimRemoveStream, shimSenderGetStats });
function shimLocalStreamsAPI(e) {
  if ("object" == typeof e && e.RTCPeerConnection) {
    if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in e.RTCPeerConnection.prototype)) {
      const t = e.RTCPeerConnection.prototype.addTrack;
      e.RTCPeerConnection.prototype.addStream = function(e2) {
        this._localStreams || (this._localStreams = []), this._localStreams.includes(e2) || this._localStreams.push(e2), e2.getAudioTracks().forEach((i) => t.call(this, i, e2)), e2.getVideoTracks().forEach((i) => t.call(this, i, e2));
      }, e.RTCPeerConnection.prototype.addTrack = function(e2) {
        for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) r[o - 1] = arguments[o];
        return r && r.forEach((e3) => {
          this._localStreams ? this._localStreams.includes(e3) || this._localStreams.push(e3) : this._localStreams = [e3];
        }), t.apply(this, arguments);
      };
    }
    "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e2) {
      this._localStreams || (this._localStreams = []);
      const t = this._localStreams.indexOf(e2);
      if (-1 === t) return;
      this._localStreams.splice(t, 1);
      const i = e2.getTracks();
      this.getSenders().forEach((e3) => {
        i.includes(e3.track) && this.removeTrack(e3);
      });
    });
  }
}
function shimRemoteStreamsAPI(e) {
  if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in e.RTCPeerConnection.prototype))) {
    Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get() {
      return this._onaddstream;
    }, set(e2) {
      this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e2), this.addEventListener("track", this._onaddstreampoly = (e3) => {
        e3.streams.forEach((e4) => {
          if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e4)) return;
          this._remoteStreams.push(e4);
          const t2 = new Event("addstream");
          t2.stream = e4, this.dispatchEvent(t2);
        });
      });
    } });
    const t = e.RTCPeerConnection.prototype.setRemoteDescription;
    e.RTCPeerConnection.prototype.setRemoteDescription = function() {
      const e2 = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t2) {
        t2.streams.forEach((t3) => {
          if (e2._remoteStreams || (e2._remoteStreams = []), e2._remoteStreams.indexOf(t3) >= 0) return;
          e2._remoteStreams.push(t3);
          const i = new Event("addstream");
          i.stream = t3, e2.dispatchEvent(i);
        });
      }), t.apply(e2, arguments);
    };
  }
}
function shimCallbacksAPI(e) {
  if ("object" != typeof e || !e.RTCPeerConnection) return;
  const t = e.RTCPeerConnection.prototype, i = t.createOffer, r = t.createAnswer, o = t.setLocalDescription, n = t.setRemoteDescription, s = t.addIceCandidate;
  t.createOffer = function(e2, t2) {
    const r2 = arguments.length >= 2 ? arguments[2] : arguments[0], o2 = i.apply(this, [r2]);
    return t2 ? (o2.then(e2, t2), Promise.resolve()) : o2;
  }, t.createAnswer = function(e2, t2) {
    const i2 = arguments.length >= 2 ? arguments[2] : arguments[0], o2 = r.apply(this, [i2]);
    return t2 ? (o2.then(e2, t2), Promise.resolve()) : o2;
  };
  let a = function(e2, t2, i2) {
    const r2 = o.apply(this, [e2]);
    return i2 ? (r2.then(t2, i2), Promise.resolve()) : r2;
  };
  t.setLocalDescription = a, a = function(e2, t2, i2) {
    const r2 = n.apply(this, [e2]);
    return i2 ? (r2.then(t2, i2), Promise.resolve()) : r2;
  }, t.setRemoteDescription = a, a = function(e2, t2, i2) {
    const r2 = s.apply(this, [e2]);
    return i2 ? (r2.then(t2, i2), Promise.resolve()) : r2;
  }, t.addIceCandidate = a;
}
function shimGetUserMedia(e) {
  const t = e && e.navigator;
  if (t.mediaDevices && t.mediaDevices.getUserMedia) {
    const e2 = t.mediaDevices, i = e2.getUserMedia.bind(e2);
    t.mediaDevices.getUserMedia = (e3) => i(shimConstraints(e3));
  }
  !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = (function(e2, i, r) {
    t.mediaDevices.getUserMedia(e2).then(i, r);
  }).bind(t));
}
function shimConstraints(e) {
  return e && void 0 !== e.video ? Object.assign({}, e, { video: compactObject(e.video) }) : e;
}
function shimRTCIceServerUrls(e) {
  if (!e.RTCPeerConnection) return;
  const t = e.RTCPeerConnection;
  e.RTCPeerConnection = function(e2, i) {
    if (e2 && e2.iceServers) {
      const t2 = [];
      for (let i2 = 0; i2 < e2.iceServers.length; i2++) {
        let r = e2.iceServers[i2];
        void 0 === r.urls && r.url ? (deprecated("RTCIceServer.url", "RTCIceServer.urls"), r = JSON.parse(JSON.stringify(r)), r.urls = r.url, delete r.url, t2.push(r)) : t2.push(e2.iceServers[i2]);
      }
      e2.iceServers = t2;
    }
    return new t(e2, i);
  }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get: () => t.generateCertificate });
}
function shimTrackEventTransceiver(e) {
  "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get() {
    return { receiver: this.receiver };
  } });
}
function shimCreateOfferLegacy(e) {
  const t = e.RTCPeerConnection.prototype.createOffer;
  e.RTCPeerConnection.prototype.createOffer = function(e2) {
    if (e2) {
      void 0 !== e2.offerToReceiveAudio && (e2.offerToReceiveAudio = !!e2.offerToReceiveAudio);
      const t2 = this.getTransceivers().find((e3) => "audio" === e3.receiver.track.kind);
      false === e2.offerToReceiveAudio && t2 ? "sendrecv" === t2.direction ? t2.setDirection ? t2.setDirection("sendonly") : t2.direction = "sendonly" : "recvonly" === t2.direction && (t2.setDirection ? t2.setDirection("inactive") : t2.direction = "inactive") : true !== e2.offerToReceiveAudio || t2 || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e2.offerToReceiveVideo && (e2.offerToReceiveVideo = !!e2.offerToReceiveVideo);
      const i = this.getTransceivers().find((e3) => "video" === e3.receiver.track.kind);
      false === e2.offerToReceiveVideo && i ? "sendrecv" === i.direction ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : "recvonly" === i.direction && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : true !== e2.offerToReceiveVideo || i || this.addTransceiver("video", { direction: "recvonly" });
    }
    return t.apply(this, arguments);
  };
}
function shimAudioContext(e) {
  "object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext);
}
var safariShim = Object.freeze({ __proto__: null, shimAudioContext, shimCallbacksAPI, shimConstraints, shimCreateOfferLegacy, shimGetUserMedia, shimLocalStreamsAPI, shimRTCIceServerUrls, shimRemoteStreamsAPI, shimTrackEventTransceiver });
var sdp$1 = { exports: {} };
!function(e) {
  const t = { generateIdentifier: function() {
    return Math.random().toString(36).substring(2, 12);
  } };
  t.localCName = t.generateIdentifier(), t.splitLines = function(e2) {
    return _trimInstanceProperty(e2).call(e2).split("\n").map((e3) => _trimInstanceProperty(e3).call(e3));
  }, t.splitSections = function(e2) {
    return e2.split("\nm=").map((e3, t2) => {
      var i;
      return _trimInstanceProperty(i = t2 > 0 ? "m=" + e3 : e3).call(i) + "\r\n";
    });
  }, t.getDescription = function(e2) {
    const i = t.splitSections(e2);
    return i && i[0];
  }, t.getMediaSections = function(e2) {
    const i = t.splitSections(e2);
    return i.shift(), i;
  }, t.matchPrefix = function(e2, i) {
    return t.splitLines(e2).filter((e3) => 0 === e3.indexOf(i));
  }, t.parseCandidate = function(e2) {
    let t2;
    t2 = 0 === e2.indexOf("a=candidate:") ? e2.substring(12).split(" ") : e2.substring(10).split(" ");
    const i = { foundation: t2[0], component: { 1: "rtp", 2: "rtcp" }[t2[1]] || t2[1], protocol: t2[2].toLowerCase(), priority: parseInt(t2[3], 10), ip: t2[4], address: t2[4], port: parseInt(t2[5], 10), type: t2[7] };
    for (let e3 = 8; e3 < t2.length; e3 += 2) switch (t2[e3]) {
      case "raddr":
        i.relatedAddress = t2[e3 + 1];
        break;
      case "rport":
        i.relatedPort = parseInt(t2[e3 + 1], 10);
        break;
      case "tcptype":
        i.tcpType = t2[e3 + 1];
        break;
      case "ufrag":
        i.ufrag = t2[e3 + 1], i.usernameFragment = t2[e3 + 1];
        break;
      default:
        void 0 === i[t2[e3]] && (i[t2[e3]] = t2[e3 + 1]);
    }
    return i;
  }, t.writeCandidate = function(e2) {
    const t2 = [];
    t2.push(e2.foundation);
    const i = e2.component;
    "rtp" === i ? t2.push(1) : "rtcp" === i ? t2.push(2) : t2.push(i), t2.push(e2.protocol.toUpperCase()), t2.push(e2.priority), t2.push(e2.address || e2.ip), t2.push(e2.port);
    const r = e2.type;
    return t2.push("typ"), t2.push(r), "host" !== r && e2.relatedAddress && e2.relatedPort && (t2.push("raddr"), t2.push(e2.relatedAddress), t2.push("rport"), t2.push(e2.relatedPort)), e2.tcpType && "tcp" === e2.protocol.toLowerCase() && (t2.push("tcptype"), t2.push(e2.tcpType)), (e2.usernameFragment || e2.ufrag) && (t2.push("ufrag"), t2.push(e2.usernameFragment || e2.ufrag)), "candidate:" + t2.join(" ");
  }, t.parseIceOptions = function(e2) {
    return e2.substring(14).split(" ");
  }, t.parseRtpMap = function(e2) {
    let t2 = e2.substring(9).split(" ");
    const i = { payloadType: parseInt(t2.shift(), 10) };
    return t2 = t2[0].split("/"), i.name = t2[0], i.clockRate = parseInt(t2[1], 10), i.channels = 3 === t2.length ? parseInt(t2[2], 10) : 1, i.numChannels = i.channels, i;
  }, t.writeRtpMap = function(e2) {
    let t2 = e2.payloadType;
    void 0 !== e2.preferredPayloadType && (t2 = e2.preferredPayloadType);
    const i = e2.channels || e2.numChannels || 1;
    return "a=rtpmap:" + t2 + " " + e2.name + "/" + e2.clockRate + (1 !== i ? "/" + i : "") + "\r\n";
  }, t.parseExtmap = function(e2) {
    const t2 = e2.substring(9).split(" ");
    return { id: parseInt(t2[0], 10), direction: t2[0].indexOf("/") > 0 ? t2[0].split("/")[1] : "sendrecv", uri: t2[1], attributes: t2.slice(2).join(" ") };
  }, t.writeExtmap = function(e2) {
    return "a=extmap:" + (e2.id || e2.preferredId) + (e2.direction && "sendrecv" !== e2.direction ? "/" + e2.direction : "") + " " + e2.uri + (e2.attributes ? " " + e2.attributes : "") + "\r\n";
  }, t.parseFmtp = function(e2) {
    const t2 = {};
    let i;
    const r = e2.substring(e2.indexOf(" ") + 1).split(";");
    for (let e3 = 0; e3 < r.length; e3++) {
      var o, n;
      i = _trimInstanceProperty(o = r[e3]).call(o).split("="), t2[_trimInstanceProperty(n = i[0]).call(n)] = i[1];
    }
    return t2;
  }, t.writeFmtp = function(e2) {
    let t2 = "", i = e2.payloadType;
    if (void 0 !== e2.preferredPayloadType && (i = e2.preferredPayloadType), e2.parameters && Object.keys(e2.parameters).length) {
      const r = [];
      Object.keys(e2.parameters).forEach((t3) => {
        void 0 !== e2.parameters[t3] ? r.push(t3 + "=" + e2.parameters[t3]) : r.push(t3);
      }), t2 += "a=fmtp:" + i + " " + r.join(";") + "\r\n";
    }
    return t2;
  }, t.parseRtcpFb = function(e2) {
    const t2 = e2.substring(e2.indexOf(" ") + 1).split(" ");
    return { type: t2.shift(), parameter: t2.join(" ") };
  }, t.writeRtcpFb = function(e2) {
    let t2 = "", i = e2.payloadType;
    return void 0 !== e2.preferredPayloadType && (i = e2.preferredPayloadType), e2.rtcpFeedback && e2.rtcpFeedback.length && e2.rtcpFeedback.forEach((e3) => {
      t2 += "a=rtcp-fb:" + i + " " + e3.type + (e3.parameter && e3.parameter.length ? " " + e3.parameter : "") + "\r\n";
    }), t2;
  }, t.parseSsrcMedia = function(e2) {
    const t2 = e2.indexOf(" "), i = { ssrc: parseInt(e2.substring(7, t2), 10) }, r = e2.indexOf(":", t2);
    return r > -1 ? (i.attribute = e2.substring(t2 + 1, r), i.value = e2.substring(r + 1)) : i.attribute = e2.substring(t2 + 1), i;
  }, t.parseSsrcGroup = function(e2) {
    const t2 = e2.substring(13).split(" ");
    return { semantics: t2.shift(), ssrcs: t2.map((e3) => parseInt(e3, 10)) };
  }, t.getMid = function(e2) {
    const i = t.matchPrefix(e2, "a=mid:")[0];
    if (i) return i.substring(6);
  }, t.parseFingerprint = function(e2) {
    const t2 = e2.substring(14).split(" ");
    return { algorithm: t2[0].toLowerCase(), value: t2[1].toUpperCase() };
  }, t.getDtlsParameters = function(e2, i) {
    return { role: "auto", fingerprints: t.matchPrefix(e2 + i, "a=fingerprint:").map(t.parseFingerprint) };
  }, t.writeDtlsParameters = function(e2, t2) {
    let i = "a=setup:" + t2 + "\r\n";
    return e2.fingerprints.forEach((e3) => {
      i += "a=fingerprint:" + e3.algorithm + " " + e3.value + "\r\n";
    }), i;
  }, t.parseCryptoLine = function(e2) {
    const t2 = e2.substring(9).split(" ");
    return { tag: parseInt(t2[0], 10), cryptoSuite: t2[1], keyParams: t2[2], sessionParams: t2.slice(3) };
  }, t.writeCryptoLine = function(e2) {
    return "a=crypto:" + e2.tag + " " + e2.cryptoSuite + " " + ("object" == typeof e2.keyParams ? t.writeCryptoKeyParams(e2.keyParams) : e2.keyParams) + (e2.sessionParams ? " " + e2.sessionParams.join(" ") : "") + "\r\n";
  }, t.parseCryptoKeyParams = function(e2) {
    if (0 !== e2.indexOf("inline:")) return null;
    const t2 = e2.substring(7).split("|");
    return { keyMethod: "inline", keySalt: t2[0], lifeTime: t2[1], mkiValue: t2[2] ? t2[2].split(":")[0] : void 0, mkiLength: t2[2] ? t2[2].split(":")[1] : void 0 };
  }, t.writeCryptoKeyParams = function(e2) {
    return e2.keyMethod + ":" + e2.keySalt + (e2.lifeTime ? "|" + e2.lifeTime : "") + (e2.mkiValue && e2.mkiLength ? "|" + e2.mkiValue + ":" + e2.mkiLength : "");
  }, t.getCryptoParameters = function(e2, i) {
    return t.matchPrefix(e2 + i, "a=crypto:").map(t.parseCryptoLine);
  }, t.getIceParameters = function(e2, i) {
    const r = t.matchPrefix(e2 + i, "a=ice-ufrag:")[0], o = t.matchPrefix(e2 + i, "a=ice-pwd:")[0];
    return r && o ? { usernameFragment: r.substring(12), password: o.substring(10) } : null;
  }, t.writeIceParameters = function(e2) {
    let t2 = "a=ice-ufrag:" + e2.usernameFragment + "\r\na=ice-pwd:" + e2.password + "\r\n";
    return e2.iceLite && (t2 += "a=ice-lite\r\n"), t2;
  }, t.parseRtpParameters = function(e2) {
    const i = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r = t.splitLines(e2)[0].split(" ");
    i.profile = r[2];
    for (let o2 = 3; o2 < r.length; o2++) {
      const n = r[o2], s = t.matchPrefix(e2, "a=rtpmap:" + n + " ")[0];
      if (s) {
        const r2 = t.parseRtpMap(s), o3 = t.matchPrefix(e2, "a=fmtp:" + n + " ");
        switch (r2.parameters = o3.length ? t.parseFmtp(o3[0]) : {}, r2.rtcpFeedback = t.matchPrefix(e2, "a=rtcp-fb:" + n + " ").map(t.parseRtcpFb), i.codecs.push(r2), r2.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            i.fecMechanisms.push(r2.name.toUpperCase());
        }
      }
    }
    t.matchPrefix(e2, "a=extmap:").forEach((e3) => {
      i.headerExtensions.push(t.parseExtmap(e3));
    });
    const o = t.matchPrefix(e2, "a=rtcp-fb:* ").map(t.parseRtcpFb);
    return i.codecs.forEach((e3) => {
      o.forEach((t2) => {
        e3.rtcpFeedback.find((e4) => e4.type === t2.type && e4.parameter === t2.parameter) || e3.rtcpFeedback.push(t2);
      });
    }), i;
  }, t.writeRtpDescription = function(e2, i) {
    let r = "";
    r += "m=" + e2 + " ", r += i.codecs.length > 0 ? "9" : "0", r += " " + (i.profile || "UDP/TLS/RTP/SAVPF") + " ", r += i.codecs.map((e3) => void 0 !== e3.preferredPayloadType ? e3.preferredPayloadType : e3.payloadType).join(" ") + "\r\n", r += "c=IN IP4 0.0.0.0\r\n", r += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i.codecs.forEach((e3) => {
      r += t.writeRtpMap(e3), r += t.writeFmtp(e3), r += t.writeRtcpFb(e3);
    });
    let o = 0;
    return i.codecs.forEach((e3) => {
      e3.maxptime > o && (o = e3.maxptime);
    }), o > 0 && (r += "a=maxptime:" + o + "\r\n"), i.headerExtensions && i.headerExtensions.forEach((e3) => {
      r += t.writeExtmap(e3);
    }), r;
  }, t.parseRtpEncodingParameters = function(e2) {
    const i = [], r = t.parseRtpParameters(e2), o = -1 !== r.fecMechanisms.indexOf("RED"), n = -1 !== r.fecMechanisms.indexOf("ULPFEC"), s = t.matchPrefix(e2, "a=ssrc:").map((e3) => t.parseSsrcMedia(e3)).filter((e3) => "cname" === e3.attribute), a = s.length > 0 && s[0].ssrc;
    let d;
    const c2 = t.matchPrefix(e2, "a=ssrc-group:FID").map((e3) => e3.substring(17).split(" ").map((e4) => parseInt(e4, 10)));
    c2.length > 0 && c2[0].length > 1 && c2[0][0] === a && (d = c2[0][1]), r.codecs.forEach((e3) => {
      if ("RTX" === e3.name.toUpperCase() && e3.parameters.apt) {
        let t2 = { ssrc: a, codecPayloadType: parseInt(e3.parameters.apt, 10) };
        a && d && (t2.rtx = { ssrc: d }), i.push(t2), o && (t2 = JSON.parse(JSON.stringify(t2)), t2.fec = { ssrc: a, mechanism: n ? "red+ulpfec" : "red" }, i.push(t2));
      }
    }), 0 === i.length && a && i.push({ ssrc: a });
    let l = t.matchPrefix(e2, "b=");
    return l.length && (l = 0 === l[0].indexOf("b=TIAS:") ? parseInt(l[0].substring(7), 10) : 0 === l[0].indexOf("b=AS:") ? 1e3 * parseInt(l[0].substring(5), 10) * 0.95 - 16e3 : void 0, i.forEach((e3) => {
      e3.maxBitrate = l;
    })), i;
  }, t.parseRtcpParameters = function(e2) {
    const i = {}, r = t.matchPrefix(e2, "a=ssrc:").map((e3) => t.parseSsrcMedia(e3)).filter((e3) => "cname" === e3.attribute)[0];
    r && (i.cname = r.value, i.ssrc = r.ssrc);
    const o = t.matchPrefix(e2, "a=rtcp-rsize");
    i.reducedSize = o.length > 0, i.compound = 0 === o.length;
    const n = t.matchPrefix(e2, "a=rtcp-mux");
    return i.mux = n.length > 0, i;
  }, t.writeRtcpParameters = function(e2) {
    let t2 = "";
    return e2.reducedSize && (t2 += "a=rtcp-rsize\r\n"), e2.mux && (t2 += "a=rtcp-mux\r\n"), void 0 !== e2.ssrc && e2.cname && (t2 += "a=ssrc:" + e2.ssrc + " cname:" + e2.cname + "\r\n"), t2;
  }, t.parseMsid = function(e2) {
    let i;
    const r = t.matchPrefix(e2, "a=msid:");
    if (1 === r.length) return i = r[0].substring(7).split(" "), { stream: i[0], track: i[1] };
    const o = t.matchPrefix(e2, "a=ssrc:").map((e3) => t.parseSsrcMedia(e3)).filter((e3) => "msid" === e3.attribute);
    return o.length > 0 ? (i = o[0].value.split(" "), { stream: i[0], track: i[1] }) : void 0;
  }, t.parseSctpDescription = function(e2) {
    const i = t.parseMLine(e2), r = t.matchPrefix(e2, "a=max-message-size:");
    let o;
    r.length > 0 && (o = parseInt(r[0].substring(19), 10)), isNaN(o) && (o = 65536);
    const n = t.matchPrefix(e2, "a=sctp-port:");
    if (n.length > 0) return { port: parseInt(n[0].substring(12), 10), protocol: i.fmt, maxMessageSize: o };
    const s = t.matchPrefix(e2, "a=sctpmap:");
    if (s.length > 0) {
      const e3 = s[0].substring(10).split(" ");
      return { port: parseInt(e3[0], 10), protocol: e3[1], maxMessageSize: o };
    }
  }, t.writeSctpDescription = function(e2, t2) {
    let i = [];
    return i = "DTLS/SCTP" !== e2.protocol ? ["m=" + e2.kind + " 9 " + e2.protocol + " " + t2.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t2.port + "\r\n"] : ["m=" + e2.kind + " 9 " + e2.protocol + " " + t2.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t2.port + " " + t2.protocol + " 65535\r\n"], void 0 !== t2.maxMessageSize && i.push("a=max-message-size:" + t2.maxMessageSize + "\r\n"), i.join("");
  }, t.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  }, t.writeSessionBoilerplate = function(e2, i, r) {
    let o;
    const n = void 0 !== i ? i : 2;
    o = e2 || t.generateSessionId();
    return "v=0\r\no=" + (r || "thisisadapterortc") + " " + o + " " + n + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
  }, t.getDirection = function(e2, i) {
    const r = t.splitLines(e2);
    for (let e3 = 0; e3 < r.length; e3++) switch (r[e3]) {
      case "a=sendrecv":
      case "a=sendonly":
      case "a=recvonly":
      case "a=inactive":
        return r[e3].substring(2);
    }
    return i ? t.getDirection(i) : "sendrecv";
  }, t.getKind = function(e2) {
    return t.splitLines(e2)[0].split(" ")[0].substring(2);
  }, t.isRejected = function(e2) {
    return "0" === e2.split(" ", 2)[1];
  }, t.parseMLine = function(e2) {
    const i = t.splitLines(e2)[0].substring(2).split(" ");
    return { kind: i[0], port: parseInt(i[1], 10), protocol: i[2], fmt: i.slice(3).join(" ") };
  }, t.parseOLine = function(e2) {
    const i = t.matchPrefix(e2, "o=")[0].substring(2).split(" ");
    return { username: i[0], sessionId: i[1], sessionVersion: parseInt(i[2], 10), netType: i[3], addressType: i[4], address: i[5] };
  }, t.isValidSDP = function(e2) {
    if ("string" != typeof e2 || 0 === e2.length) return false;
    const i = t.splitLines(e2);
    for (let e3 = 0; e3 < i.length; e3++) if (i[e3].length < 2 || "=" !== i[e3].charAt(1)) return false;
    return true;
  }, e.exports = t;
}(sdp$1);
var sdpExports = sdp$1.exports;
var SDPUtils = getDefaultExportFromCjs(sdpExports);
var sdp = _mergeNamespaces({ __proto__: null, default: SDPUtils }, [sdpExports]);
function shimRTCIceCandidate(e) {
  if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return;
  const t = e.RTCIceCandidate;
  e.RTCIceCandidate = function(e2) {
    if ("object" == typeof e2 && e2.candidate && 0 === e2.candidate.indexOf("a=") && ((e2 = JSON.parse(JSON.stringify(e2))).candidate = e2.candidate.substring(2)), e2.candidate && e2.candidate.length) {
      const i = new t(e2), r = SDPUtils.parseCandidate(e2.candidate);
      for (const e3 in r) e3 in i || Object.defineProperty(i, e3, { value: r[e3] });
      return i.toJSON = function() {
        return { candidate: i.candidate, sdpMid: i.sdpMid, sdpMLineIndex: i.sdpMLineIndex, usernameFragment: i.usernameFragment };
      }, i;
    }
    return new t(e2);
  }, e.RTCIceCandidate.prototype = t.prototype, wrapPeerConnectionEvent(e, "icecandidate", (t2) => (t2.candidate && Object.defineProperty(t2, "candidate", { value: new e.RTCIceCandidate(t2.candidate), writable: "false" }), t2));
}
function shimRTCIceCandidateRelayProtocol(e) {
  !e.RTCIceCandidate || e.RTCIceCandidate && "relayProtocol" in e.RTCIceCandidate.prototype || wrapPeerConnectionEvent(e, "icecandidate", (e2) => {
    if (e2.candidate) {
      const t = SDPUtils.parseCandidate(e2.candidate.candidate);
      "relay" === t.type && (e2.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t.priority >> 24]);
    }
    return e2;
  });
}
function shimMaxMessageSize(e, t) {
  if (!e.RTCPeerConnection) return;
  "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get() {
    return void 0 === this._sctp ? null : this._sctp;
  } });
  const i = e.RTCPeerConnection.prototype.setRemoteDescription;
  e.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, "chrome" === t.browser && t.version >= 76) {
      const { sdpSemantics: e2 } = this.getConfiguration();
      "plan-b" === e2 && Object.defineProperty(this, "sctp", { get() {
        return void 0 === this._sctp ? null : this._sctp;
      }, enumerable: true, configurable: true });
    }
    if (function(e2) {
      if (!e2 || !e2.sdp) return false;
      const t2 = SDPUtils.splitSections(e2.sdp);
      return t2.shift(), t2.some((e3) => {
        const t3 = SDPUtils.parseMLine(e3);
        return t3 && "application" === t3.kind && -1 !== t3.protocol.indexOf("SCTP");
      });
    }(arguments[0])) {
      const e2 = function(e3) {
        const t2 = e3.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
        if (null === t2 || t2.length < 2) return -1;
        const i3 = parseInt(t2[1], 10);
        return i3 != i3 ? -1 : i3;
      }(arguments[0]), i2 = function(e3) {
        let i3 = 65536;
        return "firefox" === t.browser && (i3 = t.version < 57 ? -1 === e3 ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), i3;
      }(e2), r = function(e3, i3) {
        let r2 = 65536;
        "firefox" === t.browser && 57 === t.version && (r2 = 65535);
        const o2 = SDPUtils.matchPrefix(e3.sdp, "a=max-message-size:");
        return o2.length > 0 ? r2 = parseInt(o2[0].substring(19), 10) : "firefox" === t.browser && -1 !== i3 && (r2 = 2147483637), r2;
      }(arguments[0], e2);
      let o;
      o = 0 === i2 && 0 === r ? Number.POSITIVE_INFINITY : 0 === i2 || 0 === r ? Math.max(i2, r) : Math.min(i2, r);
      const n = {};
      Object.defineProperty(n, "maxMessageSize", { get: () => o }), this._sctp = n;
    }
    return i.apply(this, arguments);
  };
}
function shimSendThrowTypeError(e) {
  if (!e.RTCPeerConnection || !("createDataChannel" in e.RTCPeerConnection.prototype)) return;
  function t(e2, t2) {
    const i2 = e2.send;
    e2.send = function() {
      return i2.apply(e2, arguments);
    };
  }
  const i = e.RTCPeerConnection.prototype.createDataChannel;
  e.RTCPeerConnection.prototype.createDataChannel = function() {
    const e2 = i.apply(this, arguments);
    return t(e2), e2;
  }, wrapPeerConnectionEvent(e, "datachannel", (e2) => (t(e2.channel, e2.target), e2));
}
function shimConnectionState(e) {
  if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return;
  const t = e.RTCPeerConnection.prototype;
  Object.defineProperty(t, "connectionState", { get() {
    return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
  }, enumerable: true, configurable: true }), Object.defineProperty(t, "onconnectionstatechange", { get() {
    return this._onconnectionstatechange || null;
  }, set(e2) {
    this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e2 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e2);
  }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e2) => {
    const i = t[e2];
    t[e2] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e3) => {
        const t2 = e3.target;
        if (t2._lastConnectionState !== t2.connectionState) {
          t2._lastConnectionState = t2.connectionState;
          const i2 = new Event("connectionstatechange", e3);
          t2.dispatchEvent(i2);
        }
        return e3;
      }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(e, t) {
  if (!e.RTCPeerConnection) return;
  if ("chrome" === t.browser && t.version >= 71) return;
  if ("safari" === t.browser && t.version >= 605) return;
  const i = e.RTCPeerConnection.prototype.setRemoteDescription;
  e.RTCPeerConnection.prototype.setRemoteDescription = function(t2) {
    if (t2 && t2.sdp && -1 !== t2.sdp.indexOf("\na=extmap-allow-mixed")) {
      const i2 = t2.sdp.split("\n").filter((e2) => "a=extmap-allow-mixed" !== _trimInstanceProperty(e2).call(e2)).join("\n");
      e.RTCSessionDescription && t2 instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: t2.type, sdp: i2 }) : t2.sdp = i2;
    }
    return i.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(e, t) {
  if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
  const i = e.RTCPeerConnection.prototype.addIceCandidate;
  i && 0 !== i.length && (e.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : i.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
  });
}
function shimParameterlessSetLocalDescription(e, t) {
  if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
  const i = e.RTCPeerConnection.prototype.setLocalDescription;
  i && 0 !== i.length && (e.RTCPeerConnection.prototype.setLocalDescription = function() {
    let e2 = arguments[0] || {};
    if ("object" != typeof e2 || e2.type && e2.sdp) return i.apply(this, arguments);
    if (e2 = { type: e2.type, sdp: e2.sdp }, !e2.type) switch (this.signalingState) {
      case "stable":
      case "have-local-offer":
      case "have-remote-pranswer":
        e2.type = "offer";
        break;
      default:
        e2.type = "answer";
    }
    if (e2.sdp || "offer" !== e2.type && "answer" !== e2.type) return i.apply(this, [e2]);
    return ("offer" === e2.type ? this.createOffer : this.createAnswer).apply(this).then((e3) => i.apply(this, [e3]));
  });
}
var commonShim = Object.freeze({ __proto__: null, removeExtmapAllowMixed, shimAddIceCandidateNullOrEmpty, shimConnectionState, shimMaxMessageSize, shimParameterlessSetLocalDescription, shimRTCIceCandidate, shimRTCIceCandidateRelayProtocol, shimSendThrowTypeError });
function adapterFactory() {
  let { window: e } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: true, shimFirefox: true, shimSafari: true };
  const i = log, r = detectBrowser(e), o = { browserDetails: r, commonShim, extractVersion, disableLog, disableWarnings, sdp };
  switch (r.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !t.shimChrome) return i("Chrome shim is not included in this adapter release."), o;
      if (null === r.version) return i("Chrome shim can not determine version, not shimming."), o;
      i("adapter.js shimming chrome."), o.browserShim = chromeShim, shimAddIceCandidateNullOrEmpty(e, r), shimParameterlessSetLocalDescription(e), shimGetUserMedia$2(e, r), shimMediaStream(e), shimPeerConnection$1(e, r), shimOnTrack$1(e), shimAddTrackRemoveTrack(e, r), shimGetSendersWithDtmf(e), shimGetStats(e), shimSenderReceiverGetStats(e), fixNegotiationNeeded(e, r), shimRTCIceCandidate(e), shimRTCIceCandidateRelayProtocol(e), shimConnectionState(e), shimMaxMessageSize(e, r), shimSendThrowTypeError(e), removeExtmapAllowMixed(e, r);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !t.shimFirefox) return i("Firefox shim is not included in this adapter release."), o;
      i("adapter.js shimming firefox."), o.browserShim = firefoxShim, shimAddIceCandidateNullOrEmpty(e, r), shimParameterlessSetLocalDescription(e), shimGetUserMedia$1(e, r), shimPeerConnection(e, r), shimOnTrack(e), shimRemoveStream(e), shimSenderGetStats(e), shimReceiverGetStats(e), shimRTCDataChannel(e), shimAddTransceiver(e), shimGetParameters(e), shimCreateOffer(e), shimCreateAnswer(e), shimRTCIceCandidate(e), shimConnectionState(e), shimMaxMessageSize(e, r), shimSendThrowTypeError(e);
      break;
    case "safari":
      if (!safariShim || !t.shimSafari) return i("Safari shim is not included in this adapter release."), o;
      i("adapter.js shimming safari."), o.browserShim = safariShim, shimAddIceCandidateNullOrEmpty(e, r), shimParameterlessSetLocalDescription(e), shimRTCIceServerUrls(e), shimCreateOfferLegacy(e), shimCallbacksAPI(e), shimLocalStreamsAPI(e), shimRemoteStreamsAPI(e), shimTrackEventTransceiver(e), shimGetUserMedia(e), shimAudioContext(e), shimRTCIceCandidate(e), shimRTCIceCandidateRelayProtocol(e), shimMaxMessageSize(e, r), shimSendThrowTypeError(e), removeExtmapAllowMixed(e, r);
      break;
    default:
      i("Unsupported browser!");
  }
  return o;
}
if (adapterFactory({ window: "undefined" == typeof window ? void 0 : window }), "undefined" != typeof MediaStreamTrack) {
  const e = MediaStreamTrack.prototype.getSettings;
  MediaStreamTrack.prototype.getSettings = function() {
    const t = e.call(this);
    return t.width && (t.width = Math.floor(t.width)), t.height && (t.height = Math.floor(t.height)), t.frameRate && (t.frameRate = Math.floor(t.frameRate)), t;
  };
}
var tryToString$3 = tryToString$6;
var $TypeError$6 = TypeError;
var deletePropertyOrThrow$1 = function(e, t) {
  if (!delete e[t]) throw new $TypeError$6("Cannot delete property " + tryToString$3(t) + " of " + tryToString$3(e));
};
var arraySlice$2 = arraySlice$5;
var floor$2 = Math.floor;
var sort$7 = function(e, t) {
  var i = e.length;
  if (i < 8) for (var r, o, n = 1; n < i; ) {
    for (o = n, r = e[n]; o && t(e[o - 1], r) > 0; ) e[o] = e[--o];
    o !== n++ && (e[o] = r);
  }
  else for (var s = floor$2(i / 2), a = sort$7(arraySlice$2(e, 0, s), t), d = sort$7(arraySlice$2(e, s), t), c2 = a.length, l = d.length, u = 0, h = 0; u < c2 || h < l; ) e[u + h] = u < c2 && h < l ? t(a[u], d[h]) <= 0 ? a[u++] : d[h++] : u < c2 ? a[u++] : d[h++];
  return e;
};
var arraySort$1 = sort$7;
var userAgent$5 = environmentUserAgent;
var firefox = userAgent$5.match(/firefox\/(\d+)/i);
var environmentFfVersion = !!firefox && +firefox[1];
var UA = environmentUserAgent;
var environmentIsIeOrEdge = /MSIE|Trident/.test(UA);
var userAgent$4 = environmentUserAgent;
var webkit = userAgent$4.match(/AppleWebKit\/(\d+)\./);
var environmentWebkitVersion = !!webkit && +webkit[1];
var $$i = _export;
var uncurryThis$6 = functionUncurryThis;
var aCallable$8 = aCallable$c;
var toObject$2 = toObject$c;
var lengthOfArrayLike$2 = lengthOfArrayLike$9;
var deletePropertyOrThrow = deletePropertyOrThrow$1;
var toString$3 = toString$e;
var fails$6 = fails$s;
var internalSort = arraySort$1;
var arrayMethodIsStrict = arrayMethodIsStrict$2;
var FF = environmentFfVersion;
var IE_OR_EDGE = environmentIsIeOrEdge;
var V8 = environmentV8Version;
var WEBKIT = environmentWebkitVersion;
var test = [];
var nativeSort = uncurryThis$6(test.sort);
var push$4 = uncurryThis$6(test.push);
var FAILS_ON_UNDEFINED = fails$6(function() {
  test.sort(void 0);
});
var FAILS_ON_NULL = fails$6(function() {
  test.sort(null);
});
var STRICT_METHOD = arrayMethodIsStrict("sort");
var STABLE_SORT = !fails$6(function() {
  if (V8) return V8 < 70;
  if (!(FF && FF > 3)) {
    if (IE_OR_EDGE) return true;
    if (WEBKIT) return WEBKIT < 603;
    var e, t, i, r, o = "";
    for (e = 65; e < 76; e++) {
      switch (t = String.fromCharCode(e), e) {
        case 66:
        case 69:
        case 70:
        case 72:
          i = 3;
          break;
        case 68:
        case 71:
          i = 4;
          break;
        default:
          i = 2;
      }
      for (r = 0; r < 47; r++) test.push({ k: t + r, v: i });
    }
    for (test.sort(function(e2, t2) {
      return t2.v - e2.v;
    }), r = 0; r < test.length; r++) t = test[r].k.charAt(0), o.charAt(o.length - 1) !== t && (o += t);
    return "DGBEFHACIJK" !== o;
  }
});
var FORCED$1 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
var getSortCompare = function(e) {
  return function(t, i) {
    return void 0 === i ? -1 : void 0 === t ? 1 : void 0 !== e ? +e(t, i) || 0 : toString$3(t) > toString$3(i) ? 1 : -1;
  };
};
$$i({ target: "Array", proto: true, forced: FORCED$1 }, { sort: function(e) {
  void 0 !== e && aCallable$8(e);
  var t = toObject$2(this);
  if (STABLE_SORT) return void 0 === e ? nativeSort(t) : nativeSort(t, e);
  var i, r, o = [], n = lengthOfArrayLike$2(t);
  for (r = 0; r < n; r++) r in t && push$4(o, t[r]);
  for (internalSort(o, getSortCompare(e)), i = lengthOfArrayLike$2(o), r = 0; r < i; ) t[r] = o[r++];
  for (; r < n; ) deletePropertyOrThrow(t, r++);
  return t;
} });
var getBuiltInPrototypeMethod = getBuiltInPrototypeMethod$a;
var sort$6 = getBuiltInPrototypeMethod("Array", "sort");
var isPrototypeOf$3 = objectIsPrototypeOf;
var method = sort$6;
var ArrayPrototype$1 = Array.prototype;
var sort$5 = function(e) {
  var t = e.sort;
  return e === ArrayPrototype$1 || isPrototypeOf$3(ArrayPrototype$1, e) && t === ArrayPrototype$1.sort ? method : t;
};
var parent$e = sort$5;
var sort$4 = parent$e;
var parent$d = sort$4;
var sort$3 = parent$d;
var parent$c = sort$3;
var sort$2 = parent$c;
var sort$1 = sort$2;
var sort2 = sort$1;
var _sortInstanceProperty = getDefaultExportFromCjs(sort2);
var eventemitter3 = { exports: {} };
!function(e) {
  var t = Object.prototype.hasOwnProperty, i = "~";
  function r() {
  }
  function o(e2, t2, i2) {
    this.fn = e2, this.context = t2, this.once = i2 || false;
  }
  function n(e2, t2, r2, n2, s2) {
    if ("function" != typeof r2) throw new TypeError("The listener must be a function");
    var a2 = new o(r2, n2 || e2, s2), d = i ? i + t2 : t2;
    return e2._events[d] ? e2._events[d].fn ? e2._events[d] = [e2._events[d], a2] : e2._events[d].push(a2) : (e2._events[d] = a2, e2._eventsCount++), e2;
  }
  function s(e2, t2) {
    0 == --e2._eventsCount ? e2._events = new r() : delete e2._events[t2];
  }
  function a() {
    this._events = new r(), this._eventsCount = 0;
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (i = false)), a.prototype.eventNames = function() {
    var e2, r2, o2 = [];
    if (0 === this._eventsCount) return o2;
    for (r2 in e2 = this._events) t.call(e2, r2) && o2.push(i ? r2.slice(1) : r2);
    return Object.getOwnPropertySymbols ? o2.concat(Object.getOwnPropertySymbols(e2)) : o2;
  }, a.prototype.listeners = function(e2) {
    var t2 = i ? i + e2 : e2, r2 = this._events[t2];
    if (!r2) return [];
    if (r2.fn) return [r2.fn];
    for (var o2 = 0, n2 = r2.length, s2 = new Array(n2); o2 < n2; o2++) s2[o2] = r2[o2].fn;
    return s2;
  }, a.prototype.listenerCount = function(e2) {
    var t2 = i ? i + e2 : e2, r2 = this._events[t2];
    return r2 ? r2.fn ? 1 : r2.length : 0;
  }, a.prototype.emit = function(e2, t2, r2, o2, n2, s2) {
    var a2 = i ? i + e2 : e2;
    if (!this._events[a2]) return false;
    var d, c2, l = this._events[a2], u = arguments.length;
    if (l.fn) {
      switch (l.once && this.removeListener(e2, l.fn, void 0, true), u) {
        case 1:
          return l.fn.call(l.context), true;
        case 2:
          return l.fn.call(l.context, t2), true;
        case 3:
          return l.fn.call(l.context, t2, r2), true;
        case 4:
          return l.fn.call(l.context, t2, r2, o2), true;
        case 5:
          return l.fn.call(l.context, t2, r2, o2, n2), true;
        case 6:
          return l.fn.call(l.context, t2, r2, o2, n2, s2), true;
      }
      for (c2 = 1, d = new Array(u - 1); c2 < u; c2++) d[c2 - 1] = arguments[c2];
      l.fn.apply(l.context, d);
    } else {
      var h, _ = l.length;
      for (c2 = 0; c2 < _; c2++) switch (l[c2].once && this.removeListener(e2, l[c2].fn, void 0, true), u) {
        case 1:
          l[c2].fn.call(l[c2].context);
          break;
        case 2:
          l[c2].fn.call(l[c2].context, t2);
          break;
        case 3:
          l[c2].fn.call(l[c2].context, t2, r2);
          break;
        case 4:
          l[c2].fn.call(l[c2].context, t2, r2, o2);
          break;
        default:
          if (!d) for (h = 1, d = new Array(u - 1); h < u; h++) d[h - 1] = arguments[h];
          l[c2].fn.apply(l[c2].context, d);
      }
    }
    return true;
  }, a.prototype.on = function(e2, t2, i2) {
    return n(this, e2, t2, i2, false);
  }, a.prototype.once = function(e2, t2, i2) {
    return n(this, e2, t2, i2, true);
  }, a.prototype.removeListener = function(e2, t2, r2, o2) {
    var n2 = i ? i + e2 : e2;
    if (!this._events[n2]) return this;
    if (!t2) return s(this, n2), this;
    var a2 = this._events[n2];
    if (a2.fn) a2.fn !== t2 || o2 && !a2.once || r2 && a2.context !== r2 || s(this, n2);
    else {
      for (var d = 0, c2 = [], l = a2.length; d < l; d++) (a2[d].fn !== t2 || o2 && !a2[d].once || r2 && a2[d].context !== r2) && c2.push(a2[d]);
      c2.length ? this._events[n2] = 1 === c2.length ? c2[0] : c2 : s(this, n2);
    }
    return this;
  }, a.prototype.removeAllListeners = function(e2) {
    var t2;
    return e2 ? (t2 = i ? i + e2 : e2, this._events[t2] && s(this, t2)) : (this._events = new r(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = i, a.EventEmitter = a, e.exports = a;
}(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
var EventEmitter2 = getDefaultExportFromCjs(eventemitter3Exports);
var logger$a = new Logger$1("VERTC", 0);
var EnhancedEventEmitter = class extends eventemitter3Exports.EventEmitter {
  safeEmit(e) {
    const t = this.listenerCount(e);
    try {
      for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) r[o - 1] = arguments[o];
      return super.emit(e, ...r);
    } catch (i2) {
      return logger$a.error("safeEmit", "safeEmit() | event listener threw an error [event:%s]:%o", e, i2), console.error(i2), Boolean(t);
    }
  }
  async asyncEmit(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    await Promise.resolve().then(() => {
      try {
        super.emit(e, ...i);
      } catch (t2) {
        logger$a.error("safeEmit", "safeEmit() | event listener threw an error [event:%s]:%o", e, t2), console.error(t2);
      }
    });
  }
};
var SEIStreamEventType = ((e) => (e[e.BLACK = 0] = "BLACK", e[e.NORMAL = 1] = "NORMAL", e))(SEIStreamEventType || {});
var RemoveStreamMessage = ((e) => (e.streamRemovedBySchedule308 = "stream removed", e.clientRePublish = "client republish", e.publishStreamFaied = "publish failed", e.clientUnPublish = "client unpublished", e.clientDisconnected = "client disconnected", e.videoMuted = "video muted", e))(RemoveStreamMessage || {});
var StreamControlType = ((e) => (e.PushLimitWarn = "PushLimitWarn", e.OTHER = "OTHER", e))(StreamControlType || {});
var EngineControlType = ((e) => (e.CHANGE_CODEC = "changeCodec", e))(EngineControlType || {});
var SignalEvent = ((e) => (e.ON_ADD_STREAM = "onAddStream", e.ON_ADD_STREAM_LIST = "onAddStreamList", e.ON_REMOVE_STREAM = "onRemoveStream", e.ON_REMOVE_STREAM_LIST = "onRemoveStreamList", e.USER_DISCONNECTION = "userDisconnection", e.USER_DISCONNECTION_LIST = "userDisconnectionList", e.USER_CONNECTION = "userConnection", e.USER_CONNECTION_LIST = "userConnectionList", e.ON_UPDATE_STREAM_ATTRIBUTES = "onUpdateStreamAttributes", e.ON_UPDATE_ROOM_ATTRIBUTES = "onUpdateRoomAttributes", e.ON_UPDATE_USER_ATTRIBUTES = "onUpdateUserAttributes", e.ON_PUSH_TRACK = "onPushTrack", e.ON_REMOVE_TRACK = "onRemoveTrack", e.ON_CUSTOM_MESSAGE = "onCustomMessage", e.NODE_CHANGE = "nodeChange", e.USER_MESSAGE_RECEIVED = "userMessageReceived", e.USER_BINARY_MESSAGE_RECEIVED = "userBinaryMessageReceived", e.USER_MESSAGE_RECEIVED_OUTSIDE_ROOM = "userMessageReceivedOutsideRoom", e.USER_BINARY_MESSAGE_RECEIVED_OUTSIDE_ROOM = "userBinaryMessageReceivedOutsideRoom", e.POST_PROCESSING_MESSAGE = "postProcessingMessage", e.ON_USER_TOKEN_WILL_EXPIRE = "onUserTokenWillExpire", e.ON_TOKEN_PUBLISH_PRIVILEGE_WILL_EXPIRE = "onTokenPublishPrivilegeWillExpire", e.ON_TOKEN_PUBLISH_PRIVILEGE_DID_EXPIRED = "onTokenPublishPrivilegeDidExpired", e.ON_TOKEN_SUBSCRIBE_PRIVILEGE_WILL_EXPIRE = "onTokenSubscribePrivilegeWillExpire", e.ON_TOKEN_SUBSCRIBE_PRIVILEGE_DID_EXPIRED = "onTokenSubscribePrivilegeDidExpired", e.STREAM_CONTROL_MESSAGE = "streamControlMessage", e.ON_SPEAKER_CHANGE = "onSpeakerChange", e.ON_STREAM_FAILED = "streamFailed", e.ON_NOTIFY_RECONNECT = "notifyReconnect", e.ON_FORWARD_DST_ROOM_USER_KICK = "onForwardDstRoomUserKick", e.ENGINE_CONTROL_MESSAGE = "engineControlMessage", e.ON_STREAM_PUSHED_BY_OTHER = "onStreamPushedByOther", e.ON_STREAM_PULL_STATE_CHANGED = "onStreamPullStateChanged", e))(SignalEvent || {});
var MediaServerSignalEvent = ((e) => (e.RSCP = "RSCP", e.RTT = "RTT", e.SSC = "SSC", e))(MediaServerSignalEvent || {});
var StateEvent = ((e) => (e.ON_CONNECTION_STATE_CHANGE = "onConnectionStateChange", e.ON_VENDOR_CONNECTION_STATE_CHANGE = "onVendorConnectionStateChange", e.ABNORMAL_DISCONNECTION = "normalConnection", e.ON_RECONNECT_FAILED = "onReconnectFailed", e.CONNECT_WITH_TCP = "onIceConnectWithTcp", e))(StateEvent || {});
var UserDisconnectionTag = ((e) => (e.userLeave = "userLeave", e.connectionLost = "connectionLost", e.userDuplicateLogin = "userDuplicateLogin", e.kickedByAdmin = "kickedByAdmin", e.roleChanged = "roleChanged", e.onUserTokenDidExpire = "onUserTokenDidExpire", e))(UserDisconnectionTag || {});
var UserDisconnectionCode = ((e) => (e[e.roomDismissByAdmin = 2] = "roomDismissByAdmin", e))(UserDisconnectionCode || {});
var RTS_MODE = ((e) => (e[e.LIMIT_MODE = 1] = "LIMIT_MODE", e[e.NORMAL_MODE = 2] = "NORMAL_MODE", e))(RTS_MODE || {});
var VideoType = ((e) => (e[e.NORMAL = 0] = "NORMAL", e[e.BLACK = 1] = "BLACK", e))(VideoType || {});
var SourceType = ((e) => (e[e.EXTERNAL = 0] = "EXTERNAL", e[e.INTERNAL = 1] = "INTERNAL", e))(SourceType || {});
var MediaType = ((e) => (e.AUDIO = "audio", e.VIDEO = "video", e))(MediaType || {});
var ExtendStreamIndex = ((e) => (e.MAIN = "main", e.SCREEN = "screen", e.PUBLIC = "public", e.VIRTUAL = "virtual", e))(ExtendStreamIndex || {});
var Track = class extends EnhancedEventEmitter {
  constructor(e, t, i) {
    super(), _defineProperty(this, "trackId", genUuid()), _defineProperty(this, "_logger", void 0), _defineProperty(this, "trackInfo", void 0), _defineProperty(this, "_originTrack", void 0), _defineProperty(this, "_channelCount", void 0), this._ctx = e, this._logger = new Logger$1("Track", 4, e.id), this.trackInfo = i, this._originTrack = t, this._channelCount = t.getSettings().channelCount;
  }
  get dummy() {
    return this.trackInfo.isDummy;
  }
  get virtual() {
    return "virtual" === this.trackInfo.streamIndex;
  }
  get isScreen() {
    return "screen" === this.trackInfo.streamIndex;
  }
  get isPublic() {
    return "public" === this.trackInfo.streamIndex;
  }
  get sourceType() {
    return this.trackInfo.sourceType;
  }
  get mediaType() {
    return this.trackInfo.mediaType;
  }
  get captureSessionId() {
    return this.trackInfo.captureSessionId;
  }
  get streamIndex() {
    const { streamIndex: e } = this.trackInfo;
    return "main" === e ? StreamIndex$1.STREAM_INDEX_MAIN : "screen" === e ? StreamIndex$1.STREAM_INDEX_SCREEN : void 0;
  }
  get channelCount() {
    var e;
    return null !== (e = this._channelCount) && void 0 !== e ? e : 0;
  }
  get originTrack() {
    return this._originTrack;
  }
  set originTrack(e) {
    this._originTrack = e, this._channelCount = mediaTrack.getSettings().channelCount;
  }
  get logger() {
    return this._logger.module = this.constructor.name, this._logger;
  }
  destroy() {
    this._originTrack.stop();
  }
};
var LocalTrack = class extends Track {
  constructor(e, t, i) {
    super(e, t, i), _defineProperty(this, "_mediaTrack", void 0), _defineProperty(this, "_preProcessingTrack", void 0), _defineProperty(this, "isTrackReady", void 0), _defineProperty(this, "handleTrackEnded", () => {
      this.emit("track-ended", this), this.destroy();
    }), _defineProperty(this, "handleMute", () => {
      this.emit("track-mute", this);
    }), _defineProperty(this, "handleUnmute", () => {
      this.emit("track-unmute", this);
    }), this._initListeners(), this.isTrackReady = this.generatePreProcessingTrack();
  }
  get mediaTrack() {
    var e;
    return null !== (e = this._mediaTrack) && void 0 !== e ? e : this._originTrack;
  }
  set mediaTrack(e) {
    this.mediaTrack.id !== e.id && (this._mediaTrack = e, this.isTrackReady = this.generatePreProcessingTrack());
  }
  get preprocessingTrack() {
    var e;
    return null !== (e = this._preProcessingTrack) && void 0 !== e ? e : this.mediaTrack;
  }
  async generatePreProcessingTrack() {
    var e;
    const t = null === (e = this._preProcessingTrack) || void 0 === e ? void 0 : e.id;
    this._preProcessingTrack = void 0;
    try {
      const e2 = await this._ctx.extensionManager.getPreProcessingTrack(this);
      e2 instanceof MediaStreamTrack && (this._preProcessingTrack = e2, t !== this._preProcessingTrack.id && setTimeout(() => {
        this.emit("needReplaceTrack");
      }));
    } catch (e2) {
      console.error(e2);
    }
  }
  destroy() {
    var e, t;
    this._originTrack.removeEventListener("ended", this.handleTrackEnded), this._originTrack.removeEventListener("mute", this.handleMute), this._originTrack.removeEventListener("unmute", this.handleUnmute), null === (e = this._preProcessingTrack) || void 0 === e || e.stop(), null === (t = this._mediaTrack) || void 0 === t || t.stop(), super.destroy();
  }
  _initListeners() {
    this._originTrack instanceof MediaStreamTrack && (this._originTrack.addEventListener("ended", this.handleTrackEnded), this._originTrack.addEventListener("mute", this.handleMute), this._originTrack.addEventListener("unmute", this.handleUnmute));
  }
};
var RemoteTrack = class extends Track {
  constructor(e, t, i) {
    super(e, t, i), _defineProperty(this, "_mediaTrack", void 0), this._originTrack = t;
  }
  get mediaTrack() {
    var e;
    return null !== (e = this._mediaTrack) && void 0 !== e ? e : this._originTrack;
  }
  set mediaTrack(e) {
    this.mediaTrack.id !== e.id && (this._mediaTrack = e);
  }
  get preprocessingTrack() {
    return this.mediaTrack;
  }
};
var RTC_SEI_TYPE = ((e) => (e[e.internal = 0] = "internal", e[e.external = 1] = "external", e[e.bypass = 2] = "bypass", e))(RTC_SEI_TYPE || {});
var UUID_INTERNAL = new Uint8Array([109, 167, 53, 190, 103, 90, 72, 1, 170, 89, 63, 164, 194, 199, 19, 85]);
var UUID_EXTERNAL = new Uint8Array([109, 167, 53, 190, 103, 90, 72, 1, 170, 89, 63, 164, 194, 199, 19, 84]);
var UUID_EXTERNAL_2 = new Uint8Array([31, 239, 3, 50, 242, 120, 76, 85, 169, 42, 161, 91, 75, 186, 22]);
var rbsp2ebsp = (e) => {
  const t = [];
  let i = 0;
  for (const r of e) i >= 2 && r <= 3 && (t.push(3), i = 0), 0 === r ? i++ : i = 0, t.push(r);
  return new Uint8Array(t);
};
var ebsp2rbsp = (e) => {
  const t = [];
  for (let i = 0; i < e.length; i++) e[i] <= 3 && 0 === e[i - 1] && 0 === e[i - 2] || t.push(e[i]);
  return new Uint8Array(t);
};
function serializeData(e) {
  const t = [];
  for (; e >= 255; ) e -= 255, t.push(255);
  return t.push(e), new Uint8Array(t);
}
function deserializeData(e) {
  let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i = 0;
  for (; 255 === e[t] && t < e.byteLength; ) t++, i += 255;
  return t < e.byteLength && (i += e[t++]), [i, t];
}
var HEVC_SEI_NALU_HEADER = new Uint8Array([80, 1]);
var SEIHelper = class _SEIHelper {
  static generateSEI(e, t) {
    let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const r = new Uint8Array([0, 0, 0, 1]), o = t ? HEVC_SEI_NALU_HEADER : new Uint8Array([6]), n = new Uint8Array([5]), s = _SEIHelper.__uuid || (i ? UUID_INTERNAL : UUID_EXTERNAL), a = serializeData(e.byteLength + s.byteLength), d = rbsp2ebsp(e);
    return new Uint8Array([...r, ...o, ...n, ...a, ...s, ...d, 128]);
  }
  static decodeSEIBody(e, t) {
    e = e.slice(0, e.length - 1);
    const i = ebsp2rbsp(e);
    if (i.byteLength < 2) return;
    let r = 0;
    const o = t ? 2 : 1;
    if (5 !== i[o] && 100 !== i[o]) return;
    r += 1 + o;
    const [n, s] = deserializeData(i, r);
    r = s;
    let a = 2;
    const d = r + n;
    i.byteLength >= UUID_EXTERNAL.byteLength && n >= UUID_EXTERNAL.byteLength && (i.slice(r, r + UUID_EXTERNAL.byteLength).toString() === UUID_EXTERNAL.toString() || i.slice(r, r + UUID_EXTERNAL_2.byteLength).toString() === UUID_EXTERNAL_2.toString()) ? (r += UUID_EXTERNAL.byteLength, a = 1) : i.byteLength >= UUID_EXTERNAL.byteLength && n >= UUID_EXTERNAL.byteLength && i.slice(r, r + UUID_INTERNAL.byteLength).toString() === UUID_INTERNAL.toString() && (r += UUID_INTERNAL.byteLength, a = 0);
    return { type: a, payload: i.slice(r, d) };
  }
  static parseInternalSEI(e) {
    const t = /* @__PURE__ */ new Map();
    let i = 0;
    if (0 === e.type) {
      for (; e.payload.byteLength - i >= 2; ) {
        const [r, o] = deserializeData(e.payload, i);
        i = o;
        const [n, s] = deserializeData(e.payload, i);
        if (i = s, t.get(r) || !(n <= e.payload.byteLength - i)) break;
        t.set(r, e.payload.slice(i, i + n)), i += n;
      }
      return t;
    }
  }
  static makeInternalSei(e) {
    const t = [];
    for (const [i2, r2] of e) {
      const e2 = serializeData(i2), o = serializeData(r2.byteLength);
      t.push(e2, o, r2);
    }
    const i = t.reduce((e2, t2) => e2 + t2.byteLength, 0), r = new Uint8Array(i);
    return t.reduce((e2, t2) => (r.set(t2, e2), e2 + t2.byteLength), 0), r;
  }
};
_defineProperty(SEIHelper, "__uuid", void 0);
var $$h = _export;
var uncurryThis$5 = functionUncurryThis;
var toAbsoluteIndex = toAbsoluteIndex$2;
var $RangeError$1 = RangeError;
var fromCharCode$2 = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;
var join$3 = uncurryThis$5([].join);
var INCORRECT_LENGTH = !!$fromCodePoint && 1 !== $fromCodePoint.length;
$$h({ target: "String", stat: true, arity: 1, forced: INCORRECT_LENGTH }, { fromCodePoint: function(e) {
  for (var t, i = [], r = arguments.length, o = 0; r > o; ) {
    if (t = +arguments[o++], toAbsoluteIndex(t, 1114111) !== t) throw new $RangeError$1(t + " is not a valid code point");
    i[o] = t < 65536 ? fromCharCode$2(t) : fromCharCode$2(55296 + ((t -= 65536) >> 10), t % 1024 + 56320);
  }
  return join$3(i, "");
} });
var globalThis$a = globalThis_1;
var DESCRIPTORS$5 = descriptors;
var getOwnPropertyDescriptor5 = Object.getOwnPropertyDescriptor;
var safeGetBuiltIn$2 = function(e) {
  if (!DESCRIPTORS$5) return globalThis$a[e];
  var t = getOwnPropertyDescriptor5(globalThis$a, e);
  return t && t.value;
};
var fails$5 = fails$s;
var wellKnownSymbol$8 = wellKnownSymbol$q;
var DESCRIPTORS$4 = descriptors;
var IS_PURE$1 = isPure;
var ITERATOR$4 = wellKnownSymbol$8("iterator");
var urlConstructorDetection = !fails$5(function() {
  var e = new URL("b?a=1&b=2&c=3", "https://a"), t = e.searchParams, i = new URLSearchParams("a=1&a=2&b=3"), r = "";
  return e.pathname = "c%20d", t.forEach(function(e2, i2) {
    t.delete("b"), r += i2 + e2;
  }), i.delete("a", 2), i.delete("b", void 0), IS_PURE$1 && (!e.toJSON || !i.has("a", 1) || i.has("a", 2) || !i.has("a", void 0) || i.has("b")) || !t.size && (IS_PURE$1 || !DESCRIPTORS$4) || !t.sort || "https://a/c%20d?a=1&c=3" !== e.href || "3" !== t.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t[ITERATOR$4] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("https://ÑÐµÑÑ").host || "#%D0%B1" !== new URL("https://a#Ð±").hash || "a1c3" !== r || "x" !== new URL("https://x", void 0).host;
});
var defineBuiltIn$3 = defineBuiltIn$8;
var defineBuiltIns$1 = function(e, t, i) {
  for (var r in t) i && i.unsafe && e[r] ? e[r] = t[r] : defineBuiltIn$3(e, r, t[r], i);
  return e;
};
var isPrototypeOf$2 = objectIsPrototypeOf;
var $TypeError$5 = TypeError;
var anInstance$3 = function(e, t) {
  if (isPrototypeOf$2(t, e)) return e;
  throw new $TypeError$5("Incorrect invocation");
};
var classof$2 = classof$a;
var getMethod$1 = getMethod$4;
var isNullOrUndefined$1 = isNullOrUndefined$5;
var Iterators$1 = iterators;
var wellKnownSymbol$7 = wellKnownSymbol$q;
var ITERATOR$3 = wellKnownSymbol$7("iterator");
var getIteratorMethod$4 = function(e) {
  if (!isNullOrUndefined$1(e)) return getMethod$1(e, ITERATOR$3) || getMethod$1(e, "@@iterator") || Iterators$1[classof$2(e)];
};
var call$a = functionCall;
var aCallable$7 = aCallable$c;
var anObject$6 = anObject$d;
var tryToString$2 = tryToString$6;
var getIteratorMethod$3 = getIteratorMethod$4;
var $TypeError$4 = TypeError;
var getIterator$3 = function(e, t) {
  var i = arguments.length < 2 ? getIteratorMethod$3(e) : t;
  if (aCallable$7(i)) return anObject$6(call$a(i, e));
  throw new $TypeError$4(tryToString$2(e) + " is not iterable");
};
var $TypeError$3 = TypeError;
var validateArgumentsLength$5 = function(e, t) {
  if (e < t) throw new $TypeError$3("Not enough arguments");
  return e;
};
var $$g = _export;
var globalThis$9 = globalThis_1;
var safeGetBuiltIn$1 = safeGetBuiltIn$2;
var getBuiltIn$6 = getBuiltIn$h;
var call$9 = functionCall;
var uncurryThis$4 = functionUncurryThis;
var DESCRIPTORS$3 = descriptors;
var USE_NATIVE_URL$3 = urlConstructorDetection;
var defineBuiltIn$2 = defineBuiltIn$8;
var defineBuiltInAccessor$2 = defineBuiltInAccessor$4;
var defineBuiltIns = defineBuiltIns$1;
var setToStringTag$2 = setToStringTag$9;
var createIteratorConstructor = iteratorCreateConstructor;
var InternalStateModule$2 = internalState;
var anInstance$2 = anInstance$3;
var isCallable$4 = isCallable$l;
var hasOwn$3 = hasOwnProperty_1;
var bind$6 = functionBindContext;
var classof$1 = classof$a;
var anObject$5 = anObject$d;
var isObject$3 = isObject$g;
var $toString$1 = toString$e;
var create$1 = objectCreate;
var createPropertyDescriptor$2 = createPropertyDescriptor$8;
var getIterator$2 = getIterator$3;
var getIteratorMethod$2 = getIteratorMethod$4;
var createIterResultObject = createIterResultObject$3;
var validateArgumentsLength$4 = validateArgumentsLength$5;
var wellKnownSymbol$6 = wellKnownSymbol$q;
var arraySort = arraySort$1;
var ITERATOR$2 = wellKnownSymbol$6("iterator");
var URL_SEARCH_PARAMS = "URLSearchParams";
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
var setInternalState$2 = InternalStateModule$2.set;
var getInternalParamsState = InternalStateModule$2.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule$2.getterFor(URL_SEARCH_PARAMS_ITERATOR);
var nativeFetch = safeGetBuiltIn$1("fetch");
var NativeRequest = safeGetBuiltIn$1("Request");
var Headers = safeGetBuiltIn$1("Headers");
var RequestPrototype = NativeRequest && NativeRequest.prototype;
var HeadersPrototype = Headers && Headers.prototype;
var TypeError$3 = globalThis$9.TypeError;
var encodeURIComponent$1 = globalThis$9.encodeURIComponent;
var fromCharCode$1 = String.fromCharCode;
var fromCodePoint2 = getBuiltIn$6("String", "fromCodePoint");
var $parseInt = parseInt;
var charAt$1 = uncurryThis$4("".charAt);
var join$2 = uncurryThis$4([].join);
var push$3 = uncurryThis$4([].push);
var replace$3 = uncurryThis$4("".replace);
var shift$1 = uncurryThis$4([].shift);
var splice = uncurryThis$4([].splice);
var split$2 = uncurryThis$4("".split);
var stringSlice$1 = uncurryThis$4("".slice);
var exec$2 = uncurryThis$4(/./.exec);
var plus = /\+/g;
var FALLBACK_REPLACER = "ï¿½";
var VALID_HEX = /^[0-9a-f]+$/i;
var parseHexOctet = function(e, t) {
  var i = stringSlice$1(e, t, t + 2);
  return exec$2(VALID_HEX, i) ? $parseInt(i, 16) : NaN;
};
var getLeadingOnes = function(e) {
  for (var t = 0, i = 128; i > 0 && e & i; i >>= 1) t++;
  return t;
};
var utf8Decode = function(e) {
  var t = null;
  switch (e.length) {
    case 1:
      t = e[0];
      break;
    case 2:
      t = (31 & e[0]) << 6 | 63 & e[1];
      break;
    case 3:
      t = (15 & e[0]) << 12 | (63 & e[1]) << 6 | 63 & e[2];
      break;
    case 4:
      t = (7 & e[0]) << 18 | (63 & e[1]) << 12 | (63 & e[2]) << 6 | 63 & e[3];
  }
  return t > 1114111 ? null : t;
};
var decode = function(e) {
  for (var t = (e = replace$3(e, plus, " ")).length, i = "", r = 0; r < t; ) {
    var o = charAt$1(e, r);
    if ("%" === o) {
      if ("%" === charAt$1(e, r + 1) || r + 3 > t) {
        i += "%", r++;
        continue;
      }
      var n = parseHexOctet(e, r + 1);
      if (n != n) {
        i += o, r++;
        continue;
      }
      r += 2;
      var s = getLeadingOnes(n);
      if (0 === s) o = fromCharCode$1(n);
      else {
        if (1 === s || s > 4) {
          i += FALLBACK_REPLACER, r++;
          continue;
        }
        for (var a = [n], d = 1; d < s && !(++r + 3 > t || "%" !== charAt$1(e, r)); ) {
          var c2 = parseHexOctet(e, r + 1);
          if (c2 != c2) {
            r += 3;
            break;
          }
          if (c2 > 191 || c2 < 128) break;
          push$3(a, c2), r += 2, d++;
        }
        if (a.length !== s) {
          i += FALLBACK_REPLACER;
          continue;
        }
        var l = utf8Decode(a);
        null === l ? i += FALLBACK_REPLACER : o = fromCodePoint2(l);
      }
    }
    i += o, r++;
  }
  return i;
};
var find = /[!'()~]|%20/g;
var replacements = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" };
var replacer = function(e) {
  return replacements[e];
};
var serialize = function(e) {
  return replace$3(encodeURIComponent$1(e), find, replacer);
};
var URLSearchParamsIterator = createIteratorConstructor(function(e, t) {
  setInternalState$2(this, { type: URL_SEARCH_PARAMS_ITERATOR, target: getInternalParamsState(e).entries, index: 0, kind: t });
}, URL_SEARCH_PARAMS, function() {
  var e = getInternalIteratorState(this), t = e.target, i = e.index++;
  if (!t || i >= t.length) return e.target = null, createIterResultObject(void 0, true);
  var r = t[i];
  switch (e.kind) {
    case "keys":
      return createIterResultObject(r.key, false);
    case "values":
      return createIterResultObject(r.value, false);
  }
  return createIterResultObject([r.key, r.value], false);
}, true);
var URLSearchParamsState = function(e) {
  this.entries = [], this.url = null, void 0 !== e && (isObject$3(e) ? this.parseObject(e) : this.parseQuery("string" == typeof e ? "?" === charAt$1(e, 0) ? stringSlice$1(e, 1) : e : $toString$1(e)));
};
URLSearchParamsState.prototype = { type: URL_SEARCH_PARAMS, bindURL: function(e) {
  this.url = e, this.update();
}, parseObject: function(e) {
  var t, i, r, o, n, s, a, d = this.entries, c2 = getIteratorMethod$2(e);
  if (c2) for (i = (t = getIterator$2(e, c2)).next; !(r = call$9(i, t)).done; ) {
    if (n = (o = getIterator$2(anObject$5(r.value))).next, (s = call$9(n, o)).done || (a = call$9(n, o)).done || !call$9(n, o).done) throw new TypeError$3("Expected sequence with length 2");
    push$3(d, { key: $toString$1(s.value), value: $toString$1(a.value) });
  }
  else for (var l in e) hasOwn$3(e, l) && push$3(d, { key: l, value: $toString$1(e[l]) });
}, parseQuery: function(e) {
  if (e) for (var t, i, r = this.entries, o = split$2(e, "&"), n = 0; n < o.length; ) (t = o[n++]).length && (i = split$2(t, "="), push$3(r, { key: decode(shift$1(i)), value: decode(join$2(i, "=")) }));
}, serialize: function() {
  for (var e, t = this.entries, i = [], r = 0; r < t.length; ) e = t[r++], push$3(i, serialize(e.key) + "=" + serialize(e.value));
  return join$2(i, "&");
}, update: function() {
  this.entries.length = 0, this.parseQuery(this.url.query);
}, updateURL: function() {
  this.url && this.url.update();
} };
var URLSearchParamsConstructor = function() {
  anInstance$2(this, URLSearchParamsPrototype);
  var e = setInternalState$2(this, new URLSearchParamsState(arguments.length > 0 ? arguments[0] : void 0));
  DESCRIPTORS$3 || (this.size = e.entries.length);
};
var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
if (defineBuiltIns(URLSearchParamsPrototype, { append: function(e, t) {
  var i = getInternalParamsState(this);
  validateArgumentsLength$4(arguments.length, 2), push$3(i.entries, { key: $toString$1(e), value: $toString$1(t) }), DESCRIPTORS$3 || this.length++, i.updateURL();
}, delete: function(e) {
  for (var t = getInternalParamsState(this), i = validateArgumentsLength$4(arguments.length, 1), r = t.entries, o = $toString$1(e), n = i < 2 ? void 0 : arguments[1], s = void 0 === n ? n : $toString$1(n), a = 0; a < r.length; ) {
    var d = r[a];
    if (d.key !== o || void 0 !== s && d.value !== s) a++;
    else if (splice(r, a, 1), void 0 !== s) break;
  }
  DESCRIPTORS$3 || (this.size = r.length), t.updateURL();
}, get: function(e) {
  var t = getInternalParamsState(this).entries;
  validateArgumentsLength$4(arguments.length, 1);
  for (var i = $toString$1(e), r = 0; r < t.length; r++) if (t[r].key === i) return t[r].value;
  return null;
}, getAll: function(e) {
  var t = getInternalParamsState(this).entries;
  validateArgumentsLength$4(arguments.length, 1);
  for (var i = $toString$1(e), r = [], o = 0; o < t.length; o++) t[o].key === i && push$3(r, t[o].value);
  return r;
}, has: function(e) {
  for (var t = getInternalParamsState(this).entries, i = validateArgumentsLength$4(arguments.length, 1), r = $toString$1(e), o = i < 2 ? void 0 : arguments[1], n = void 0 === o ? o : $toString$1(o), s = 0; s < t.length; ) {
    var a = t[s++];
    if (a.key === r && (void 0 === n || a.value === n)) return true;
  }
  return false;
}, set: function(e, t) {
  var i = getInternalParamsState(this);
  validateArgumentsLength$4(arguments.length, 1);
  for (var r, o = i.entries, n = false, s = $toString$1(e), a = $toString$1(t), d = 0; d < o.length; d++) (r = o[d]).key === s && (n ? splice(o, d--, 1) : (n = true, r.value = a));
  n || push$3(o, { key: s, value: a }), DESCRIPTORS$3 || (this.size = o.length), i.updateURL();
}, sort: function() {
  var e = getInternalParamsState(this);
  arraySort(e.entries, function(e2, t) {
    return e2.key > t.key ? 1 : -1;
  }), e.updateURL();
}, forEach: function(e) {
  for (var t, i = getInternalParamsState(this).entries, r = bind$6(e, arguments.length > 1 ? arguments[1] : void 0), o = 0; o < i.length; ) r((t = i[o++]).value, t.key, this);
}, keys: function() {
  return new URLSearchParamsIterator(this, "keys");
}, values: function() {
  return new URLSearchParamsIterator(this, "values");
}, entries: function() {
  return new URLSearchParamsIterator(this, "entries");
} }, { enumerable: true }), defineBuiltIn$2(URLSearchParamsPrototype, ITERATOR$2, URLSearchParamsPrototype.entries, { name: "entries" }), defineBuiltIn$2(URLSearchParamsPrototype, "toString", function() {
  return getInternalParamsState(this).serialize();
}, { enumerable: true }), DESCRIPTORS$3 && defineBuiltInAccessor$2(URLSearchParamsPrototype, "size", { get: function() {
  return getInternalParamsState(this).entries.length;
}, configurable: true, enumerable: true }), setToStringTag$2(URLSearchParamsConstructor, URL_SEARCH_PARAMS), $$g({ global: true, constructor: true, forced: !USE_NATIVE_URL$3 }, { URLSearchParams: URLSearchParamsConstructor }), !USE_NATIVE_URL$3 && isCallable$4(Headers)) {
  headersHas = uncurryThis$4(HeadersPrototype.has), headersSet = uncurryThis$4(HeadersPrototype.set), wrapRequestOptions = function(e) {
    if (isObject$3(e)) {
      var t, i = e.body;
      if (classof$1(i) === URL_SEARCH_PARAMS) return t = e.headers ? new Headers(e.headers) : new Headers(), headersHas(t, "content-type") || headersSet(t, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), create$1(e, { body: createPropertyDescriptor$2(0, $toString$1(i)), headers: createPropertyDescriptor$2(0, t) });
    }
    return e;
  };
  if (isCallable$4(nativeFetch) && $$g({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, { fetch: function(e) {
    return nativeFetch(e, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
  } }), isCallable$4(NativeRequest)) {
    RequestConstructor = function(e) {
      return anInstance$2(this, RequestPrototype), new NativeRequest(e, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
    };
    RequestPrototype.constructor = RequestConstructor, RequestConstructor.prototype = RequestPrototype, $$g({ global: true, constructor: true, dontCallGetSet: true, forced: true }, { Request: RequestConstructor });
  }
}
var headersHas;
var headersSet;
var wrapRequestOptions;
var RequestConstructor;
var EOF;
var web_urlSearchParams_constructor = { URLSearchParams: URLSearchParamsConstructor, getState: getInternalParamsState };
var DESCRIPTORS$2 = descriptors;
var uncurryThis$3 = functionUncurryThis;
var call$8 = functionCall;
var fails$4 = fails$s;
var objectKeys = objectKeys$3;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject$1 = toObject$c;
var IndexedObject = indexedObject;
var $assign = Object.assign;
var defineProperty5 = Object.defineProperty;
var concat2 = uncurryThis$3([].concat);
var objectAssign = !$assign || fails$4(function() {
  if (DESCRIPTORS$2 && 1 !== $assign({ b: 1 }, $assign(defineProperty5({}, "a", { enumerable: true, get: function() {
    defineProperty5(this, "b", { value: 3, enumerable: false });
  } }), { b: 2 })).b) return true;
  var e = {}, t = {}, i = Symbol("assign detection"), r = "abcdefghijklmnopqrst";
  return e[i] = 7, r.split("").forEach(function(e2) {
    t[e2] = e2;
  }), 7 !== $assign({}, e)[i] || objectKeys($assign({}, t)).join("") !== r;
}) ? function(e, t) {
  for (var i = toObject$1(e), r = arguments.length, o = 1, n = getOwnPropertySymbolsModule.f, s = propertyIsEnumerableModule.f; r > o; ) for (var a, d = IndexedObject(arguments[o++]), c2 = n ? concat2(objectKeys(d), n(d)) : objectKeys(d), l = c2.length, u = 0; l > u; ) a = c2[u++], DESCRIPTORS$2 && !call$8(s, d, a) || (i[a] = d[a]);
  return i;
} : $assign;
var call$7 = functionCall;
var anObject$4 = anObject$d;
var getMethod = getMethod$4;
var iteratorClose$2 = function(e, t, i) {
  var r, o;
  anObject$4(e);
  try {
    if (!(r = getMethod(e, "return"))) {
      if ("throw" === t) throw i;
      return i;
    }
    r = call$7(r, e);
  } catch (e2) {
    o = true, r = e2;
  }
  if ("throw" === t) throw i;
  if (o) throw r;
  return anObject$4(r), i;
};
var anObject$3 = anObject$d;
var iteratorClose$1 = iteratorClose$2;
var callWithSafeIterationClosing$1 = function(e, t, i, r) {
  try {
    return r ? t(anObject$3(i)[0], i[1]) : t(i);
  } catch (t2) {
    iteratorClose$1(e, "throw", t2);
  }
};
var wellKnownSymbol$5 = wellKnownSymbol$q;
var Iterators = iterators;
var ITERATOR$1 = wellKnownSymbol$5("iterator");
var ArrayPrototype = Array.prototype;
var isArrayIteratorMethod$2 = function(e) {
  return void 0 !== e && (Iterators.Array === e || ArrayPrototype[ITERATOR$1] === e);
};
var bind$5 = functionBindContext;
var call$6 = functionCall;
var toObject = toObject$c;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod$1 = isArrayIteratorMethod$2;
var isConstructor$1 = isConstructor$3;
var lengthOfArrayLike$1 = lengthOfArrayLike$9;
var createProperty$1 = createProperty$4;
var getIterator$1 = getIterator$3;
var getIteratorMethod$1 = getIteratorMethod$4;
var $Array = Array;
var arrayFrom$1 = function(e) {
  var t = toObject(e), i = isConstructor$1(this), r = arguments.length, o = r > 1 ? arguments[1] : void 0, n = void 0 !== o;
  n && (o = bind$5(o, r > 2 ? arguments[2] : void 0));
  var s, a, d, c2, l, u, h = getIteratorMethod$1(t), _ = 0;
  if (!h || this === $Array && isArrayIteratorMethod$1(h)) for (s = lengthOfArrayLike$1(t), a = i ? new this(s) : $Array(s); s > _; _++) u = n ? o(t[_], _) : t[_], createProperty$1(a, _, u);
  else for (a = i ? new this() : [], l = (c2 = getIterator$1(t, h)).next; !(d = call$6(l, c2)).done; _++) u = n ? callWithSafeIterationClosing(c2, o, [d.value, _], true) : d.value, createProperty$1(a, _, u);
  return a.length = _, a;
};
var uncurryThis$2 = functionUncurryThis;
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexNonASCII = /[^\0-\u007E]/;
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
var baseMinusTMin = base - tMin;
var $RangeError = RangeError;
var exec$1 = uncurryThis$2(regexSeparators.exec);
var floor$1 = Math.floor;
var fromCharCode = String.fromCharCode;
var charCodeAt = uncurryThis$2("".charCodeAt);
var join$1 = uncurryThis$2([].join);
var push$2 = uncurryThis$2([].push);
var replace$2 = uncurryThis$2("".replace);
var split$1 = uncurryThis$2("".split);
var toLowerCase$1 = uncurryThis$2("".toLowerCase);
var ucs2decode = function(e) {
  for (var t = [], i = 0, r = e.length; i < r; ) {
    var o = charCodeAt(e, i++);
    if (o >= 55296 && o <= 56319 && i < r) {
      var n = charCodeAt(e, i++);
      56320 == (64512 & n) ? push$2(t, ((1023 & o) << 10) + (1023 & n) + 65536) : (push$2(t, o), i--);
    } else push$2(t, o);
  }
  return t;
};
var digitToBasic = function(e) {
  return e + 22 + 75 * (e < 26);
};
var adapt = function(e, t, i) {
  var r = 0;
  for (e = i ? floor$1(e / damp) : e >> 1, e += floor$1(e / t); e > baseMinusTMin * tMax >> 1; ) e = floor$1(e / baseMinusTMin), r += base;
  return floor$1(r + (baseMinusTMin + 1) * e / (e + skew));
};
var encode = function(e) {
  var t, i, r = [], o = (e = ucs2decode(e)).length, n = initialN, s = 0, a = initialBias;
  for (t = 0; t < e.length; t++) (i = e[t]) < 128 && push$2(r, fromCharCode(i));
  var d = r.length, c2 = d;
  for (d && push$2(r, delimiter); c2 < o; ) {
    var l = maxInt;
    for (t = 0; t < e.length; t++) (i = e[t]) >= n && i < l && (l = i);
    var u = c2 + 1;
    if (l - n > floor$1((maxInt - s) / u)) throw new $RangeError(OVERFLOW_ERROR);
    for (s += (l - n) * u, n = l, t = 0; t < e.length; t++) {
      if ((i = e[t]) < n && ++s > maxInt) throw new $RangeError(OVERFLOW_ERROR);
      if (i === n) {
        for (var h = s, _ = base; ; ) {
          var p = _ <= a ? tMin : _ >= a + tMax ? tMax : _ - a;
          if (h < p) break;
          var m = h - p, S = base - p;
          push$2(r, fromCharCode(digitToBasic(p + m % S))), h = floor$1(m / S), _ += base;
        }
        push$2(r, fromCharCode(digitToBasic(h))), a = adapt(s, u, c2 === d), s = 0, c2++;
      }
    }
    s++, n++;
  }
  return join$1(r, "");
};
var stringPunycodeToAscii = function(e) {
  var t, i, r = [], o = split$1(replace$2(toLowerCase$1(e), regexSeparators, "."), ".");
  for (t = 0; t < o.length; t++) i = o[t], push$2(r, exec$1(regexNonASCII, i) ? "xn--" + encode(i) : i);
  return join$1(r, ".");
};
var $$f = _export;
var DESCRIPTORS$1 = descriptors;
var USE_NATIVE_URL$2 = urlConstructorDetection;
var globalThis$8 = globalThis_1;
var bind$4 = functionBindContext;
var uncurryThis$1 = functionUncurryThis;
var defineBuiltIn$1 = defineBuiltIn$8;
var defineBuiltInAccessor$1 = defineBuiltInAccessor$4;
var anInstance$1 = anInstance$3;
var hasOwn$2 = hasOwnProperty_1;
var assign2 = objectAssign;
var arrayFrom = arrayFrom$1;
var arraySlice$1 = arraySlice$5;
var codeAt = stringMultibyte.codeAt;
var toASCII = stringPunycodeToAscii;
var $toString = toString$e;
var setToStringTag$1 = setToStringTag$9;
var validateArgumentsLength$3 = validateArgumentsLength$5;
var URLSearchParamsModule = web_urlSearchParams_constructor;
var InternalStateModule$1 = internalState;
var setInternalState$1 = InternalStateModule$1.set;
var getInternalURLState = InternalStateModule$1.getterFor("URL");
var URLSearchParams$1 = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var NativeURL = globalThis$8.URL;
var TypeError$2 = globalThis$8.TypeError;
var parseInt$1 = globalThis$8.parseInt;
var floor = Math.floor;
var pow = Math.pow;
var charAt = uncurryThis$1("".charAt);
var exec = uncurryThis$1(/./.exec);
var join = uncurryThis$1([].join);
var numberToString = uncurryThis$1(1 .toString);
var pop = uncurryThis$1([].pop);
var push$1 = uncurryThis$1([].push);
var replace$1 = uncurryThis$1("".replace);
var shift = uncurryThis$1([].shift);
var split = uncurryThis$1("".split);
var stringSlice = uncurryThis$1("".slice);
var toLowerCase = uncurryThis$1("".toLowerCase);
var unshift = uncurryThis$1([].unshift);
var INVALID_AUTHORITY = "Invalid authority";
var INVALID_SCHEME = "Invalid scheme";
var INVALID_HOST = "Invalid host";
var INVALID_PORT = "Invalid port";
var ALPHA = /[a-z]/i;
var ALPHANUMERIC = /[\d+-.a-z]/i;
var DIGIT = /\d/;
var HEX_START = /^0x/i;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\da-f]+$/i;
var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
var TAB_AND_NEW_LINE = /[\t\n\r]/g;
var parseIPv4 = function(e) {
  var t, i, r, o, n, s, a, d = split(e, ".");
  if (d.length && "" === d[d.length - 1] && d.length--, (t = d.length) > 4) return e;
  for (i = [], r = 0; r < t; r++) {
    if ("" === (o = d[r])) return e;
    if (n = 10, o.length > 1 && "0" === charAt(o, 0) && (n = exec(HEX_START, o) ? 16 : 8, o = stringSlice(o, 8 === n ? 1 : 2)), "" === o) s = 0;
    else {
      if (!exec(10 === n ? DEC : 8 === n ? OCT : HEX, o)) return e;
      s = parseInt$1(o, n);
    }
    push$1(i, s);
  }
  for (r = 0; r < t; r++) if (s = i[r], r === t - 1) {
    if (s >= pow(256, 5 - t)) return null;
  } else if (s > 255) return null;
  for (a = pop(i), r = 0; r < i.length; r++) a += i[r] * pow(256, 3 - r);
  return a;
};
var parseIPv6 = function(e) {
  var t, i, r, o, n, s, a, d = [0, 0, 0, 0, 0, 0, 0, 0], c2 = 0, l = null, u = 0, h = function() {
    return charAt(e, u);
  };
  if (":" === h()) {
    if (":" !== charAt(e, 1)) return;
    u += 2, l = ++c2;
  }
  for (; h(); ) {
    if (8 === c2) return;
    if (":" !== h()) {
      for (t = i = 0; i < 4 && exec(HEX, h()); ) t = 16 * t + parseInt$1(h(), 16), u++, i++;
      if ("." === h()) {
        if (0 === i) return;
        if (u -= i, c2 > 6) return;
        for (r = 0; h(); ) {
          if (o = null, r > 0) {
            if (!("." === h() && r < 4)) return;
            u++;
          }
          if (!exec(DIGIT, h())) return;
          for (; exec(DIGIT, h()); ) {
            if (n = parseInt$1(h(), 10), null === o) o = n;
            else {
              if (0 === o) return;
              o = 10 * o + n;
            }
            if (o > 255) return;
            u++;
          }
          d[c2] = 256 * d[c2] + o, 2 !== ++r && 4 !== r || c2++;
        }
        if (4 !== r) return;
        break;
      }
      if (":" === h()) {
        if (u++, !h()) return;
      } else if (h()) return;
      d[c2++] = t;
    } else {
      if (null !== l) return;
      u++, l = ++c2;
    }
  }
  if (null !== l) for (s = c2 - l, c2 = 7; 0 !== c2 && s > 0; ) a = d[c2], d[c2--] = d[l + s - 1], d[l + --s] = a;
  else if (8 !== c2) return;
  return d;
};
var findLongestZeroSequence = function(e) {
  for (var t = null, i = 1, r = null, o = 0, n = 0; n < 8; n++) 0 !== e[n] ? (o > i && (t = r, i = o), r = null, o = 0) : (null === r && (r = n), ++o);
  return o > i ? r : t;
};
var serializeHost = function(e) {
  var t, i, r, o;
  if ("number" == typeof e) {
    for (t = [], i = 0; i < 4; i++) unshift(t, e % 256), e = floor(e / 256);
    return join(t, ".");
  }
  if ("object" == typeof e) {
    for (t = "", r = findLongestZeroSequence(e), i = 0; i < 8; i++) o && 0 === e[i] || (o && (o = false), r === i ? (t += i ? ":" : "::", o = true) : (t += numberToString(e[i], 16), i < 7 && (t += ":")));
    return "[" + t + "]";
  }
  return e;
};
var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign2({}, C0ControlPercentEncodeSet, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 });
var pathPercentEncodeSet = assign2({}, fragmentPercentEncodeSet, { "#": 1, "?": 1, "{": 1, "}": 1 });
var userinfoPercentEncodeSet = assign2({}, pathPercentEncodeSet, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 });
var percentEncode = function(e, t) {
  var i = codeAt(e, 0);
  return i > 32 && i < 127 && !hasOwn$2(t, e) ? e : encodeURIComponent(e);
};
var specialSchemes = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 };
var isWindowsDriveLetter = function(e, t) {
  var i;
  return 2 === e.length && exec(ALPHA, charAt(e, 0)) && (":" === (i = charAt(e, 1)) || !t && "|" === i);
};
var startsWithWindowsDriveLetter = function(e) {
  var t;
  return e.length > 1 && isWindowsDriveLetter(stringSlice(e, 0, 2)) && (2 === e.length || "/" === (t = charAt(e, 2)) || "\\" === t || "?" === t || "#" === t);
};
var isSingleDot = function(e) {
  return "." === e || "%2e" === toLowerCase(e);
};
var isDoubleDot = function(e) {
  return ".." === (e = toLowerCase(e)) || "%2e." === e || ".%2e" === e || "%2e%2e" === e;
};
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};
var URLState = function(e, t, i) {
  var r, o, n, s = $toString(e);
  if (t) {
    if (o = this.parse(s)) throw new TypeError$2(o);
    this.searchParams = null;
  } else {
    if (void 0 !== i && (r = new URLState(i, true)), o = this.parse(s, null, r)) throw new TypeError$2(o);
    (n = getInternalSearchParamsState(new URLSearchParams$1())).bindURL(this), this.searchParams = n;
  }
};
URLState.prototype = { type: "URL", parse: function(e, t, i) {
  var r, o, n, s, a = this, d = t || SCHEME_START, c2 = 0, l = "", u = false, h = false, _ = false;
  for (e = $toString(e), t || (a.scheme = "", a.username = "", a.password = "", a.host = null, a.port = null, a.path = [], a.query = null, a.fragment = null, a.cannotBeABaseURL = false, e = replace$1(e, LEADING_C0_CONTROL_OR_SPACE, ""), e = replace$1(e, TRAILING_C0_CONTROL_OR_SPACE, "$1")), e = replace$1(e, TAB_AND_NEW_LINE, ""), r = arrayFrom(e); c2 <= r.length; ) {
    switch (o = r[c2], d) {
      case SCHEME_START:
        if (!o || !exec(ALPHA, o)) {
          if (t) return INVALID_SCHEME;
          d = NO_SCHEME;
          continue;
        }
        l += toLowerCase(o), d = SCHEME;
        break;
      case SCHEME:
        if (o && (exec(ALPHANUMERIC, o) || "+" === o || "-" === o || "." === o)) l += toLowerCase(o);
        else {
          if (":" !== o) {
            if (t) return INVALID_SCHEME;
            l = "", d = NO_SCHEME, c2 = 0;
            continue;
          }
          if (t && (a.isSpecial() !== hasOwn$2(specialSchemes, l) || "file" === l && (a.includesCredentials() || null !== a.port) || "file" === a.scheme && !a.host)) return;
          if (a.scheme = l, t) return void (a.isSpecial() && specialSchemes[a.scheme] === a.port && (a.port = null));
          l = "", "file" === a.scheme ? d = FILE : a.isSpecial() && i && i.scheme === a.scheme ? d = SPECIAL_RELATIVE_OR_AUTHORITY : a.isSpecial() ? d = SPECIAL_AUTHORITY_SLASHES : "/" === r[c2 + 1] ? (d = PATH_OR_AUTHORITY, c2++) : (a.cannotBeABaseURL = true, push$1(a.path, ""), d = CANNOT_BE_A_BASE_URL_PATH);
        }
        break;
      case NO_SCHEME:
        if (!i || i.cannotBeABaseURL && "#" !== o) return INVALID_SCHEME;
        if (i.cannotBeABaseURL && "#" === o) {
          a.scheme = i.scheme, a.path = arraySlice$1(i.path), a.query = i.query, a.fragment = "", a.cannotBeABaseURL = true, d = FRAGMENT;
          break;
        }
        d = "file" === i.scheme ? FILE : RELATIVE;
        continue;
      case SPECIAL_RELATIVE_OR_AUTHORITY:
        if ("/" !== o || "/" !== r[c2 + 1]) {
          d = RELATIVE;
          continue;
        }
        d = SPECIAL_AUTHORITY_IGNORE_SLASHES, c2++;
        break;
      case PATH_OR_AUTHORITY:
        if ("/" === o) {
          d = AUTHORITY;
          break;
        }
        d = PATH;
        continue;
      case RELATIVE:
        if (a.scheme = i.scheme, o === EOF) a.username = i.username, a.password = i.password, a.host = i.host, a.port = i.port, a.path = arraySlice$1(i.path), a.query = i.query;
        else if ("/" === o || "\\" === o && a.isSpecial()) d = RELATIVE_SLASH;
        else if ("?" === o) a.username = i.username, a.password = i.password, a.host = i.host, a.port = i.port, a.path = arraySlice$1(i.path), a.query = "", d = QUERY;
        else {
          if ("#" !== o) {
            a.username = i.username, a.password = i.password, a.host = i.host, a.port = i.port, a.path = arraySlice$1(i.path), a.path.length--, d = PATH;
            continue;
          }
          a.username = i.username, a.password = i.password, a.host = i.host, a.port = i.port, a.path = arraySlice$1(i.path), a.query = i.query, a.fragment = "", d = FRAGMENT;
        }
        break;
      case RELATIVE_SLASH:
        if (!a.isSpecial() || "/" !== o && "\\" !== o) {
          if ("/" !== o) {
            a.username = i.username, a.password = i.password, a.host = i.host, a.port = i.port, d = PATH;
            continue;
          }
          d = AUTHORITY;
        } else d = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        break;
      case SPECIAL_AUTHORITY_SLASHES:
        if (d = SPECIAL_AUTHORITY_IGNORE_SLASHES, "/" !== o || "/" !== charAt(l, c2 + 1)) continue;
        c2++;
        break;
      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
        if ("/" !== o && "\\" !== o) {
          d = AUTHORITY;
          continue;
        }
        break;
      case AUTHORITY:
        if ("@" === o) {
          u && (l = "%40" + l), u = true, n = arrayFrom(l);
          for (var p = 0; p < n.length; p++) {
            var m = n[p];
            if (":" !== m || _) {
              var S = percentEncode(m, userinfoPercentEncodeSet);
              _ ? a.password += S : a.username += S;
            } else _ = true;
          }
          l = "";
        } else if (o === EOF || "/" === o || "?" === o || "#" === o || "\\" === o && a.isSpecial()) {
          if (u && "" === l) return INVALID_AUTHORITY;
          c2 -= arrayFrom(l).length + 1, l = "", d = HOST;
        } else l += o;
        break;
      case HOST:
      case HOSTNAME:
        if (t && "file" === a.scheme) {
          d = FILE_HOST;
          continue;
        }
        if (":" !== o || h) {
          if (o === EOF || "/" === o || "?" === o || "#" === o || "\\" === o && a.isSpecial()) {
            if (a.isSpecial() && "" === l) return INVALID_HOST;
            if (t && "" === l && (a.includesCredentials() || null !== a.port)) return;
            if (s = a.parseHost(l)) return s;
            if (l = "", d = PATH_START, t) return;
            continue;
          }
          "[" === o ? h = true : "]" === o && (h = false), l += o;
        } else {
          if ("" === l) return INVALID_HOST;
          if (s = a.parseHost(l)) return s;
          if (l = "", d = PORT, t === HOSTNAME) return;
        }
        break;
      case PORT:
        if (!exec(DIGIT, o)) {
          if (o === EOF || "/" === o || "?" === o || "#" === o || "\\" === o && a.isSpecial() || t) {
            if ("" !== l) {
              var g = parseInt$1(l, 10);
              if (g > 65535) return INVALID_PORT;
              a.port = a.isSpecial() && g === specialSchemes[a.scheme] ? null : g, l = "";
            }
            if (t) return;
            d = PATH_START;
            continue;
          }
          return INVALID_PORT;
        }
        l += o;
        break;
      case FILE:
        if (a.scheme = "file", "/" === o || "\\" === o) d = FILE_SLASH;
        else {
          if (!i || "file" !== i.scheme) {
            d = PATH;
            continue;
          }
          switch (o) {
            case EOF:
              a.host = i.host, a.path = arraySlice$1(i.path), a.query = i.query;
              break;
            case "?":
              a.host = i.host, a.path = arraySlice$1(i.path), a.query = "", d = QUERY;
              break;
            case "#":
              a.host = i.host, a.path = arraySlice$1(i.path), a.query = i.query, a.fragment = "", d = FRAGMENT;
              break;
            default:
              startsWithWindowsDriveLetter(join(arraySlice$1(r, c2), "")) || (a.host = i.host, a.path = arraySlice$1(i.path), a.shortenPath()), d = PATH;
              continue;
          }
        }
        break;
      case FILE_SLASH:
        if ("/" === o || "\\" === o) {
          d = FILE_HOST;
          break;
        }
        i && "file" === i.scheme && !startsWithWindowsDriveLetter(join(arraySlice$1(r, c2), "")) && (isWindowsDriveLetter(i.path[0], true) ? push$1(a.path, i.path[0]) : a.host = i.host), d = PATH;
        continue;
      case FILE_HOST:
        if (o === EOF || "/" === o || "\\" === o || "?" === o || "#" === o) {
          if (!t && isWindowsDriveLetter(l)) d = PATH;
          else if ("" === l) {
            if (a.host = "", t) return;
            d = PATH_START;
          } else {
            if (s = a.parseHost(l)) return s;
            if ("localhost" === a.host && (a.host = ""), t) return;
            l = "", d = PATH_START;
          }
          continue;
        }
        l += o;
        break;
      case PATH_START:
        if (a.isSpecial()) {
          if (d = PATH, "/" !== o && "\\" !== o) continue;
        } else if (t || "?" !== o) if (t || "#" !== o) {
          if (o !== EOF && (d = PATH, "/" !== o)) continue;
        } else a.fragment = "", d = FRAGMENT;
        else a.query = "", d = QUERY;
        break;
      case PATH:
        if (o === EOF || "/" === o || "\\" === o && a.isSpecial() || !t && ("?" === o || "#" === o)) {
          if (isDoubleDot(l) ? (a.shortenPath(), "/" === o || "\\" === o && a.isSpecial() || push$1(a.path, "")) : isSingleDot(l) ? "/" === o || "\\" === o && a.isSpecial() || push$1(a.path, "") : ("file" === a.scheme && !a.path.length && isWindowsDriveLetter(l) && (a.host && (a.host = ""), l = charAt(l, 0) + ":"), push$1(a.path, l)), l = "", "file" === a.scheme && (o === EOF || "?" === o || "#" === o)) for (; a.path.length > 1 && "" === a.path[0]; ) shift(a.path);
          "?" === o ? (a.query = "", d = QUERY) : "#" === o && (a.fragment = "", d = FRAGMENT);
        } else l += percentEncode(o, pathPercentEncodeSet);
        break;
      case CANNOT_BE_A_BASE_URL_PATH:
        "?" === o ? (a.query = "", d = QUERY) : "#" === o ? (a.fragment = "", d = FRAGMENT) : o !== EOF && (a.path[0] += percentEncode(o, C0ControlPercentEncodeSet));
        break;
      case QUERY:
        t || "#" !== o ? o !== EOF && ("'" === o && a.isSpecial() ? a.query += "%27" : a.query += "#" === o ? "%23" : percentEncode(o, C0ControlPercentEncodeSet)) : (a.fragment = "", d = FRAGMENT);
        break;
      case FRAGMENT:
        o !== EOF && (a.fragment += percentEncode(o, fragmentPercentEncodeSet));
    }
    c2++;
  }
}, parseHost: function(e) {
  var t, i, r;
  if ("[" === charAt(e, 0)) {
    if ("]" !== charAt(e, e.length - 1)) return INVALID_HOST;
    if (!(t = parseIPv6(stringSlice(e, 1, -1)))) return INVALID_HOST;
    this.host = t;
  } else if (this.isSpecial()) {
    if (e = toASCII(e), exec(FORBIDDEN_HOST_CODE_POINT, e)) return INVALID_HOST;
    if (null === (t = parseIPv4(e))) return INVALID_HOST;
    this.host = t;
  } else {
    if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, e)) return INVALID_HOST;
    for (t = "", i = arrayFrom(e), r = 0; r < i.length; r++) t += percentEncode(i[r], C0ControlPercentEncodeSet);
    this.host = t;
  }
}, cannotHaveUsernamePasswordPort: function() {
  return !this.host || this.cannotBeABaseURL || "file" === this.scheme;
}, includesCredentials: function() {
  return "" !== this.username || "" !== this.password;
}, isSpecial: function() {
  return hasOwn$2(specialSchemes, this.scheme);
}, shortenPath: function() {
  var e = this.path, t = e.length;
  !t || "file" === this.scheme && 1 === t && isWindowsDriveLetter(e[0], true) || e.length--;
}, serialize: function() {
  var e = this, t = e.scheme, i = e.username, r = e.password, o = e.host, n = e.port, s = e.path, a = e.query, d = e.fragment, c2 = t + ":";
  return null !== o ? (c2 += "//", e.includesCredentials() && (c2 += i + (r ? ":" + r : "") + "@"), c2 += serializeHost(o), null !== n && (c2 += ":" + n)) : "file" === t && (c2 += "//"), c2 += e.cannotBeABaseURL ? s[0] : s.length ? "/" + join(s, "/") : "", null !== a && (c2 += "?" + a), null !== d && (c2 += "#" + d), c2;
}, setHref: function(e) {
  var t = this.parse(e);
  if (t) throw new TypeError$2(t);
  this.searchParams.update();
}, getOrigin: function() {
  var e = this.scheme, t = this.port;
  if ("blob" === e) try {
    return new URLConstructor(e.path[0]).origin;
  } catch (e2) {
    return "null";
  }
  return "file" !== e && this.isSpecial() ? e + "://" + serializeHost(this.host) + (null !== t ? ":" + t : "") : "null";
}, getProtocol: function() {
  return this.scheme + ":";
}, setProtocol: function(e) {
  this.parse($toString(e) + ":", SCHEME_START);
}, getUsername: function() {
  return this.username;
}, setUsername: function(e) {
  var t = arrayFrom($toString(e));
  if (!this.cannotHaveUsernamePasswordPort()) {
    this.username = "";
    for (var i = 0; i < t.length; i++) this.username += percentEncode(t[i], userinfoPercentEncodeSet);
  }
}, getPassword: function() {
  return this.password;
}, setPassword: function(e) {
  var t = arrayFrom($toString(e));
  if (!this.cannotHaveUsernamePasswordPort()) {
    this.password = "";
    for (var i = 0; i < t.length; i++) this.password += percentEncode(t[i], userinfoPercentEncodeSet);
  }
}, getHost: function() {
  var e = this.host, t = this.port;
  return null === e ? "" : null === t ? serializeHost(e) : serializeHost(e) + ":" + t;
}, setHost: function(e) {
  this.cannotBeABaseURL || this.parse(e, HOST);
}, getHostname: function() {
  var e = this.host;
  return null === e ? "" : serializeHost(e);
}, setHostname: function(e) {
  this.cannotBeABaseURL || this.parse(e, HOSTNAME);
}, getPort: function() {
  var e = this.port;
  return null === e ? "" : $toString(e);
}, setPort: function(e) {
  this.cannotHaveUsernamePasswordPort() || ("" === (e = $toString(e)) ? this.port = null : this.parse(e, PORT));
}, getPathname: function() {
  var e = this.path;
  return this.cannotBeABaseURL ? e[0] : e.length ? "/" + join(e, "/") : "";
}, setPathname: function(e) {
  this.cannotBeABaseURL || (this.path = [], this.parse(e, PATH_START));
}, getSearch: function() {
  var e = this.query;
  return e ? "?" + e : "";
}, setSearch: function(e) {
  "" === (e = $toString(e)) ? this.query = null : ("?" === charAt(e, 0) && (e = stringSlice(e, 1)), this.query = "", this.parse(e, QUERY)), this.searchParams.update();
}, getSearchParams: function() {
  return this.searchParams.facade;
}, getHash: function() {
  var e = this.fragment;
  return e ? "#" + e : "";
}, setHash: function(e) {
  "" !== (e = $toString(e)) ? ("#" === charAt(e, 0) && (e = stringSlice(e, 1)), this.fragment = "", this.parse(e, FRAGMENT)) : this.fragment = null;
}, update: function() {
  this.query = this.searchParams.serialize() || null;
} };
var URLConstructor = function(e) {
  var t = anInstance$1(this, URLPrototype), i = validateArgumentsLength$3(arguments.length, 1) > 1 ? arguments[1] : void 0, r = setInternalState$1(t, new URLState(e, false, i));
  DESCRIPTORS$1 || (t.href = r.serialize(), t.origin = r.getOrigin(), t.protocol = r.getProtocol(), t.username = r.getUsername(), t.password = r.getPassword(), t.host = r.getHost(), t.hostname = r.getHostname(), t.port = r.getPort(), t.pathname = r.getPathname(), t.search = r.getSearch(), t.searchParams = r.getSearchParams(), t.hash = r.getHash());
};
var URLPrototype = URLConstructor.prototype;
var accessorDescriptor = function(e, t) {
  return { get: function() {
    return getInternalURLState(this)[e]();
  }, set: t && function(e2) {
    return getInternalURLState(this)[t](e2);
  }, configurable: true, enumerable: true };
};
if (DESCRIPTORS$1 && (defineBuiltInAccessor$1(URLPrototype, "href", accessorDescriptor("serialize", "setHref")), defineBuiltInAccessor$1(URLPrototype, "origin", accessorDescriptor("getOrigin")), defineBuiltInAccessor$1(URLPrototype, "protocol", accessorDescriptor("getProtocol", "setProtocol")), defineBuiltInAccessor$1(URLPrototype, "username", accessorDescriptor("getUsername", "setUsername")), defineBuiltInAccessor$1(URLPrototype, "password", accessorDescriptor("getPassword", "setPassword")), defineBuiltInAccessor$1(URLPrototype, "host", accessorDescriptor("getHost", "setHost")), defineBuiltInAccessor$1(URLPrototype, "hostname", accessorDescriptor("getHostname", "setHostname")), defineBuiltInAccessor$1(URLPrototype, "port", accessorDescriptor("getPort", "setPort")), defineBuiltInAccessor$1(URLPrototype, "pathname", accessorDescriptor("getPathname", "setPathname")), defineBuiltInAccessor$1(URLPrototype, "search", accessorDescriptor("getSearch", "setSearch")), defineBuiltInAccessor$1(URLPrototype, "searchParams", accessorDescriptor("getSearchParams")), defineBuiltInAccessor$1(URLPrototype, "hash", accessorDescriptor("getHash", "setHash"))), defineBuiltIn$1(URLPrototype, "toJSON", function() {
  return getInternalURLState(this).serialize();
}, { enumerable: true }), defineBuiltIn$1(URLPrototype, "toString", function() {
  return getInternalURLState(this).serialize();
}, { enumerable: true }), NativeURL) {
  nativeCreateObjectURL = NativeURL.createObjectURL, nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  nativeCreateObjectURL && defineBuiltIn$1(URLConstructor, "createObjectURL", bind$4(nativeCreateObjectURL, NativeURL)), nativeRevokeObjectURL && defineBuiltIn$1(URLConstructor, "revokeObjectURL", bind$4(nativeRevokeObjectURL, NativeURL));
}
var nativeCreateObjectURL;
var nativeRevokeObjectURL;
setToStringTag$1(URLConstructor, "URL"), $$f({ global: true, constructor: true, forced: !USE_NATIVE_URL$2, sham: !DESCRIPTORS$1 }, { URL: URLConstructor });
var $$e = _export;
var getBuiltIn$5 = getBuiltIn$h;
var fails$3 = fails$s;
var validateArgumentsLength$2 = validateArgumentsLength$5;
var toString$2 = toString$e;
var USE_NATIVE_URL$1 = urlConstructorDetection;
var URL$2 = getBuiltIn$5("URL");
var THROWS_WITHOUT_ARGUMENTS = USE_NATIVE_URL$1 && fails$3(function() {
  URL$2.canParse();
});
var WRONG_ARITY = fails$3(function() {
  return 1 !== URL$2.canParse.length;
});
$$e({ target: "URL", stat: true, forced: !THROWS_WITHOUT_ARGUMENTS || WRONG_ARITY }, { canParse: function(e) {
  var t = validateArgumentsLength$2(arguments.length, 1), i = toString$2(e), r = t < 2 || void 0 === arguments[1] ? void 0 : toString$2(arguments[1]);
  try {
    return !!new URL$2(i, r);
  } catch (e2) {
    return false;
  }
} });
var $$d = _export;
var getBuiltIn$4 = getBuiltIn$h;
var validateArgumentsLength$1 = validateArgumentsLength$5;
var toString$1 = toString$e;
var USE_NATIVE_URL = urlConstructorDetection;
var URL$1 = getBuiltIn$4("URL");
$$d({ target: "URL", stat: true, forced: !USE_NATIVE_URL }, { parse: function(e) {
  var t = validateArgumentsLength$1(arguments.length, 1), i = toString$1(e), r = t < 2 || void 0 === arguments[1] ? void 0 : toString$1(arguments[1]);
  try {
    return new URL$1(i, r);
  } catch (e2) {
    return null;
  }
} });
var path$2 = path$e;
var url$5 = path$2.URL;
var parent$b = url$5;
var url$4 = parent$b;
var parent$a = url$4;
var url$3 = parent$a;
var parent$9 = url$3;
var url$2 = parent$9;
var url$1 = url$2;
var url = url$1;
var _URL = getDefaultExportFromCjs(url);
function setPressureObserver(e) {
  const t = PressureObserver.supportedSources;
  let i = "thermal";
  i = null != t && t.includes("thermal") ? "thermal" : "cpu";
  const r = new PressureObserver((t2) => {
    t2.forEach((t3) => {
      t3.source === i && e(t3.state);
    });
  });
  return r.observe(i, { sampleInterval: 2e3 }), r;
}
var ComputePressureMonitor = class {
  constructor() {
    _defineProperty(this, "_state", void 0), _defineProperty(this, "_handler", false);
  }
  init() {
    if (isComputePressureSupported && !getParameter("DISABLE_COMPUTE_PRESSURE") && "UT" !== {}.VITE_TEST) try {
      if (isWorkerSupported()) {
        const e = new Blob(["(".concat(setPressureObserver.toString(), ")(self.postMessage)")], { type: "text/javascript" }), t = new Worker(_URL.createObjectURL(e));
        t.onmessage = (e2) => {
          this._state = e2.data;
        }, this._handler = t;
      } else this._handler = setPressureObserver((e) => {
        this._state = e;
      });
    } catch (e) {
    }
  }
  get state() {
    return isDebuggerMode && !isSSR$1() && (window.thermal_status = this._state), this._handler || this.init(), this._state;
  }
};
var computePressureMonitor = new ComputePressureMonitor();
var stasType = ["codec", "inbound-rtp", "outbound-rtp", "remote-inbound-rtp", "remote-outbound-rtp", "media-source", "csrc", "peer-connection", "data-channel", "stream", "track", "transceiver", "sender", "receiver", "transport", "sctp-transport", "candidate-pair", "local-candidate", "remote-candidate", "certificate", "ice-server"];
var STATS_CACHE = /* @__PURE__ */ new Map();
var canIUseGetStatsCallback = true;
var getExtraChromeStatsReport = async (e) => new Promise((t) => {
  const i = { all: [], getTrackStats: () => [] }, r = getParameter("STATS_SCALLBACK_SUPPORT");
  if (canIUseGetStatsCallback && isChrome && void 0 === window.InstallTrigger && isStatsCallbackSupport && r) try {
    var o, n, s;
    null === (o = e.getStats((e2) => {
      const i2 = [];
      e2.result().forEach((e3) => {
        if (stasType.includes(e3.type)) return;
        const t2 = {};
        e3.names().forEach(function(i3) {
          t2[i3] = e3.stat(i3);
        }), i2.push(_objectSpread2(_objectSpread2({}, t2), {}, { id: e3.id, type: e3.type, timestamp: e3.timestamp }));
      }), t({ all: i2, getTrackStats: (e3) => i2.filter((t2) => "ssrc" !== t2.type || t2.googTrackId === e3) });
    })) || void 0 === o || null === (n = o.then) || void 0 === n || null === (n = n.call(o, () => {
      t(i);
    })) || void 0 === n || null === (s = n.catch) || void 0 === s || s.call(n, () => {
      canIUseGetStatsCallback = false, t(i);
    });
  } catch (e2) {
    canIUseGetStatsCallback = false, t(i);
  }
  else t(i);
});
var getAllStatsReport = async (e) => {
  var t;
  const i = await e.getStats(), r = { all: [] }, o = /* @__PURE__ */ new Map();
  i.forEach((e2) => {
    const t2 = o.get(e2.type) || /* @__PURE__ */ new Map();
    t2.set(e2.id, e2), o.set(e2.type, t2), r.all.push(e2);
  });
  const n = (e2, t2) => {
    e2.forEach((e3) => {
      var i2, r2, n2, s2;
      let a2, d, { codecId: c2, transportId: l, trackId: u, playoutId: h } = e3;
      if (null === (i2 = o.get("codec")) || void 0 === i2 || i2.forEach((e4) => {
        e4.id === c2 && t2.add(e4);
      }), null === (r2 = o.get("transport")) || void 0 === r2 || r2.forEach((e4) => {
        e4.id === l && (a2 = e4, t2.add(e4));
      }), null === (n2 = o.get("track")) || void 0 === n2 || n2.forEach((e4) => {
        e4.id === u && t2.add(e4);
      }), null === (s2 = o.get("media-playout")) || void 0 === s2 || s2.forEach((e4) => {
        e4.id === h && t2.add(e4);
      }), a2) {
        var _, p;
        const { localCertificateId: e4, remoteCertificateId: i3, selectedCandidatePairId: r3 } = a2;
        null === (_ = o.get("certificate")) || void 0 === _ || _.forEach((r4) => {
          (r4.id === e4 || r4.id === i3) && t2.add(r4);
        }), null === (p = o.get("candidate-pair")) || void 0 === p || p.forEach((e5) => {
          e5.id === r3 && (d = e5, t2.add(e5));
        });
      }
      if (d) {
        var m, S;
        const { localCandidateId: e4, remoteCandidateId: i3 } = d;
        null === (m = o.get("local-candidate")) || void 0 === m || m.forEach((i4) => {
          i4.id === e4 && t2.add(i4);
        }), null === (S = o.get("remote-candidate")) || void 0 === S || S.forEach((e5) => {
          e5.id === i3 && t2.add(e5);
        });
      }
    });
  };
  var s;
  if (o.get("media-source")) null === (s = o.get("media-source")) || void 0 === s || s.forEach((e2) => {
    var t2;
    const i2 = /* @__PURE__ */ new Set();
    i2.add(e2);
    const s2 = [];
    null === (t2 = o.get("outbound-rtp")) || void 0 === t2 || t2.forEach((t3) => {
      var r2;
      t3.mediaSourceId === e2.id && (i2.add(t3), s2.push(t3), null === (r2 = o.get("remote-inbound-rtp")) || void 0 === r2 || r2.forEach((e3) => {
        e3.localId === t3.id && i2.add(e3);
      }));
    }), n(s2, i2), r[e2.trackIdentifier] = Array.from(i2);
  });
  else if (o.get("track")) {
    var a;
    null === (a = o.get("track")) || void 0 === a || a.forEach((e2) => {
      var t2;
      const i2 = /* @__PURE__ */ new Set();
      i2.add(e2);
      const s2 = [];
      null === (t2 = o.get("outbound-rtp")) || void 0 === t2 || t2.forEach((t3) => {
        var r2;
        t3.trackId === e2.id && (i2.add(t3), s2.push(t3), null === (r2 = o.get("remote-inbound-rtp")) || void 0 === r2 || r2.forEach((e3) => {
          e3.localId === t3.id && i2.add(e3);
        }));
      }), n(s2, i2), r[e2.trackIdentifier] = Array.from(i2);
    });
  }
  return null === (t = o.get("inbound-rtp")) || void 0 === t || t.forEach((e2) => {
    var t2;
    const i2 = /* @__PURE__ */ new Set();
    i2.add(e2), null === (t2 = o.get("remote-outbound-rtp")) || void 0 === t2 || t2.forEach((t3) => {
      t3.localId === e2.id && i2.add(t3);
    }), n([e2], i2);
    let { trackIdentifier: s2 } = e2;
    var a2;
    s2 || (null === (a2 = o.get("track")) || void 0 === a2 || a2.forEach((t3) => {
      t3.id === e2.trackId && (s2 = t3.trackIdentifier);
    }));
    r[s2] = Array.from(i2);
  }), r;
};
var getStats$1 = async (e, t, i, r) => {
  const o = null == t ? void 0 : t.id;
  if (!(e instanceof RTCPeerConnection)) return [];
  if (isFirefox || isSafari) {
    const i2 = [];
    try {
      (r ? await r.getStats() : await e.getStats(t)).forEach((e2) => {
        i2.push(e2);
      });
    } catch (e2) {
    }
    return i2;
  }
  let n = STATS_CACHE.get(e);
  (!n || Date.now() - n.timestamp > 150) && (n = { timestamp: Date.now(), statsPromise: getAllStatsReport(e), extraStatsPromise: getExtraChromeStatsReport(e) }, STATS_CACHE.set(e, n));
  const s = await n.statsPromise;
  let a = (o ? s[o] : s.all) || [];
  if (!i) {
    const e2 = await n.extraStatsPromise;
    a = a.concat((o ? e2.getTrackStats(o) : e2.all) || []);
  }
  return a;
};
var clearPeerCache = (e) => {
  STATS_CACHE.has(e) && STATS_CACHE.delete(e);
};
var StatsMonitor = class extends EnhancedEventEmitter {
  constructor() {
    super(...arguments), _defineProperty(this, "_continuousVideoEncodeFailure", 0), _defineProperty(this, "_remoteStreamDecodeStatus", /* @__PURE__ */ new Map());
  }
  setLocalVideoStats(e, t) {
    this.checkVideoEncodeFailure(e, t);
  }
  setRemoteVideoStats(e, t) {
    this.checkVideoDecodeFailure(e, t);
  }
  destroy() {
    this._continuousVideoEncodeFailure = 0, this._remoteStreamDecodeStatus = /* @__PURE__ */ new Map();
  }
  checkVideoEncodeFailure(e, t) {
    const i = e.frame_rate_input;
    window.__createEncodeError__ && (e.frame_rate_sent = 0, e.frame_rate_encoded = 0);
    const r = e.frame_rate_sent, o = e.frame_rate_encoded, n = void 0 !== i && i > 0 && void 0 !== o && 0 === o && void 0 !== r && 0 === r, s = null != e && e.is_screen ? 10 : 5;
    var a;
    n ? (this._continuousVideoEncodeFailure++, this._continuousVideoEncodeFailure > s && (this.emit("rtc-encode-error", { codec: null == e ? void 0 : e.codecName, media_type: "video", track_frame_size_width: null == t ? void 0 : t.getSettings().width, track_frame_size_height: null == t ? void 0 : t.getSettings().height, track_frame_rate: null == t ? void 0 : t.getSettings().frameRate, stats_frame_size_width: null == e ? void 0 : e.frame_size_width, stats_frame_size_height: null == e ? void 0 : e.frame_size_height, stats_frame_rate_input: null == e ? void 0 : e.frame_rate_input, stats_frame_rate_sent: null == e ? void 0 : e.frame_rate_sent, stats_frame_rate_encoded: null == e ? void 0 : e.frame_rate_encoded, stats_frame_encoder_name: e.encoder_implementation, stats_is_hardware_encoder_enabled: Config2.H264_HW_ENCODER, stats_gpu_url: Config2.GPU_URL || (null === (a = getGpuInfo()) || void 0 === a ? void 0 : a.renderer), is_screen: null == e ? void 0 : e.is_screen }), this._continuousVideoEncodeFailure = 0)) : this._continuousVideoEncodeFailure = 0;
  }
  checkVideoDecodeFailure(e, t) {
    const i = e.stream_id;
    if (this._remoteStreamDecodeStatus.has(i)) {
      const o = this._remoteStreamDecodeStatus.get(i), n = 0 === e.frame_rate_decoded && e.packetsReceived > o.packets_received && e.framesDecoded < 10;
      var r;
      if (o.packets_received = e.packetsReceived, o.frames_decoded = e.framesDecoded, o.frame_rate_decoded = e.frame_rate_decoded, o.continuous_video_decode_failure = n ? o.continuous_video_decode_failure + 1 : 0, o.continuous_video_decode_failure > 5) this.emit("rtc-decode-error", { codec: e.codecName, media_type: "video", track_frame_size_width: t.getSettings().width, track_frame_size_height: t.getSettings().height, track_frame_rate: t.getSettings().frameRate, stats_frame_size_width: e.frame_size_width, stats_frame_size_height: e.frame_size_height, stats_frame_rate_decode: e.frame_rate_decoded, stats_frame_rate_receive: e.frame_rate_received, stats_frame_decoder_name: e.decoder_name, stats_gpu_url: Config2.GPU_URL || (null === (r = getGpuInfo()) || void 0 === r ? void 0 : r.renderer), is_screen: e.is_screen }), o.continuous_video_decode_failure = 0;
    } else this._remoteStreamDecodeStatus.set(i, { packets_received: e.packetsReceived, frames_decoded: e.framesDecoded, frame_rate_decoded: e.frame_rate_decoded, continuous_video_decode_failure: 0 });
  }
};
var Stats = class extends EnhancedEventEmitter {
  constructor(e) {
    super(), _defineProperty(this, "_timer", void 0), _defineProperty(this, "_reportTimer", void 0), _defineProperty(this, "handler", void 0), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "logger", void 0), _defineProperty(this, "_destroyed", false), _defineProperty(this, "_isReportStarted", false), this._context = e, this._monitor = getMonitor(e.id), this.logger = new Logger$1("Stats", 3, e.id);
  }
  setVar(e) {
    this.handler = e;
  }
  stopReport(e) {
    this._isReportStarted && (this.logger.info("stopReport", "invoke"), this._isReportStarted = false, clearTimeout(this._reportTimer), delete this._reportTimer, reportRtcInvokeStatus(this._context.id, "del_media_statistics_timer", "reason: ".concat(e, ", stack: ").concat(new Error().stack), 0, this._stream.streamId || ""));
  }
  filterIllegal(e) {
    const t = {};
    return Object.keys(e).forEach((i) => {
      null === e[i] || void 0 === e[i] || Number.isNaN(e[i]) || (t[i] = e[i]);
    }), t;
  }
  destroy() {
    this.logger.info("destroy", "invoke"), reportRtcInvokeStatus(this._context.id, "media_statistics_destroy", "".concat(new Error().stack), 0, "".concat(this._stream.streamId)), this.stopReport("destroy"), clearTimeout(this._timer), this._destroyed = true;
  }
};
var LocalStatsReport = class extends Stats {
  constructor(e, t) {
    super(e), _defineProperty(this, "_stats", { audioStats: {}, videoStats: {} }), _defineProperty(this, "_preReports", { audio: {}, video: {} }), _defineProperty(this, "statsMonitor", void 0), this._stream = t, this.statsMonitor = new StatsMonitor(), this.statsMonitor.on("stats-exception", (e2) => {
      this.emit("stats-exception", e2);
    }), this.statsMonitor.on("rtc-encode-error", (e2) => {
      var t2;
      this.logger.info("rtc_encode_error", JSON.stringify(e2)), null === (t2 = this._monitor) || void 0 === t2 || t2.report("rtc_encode_error", e2);
    });
    const i = async () => {
      this._stats = await this._getLocalStats(this._stream, this._preReports, false), this._destroyed || (this._timer = setTimeout(i, getParameter("STATS_LOOP_INTERVAL")));
    };
    i();
  }
  setLocalStreamStatsEvtInterval(e, t) {
    if (this._isReportStarted) return;
    this.logger.info("setLocalStreamStatsEvtInterval", "invoke"), this._isReportStarted = true, this.setVar(t), this._destroyed = false;
    const i = { audio: {}, video: {} }, r = async () => {
      const t2 = await this._getLocalStats(this._stream, i, true);
      e(t2), this._destroyed || (this._reportTimer = setTimeout(r, 2e3));
    };
    r();
  }
  getLocalStats() {
    return this._stats;
  }
  async _getLocalStats(e, t, i) {
    var r, o, n, s, a, d, c2;
    const l = void 0 !== (null === (r = e.audioTrack) || void 0 === r ? void 0 : r.mixType) && e.audioTrack.mixType !== AudioMixingType.PLAYOUT ? null !== (o = null === (n = e.audioTrack) || void 0 === n ? void 0 : n.mixedAudioTrack) && void 0 !== o ? o : null === (s = e.audioTrack) || void 0 === s ? void 0 : s.preprocessingTrack : null === (a = e.audioTrack) || void 0 === a ? void 0 : a.preprocessingTrack, u = null === (d = e.videoTrack) || void 0 === d ? void 0 : d.preprocessingTrack;
    var h;
    0 === Object.keys(t.audio).length && 0 === Object.keys(t.video).length && (await this.getAudioStats(l, t, null === (h = e.audioTrack) || void 0 === h ? void 0 : h.getAudioLevel(), i), await this.getVideoStats(u, t, i), await wait(150));
    return { audioStats: await this.getAudioStats(l, t, null === (c2 = e.audioTrack) || void 0 === c2 ? void 0 : c2.getAudioLevel(), i), videoStats: await this.getVideoStats(u, t, i), isScreen: e.isScreen };
  }
  async getAudioStats(e, t, i, r) {
    var o, n, s;
    const a = {}, d = { timestamp: Date.now() }, { streamId: c2, audioMid: l, isScreen: u, pubAttributes: h, pubAudio: _, audioTrack: p } = this._stream, m = { media_type: "audio", is_screen: !!u, direction: "up", stream_id: c2, vid: l, connection_status: navigator.onLine, track_enabled: null == e ? void 0 : e.enabled, capture_state: h.localaudio ? "capture_state_on" : "capture_state_off", mute_state: _ ? "mute_state_off" : "mute_state_on", thermal_status: computePressureMonitor.state, is_public_stream: this._stream.isPublicStream };
    if (p && (m.playback_volume = p.getVolume()), !e || !this.handler) return a;
    const S = await (null === (o = this.handler.peer) || void 0 === o ? void 0 : o.getStatsWithLowFrequency(e, false, null === (n = this._stream.audioTransceiver) || void 0 === n ? void 0 : n.sender));
    if (!S.length) return a;
    if (S.forEach((e2) => {
      let { type: t2, packetsSent: i2, packetsLost: r2, bytesSent: o2, clockRate: n2, roundTripTime: s2, channels: c3, audioLevel: l2, mimeType: u2, availableIncomingBitrate: h2, availableOutgoingBitrate: _2, bytesReceived: p2, nominated: S2, id: g2, currentRoundTripTime: v5, state: f, writable: y, requestsReceived: E, responsesReceived: T, requestsSent: b, consentRequestsSent: I, responsesSent: R, jitter: C, candidateType: P, ip: A, address: O, networkType: k, port: N, protocol: w, nackCount: M, retransmittedBytesSent: D, retransmittedPacketsSent: L, audioInputLevel: $2, ssrc: x, totalAudioEnergy: V, totalSamplesDuration: U, mediaType: W, fractionLost: F } = e2;
      "outbound-rtp" === t2 ? (d.packetsSent = i2, d.bytesSent = o2, m.bytes = o2, m.packetsSent = i2, m.nackCount = M, m.ssrc = x, m.retransmitted_bytes_sent = D, m.retransmitted_packets_sent = L, d.retransmittedBytesSent = D, d.retransmittedPacketsSent = L) : "remote-inbound-rtp" === t2 ? (d.packetsLost = r2, m.packetsLost = r2, m.net_jitter = 1e3 * C, a.rtt = 1e3 * s2, m.rtt = a.rtt, a._fractionLost = F || 0) : "codec" === t2 ? (a.recordSampleRate = n2, a.numChannels = c3, m.codecName = u2) : "media-source" === t2 && void 0 !== l2 ? (m.audio_level = l2 ? -10 * Math.log10(Math.pow(l2, 2)) : l2, m.volume = 255 * l2, m.total_audio_energy = V, m.totalInputDuration = U, m.send_level || (m.send_level = l2)) : "ssrc" === t2 && "audio" === W ? $2 && (m.send_level = $2) : "candidate-pair" === t2 ? (m.ice_available_incoming_bitrate = h2, m.ice_available_outgoing_bitrate = _2, m.ice_bytes_received = p2, m.ice_bytes_sent = o2, m.ice_nominated = Number(S2), m.ice_pair_id = g2, m.ice_pair_rtt = v5, m.ice_pair_state = f, m.ice_pair_writable = y, m.recv_ping_requests = E, m.recv_ping_responses = T, m.sent_ping_requests_before_first_response = b, m.sent_ping_requests_total = b + (I || 0), m.sent_ping_responses = R) : "local-candidate" === t2 ? (m.local_candidate_type = P, m.local_ip = A || O, m.local_network_type = k, m.local_port = N, m.protocol = w) : "remote-candidate" === t2 && (m.remote_candidate_type = P, m.remote_ip = A || O, m.remote_port = N);
    }), m.send_level) m.send_level < 1 ? m._sendVolumeLevel = 32767 * m.send_level : m._sendVolumeLevel = m.send_level;
    else {
      const e2 = (null == p ? void 0 : p.getAudioLevel()) || 0;
      m._sendVolumeLevel = Math.round(e2 / 255 * 32767);
    }
    void 0 === m.volume && void 0 !== i && (m.volume = i, m.audio_level = i ? -10 * Math.log10(Math.pow(i / 255, 2)) : i);
    const { audio: g } = t;
    if (!g.timestamp) return t.audio = d, this.filterIllegal(a);
    var v3;
    (void 0 !== d.packetsLost && (a.audioLossRate = Math.max(0, d.packetsLost - g.packetsLost) / (d.packetsSent - g.packetsSent), a.audioLossRate = Number.isNaN(a.audioLossRate) ? 0 : a.audioLossRate, m.fraction_lost = a.audioLossRate), a.statsInterval = d.timestamp - g.timestamp, m.stats_interval = a.statsInterval, a.sendKBitrate = (d.bytesSent - g.bytesSent || 0) / a.statsInterval * 8, m.mediaBitratebps = Math.round(1e3 * a.sendKBitrate), m.bandwidth = Math.round(m.mediaBitratebps / 1024), void 0 !== d.retransmittedBytesSent && (m.retransmitBitratebps = (d.retransmittedBytesSent - g.retransmittedBytesSent || 0) / a.statsInterval), t.audio = d, m.vendor_mode = this._stream.vendorCode || 0, m.pc_session_id = null === (s = this.handler) || void 0 === s ? void 0 : s.peerConnectionId, r) && (null === (v3 = this._monitor) || void 0 === v3 || v3.report("rtc_media_statistics", m));
    return a._retransmittedRate = (d.retransmittedPacketsSent - g.retransmittedPacketsSent) / (d.packetsSent - g.packetsSent), void 0 === a.audioLossRate && (a.audioLossRate = a._retransmittedRate, m.fraction_lost = a.audioLossRate), a._fractionLost = Math.max(a._fractionLost, a.audioLossRate), a._sendVolumeLevel = m._sendVolumeLevel, this.filterIllegal(a);
  }
  async getVideoStats(e, t, i) {
    var r, o, n;
    const s = {}, a = { timestamp: Date.now(), simulcast: {} }, { streamId: d, videoMid: c2, isScreen: l, pubAttributes: u, enableSimulcast: h, pubVideo: _ } = this._stream, p = { media_type: "video", is_screen: !!l, direction: "up", stream_id: d, vid: c2, connection_status: navigator.onLine, track_enabled: null == e ? void 0 : e.enabled, capture_state: u.localvideo ? "capture_state_on" : "capture_state_off", mute_state: _ ? "mute_state_off" : "mute_state_on", thermal_status: computePressureMonitor.state, is_public_stream: this._stream.isPublicStream };
    if (!e || !this.handler) return s;
    p.cap_frame_width = e.getSettings().width, p.cap_frame_height = e.getSettings().height, p.frameRateSent = e.getSettings().frameRate, s.isScreen = l, p.is_intersecting = JSON.stringify(null === (r = this._stream) || void 0 === r || null === (r = r.videoTrack) || void 0 === r ? void 0 : r.intersection());
    const m = await (null === (o = this.handler.peer) || void 0 === o ? void 0 : o.getStatsWithLowFrequency(e, false, null === (n = this._stream.videoTransceiver) || void 0 === n ? void 0 : n.sender));
    if (!m.length) return s;
    let S = 0;
    m.forEach((e2) => {
      const { type: i2, framesEncoded: r2, packetsLost: o2, bytesSent: n2, framesSent: d2, retransmittedBytesSent: c3, totalPacketSendDelay: l2, totalEncodeTime: u2, firCount: _2, targetBitrate: m2, roundTripTime: g2, mimeType: v5, frameWidth: f2, frameHeight: y2, packetsSent: E2, googActualEncBitrate: T2, googAvailableReceiveBandwidth: b, googAvailableSendBandwidth: I, googAvgEncodeMs: R, googBucketDelay: C, googEncodeUsagePercent: P, googFrameRateInput: A, availableIncomingBitrate: O, availableOutgoingBitrate: k, bytesReceived: N, nominated: w, id: M, currentRoundTripTime: D, state: L, writable: $2, candidateType: x, ip: V, address: U, networkType: W, port: F, nackCount: Z, pliCount: G, protocol: H, qpSum: K, requestsReceived: X, responsesReceived: B, googRetransmitBitrate: Y, requestsSent: j, consentRequestsSent: J, responsesSent: z, ssrc: Q, googTargetEncBitrate: q, googTransmitBitrate: ee, retransmittedPacketsSent: te, encoderImplementation: ie, jitter: re, rid: oe, fractionLost: ne, googAdaptationChanges: se, qualityLimitationReason: ae, qualityLimitationDurations: de, googFirsReceived: ce, googFrameRateSent: le, keyFramesEncoded: ue, scalabilityMode: he, framesPerSecond: _e, frames: pe } = e2;
      "outbound-rtp" === i2 ? (h && (oe ? a.simulcast[oe] = e2 : a.simulcast[S] = e2, S++), a.framesEncoded = r2 || a.framesEncoded || 0, p.key_frames_encoded = ue || 0, a.bytesSent = n2 || a.bytesSent || 0, a.framesSent = d2 || a.framesSent, p.bytes = n2 || p.bytes || 0, a.packetsSent = E2 || a.packetsSent || 0, p.packetsSent = E2 || p.packetsSent || 0, p.nackCount = Z || p.nackCount || 0, p.pli_count = G || p.pli_count || 0, p.qp_sum = K || p.qp_sum || 0, p.ssrc = Q || p.ssrc || 0, p.retransmitted_packets_sent = te, a.retransmittedPacketsSent = te, a.retransmittedBytesSent = c3, p.encoder_implementation = ie, p.qualityLimitationReason = ae, p.qualityLimitationDurations = de, p.scalabilityMode = he, void 0 !== f2 && ((!s.encodedFrameWidth || f2 > s.encodedFrameWidth) && (s.encodedFrameWidth = f2), (!s.encodedFrameHeight || y2 > s.encodedFrameHeight) && (s.encodedFrameHeight = y2), p.frame_size_height = y2, p.frame_size_width = f2)) : "track" === i2 ? (s.encodedFrameWidth = f2, s.encodedFrameHeight = y2, p.frame_size_height = y2, p.frame_size_width = f2) : "remote-inbound-rtp" === i2 ? (a.packetsLost = o2, s.rtt = 1e3 * g2, p.rtt = s.rtt, p.jitter = 1e3 * re, p.packetsLost = o2, s._fractionLost = ne || 0) : "codec" === i2 ? (s.codecType = v5, p.codecName = v5) : "candidate-pair" === i2 ? (p.ice_available_incoming_bitrate = O, p.ice_available_outgoing_bitrate = k, p.ice_bytes_received = N, p.ice_bytes_sent = n2, p.ice_nominated = Number(w), p.ice_pair_id = M, p.ice_pair_rtt = D, p.ice_pair_state = L, p.ice_pair_writable = $2, p.recv_ping_requests = X, p.recv_ping_responses = B, p.sent_ping_requests_before_first_response = j, p.sent_ping_requests_total = j + J, p.sent_ping_responses = z) : "local-candidate" === i2 ? (p.local_candidate_type = x, p.local_ip = V || U, p.local_network_type = W, p.local_port = F, p.protocol = H) : "remote-candidate" === i2 ? (p.remote_candidate_type = x, p.remote_ip = V || U, p.remote_port = F) : "VideoBwe" === i2 ? (p.encBitratebps = T2, p.available_receive_bandwidth = b, p.available_send_bandwidth = I, p.bucket_delay = C, p.retransmitBitratebps = Y, p.targetEncBitratebps = q, p.transmit_bitrate = ee, s._sendBandWidth = Number(I)) : "ssrc" === i2 && (p.avg_encode_ms = R, p.encodeUsage = P, p.frame_rate_input = A, p.orignal_input_Framerate = Number(A), p.ddaptationChanges = se, p.firsReceived = ce, p.frameRateSent = le);
      const me = getParameter("STATS_SCALLBACK_SUPPORT");
      if (!isStatsCallbackSupport || !me) {
        const { video: e3 } = t, o3 = a.timestamp - e3.timestamp;
        if ("outbound-rtp" === i2) {
          const t2 = n2 - e3.bytesSent, i3 = c3 - e3.retransmittedBytesSent;
          p.encBitratebps = Math.round(8e3 * (t2 - i3) / o3), p.bucket_delay = l2 / E2, p.retransmitBitratebps = Math.round(8e3 * i3 / o3), p.targetEncBitratebps = m2, p.transmit_bitrate = Math.round(1e3 * (n2 - e3.bytesSent) * 8 / o3), p.avg_encode_ms = 1e3 * u2 / r2, p.firsReceived = _2 + G;
        } else "candidate-pair" === i2 ? (p.available_send_bandwidth = k, s._sendBandWidth = k) : "media-source" === i2 && (p.frame_rate_input = _e, p.orignal_input_Framerate = Number(_e), p.frame_input = pe);
      }
    });
    const { video: g } = t;
    if (!g.timestamp) return t.video = a, this.filterIllegal(s);
    s.statsInterval = a.timestamp - g.timestamp, p.stats_interval = s.statsInterval;
    const v3 = Object.keys(a.simulcast);
    if (h) {
      var f;
      p.sim_enc_width = [], p.sim_enc_height = [], p.sim_enc_bps = [], p.sim_enc_framerate = [], p.sim_enc_key_frames = [], p.sim_rids = [], p.sim_enc_bandwidth = [], p.sim_sent_framerate = [], p.sim_fraction_lost = [], p.sim_keyencoded = [], p.active_sim_streams = this._context.videoProfile.activeSimStreams || [], p.sim_retransmittedRate = [];
      let e2 = false;
      var y;
      if (_sortInstanceProperty(v3).call(v3, (e3, t2) => Number(e3) - Number(t2)).forEach((t2) => {
        const { frameWidth: i2, frameHeight: r2, bytesSent: o2, framesEncoded: n2, framesSent: d2, packetsLost: c3, packetsSent: l2, qualityLimitationReason: u2, qualityLimitationDurations: h2, qualityLimitationResolutionChanges: _2, retransmittedPacketsSent: m2, pliCount: S2, keyFramesEncoded: v5 } = a.simulcast[t2];
        void 0 !== u2 && (p.sim_qualityLimitationReason || (p.sim_qualityLimitationReason = [], p.sim_qualityLimitationDurations = [], p.sim_qualityLimitationResolutionChanges = []), p.sim_qualityLimitationReason.push(u2), p.sim_qualityLimitationDurations.push(h2), p.sim_qualityLimitationResolutionChanges.push(_2));
        const f2 = g.simulcast[t2];
        if (p.sim_enc_width.push(i2 || 0), p.sim_enc_height.push(r2 || 0), p.sim_enc_key_frames.push(v5 || 0), f2) {
          const r3 = (o2 - f2.bytesSent || 0) / s.statsInterval;
          p.sim_enc_bps.push(Math.round(8e3 * r3)), p.sim_enc_bandwidth.push(Math.round(8e3 * r3 / 1024));
          const a2 = 1e3 * (n2 - f2.framesEncoded) / s.statsInterval;
          p.sim_enc_framerate.push(Math.round(a2)), p.sim_rids.push(t2);
          const u3 = void 0 !== d2 ? d2 - f2.framesSent : n2 - f2.framesEncoded, h3 = 1e3 * u3 / s.statsInterval;
          p.sim_sent_framerate.push(Math.round(h3));
          let _3 = (c3 - f2.packetsLost) / (l2 - f2.packetsSent);
          s._retransmittedRate = (m2 - f2.retransmittedPacketsSent) / (l2 - f2.packetsSent), _3 = Number.isNaN(_3) ? 0 : _3, p.sim_fraction_lost.push(_3), p.sim_keyencoded.push(S2 - f2.pliCount > 0), p.sim_retransmittedRate.push(s._retransmittedRate), i2 > 0 && !e2 && (s.rid = t2, s.sentKBitrate = 8 * r3, s.encoderOutputFrameRate = a2, s.encodedFrameCount = u3, s.sentFrameRate = h3, s.videoLossRate = _3, e2 = true);
        }
      }), p.vendor_mode = this._stream.vendorCode || 0, p.pc_session_id = null === (f = this.handler) || void 0 === f ? void 0 : f.peerConnectionId, i) null === (y = this._monitor) || void 0 === y || y.report("rtc_media_statistics", p);
    } else {
      var E, T;
      if (s.encodedFrameCount = void 0 !== a.framesSent ? a.framesSent - g.framesSent : a.framesEncoded - g.framesEncoded, s.sentKBitrate = (a.bytesSent - g.bytesSent || 0) / s.statsInterval * 8, p.bitrate = Math.round(1e3 * s.sentKBitrate), p.bandwidth = Math.round(p.bitrate / 1024), s.encoderOutputFrameRate = 1e3 * (a.framesEncoded - g.framesEncoded) / s.statsInterval, p.frame_rate_encoded = Math.round(s.encoderOutputFrameRate), s.sentFrameRate = 1e3 * s.encodedFrameCount / s.statsInterval, p.frame_rate_sent = Math.round(s.sentFrameRate), s.videoLossRate = Math.max(0, a.packetsLost - g.packetsLost) / (a.packetsSent - g.packetsSent), s.videoLossRate = Number.isNaN(s.videoLossRate) ? 0 : s.videoLossRate, p.fraction_lost = s.videoLossRate, s._retransmittedRate = (a.retransmittedPacketsSent - g.retransmittedPacketsSent) / (a.packetsSent - g.packetsSent), p.vendor_mode = this._stream.vendorCode || 0, p.pc_session_id = null === (E = this.handler) || void 0 === E ? void 0 : E.peerConnectionId, p.sentKBitrate = s.sentKBitrate, s.inputFrameRate = p.orignal_input_Framerate, s.encoderName = p.encoder_implementation, i) null === (T = this._monitor) || void 0 === T || T.report("rtc_media_statistics", p);
      else this.statsMonitor.setLocalVideoStats(p, e);
    }
    return t.video = a, s._fractionLost = Math.max(s._fractionLost, s.videoLossRate), s._captureResolutionWidth = p.cap_frame_width, s._captureResolutionHeight = p.cap_frame_height, this.filterIllegal(s);
  }
  destroy() {
    super.destroy(), this.statsMonitor.destroy();
  }
};
var RemoteStatsReport = class extends Stats {
  constructor(e, t) {
    super(e), _defineProperty(this, "_stats", { audioStats: {}, videoStats: {} }), _defineProperty(this, "_preReports", { audio: {}, video: {} }), _defineProperty(this, "statsMonitor", void 0), this._stream = t, this.statsMonitor = new StatsMonitor(), this.statsMonitor.on("stats-exception", (e2) => {
      this.emit("stats-exception", e2);
    }), this.statsMonitor.on("rtc-decode-error", (e2) => {
      var t2;
      this.logger.info("rtc_decode_error", JSON.stringify(e2)), null === (t2 = this._monitor) || void 0 === t2 || t2.report("rtc_decode_error", e2);
    });
    const i = async () => {
      this._stats = await this._getRemoteStreamStats(this._stream, this._preReports, false), this._destroyed || (this._timer = setTimeout(i, getParameter("STATS_LOOP_INTERVAL")));
    };
    i();
  }
  async setRemoteStreamStatsEvtInterval(e, t) {
    if (this._isReportStarted) return;
    this.logger.info("setRemoteStreamStatsEvtInterval", "invoke"), this._isReportStarted = true, this.setVar(t), this._destroyed = false;
    const i = { audio: {}, video: {} }, r = async () => {
      const t2 = await this._getRemoteStreamStats(this._stream, i, true);
      e(t2), this._destroyed || (this._reportTimer = setTimeout(r, 2e3));
    };
    r();
  }
  getRemoteStreamStats() {
    return this._stats;
  }
  async _getRemoteStreamStats(e, t, i) {
    var r, o, n;
    const s = null === (r = e.videoTrack) || void 0 === r ? void 0 : r.originTrack, a = null === (o = e.audioTrack) || void 0 === o ? void 0 : o.originTrack;
    var d;
    0 === Object.keys(t.audio).length && 0 === Object.keys(t.video).length && (await this.getRemoteAudioStats(a, t, null === (d = this._stream.audioTrack) || void 0 === d ? void 0 : d.getAudioLevel(), i), await this.getRemoteVideoStats(s, t, i), await wait(150));
    return { audioStats: await this.getRemoteAudioStats(a, t, null === (n = this._stream.audioTrack) || void 0 === n ? void 0 : n.getAudioLevel(), i), videoStats: await this.getRemoteVideoStats(s, t, i), isScreen: e.isScreen, userId: e.userId, streamId: e.streamId };
  }
  unsubscribe() {
    this.logger.info("unsubscribe", "invoke"), super.stopReport("unsubscribe"), this._stream.stopAudioStallObserve();
  }
  async getRemoteAudioStats(e, t, i, r) {
    var o, n, s, a;
    const d = {}, c2 = {}, { streamId: l, userId: u, isScreen: h, audioMid: _, subMediaType: p, _attributes: m, virtual: S, audioTrack: g } = this._stream, v3 = { media_type: "audio", is_screen: !!h, direction: "down", stream_id: l, stream_user_id: u, vid: _, audio_mux: S, connection_status: navigator.onLine, track_enabled: null == e ? void 0 : e.enabled, mute_state: audioInMediaType(p) ? "mute_state_off" : "mute_state_on", remote_user_capture_state: m.localaudio ? "capture_state_on" : "capture_state_off", remote_user_mute_state: m.localaudio && m.audiostream ? "mute_state_off" : "mute_state_on", thermal_status: computePressureMonitor.state, is_public_stream: this._stream.isPublicStream };
    if (g && (v3.playback_volume = g.getVolume()), !e || !this.handler) return d;
    const f = await (null === (o = this.handler.peer) || void 0 === o ? void 0 : o.getStatsWithLowFrequency(e, false, null === (n = this._stream.audioTransceiver) || void 0 === n ? void 0 : n.receiver));
    if (!f.length) return d;
    f.forEach((e2) => {
      let { type: t2, packetsLost: r2, packetsReceived: o2, bytesReceived: n2, jitterBufferDelay: s2, jitterBufferEmittedCount: a2, clockRate: u2, channels: h2, totalSamplesReceived: _2, concealedSamples: p2, silentConcealedSamples: m2, concealmentEvents: S2, totalRoundTripTime: g2, packetsDiscarded: f2, state: y2, currentRoundTripTime: E2, audioLevel: T2, totalAudioEnergy: b, totalSamplesDuration: I, mimeType: R, googDecodingNormal: C, googDecodingMuted: P, availableIncomingBitrate: A, availableOutgoingBitrate: O, bytesSent: k, nominated: N, id: w, writable: M, jitter: D, candidateType: L, ip: $2, address: x, networkType: V, port: U, protocol: W, audioOutputLevel: F, requestsReceived: Z, responsesReceived: G, requestsSent: H, consentRequestsSent: K, responsesSent: X, ssrc: B, nackCount: Y, lastPacketReceivedTimestamp: j, concealmentevents: J, fecPacketsReceived: z } = e2;
      if ("inbound-rtp" === t2) c2.packetsLost = r2, c2.packetsReceived = o2, v3.packetsLost = r2, v3.packetsReceived = o2, v3.packetsDiscarded = f2, v3.nackCount = Y, v3.lastPacketReceivedTimestamp = j, v3.concealmentevents = J, c2.bytesReceived = n2, void 0 !== s2 && (d.jitterBufferDelay = s2 / a2 * 1e3, v3.average_jitter_buffer_delay_ms = d.jitterBufferDelay), void 0 !== _2 && (c2.totalSamplesReceived = _2, d.concealedSamples = p2, c2.concealedSamples = p2, c2.silentConcealedSamples = m2, v3.concealedSamples = p2, d.concealmentEvents = S2, v3.totalSamplesReceived = _2), void 0 !== z && (v3.fec_packets_received = z, c2.fecPacketsReceived = z), v3.jitter = 1e3 * D, v3.ssrc = B, void 0 !== T2 && 0 !== T2 ? (v3.audio_level = T2 ? -10 * Math.log10(Math.pow(T2, 2)) : T2, v3.volume = 255 * T2) : (v3.volume = null != i ? i : 255 * T2, v3.audio_level = i ? -10 * Math.log10(Math.pow(i / 255, 2)) : i), void 0 !== b && (v3.total_audio_energy = b), void 0 !== I && (v3.totalAudioDuration = I);
      else if ("codec" === t2) d.recordSampleRate = u2, h2 && (d.numChannels = h2), v3.codecName = R, d.codecType = R;
      else if ("candidate-pair" === t2) {
        var Q;
        v3.ice_available_incoming_bitrate = A, v3.ice_available_outgoing_bitrate = O, v3.ice_bytes_received = n2, v3.ice_bytes_sent = k, v3.ice_nominated = Number(N), v3.ice_pair_id = w, v3.ice_pair_rtt = E2, v3.rtt = 1e3 * E2, v3.rtt && null !== (Q = this._context.streamRTT) && void 0 !== Q && null !== (Q = Q[l]) && void 0 !== Q && Q.audio && (v3.total_rtt_ms = Math.round(v3.rtt + this._context.streamRTT[l].audio)), v3.ice_pair_state = y2, v3.ice_pair_writable = M, v3.recv_ping_requests = Z, v3.recv_ping_responses = G, v3.sent_ping_requests_before_first_response = H, v3.sent_ping_requests_total = H + (K || 0), v3.sent_ping_responses = X, "succeeded" === y2 && (d.rtt = 1e3 * E2, d.total_rtt = 1e3 * g2);
      } else "track" === t2 && void 0 !== T2 ? (0 === T2 && 0 !== i ? (v3.volume = i, v3.audio_level = i ? -10 * Math.log10(Math.pow(i / 255, 2)) : i) : (v3.audio_level = T2 ? -10 * Math.log10(Math.pow(T2, 2)) : T2, v3.volume = 255 * T2), v3.total_audio_energy = b, v3.totalAudioDuration = I) : "ssrc" === t2 ? (v3.decodingNormal = C, v3.recvAudioLevel = F, v3.decodingMuted = P) : "local-candidate" === t2 ? (v3.local_candidate_type = L, v3.local_ip = $2 || x, v3.local_network_type = V, v3.local_port = U, v3.protocol = W) : "remote-candidate" === t2 && (v3.remote_candidate_type = L, v3.remote_ip = $2 || x, v3.remote_port = U);
    });
    const { audio: y } = t;
    if (!y.timestamp) return c2.timestamp = Date.now(), t.audio = c2, this.filterIllegal(d);
    let E;
    var T;
    (void 0 !== c2.concealedSamples && (v3.interval_concealed_samples = c2.concealedSamples - y.concealedSamples, v3.interval_samples_received = c2.totalSamplesReceived - y.totalSamplesReceived, v3.interval_silent_concealed_samples = c2.silentConcealedSamples - y.silentConcealedSamples, E = await this._stream.updateAudioStallInfo(v3, d, c2)), c2.timestamp = Date.now(), d.audioLossRate = Math.max(0, c2.packetsLost - y.packetsLost) / (c2.packetsReceived - y.packetsReceived + (c2.packetsLost - y.packetsLost)), d.audioLossRate = Number.isNaN(d.audioLossRate) ? 0 : d.audioLossRate, v3.fraction_lost = d.audioLossRate, d.statsInterval = c2.timestamp - y.timestamp, v3.stats_interval = d.statsInterval, d.receivedKBitrate = (c2.bytesReceived - y.bytesReceived || 0) / d.statsInterval * 8, v3.bandwidth = Math.round(1e3 * d.receivedKBitrate / 1024), void 0 !== c2.concealedSamples && (d.receivedSampleRate = 1e3 * v3.interval_samples_received / d.statsInterval), void 0 !== c2.fecPacketsReceived && (v3.fecBitratebps = (c2.fecPacketsReceived - y.fecPacketsReceived || 0) / d.statsInterval), v3.average_jitter_buffer_delay_ms && v3.total_rtt_ms && (d.e2eDelay = v3.average_jitter_buffer_delay_ms + v3.total_rtt_ms), null !== (s = this._context.streamRTT) && void 0 !== s && null !== (s = s[l]) && void 0 !== s && s.audio && (d.totalRtt = (v3.rtt ? v3.rtt : 0) + this._context.streamRTT[l].audio), t.audio = c2, v3.vendor_mode = this._stream.vendorCode || 0, v3.pc_session_id = null === (a = this.handler) || void 0 === a ? void 0 : a.peerConnectionId, r) && (null === (T = this._monitor) || void 0 === T || T.report("rtc_media_statistics", v3, E));
    return this.filterIllegal(d);
  }
  async getRemoteVideoStats(e, t, i) {
    var r, o, n, s, a;
    const d = {}, c2 = { timestamp: Date.now() }, { streamId: l, userId: u, isScreen: h, subMediaType: _, _attributes: p } = this._stream, m = _objectSpread2({ media_type: "video", is_screen: !!h, direction: "down", stream_id: l, stream_user_id: u, vid: this._stream.videoMid, connection_status: navigator.onLine, track_enabled: null == e ? void 0 : e.enabled, mute_state: videoInMediaType(_) ? "mute_state_off" : "mute_state_on", remote_user_capture_state: p.localvideo ? "capture_state_on" : "capture_state_off", remote_user_mute_state: p.localvideo && p.videostream ? "mute_state_off" : "mute_state_on", is_intersecting: JSON.stringify(null === (r = this._stream.videoTrack) || void 0 === r ? void 0 : r.intersection()), thermal_status: computePressureMonitor.state, is_public_stream: this._stream.isPublicStream }, this._stream.getVideoRenderInfo());
    if (!e || !this.handler) return d;
    d.isScreen = h;
    const S = await (null === (o = this.handler.peer) || void 0 === o ? void 0 : o.getStatsWithLowFrequency(e, false, null === (n = this._stream.videoTransceiver) || void 0 === n ? void 0 : n.receiver));
    if (!S.length) return d;
    S.forEach((e2) => {
      let { type: t2, frameHeight: i2, frameWidth: r2, packetsLost: o2, packetsReceived: n2, bytesReceived: s2, framesDecoded: a2, jitterBufferDelay: u2, jitterBufferEmittedCount: h2, mimeType: _2, firCount: p2, availableIncomingBitrate: S2, availableOutgoingBitrate: g2, bytesSent: v5, nominated: f2, id: y2, currentRoundTripTime: E, state: T, writable: b, candidateType: I, ip: R, address: C, networkType: P, port: A, nackCount: O, pliCount: k, protocol: N, requestsReceived: w, responsesReceived: M, requestsSent: D, consentRequestsSent: L, responsesSent: $2, ssrc: x, jitter: V, framesReceived: U, keyFramesDecoded: W, totalDecodeTime: F, decoderImplementation: Z, lastPacketReceivedTimestamp: G, framesDropped: H } = e2;
      if ("inbound-rtp" === t2) c2.packetsLost = o2, m.packetsLost = o2, c2.packetsReceived = n2, m.packetsReceived = n2, c2.bytesReceived = s2, m.bytes = s2, c2.framesDecoded = a2, c2.totalDecodeTime = F, void 0 !== u2 && (c2.jitterBufferDelay = u2 / h2 * 1e3, m.average_jitter_buffer_delay_ms = c2.jitterBufferDelay), m.fir_count = p2, m.nackCount = O, c2.nackCount = O, m.pli_count = k, m.ssrc = x, m.framesDropped = H, m.jitter = 1e3 * V, m.framesReceived = U, c2.framesReceived = U, m.framesDecoded = a2, m.key_frames_decoded = W, m.decoder_name = Z, d.decoderName = Z, m.last_packet_received_timestamp = G, void 0 !== r2 && (d.width = r2, m.frame_size_width = r2, d.height = i2, m.frame_size_height = i2);
      else if ("track" === t2 && void 0 !== r2) d.width = r2, m.frame_size_width = r2, d.height = i2, m.frame_size_height = i2, void 0 !== U && (m.framesReceived = U, c2.framesReceived = U);
      else if ("codec" === t2) m.codecName = _2, d.codecType = _2;
      else if ("candidate-pair" === t2) {
        var K;
        m.ice_available_incoming_bitrate = S2, m.ice_available_outgoing_bitrate = g2, m.ice_bytes_received = s2, m.ice_bytes_sent = v5, m.ice_nominated = Number(f2), m.ice_pair_id = y2, m.ice_pair_rtt = E, m.rtt = 1e3 * E, m.rtt && null !== (K = this._context.streamRTT) && void 0 !== K && null !== (K = K[l]) && void 0 !== K && K.video && (m.total_rtt_ms = Math.round(m.rtt + (this._context.streamRTT[l].video || 0))), d.rtt = m.rtt, m.ice_pair_state = T, m.ice_pair_writable = b, m.recv_ping_requests = w, m.recv_ping_responses = M, m.sent_ping_requests_before_first_response = D, m.sent_ping_requests_total = D + (L || 0), m.sent_ping_responses = $2;
      } else "local-candidate" === t2 ? (m.local_candidate_type = I, m.local_ip = R || C, m.local_network_type = P, m.local_port = A, m.protocol = N) : "remote-candidate" === t2 && (m.remote_candidate_type = I, m.remote_ip = R || C, m.remote_port = A);
    });
    const { video: g } = t;
    if (!g.timestamp) return t.video = c2, this.filterIllegal(d);
    const v3 = Math.max(0, c2.packetsLost - g.packetsLost), f = c2.packetsReceived - g.packetsReceived;
    if (d.videoLossRate = v3 / (f + v3), d._receivePackets = c2.packetsReceived, d._receivePacketsLost = c2.packetsLost, g.totalDecodeTime && g.framesDecoded && c2.framesDecoded !== g.framesDecoded) {
      const e2 = c2.totalDecodeTime - g.totalDecodeTime, t2 = c2.framesDecoded - g.framesDecoded;
      m.decode_elapse_per_frame = Number((e2 / t2 * 1e3).toFixed(2));
    }
    var y;
    (d._retransmittedRate = (c2.nackCount - g.nackCount) / (f + v3), d.videoLossRate = Number.isNaN(d.videoLossRate) ? 0 : d.videoLossRate, m.fraction_lost = d.videoLossRate, d.statsInterval = c2.timestamp - g.timestamp, m.stats_interval = d.statsInterval, d.receivedKBitrate = (c2.bytesReceived - g.bytesReceived || 0) / d.statsInterval * 8, m.bitrate = Math.round(1e3 * d.receivedKBitrate), m.bandwidth = Math.round(m.bitrate / 1024), d.decoderOutputFrameRate = 1e3 * (c2.framesDecoded - g.framesDecoded) / d.statsInterval, d.receivedFrameRate = 1e3 * (c2.framesReceived - g.framesReceived) / d.statsInterval, m.frame_rate_decoded = Math.round(d.decoderOutputFrameRate), m.frame_rate_received = Math.round(d.receivedFrameRate), m.average_jitter_buffer_delay_ms && m.total_rtt_ms && (d.e2eDelay = m.average_jitter_buffer_delay_ms + m.total_rtt_ms), null !== (s = this._context.streamRTT) && void 0 !== s && null !== (s = s[l]) && void 0 !== s && s.video && (d.totalRtt = (m.rtt ? m.rtt : 0) + (this._context.streamRTT[l].video || 0)), t.video = c2, this._stream.updateVideoStallInfo(m, d, i), m.vendor_mode = this._stream.vendorCode || 0, m.pc_session_id = null === (a = this.handler) || void 0 === a ? void 0 : a.peerConnectionId, d.frameSizeWidth = m.frame_size_width, d.frameSizeHeight = m.frame_size_height, d.decoderName = m.decoder_name, i) ? null === (y = this._monitor) || void 0 === y || y.report("rtc_media_statistics", m) : this.statsMonitor.setRemoteVideoStats(m, e);
    return this.filterIllegal(d);
  }
  destroy() {
    super.destroy(), super.stopReport("destroy"), this._stream.stopAudioStallObserve(), this.statsMonitor.destroy();
  }
};
var VideoStallObserver = class {
  constructor(e, t) {
    _defineProperty(this, "_removeHandler", void 0), _defineProperty(this, "_remotePauseHandler", void 0), _defineProperty(this, "_prePts", void 0), _defineProperty(this, "_stallList", void 0), _defineProperty(this, "_videoInWaiting", false), _defineProperty(this, "_videoInWaitingCallback", false), _defineProperty(this, "_videoInWaiting100ms", false), _defineProperty(this, "_isPaused", void 0), _defineProperty(this, "_pauseStart", 0), _defineProperty(this, "_pauseDuration", 0), _defineProperty(this, "_requestVideoFrameCallbackTimer", void 0), _defineProperty(this, "_logger", void 0), _defineProperty(this, "_player", void 0), _defineProperty(this, "_recentVideoInfo", void 0), _defineProperty(this, "_stallTimeThreshold", void 0), _defineProperty(this, "_openVideoStall100ms", Config2.VIDEO_STALL_100MS);
    const i = e ? 1500 : isSafari || isFirefox ? 550 : 500;
    this._stallTimeThreshold = { report: i, callback: Math.max(Config2.VIDEO_STALL_DATA, i) }, this._logger = new Logger$1("VideoStallObserver", 1, t);
  }
  start(e) {
    if (this._logger.print("start", "invoke"), this._player = e, checkVideoFrameCallback()) e.domElement && (this._requestVideoFrameCallbackTimer = e.domElement.requestVideoFrameCallback(this._onVideoRefresh.bind(this)), this._removeHandler = () => {
      var t2;
      this._requestVideoFrameCallbackTimer && (null === (t2 = e.domElement) || void 0 === t2 || t2.cancelVideoFrameCallback(this._requestVideoFrameCallbackTimer));
    });
    else {
      const t2 = (t3) => this._onVideoTimeupdate(t3, e);
      e.on("playback_event", t2), this._removeHandler = () => e.off("playback_event", t2);
    }
    const t = (e2) => this._onVideoPause(e2);
    e.on("playback_event", t), this._remotePauseHandler = () => e.off("playback_event", t);
  }
  getRecentRenderInfo4Report() {
    const e = {};
    return this._recentVideoInfo && Object.keys(this._recentVideoInfo).forEach((t) => {
      var i;
      const r = t.replace(/[a-z]{1}[A-Z]{1}/g, (e2) => "".concat(e2[0], "_").concat(e2[1].toLowerCase()));
      e["video_".concat(r)] = null === (i = this._recentVideoInfo) || void 0 === i ? void 0 : i[t];
    }), e;
  }
  stop() {
    var e, t;
    this._logger.print("stop", "invoke"), delete this._player, null === (e = this._removeHandler) || void 0 === e || e.call(this), delete this._removeHandler, null === (t = this._remotePauseHandler) || void 0 === t || t.call(this), delete this._remotePauseHandler, delete this._stallList, delete this._prePts, delete this._recentVideoInfo, this._videoInWaiting = false, this._videoInWaitingCallback = false, this._videoInWaiting100ms = false;
  }
  destroy() {
    this.stop();
  }
  getStallInfo(e) {
    let { interval: t, frameRateReceived: i, frameRateDecoded: r, bitrate: o } = e;
    const n = { pts: 0, report: { stallCount: 0, stallDuration: 0, list: [] }, callback: { stallCount: 0, stallDuration: 0 }, pauseDuration: this._getPauseDuration() };
    if (this._stallList) {
      (isSafari || isFirefox) && (0 === o || (r || 1 / 0) <= 1 || (i || 1 / 0) <= 1) || 0 === this._stallList.length ? (n.report.stallDuration = n.callback.stallDuration = 2e3, n.report.stallCount = n.callback.stallCount = this._videoInWaiting ? 0 : 1, this._openVideoStall100ms && (n.stall100ms = { count: this._videoInWaiting100ms ? 0 : 1, duration: 2e3 }), this._videoInWaiting = true, this._videoInWaitingCallback = true, this._videoInWaiting100ms = true) : this._stallList.forEach((e2, i2) => {
        let r2 = e2.timeUpdateInterval;
        0 === i2 && this._videoInWaiting && (r2 = Math.round(e2.timeUpdateInterval % t));
        const o2 = e2.timeUpdateInterval > this._stallTimeThreshold.report;
        o2 && (n.report.list.push(e2.timeUpdateInterval), n.report.stallDuration += r2, this._videoInWaiting || n.report.stallCount++), this._videoInWaiting = o2, e2.timeUpdateInterval > this._stallTimeThreshold.callback ? (n.callback.stallDuration += r2, this._videoInWaitingCallback || n.callback.stallCount++, this._videoInWaitingCallback = true) : this._videoInWaitingCallback = false, this._openVideoStall100ms && (n.stall100ms || (n.stall100ms = { count: 0, duration: 0 }), e2.timeUpdateInterval > 100 ? (n.stall100ms.duration += r2, this._videoInWaiting100ms || n.stall100ms.count++, this._videoInWaiting100ms = true) : this._videoInWaiting100ms = false), n.pts = e2.playTime;
      }), this._stallList = [];
    }
    return n;
  }
  _getPauseDuration() {
    let e = this._pauseDuration;
    if (this._pauseDuration = 0, this._isPaused) {
      const t = getServerNow(), i = t - (this._pauseStart || 0);
      i > 500 && (this._pauseStart = t, e += i);
    }
    return e;
  }
  _onVideoPause(e) {
    if ("pause" === e.eventName) this._isPaused = true, this._pauseStart = getServerNow();
    else if ("play" === e.eventName && this._isPaused) {
      this._isPaused = false;
      const e2 = getServerNow() - this._pauseStart;
      e2 > 500 && (this._pauseDuration += e2);
    }
  }
  _onVideoTimeupdate(e, t) {
    if ("timeupdate" === e.eventName) {
      const e2 = t.domElement;
      if (!e2 || 0 === e2.currentTime) return;
      if (void 0 === this._prePts) return void (this._prePts = e2.currentTime);
      if (this._stallList || (this._stallList = []), e2.currentTime > this._prePts) {
        const t2 = e2.currentTime - this._prePts;
        this._stallList.push({ playTime: e2.currentTime, timeUpdateInterval: Math.round(1e3 * t2) });
      }
      this._prePts = e2.currentTime;
    }
  }
  _onVideoRefresh(e, t) {
    var i;
    if (this._stallList || (this._stallList = []), this._prePts) {
      const e2 = t.presentationTime - this._prePts;
      this._stallList.push({ playTime: t.presentationTime, timeUpdateInterval: Math.round(e2) });
    }
    this._recentVideoInfo = t, this._prePts = t.presentationTime, null === (i = this._player) || void 0 === i || null === (i = i.domElement) || void 0 === i || i.requestVideoFrameCallback(this._onVideoRefresh.bind(this));
  }
};
var AudioStallObserver = class _AudioStallObserver {
  constructor(e) {
    _defineProperty(this, "_audioStallTimer", void 0), _defineProperty(this, "_preSample", void 0), _defineProperty(this, "_isStallInPreCallbackEnd", false), _defineProperty(this, "_isStallInPreReportEnd", false), _defineProperty(this, "_stallList", []), this._stream = e;
  }
  static setAudioStallConfig(e) {
    _AudioStallObserver.interval = ((null == e ? void 0 : e.audio_stall_interval) || 200) / 2, _AudioStallObserver.ratio = (null == e ? void 0 : e.audio_stall_ratio) || 0.6;
  }
  start(e, t) {
    this.stop(), Config2.AUDIO_STALL && _AudioStallObserver.interval > 0 && "number" == typeof e && "number" == typeof t && (this._preSample = { ts: getServerNow(), concealedSamples: e, totalSamplesReceived: t }, this._startStallCountInterval());
  }
  stop() {
    this._stallList = [], this._audioStallTimer && (clearTimeout(this._audioStallTimer), delete this._audioStallTimer);
  }
  destroy() {
    this.stop();
  }
  async getAudioStallInfo() {
    const e = { stats_count: this._stallList.filter((e2) => !!e2.get_stats_cost).length, stall_list: [...this._stallList] };
    try {
      await this._audioStallCount();
    } catch (e2) {
    }
    const t = computeStallInfo(this._stallList, 2, this._isStallInPreReportEnd);
    this._isStallInPreReportEnd = t.isStallInEnd;
    const i = Config2.AUDIO_STALL_DATA / _AudioStallObserver.interval, r = computeStallInfo(this._stallList, i, this._isStallInPreCallbackEnd);
    return this._isStallInPreCallbackEnd = r.isStallInEnd, this.stop(), this._startStallCountInterval(), { report: { stall_count: t.stall_count, stall_duration: t.stall_duration, list: t.list }, callback: { stall_count: r.stall_count, stall_duration: r.stall_duration, list: r.list }, extra: e };
  }
  _startStallCountInterval() {
    const e = async () => {
      clearTimeout(this._audioStallTimer), delete this._audioStallTimer, await this._audioStallCount(), this._audioStallTimer || (this._audioStallTimer = setTimeout(e, _AudioStallObserver.interval));
    };
    this._audioStallTimer = setTimeout(e, _AudioStallObserver.interval);
  }
  async _audioStallCount() {
    if (!this._preSample || getServerNow() - this._preSample.ts < 0.5 * _AudioStallObserver.interval) return;
    const { hasAudio: e, subAudio: t, virtual: i, virtualOccupy: r, removeTrack: o, audioTrack: n } = this._stream;
    if (o || !n) return clearTimeout(this._audioStallTimer), void delete this._audioStallTimer;
    const s = e && t;
    if (!s || i && !r) this._preSample.ts = getServerNow(), this._stallList.push({ reason: s ? "virtual: ".concat(i, ", virtualOccupy: ").concat(r) : "hasAudio: ".concat(e, ", subAudio: ").concat(t) });
    else {
      const e2 = getServerNow();
      let t2, i2, r2 = 0;
      try {
        var a;
        const e3 = await (null === (a = this._stream.audioTransceiver) || void 0 === a ? void 0 : a.receiver.getStats());
        null == e3 || e3.forEach((e4) => {
          "inbound-rtp" === e4.type && (t2 = e4), r2++;
        });
      } catch (e3) {
        i2 = e3.message || JSON.stringify(e3);
      }
      const o2 = getServerNow(), n2 = getServerNow(), s2 = n2 - this._preSample.ts;
      if (t2) {
        const { concealedSamples: i3, totalSamplesReceived: r3 } = t2, a2 = i3 - this._preSample.concealedSamples, d = r3 - this._preSample.totalSamplesReceived, c2 = a2 >= 0 && d >= 0 && a2 >= _AudioStallObserver.ratio * d;
        this._stallList.push({ concealed: a2, received: d, diff: s2, start: this._preSample.ts, end: n2, get_stats_cost: o2 - e2, get_stats_start: e2, get_stats_end: o2, is_stall: c2 }), this._preSample.concealedSamples = i3, this._preSample.totalSamplesReceived = r3, this._preSample.ts = n2;
      } else this._stallList.push({ diff: s2, start: this._preSample.ts, end: n2, get_stats_cost: o2 - e2, get_stats_start: e2, get_stats_end: o2, reason: r2 ? i2 || "no inbound-rtp" : "no report" });
    }
  }
};
_defineProperty(AudioStallObserver, "interval", 100), _defineProperty(AudioStallObserver, "ratio", 0.6);
var computeStallInfo = (e, t, i) => {
  var r;
  const o = { stall_count: 0, stall_duration: 0, isStallInEnd: false, list: [] };
  let n = 0, s = 0;
  for (let i2 = 0; i2 < e.length; i2++) {
    const r2 = e[i2];
    r2.is_stall && (n++, s += r2.diff || 0);
    const a = i2 === e.length - 1;
    if (!r2.is_stall || a) {
      let r3 = n >= t;
      const d = i2 + t - n - 1;
      if (!r3 && n > 2) {
        let o2 = 0;
        e.slice(i2 + 1, d + 1).forEach((e2) => {
          e2.is_stall && (o2 += e2.diff || 0);
        }), r3 = s + o2 > AudioStallObserver.interval * t * AudioStallObserver.ratio, r3 && (i2 = d, s += o2);
      }
      r3 && (o.stall_count++, o.stall_duration += s, o.list.push(s)), a && (o.isStallInEnd = r3), n = s = 0;
    }
  }
  return true === (null === (r = e[0]) || void 0 === r ? void 0 : r.is_stall) && i && o.stall_count > 0 && o.stall_count--, o;
};
var RTCExtensionType = ((e) => (e[e.CAPTURE = 0] = "CAPTURE", e[e.PRE_PROCESSING = 1] = "PRE_PROCESSING", e[e.ENCODE = 2] = "ENCODE", e[e.TRANSFER = 3] = "TRANSFER", e[e.POST_PROCESSING = 4] = "POST_PROCESSING", e[e.DECODE = 5] = "DECODE", e[e.RENDERING = 6] = "RENDERING", e))(RTCExtensionType || {});
var StreamIndex = ((e) => (e[e.STREAM_INDEX_MAIN = 0] = "STREAM_INDEX_MAIN", e[e.STREAM_INDEX_SCREEN = 1] = "STREAM_INDEX_SCREEN", e))(StreamIndex || {});
var ExtensionManager = class {
  constructor(e) {
    _defineProperty(this, "_plugins", /* @__PURE__ */ new Map()), this.id = e;
  }
  register(e) {
    const t = this._plugins.get(e.type) || [];
    if (t.findIndex((t2) => t2.name === e.name) > -1) throw new Error("Failed to register ".concat(e.name, ": name is repeated."));
    t.push(e), this._plugins.set(e.type, t);
  }
  getPluginsByType(e) {
    return this._plugins.get(e) || [];
  }
  getPluginByName(e, t) {
    return (this._plugins.get(e) || []).find((e2) => e2.name === t);
  }
  async getPreProcessingTrack(e) {
    const t = this._plugins.get(1) || [];
    let i = e.mediaTrack;
    for (const r of t) i = await r.effect(e, i);
    return i;
  }
  destroy() {
    this._plugins.forEach((e) => {
      e.forEach((e2) => e2.destroy());
    }), this._plugins.clear();
  }
};
var logger$9 = new Logger$1("InternalEventBus", 1);
var InternalEvent = ((e) => (e.ON_IOS_INTERRUPTION_START = "ON_IOS_INTERRUPTION_START", e.ON_IOS_INTERRUPTION_END = "ON_IOS_INTERRUPTION_END", e.ON_IOS_LOCAL_TRACK_MUTE = "ON_IOS_LOCAL_TRACK_MUTE", e.ON_IOS_LOCAL_TRACK_UNMUTE = "ON_IOS_LOCAL_TRACK_UNMUTE", e))(InternalEvent || {});
var InternalEventBus = class extends eventemitter3Exports.EventEmitter {
  emit(e) {
    logger$9.info(e);
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    return super.emit(e, ...i);
  }
};
var internalEventBus = new InternalEventBus();
var dumpAudioDataWorklet = "data:application/javascript;base64,Y2xhc3MgRHVtcEF1ZGlvRGF0YSBleHRlbmRzIEF1ZGlvV29ya2xldFByb2Nlc3NvciB7CiAgcHJvY2VzcyhpbnB1dHMpIHsKICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSh7CiAgICAgIGRhdGE6IGlucHV0c1swXSwKICAgICAgY2hhbm5lbENvdW50OiBpbnB1dHNbMF0ubGVuZ3RoLAogICAgICBzYW1wbGVSYXRlLAogICAgfSk7CiAgICByZXR1cm4gdHJ1ZTsKICB9Cn0KCnJlZ2lzdGVyUHJvY2Vzc29yKCdkdW1wLWF1ZGlvLWRhdGEnLCBEdW1wQXVkaW9EYXRhKTsK";
var logger$8 = new Logger$1("AudioContext", 1);
var WebAudioManager = class {
  constructor() {
    _defineProperty(this, "isWorkletReady", void 0), _defineProperty(this, "_audioContextInstance", void 0), _defineProperty(this, "_previousState", ""), _defineProperty(this, "_currentState", ""), _defineProperty(this, "_contextStuckAt", 0);
    let e = 0;
    isSSR() || setInterval(() => {
      if (this._audioContextInstance) {
        const t = this._audioContextInstance.currentTime;
        this._contextStuckAt ? this._contextStuckAt !== t && (this._contextStuckAt = 0, logger$8.info("currentTime resume"), reportGlobalInvokeStatus("currentTime resume", "")) : t && e === t && (this._contextStuckAt = t, logger$8.warn("currentTime stuck", this._contextStuckAt), this._audioContextInstance.suspend(), this._audioContextInstance.resume(), reportGlobalInvokeStatus("AudioContext currentTime stuck", this._contextStuckAt)), e = t;
      }
    }, 3e3);
  }
  getAudioContextInstance() {
    if (!this._audioContextInstance) {
      const e = window.AudioContext || window.webkitAudioContext;
      this._audioContextInstance = is48kSupported ? new e() : new e({ sampleRate: 44100 });
      try {
        this.isWorkletReady = this._audioContextInstance.audioWorklet.addModule(dumpAudioDataWorklet), this.isWorkletReady.catch((e2) => {
          reportGlobalError("initial AudioWorklet error in promise", -1, "".concat(e2.name, "-").concat(e2.message)), logger$8.error("isWorkletReady", e2), this.isWorkletReady = null;
        });
      } catch (e2) {
        reportGlobalError("initial AudioWorklet error in catch", -1, "".concat(e2.name, "-").concat(e2.message)), logger$8.error("isWorkletReady", e2), this.isWorkletReady = null;
      }
      this._audioContextInstance.onstatechange = () => {
        var e2, t, i;
        logger$8.warn("state change", null === (e2 = this._audioContextInstance) || void 0 === e2 ? void 0 : e2.state), this._previousState = this._currentState, this._currentState = (null === (t = this._audioContextInstance) || void 0 === t ? void 0 : t.state) || "", "interrupted" === (null === (i = this._audioContextInstance) || void 0 === i ? void 0 : i.state) && this._audioContextInstance.resume(), (isIOS || isIPad) && ("running" === this._previousState && "interrupted" === this._currentState && internalEventBus.emit(InternalEvent.ON_IOS_INTERRUPTION_START), "interrupted" === this._previousState && "running" === this._currentState && internalEventBus.emit(InternalEvent.ON_IOS_INTERRUPTION_END));
      };
    }
    return this._audioContextInstance;
  }
};
var AudioLevelFetcher = class {
  constructor(e) {
    _defineProperty(this, "_ctx", void 0), _defineProperty(this, "_analyserNode", void 0), _defineProperty(this, "_audioSource", void 0), _defineProperty(this, "currentTrackId", void 0), this.currentTrackId = e.id;
    const t = audioContextManager.getAudioContextInstance();
    if (e instanceof MediaStreamTrack) {
      const i2 = new MediaStream();
      i2.addTrack(e), this._audioSource = t.createMediaStreamSource(i2);
    } else this._audioSource = t.createMediaElementSource(e), this._audioSource.connect(t.destination);
    const i = t.createAnalyser();
    this._audioSource.connect(i), this._analyserNode = i, this._ctx = t;
  }
  getAudioLevel() {
    var e;
    "suspended" === (null === (e = this._ctx) || void 0 === e ? void 0 : e.state) && this._ctx.resume();
    const t = new Uint8Array(2048);
    this._analyserNode.getByteTimeDomainData(t);
    let i = 0;
    t.forEach((e2) => i = Math.max(i, Math.abs(e2 - 128)));
    const r = i / 128 * 255;
    return r > 2 ? r : 0;
  }
  async resume() {
    var e;
    await (null === (e = this._ctx) || void 0 === e ? void 0 : e.resume());
  }
  destroy() {
    this._audioSource.disconnect(), this._analyserNode.disconnect();
  }
};
var AudioDataFetcher = class extends eventemitter3Exports.EventEmitter {
  constructor(e, t) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : audioContextManager.getAudioContextInstance(), r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : audioContextManager.isWorkletReady;
    var o;
    (super(), _defineProperty(this, "_ctx", void 0), _defineProperty(this, "_worklet", void 0), _defineProperty(this, "_source", void 0), _defineProperty(this, "_buffers", []), _defineProperty(this, "_bufferLength", 0), _defineProperty(this, "_sampleRate", void 0), _defineProperty(this, "_channelCount", void 0), _defineProperty(this, "_frameSize", void 0), e instanceof MediaStreamTrack) ? this._channelCount = null !== (o = e.getSettings().channelCount) && void 0 !== o ? o : 1 : this._channelCount = e.channelCount;
    this._ctx = i, this._frameSize = t, null == r || r.then(() => {
      this._worklet = new AudioWorkletNode(this._ctx, "dump-audio-data"), e instanceof MediaStreamTrack ? this._source = this._ctx.createMediaStreamSource(new MediaStream([e])) : this._source = e, this._source.connect(this._worklet), this._initWorkletEventListener(this._worklet);
    }).catch();
  }
  _initWorkletEventListener(e) {
    e.port.onmessage = this._handleWorkletMessage.bind(this);
  }
  _handleWorkletMessage(e) {
    const { data: t, sampleRate: i } = e.data;
    if (this._bufferLength >= this._frameSize || this._sampleRate !== i) {
      if (this._sampleRate) {
        const e2 = 1 === this._channelCount || 1 === t.length ? 1 : 2;
        this.emit("data", { channels: [...this._buffers], sampleRate: this._sampleRate, channelCount: e2 });
      }
      this._sampleRate = i, this._buffers = new Array(this._channelCount).fill(0).map(() => new Float32Array(this._frameSize)), this._bufferLength = 0;
    }
    for (let e2 = 0; e2 < this._channelCount; e2++) this._buffers[e2].set(t[e2], this._bufferLength);
    this._bufferLength = this._bufferLength + t[0].length;
  }
  setFrameSize(e) {
    this._frameSize = e;
  }
  destroy() {
    var e, t, i;
    this.removeAllListeners("data"), this._worklet && (null === (e = this._source) || void 0 === e || e.disconnect(this._worklet)), null === (t = this._worklet) || void 0 === t || t.disconnect(), null === (i = this._worklet) || void 0 === i || i.port.close(), this._buffers = [], delete this._source, delete this._worklet;
  }
};
var audioContextManager = new WebAudioManager();
var createElement$1 = function(e) {
  let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const i = document.createElement(e);
  return t.id && (i.id = t.id), t.classList && t.classList.forEach((e2) => {
    i.classList.add(e2);
  }), t.style && Object.assign(i.style, t.style), t.attributes && Object.entries(t.attributes).forEach((e2) => {
    let [t2, r] = e2;
    "muted" === t2 ? i.muted = true : i.setAttribute(t2, r);
  }), i;
};
var DeviceDetector = class extends EnhancedEventEmitter {
  constructor() {
    var e;
    super(), _defineProperty(this, "deviceMap", { audioinput: /* @__PURE__ */ new Map(), audiooutput: /* @__PURE__ */ new Map(), videoinput: /* @__PURE__ */ new Map() }), _defineProperty(this, "checkDeviceChangeTimer", null), _defineProperty(this, "isSupportedPermissionsQuery", false), _defineProperty(this, "isGrantedMicrophonePermission", false), _defineProperty(this, "isGrantedCameraPermission", false), this.isSupportedPermissionsQuery = !isSSR() && !(null === (e = navigator) || void 0 === e || null === (e = e.permissions) || void 0 === e || !e.query), this._handleDeviceChange = this._handleDeviceChange.bind(this), !isSSR() && this.initListener().then(() => {
      this.updateDeviceListInSilent();
    });
  }
  async refreshDevices() {
    let e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "audio";
    if (!navigator.mediaDevices) return;
    if (isFirefox) try {
      e = "audio" === t ? await navigator.mediaDevices.getUserMedia({ audio: true }) : await navigator.mediaDevices.getUserMedia({ video: true });
    } catch (e2) {
    }
    const i = await navigator.mediaDevices.enumerateDevices();
    e && e.getTracks().forEach((e2) => e2.stop()), i.forEach((e2) => {
      var t2;
      e2.deviceId && (null === (t2 = this.deviceMap[e2.kind]) || void 0 === t2 || t2.set(e2.deviceId, e2));
    });
  }
  async initListener() {
    var e, t;
    if (void 0 !== (null === (e = navigator.mediaDevices) || void 0 === e ? void 0 : e.ondevicechange) && "function" == typeof (null === (t = navigator.mediaDevices) || void 0 === t ? void 0 : t.addEventListener) ? navigator.mediaDevices.addEventListener("devicechange", () => {
      this._handleDeviceChange(), setTimeout(() => {
        this._handleDeviceChange();
      }, 300);
    }) : this.checkDeviceChangeTimer = window.setInterval(() => {
      this._handleDeviceChange();
    }, 3e3), this.isSupportedPermissionsQuery) {
      try {
        const e2 = await navigator.permissions.query({ name: "microphone" });
        this.isGrantedMicrophonePermission = "granted" === e2.state, e2.addEventListener("change", () => {
          this.isGrantedMicrophonePermission = "granted" === e2.state;
        });
      } catch (e2) {
      }
      try {
        const e2 = await navigator.permissions.query({ name: "camera" });
        this.isGrantedCameraPermission = "granted" === e2.state, e2.addEventListener("change", () => {
          this.isGrantedCameraPermission = "granted" === e2.state;
        });
      } catch (e2) {
      }
    }
  }
  async _handleDeviceChange() {
    if (!navigator.mediaDevices) return;
    let e;
    isFirefox && (e = await navigator.mediaDevices.getUserMedia({ audio: true }));
    let t = await navigator.mediaDevices.enumerateDevices();
    t = t.filter((e2) => !!e2.deviceId), e && e.getTracks().forEach((e2) => e2.stop());
    const i = Array.from([...this.deviceMap.audioinput.values(), ...this.deviceMap.videoinput.values(), ...this.deviceMap.audiooutput.values()]);
    (isMobile || isIPad) && !i.length && t.length && t.forEach((e2) => {
      var t2;
      null === (t2 = this.deviceMap[e2.kind]) || void 0 === t2 || t2.set(e2.deviceId, e2);
    }), i.forEach((e2) => {
      t.find((t2) => t2.deviceId === e2.deviceId && t2.kind === e2.kind && t2.label === e2.label) || (this.deviceMap[e2.kind].delete(e2.deviceId), e2.kind.includes("video") ? this.emit(EngineEventsTypes.onVideoDeviceStateChanged, { mediaDeviceInfo: e2, deviceState: "inactive" }) : e2.kind.includes("audio") && this.emit(EngineEventsTypes.onAudioDeviceStateChanged, { mediaDeviceInfo: e2, deviceState: "inactive" }));
    }), t.forEach((e2) => {
      const t2 = this.deviceMap[e2.kind].get(e2.deviceId);
      this.deviceMap[e2.kind].set(e2.deviceId, e2), t2 || (e2.kind.includes("video") ? this.emit(EngineEventsTypes.onVideoDeviceStateChanged, { mediaDeviceInfo: e2, deviceState: "active" }) : e2.kind.includes("audio") && this.emit(EngineEventsTypes.onAudioDeviceStateChanged, { mediaDeviceInfo: e2, deviceState: "active" }));
    });
  }
  async getUserMedia(e) {
    const t = await navigator.mediaDevices.getUserMedia(e);
    return null != e && e.audio && (this.isGrantedMicrophonePermission = true), null != e && e.video && (this.isGrantedCameraPermission = true), null != e && e.video ? this.refreshDevices("video") : this.refreshDevices("audio"), t;
  }
  async checkPermissionsByDevices() {
    const e = { audio: false, video: false };
    if (!navigator.mediaDevices) return e;
    const t = await navigator.mediaDevices.enumerateDevices();
    return e.audio = t.filter((e2) => "audioinput" === e2.kind && e2.label && e2.deviceId).length > 0, e.video = t.filter((e2) => "videoinput" === e2.kind && e2.label && e2.deviceId).length > 0, e;
  }
  async getPermissions() {
    var e;
    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, { audio: i, video: r } = t;
    const { force: o } = t;
    i || r || (i = true, r = true);
    const n = { audio: false, video: false, reason: void 0 };
    if (!o) if (this.isSupportedPermissionsQuery) {
      if (i && r) {
        if (this.isGrantedMicrophonePermission && this.isGrantedCameraPermission) return n.audio = true, n.video = true, n;
      } else if (i && this.isGrantedMicrophonePermission || r && this.isGrantedCameraPermission) return n.audio = this.isGrantedMicrophonePermission, n.video = this.isGrantedCameraPermission, n;
    } else {
      const e2 = await this.checkPermissionsByDevices();
      if (i && r) {
        if (e2.audio && e2.video) return e2;
      } else if (i && e2.audio || r && e2.video) return e2;
    }
    if (null !== (e = navigator.mediaDevices) && void 0 !== e && e.getUserMedia) try {
      const e2 = await navigator.mediaDevices.getUserMedia({ audio: i, video: r });
      e2 && (e2.getTracks().forEach((e3) => e3.stop()), i && (n.audio = true, this.isGrantedMicrophonePermission = true), r && (n.video = true, this.isGrantedCameraPermission = true));
    } catch (e2) {
      if (n.reason = e2, this.isSupportedPermissionsQuery) {
        var s, a;
        if (i) n.audio = "granted" === (null === (s = await navigator.permissions.query({ name: "microphone" }).catch(() => {
        })) || void 0 === s ? void 0 : s.state);
        if (r) n.video = "granted" === (null === (a = await navigator.permissions.query({ name: "camera" }).catch(() => {
        })) || void 0 === a ? void 0 : a.state);
      }
    }
    return i ? await this.refreshDevices("audio") : await this.refreshDevices("video"), n;
  }
  async updateDeviceListInSilent() {
    this.isGrantedCameraPermission && this.isGrantedMicrophonePermission && this.refreshDevices("audio");
  }
  async enumerateDevices() {
    return await this.getPermissions(), await this.refreshDevices(), Array.from([...this.deviceMap.audioinput.values(), ...this.deviceMap.videoinput.values(), ...this.deviceMap.audiooutput.values()]);
  }
  async enumerateAudioCaptureDevices() {
    return await this.getPermissions({ audio: true }), await this.refreshDevices(), Array.from(this.deviceMap.audioinput.values());
  }
  async enumerateVideoCaptureDevices() {
    return await this.getPermissions({ video: true }), await this.refreshDevices("video"), Array.from(this.deviceMap.videoinput.values());
  }
  async enumerateAudioPlaybackDevices() {
    return await this.getPermissions({ audio: true }), await this.refreshDevices("audio"), Array.from(this.deviceMap.audiooutput.values());
  }
  async getAudioPlaybackDeviceById(e) {
    return (await this.enumerateAudioPlaybackDevices()).find((t) => t.deviceId === e);
  }
};
var dd = new DeviceDetector();
isDebuggerMode && (window.__rtc_dd__ = dd);
var RtcErrorCode = ((e) => (e[e.AUTOPLAY_FAILED = -1e3] = "AUTOPLAY_FAILED", e[e.TRACK_ERROR = -1001] = "TRACK_ERROR", e[e.Fetch_MODIFY = -1002] = "Fetch_MODIFY", e[e.BLACK_BROWSER = -1003] = "BLACK_BROWSER", e[e.DC_SEND_ERROR = -1004] = "DC_SEND_ERROR", e[e.DUPLICATE_DOM = -1005] = "DUPLICATE_DOM", e))(RtcErrorCode || {});
var logger$7 = new Logger$1("VideoSnapshot", 1);
var getPlayingVideoDom = (e) => {
  const t = null == e ? void 0 : e.domElement;
  if (t && !t.paused && 4 === t.readyState) return t;
};
var takeSnapshot = async (e, t) => {
  const i = document.createElement("canvas"), r = i.getContext("2d");
  if (!r) throw new Error("canvas.getContext error");
  const o = (e2, t2, o2) => (t2 = t2 || e2.width, o2 = o2 || e2.height, i.width = t2, i.height = o2, r.setTransform(1, 0, 0, 1, 0, 0), r.drawImage(e2, 0, 0, t2, o2), r.getImageData(0, 0, t2, o2)), n = Date.now(), s = getPlayingVideoDom(t);
  if (s) {
    logger$7.info("takeSnapshot", "VideoPlayer already set.");
    const e2 = await o(s, s.videoWidth, s.videoHeight);
    return logger$7.info("takeSnapshot", "success, cost ".concat(Date.now() - n, "ms")), e2;
  }
  if (window.ImageCapture) {
    const t2 = new window.ImageCapture(e);
    if ("live" === t2.track.readyState && t2.track.enabled && !t2.track.muted) {
      logger$7.info("takeSnapshot", "use ImageCapture");
      const e2 = await o(await t2.grabFrame());
      return logger$7.info("takeSnapshot", "success, cost ".concat(Date.now() - n, "ms")), e2;
    }
  }
  return logger$7.info("takeSnapshot", "use temp video"), new Promise((t2, i2) => {
    const r2 = new MediaStream([e]), s2 = document.createElement("video");
    s2.setAttribute("playsinline", ""), s2.muted = true, document.body.appendChild(s2), s2.onplaying = () => {
      const i3 = o(s2, s2.videoWidth, s2.videoHeight);
      logger$7.info("takeSnapshot", "success, cost ".concat(Date.now() - n, "ms")), t2(i3), r2.removeTrack(e), s2.srcObject = null, s2.load();
    }, s2.onerror = i2, s2.srcObject = r2, s2.play();
  });
};
var DEFAULT_PLAYER_ID = Symbol("default");
var PlayerStallEvent = ((e) => (e.START_STALL_OBSERVE = "start_stall_observe", e.STOP_STALL_OBSERVE = "stop_stall_observe", e))(PlayerStallEvent || {});
var LocalVideoTrack = class extends LocalTrack {
  constructor(e, t, i) {
    super(e, t, _objectSpread2(_objectSpread2({}, i), {}, { mediaType: MediaType.VIDEO })), _defineProperty(this, "resolution", void 0), _defineProperty(this, "videoPlayers", /* @__PURE__ */ new Map()), this.resolution = { width: 0, height: 0 };
  }
  intersection() {
    const e = {};
    return this.videoPlayers.forEach((t, i) => {
      e[i.toString()] = t.isIntersecting;
    }), e;
  }
  async updateVideoCaptureConfig(e) {
    this.logger.info("updateVideoEncoderConfig", "update localVideoTrack: ", e);
    const t = _objectSpread2({}, e);
    delete t.contentHint, isFirefox && this.trackInfo.streamIndex === ExtendStreamIndex.MAIN && (t.frameRate = { ideal: 30, max: 30 }), await this.originTrack.applyConstraints(t);
    const i = this.originTrack.getSettings();
    (i.width && i.width !== this.resolution.width || i.height && i.height !== this.resolution.height) && (this.resolution = { width: i.width, height: i.height }, this.emit("resolution-change", this.resolution));
  }
  setContentHint(e) {
    "contentHint" in this.originTrack && ["text", "motion", "detail"].includes(e) && (this.originTrack.contentHint = e);
  }
  setTrack(e, t) {
    this._originTrack = e, this.trackInfo = _objectSpread2(_objectSpread2({}, this.trackInfo), t), this.isTrackReady = this.generatePreProcessingTrack();
  }
  setPlayer(e, t, i, r) {
    var o;
    const n = null !== (o = e.playerId) && void 0 !== o ? o : DEFAULT_PLAYER_ID;
    let s = this.videoPlayers.get(n);
    return e.player !== s && (s = e.player, this.videoPlayers.set(n, s), r(s, this.isPublic, this.streamIndex)), this.mirror(!!t), this.dummy || i === RTCAutoPlayPolicy.PLAY_MANUALLY || this.play(n), s.domElement;
  }
  setUserId(e) {
    this.trackInfo.streamUserId = e, this.videoPlayers.forEach((t) => {
      t.userId = e;
    });
  }
  snapshot() {
    let e;
    for (const t of this.videoPlayers.values()) if (t.played) {
      e = t;
      break;
    }
    return takeSnapshot(this.preprocessingTrack, e);
  }
  setRenderMode(e, t) {
    var i;
    return null === (i = this.videoPlayers.get(e)) || void 0 === i ? void 0 : i.setRenderMode(t);
  }
  mirror(e) {
    this.videoPlayers.forEach((t) => {
      t.mirror(e);
    });
  }
  removePlayerTrack() {
    this.videoPlayers.forEach((e, t) => {
      var i;
      null === (i = this.videoPlayers.get(t)) || void 0 === i || i.removeTrack();
    });
  }
  play(e) {
    const t = this.videoPlayers.get(e);
    return null != t && t.played ? t.manuallyPlay() : null == t ? void 0 : t.playVideo(this);
  }
  playAll() {
    this.videoPlayers.forEach((e, t) => {
      this.play(t);
    });
  }
  manuallyPlay(e) {
    var t;
    return null === (t = this.videoPlayers.get(e)) || void 0 === t ? void 0 : t.manuallyPlay();
  }
  pause(e) {
    var t;
    null === (t = this.videoPlayers.get(e)) || void 0 === t || t.manuallyPause();
  }
  stop(e) {
    var t;
    return null === (t = this.videoPlayers.get(e)) || void 0 === t ? void 0 : t.stop();
  }
  stopAll() {
    return this.videoPlayers.forEach((e, t) => {
      this.stop(t);
    });
  }
  removePlayer(e) {
    this.videoPlayers.delete(e);
  }
  destroy() {
    this.videoPlayers.forEach((e, t) => {
      this.stop(t), e.removeAllListeners(), this.videoPlayers.delete(t);
    }), super.destroy();
  }
};
var RemoteVideoTrack = class extends RemoteTrack {
  constructor(e, t, i, r) {
    super(e, t, _objectSpread2(_objectSpread2({}, r), {}, { mediaType: MediaType.VIDEO })), _defineProperty(this, "videoPlayers", /* @__PURE__ */ new Map()), _defineProperty(this, "_stream", void 0), _defineProperty(this, "_observingPlayer", void 0), this._stream = i;
  }
  get observingPlayerId() {
    var e;
    return null === (e = this._observingPlayer) || void 0 === e ? void 0 : e.playerId;
  }
  getSizeByPlayer() {
    let e = 0, t = 0;
    return this.videoPlayers.forEach((i) => {
      var r;
      null !== (r = i.domElement) && void 0 !== r && r.videoWidth && i.domElement.videoHeight && (e = i.domElement.videoWidth, t = i.domElement.videoHeight);
    }), { width: e, height: t };
  }
  intersection() {
    const e = {};
    return this.videoPlayers.forEach((t, i) => {
      e[i.toString()] = t.isIntersecting;
    }), e;
  }
  setPlayer(e, t, i, r) {
    var o, n;
    const s = null !== (o = t.playerId) && void 0 !== o ? o : DEFAULT_PLAYER_ID;
    let a = this.videoPlayers.get(s);
    if (t.player !== a) {
      var d;
      if (a = t.player, !isUndefined(this.streamIndex)) a.mirror(this._ctx.getRemoteMirrorType(null !== (d = this.trackInfo.streamUserId) && void 0 !== d ? d : "", this.streamIndex));
      this.videoPlayers.set(s, a), this._handlePlayerStallEvent(a), r(a, this.isPublic, this.streamIndex);
    }
    return this.dummy || this.play(s), null === (n = a) || void 0 === n ? void 0 : n.domElement;
  }
  mirror(e) {
    this.videoPlayers.forEach((t) => {
      t.mirror(e);
    });
  }
  dangerousGetPlayer(e) {
    return this.videoPlayers.get(e);
  }
  snapshot() {
    let e;
    for (const t of this.videoPlayers.values()) if (t.played) {
      e = t;
      break;
    }
    return takeSnapshot(this.preprocessingTrack, e);
  }
  stop(e) {
    var t;
    null === (t = this.videoPlayers.get(e)) || void 0 === t || t.stop();
  }
  stopAll() {
    this.videoPlayers.forEach((e, t) => {
      this.stop(t);
    });
  }
  play(e) {
    if (this._ctx.autoPlayPolicy === RTCAutoPlayPolicy.PLAY_MANUALLY) return;
    const t = this.videoPlayers.get(e);
    return null == t ? void 0 : t.playVideo(this);
  }
  manuallyPlay(e) {
    const t = this.videoPlayers.get(e);
    return null != t && t.played ? t.manuallyPlay() : null == t ? void 0 : t.playVideo(this);
  }
  pause(e) {
    var t;
    return null === (t = this.videoPlayers.get(e)) || void 0 === t ? void 0 : t.manuallyPause();
  }
  _handlePlayerStallEvent(e) {
    e.on("start_stall_observe", () => {
      !this._observingPlayer && e && (this._observingPlayer = e, this._stream.startVideoStallObserve(this._observingPlayer));
    }), e.on("stop_stall_observe", () => {
      this._observingPlayer === e && (this._stream.stopVideoStallObserve(), this._observingPlayer = void 0, this.videoPlayers.forEach((e2) => {
        !this._observingPlayer && e2.played && (this._observingPlayer = e2, this._stream.startVideoStallObserve(e2));
      }));
    });
  }
  removePlayer(e) {
    this.videoPlayers.delete(e);
  }
  destroy() {
    this.videoPlayers.forEach((e, t) => {
      this.stop(t), e.removeAllListeners(), this.videoPlayers.delete(t);
    }), super.destroy();
  }
};
var MEDIA_EVENTS = ["play", "playing", "pause", "ended", "error", "seeking", "seeked", "waiting", "canplay", "canplaythrough", "durationchange", "volumechange", "loadedmetadata", "loadeddata", "loadstart", "timeupdate"];
var AUDIO_ATTRIBUTES = { playsinline: "", "webkit-playsinline": "" };
var VIDEO_ATTRIBUTES = { playsinline: "", "webkit-playsinline": "", "x5-playsinline": "", "x5-video-player-type": "h5", "x-webkit-airplay": "allow", preload: "", muted: "" };
var VideoPlayer = class extends eventemitter3Exports.EventEmitter {
  constructor(e, t, i) {
    super(), _defineProperty(this, "_containerDom", void 0), _defineProperty(this, "_videoDom", void 0), _defineProperty(this, "userId", void 0), _defineProperty(this, "renderMode", void 0), _defineProperty(this, "mirrorType", MirrorType.MIRROR_TYPE_NONE), _defineProperty(this, "isScreen", void 0), _defineProperty(this, "isLocal", void 0), _defineProperty(this, "played", false), _defineProperty(this, "_needLoad", false), _defineProperty(this, "_emitPlayFailed", false), _defineProperty(this, "_videoContainer", void 0), _defineProperty(this, "_safari15VideoTimer", void 0), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "logger", void 0), _defineProperty(this, "_onLocalTrackMute", void 0), _defineProperty(this, "_onInterruptionEnd", void 0), _defineProperty(this, "_needResume", false), _defineProperty(this, "_rotate", 0), _defineProperty(this, "_rotateDom", void 0), _defineProperty(this, "_resizeObserver", void 0), _defineProperty(this, "_hasManuallyPaused", false), _defineProperty(this, "isIntersecting", void 0), _defineProperty(this, "intersectionObserver", void 0), _defineProperty(this, "hasStartPlaying", false), _defineProperty(this, "emitVideoEvent", (e2) => {
      var t2, i2;
      const r2 = { type: "video", rawEvent: e2, readyState: (null === (t2 = this._videoDom) || void 0 === t2 ? void 0 : t2.readyState) || 0, userId: this.userId, eventName: e2.type, currentTime: (null === (i2 = this._videoDom) || void 0 === i2 ? void 0 : i2.currentTime) || 0, isScreen: this.isScreen };
      switch (this.emit("playback_event", r2), e2.type) {
        case "canplay":
          this.refreshRenderSize("the video started playing."), this._internalPlay();
          break;
        case "loadeddata":
          this._internalPlay();
          break;
        case "playing":
          this.logger.info("VideoPlayerPlaying", "[userId-".concat(this.userId, "] video element playing"));
          break;
        case "pause":
          this.logger.info("VideoPlayerPause", "[userId-".concat(this.userId, "] video element pause")), this._needResume ? (this.logger.info("VideoPlayerPause", "[userId-".concat(this.userId, "] video element resume")), this._internalPlay(), this._needResume = false) : this._hasManuallyPaused || (this.logger.info("VideoPlayerPause", "[userId-".concat(this.userId, "] video element resume")), this._internalPlay());
      }
    }), _defineProperty(this, "_internalPlay", () => {
      var e2, t2;
      if (reportRtcInvokeStatus(this.engineId, "video _internalPlay", { paused: null === (e2 = this._videoDom) || void 0 === e2 ? void 0 : e2.paused, hasManuallyPaused: this._hasManuallyPaused }), this._hasManuallyPaused || null === (t2 = this._videoDom) || void 0 === t2 || !t2.paused) return;
      const i2 = this._videoDom.play();
      null != i2 && i2.then && i2.then(() => {
        var e3;
        this.isLocal && isCriOS && !this._needLoad && (null === (e3 = this._videoDom) || void 0 === e3 || e3.load(), this._needLoad = true);
      }).catch((e3) => {
        var t3, i3, r2, o2;
        this._emitPlayFailed || ("AbortError" !== e3.name ? (this._emitPlayFailed = true, null === (t3 = this._monitor) || void 0 === t3 || t3.report("rtc_error", { message: "video autoplay failed, userId: ".concat(this.userId, ", ").concat(e3.name), error_code: RtcErrorCode.AUTOPLAY_FAILED }), this.emit("playback_event", { type: "video", rawEvent: e3, readyState: (null === (i3 = this._videoDom) || void 0 === i3 ? void 0 : i3.readyState) || 0, userId: this.userId, eventName: "autoplay-error", currentTime: (null === (r2 = this._videoDom) || void 0 === r2 ? void 0 : r2.currentTime) || 0, isScreen: this.isScreen })) : null === (o2 = this._monitor) || void 0 === o2 || o2.report("rtc_error", { message: "video autoplay failed, userId: ".concat(this.userId, ", ").concat(e3.name), error_code: RtcErrorCode.AUTOPLAY_FAILED }));
      });
    }), this.engineId = e, this.playerId = t;
    const r = i.renderDom;
    this._monitor = getMonitor(e), this.logger = new Logger$1("Player", 0, e);
    const { userId: o } = i, n = i.isScreen ? VideoRenderMode.RENDER_MODE_FIT : VideoRenderMode.RENDER_MODE_HIDDEN;
    this.renderMode = void 0 !== i.renderMode ? i.renderMode : n, this._rotate = Number(i.rotation || 0);
    const s = "string" == typeof r ? document.getElementById(r) : r;
    if (!s) throw new SDKError(ErrorCode.CANT_FIND_DOM, "can't find dom");
    this._videoContainer = document.createElement("div"), this._videoContainer.style.width = "100%", this._videoContainer.style.height = "100%", this._videoContainer.style.position = "relative", this._videoContainer.style.overflow = "hidden", this._containerDom = s, this.userId = o, this.isLocal = !!i.isLocal, this.isScreen = !!i.isScreen, this._initVideo(), !this.isLocal || 15 !== (null == iOSVersion ? void 0 : iOSVersion[0]) && 15 !== safariVersion || (this._safari15VideoTimer = setTimeout(() => {
      try {
        this._videoContainer.style.display = "block", setTimeout(() => {
          this._videoContainer.style.display = "flex";
        }, 500);
      } catch (e2) {
      }
    }, 1e3));
  }
  _initVideo() {
    this._videoDom || (this._videoDom = createElement$1("video", { style: { width: "100%", height: "100%" }, attributes: VIDEO_ATTRIBUTES }), this._videoDom.id = "".concat(this.userId, "_").concat(genUuid()), this.setRenderMode(this.renderMode), this.mirror(this.mirrorType === MirrorType.MIRROR_TYPE_RENDER)), this._containerDom.appendChild(this._videoContainer), [90, 270].indexOf(this._rotate) > -1 ? (this._rotateDom = this._createRotationDiv(), this._rotateDom.appendChild(this._videoDom), this._videoContainer.appendChild(this._rotateDom)) : (180 === this._rotate && (this._videoContainer.style.transform = "rotate(180deg)"), this._videoContainer.appendChild(this._videoDom)), this._initInterSectionObserver(), this._initListeners(), this._onLocalTrackMute = () => {
      this._needResume = true;
    }, this._onInterruptionEnd = () => {
      this.logger.warn("resume player after iOS interruption"), this._internalPlay();
    }, internalEventBus.on(InternalEvent.ON_IOS_LOCAL_TRACK_MUTE, this._onLocalTrackMute), internalEventBus.on(InternalEvent.ON_IOS_LOCAL_TRACK_UNMUTE, this._onInterruptionEnd), internalEventBus.on(InternalEvent.ON_IOS_INTERRUPTION_END, this._onInterruptionEnd);
  }
  _initInterSectionObserver() {
    !this.intersectionObserver && "undefined" != typeof IntersectionObserver && this._videoDom && (this.intersectionObserver = new IntersectionObserver((e) => {
      e[0] && (this.isIntersecting = e[0].isIntersecting);
    }, {}), this.intersectionObserver.observe(this._videoDom));
  }
  _closeIntersectionObserver() {
    this.intersectionObserver && this._videoDom && (this.intersectionObserver.disconnect(), this.intersectionObserver.unobserve(this._videoDom), delete this.intersectionObserver);
  }
  _createRotationDiv() {
    const e = document.createElement("div");
    return e.style.transform = "rotate(".concat(this._rotate, "deg)"), 180 !== this._rotate && (e.style.position = "absolute", this.refreshRenderSize("init"), window.ResizeObserver && (this._resizeObserver = new ResizeObserver(() => {
      this.refreshRenderSize("the container size has changed.");
    }), this._resizeObserver.observe(this._containerDom))), e;
  }
  refreshRenderSize(e) {
    if (this._rotateDom) {
      var t, i;
      this.logger.print("refreshRenderSize", "Because ".concat(e));
      const r = Number(window.getComputedStyle(this._containerDom).width.replace("px", "")), o = Number(window.getComputedStyle(this._containerDom).height.replace("px", "")), n = null === (t = this._videoDom) || void 0 === t ? void 0 : t.videoWidth, s = null === (i = this._videoDom) || void 0 === i ? void 0 : i.videoHeight;
      if (r && o && s && n) {
        let e2, t2;
        if (this.renderMode === VideoRenderMode.RENDER_MODE_FILL) e2 = o, t2 = r;
        else {
          const i2 = this.renderMode === VideoRenderMode.RENDER_MODE_HIDDEN ? Math.max(r / s, o / n) : Math.min(r / s, o / n);
          e2 = n * i2, t2 = s * i2;
        }
        this._rotateDom.style.width = "".concat(e2, "px"), this._rotateDom.style.height = "".concat(t2, "px"), this._rotateDom.style.left = "".concat((r - e2) / 2, "px"), this._rotateDom.style.top = "".concat((o - t2) / 2, "px");
      }
    }
  }
  _initListeners() {
    this._videoDom && MEDIA_EVENTS.forEach((e) => {
      var t;
      null === (t = this._videoDom) || void 0 === t || t.addEventListener(e, this.emitVideoEvent);
    });
  }
  _removeListeners() {
    this._videoDom && MEDIA_EVENTS.forEach((e) => {
      var t;
      null === (t = this._videoDom) || void 0 === t || t.removeEventListener(e, this.emitVideoEvent);
    });
  }
  setRenderMode(e) {
    this.renderMode = e, this._videoDom && (this.renderMode === VideoRenderMode.RENDER_MODE_FIT ? this._videoDom.style.objectFit = "contain" : this.renderMode === VideoRenderMode.RENDER_MODE_FILL ? this._videoDom.style.objectFit = "fill" : this._videoDom.style.objectFit = "cover");
  }
  async playVideo(e) {
    var t, i;
    let r = this._videoDom;
    if (this.logger.info("playVideo", "play video track: ".concat(this.userId)), r && r.srcObject instanceof MediaStream && r.srcObject.getTrackById(null === (t = e.preprocessingTrack) || void 0 === t ? void 0 : t.id)) {
      try {
        reportRtcInvokeStatus(this.engineId, "playVideo", "play video repeatedly", 0, this.userId);
      } catch (e2) {
      }
      return;
    }
    r || (this._initVideo(), r = this._videoDom), this.logger.info("playVideo", "play video by dom: ".concat(null === (i = r) || void 0 === i ? void 0 : i.id));
    const o = new MediaStream();
    o.addTrack(e.preprocessingTrack), r.srcObject = o, r && !this._containerDom.contains(this._videoContainer) && this._containerDom.appendChild(this._videoContainer), r && !this._videoContainer.contains(r) && this._videoContainer.appendChild(r), setTimeout(() => this._internalPlay()), Config2.VIDEO_STALL && this.emit(PlayerStallEvent.START_STALL_OBSERVE), this.played = true, this.hasStartPlaying = false;
  }
  updateSrcObject(e) {
    const t = e.preprocessingTrack;
    if (!t || !this._videoDom) return;
    const i = new MediaStream();
    i.addTrack(t), this._videoDom.srcObject = i;
  }
  removeTrack() {
    var e;
    const t = null === (e = this._videoDom) || void 0 === e ? void 0 : e.srcObject;
    if (t) {
      const e2 = t.getVideoTracks();
      null != e2 && e2.length && e2.forEach((e3) => {
        t.removeTrack(e3);
      });
    }
  }
  manuallyPlay() {
    if (this.logger.info("Invoke VideoPlayer.manuallyPlay", this.userId, this.isScreen), this._emitPlayFailed = false, this._hasManuallyPaused = false, !this._videoDom) throw new SDKError(ErrorCode.INVALID_PARAMS, "Player not found");
    return 0 !== this._videoDom.readyState || isWeChat ? this._videoDom.play() : Promise.resolve();
  }
  manuallyPause() {
    if (this.logger.print("Invoke VideoPlayer.manuallyPause", this.userId, this.isScreen), this.played) {
      if (this._hasManuallyPaused = true, !this._videoDom) throw new SDKError(ErrorCode.INVALID_PARAMS, "Player not found");
      return this._videoDom.pause();
    }
  }
  mirror(e) {
    this.logger.info("mirror", "".concat(this.userId, " set mirror: ").concat(e)), this.mirrorType = e ? MirrorType.MIRROR_TYPE_RENDER : MirrorType.MIRROR_TYPE_NONE, this._videoDom && (this._videoDom.style.transform = e ? "rotateY(180deg)" : "");
  }
  stop() {
    let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    const { _containerDom: t } = this;
    var i, r;
    (this.logger.info("stop", "stop video track: ".concat(this.userId, " ").concat(this.playerId.toString())), this._videoDom) && (e || (this._videoDom.srcObject = null), null != t && t.contains(this._videoContainer) && t.removeChild(this._videoContainer), null === (i = this._videoContainer) || void 0 === i || i.childNodes.forEach((e2) => {
      e2 !== this._videoDom && e2 !== this._rotateDom || this._videoContainer.removeChild(e2);
    }), null !== (r = this._rotateDom) && void 0 !== r && r.contains(this._videoDom) && this._rotateDom.removeChild(this._videoDom));
    this._hasManuallyPaused = false, this.played = false, this.hasStartPlaying = false, Config2.VIDEO_STALL && this.emit(PlayerStallEvent.STOP_STALL_OBSERVE), this._closeIntersectionObserver();
  }
  destroy() {
    var e;
    let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    this.logger.info("destroy", "video player: ".concat(this.userId)), this.stop(t), null === (e = this._resizeObserver) || void 0 === e || e.disconnect(), super.removeAllListeners(), this._removeListeners(), internalEventBus.off(InternalEvent.ON_IOS_LOCAL_TRACK_MUTE, this._onLocalTrackMute), internalEventBus.off(InternalEvent.ON_IOS_LOCAL_TRACK_UNMUTE, this._onInterruptionEnd), internalEventBus.off(InternalEvent.ON_IOS_INTERRUPTION_END, this._onInterruptionEnd), this._videoDom && delete this._videoDom, this._safari15VideoTimer && (window.clearInterval(this._safari15VideoTimer), this._safari15VideoTimer = void 0);
  }
  get domElement() {
    return this._videoDom;
  }
};
var AudioPlayer = class extends eventemitter3Exports.EventEmitter {
  constructor(e, t) {
    let { divId: i, muted: r, isScreen: o } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { divId: void 0, muted: false, isScreen: false };
    if (super(), _defineProperty(this, "_containerDom", void 0), _defineProperty(this, "_audioDom", void 0), _defineProperty(this, "_fakeAudioDom", void 0), _defineProperty(this, "userId", void 0), _defineProperty(this, "muted", false), _defineProperty(this, "_emitPlayFailed", false), _defineProperty(this, "played", false), _defineProperty(this, "isScreen", void 0), _defineProperty(this, "_wechatTimer", void 0), _defineProperty(this, "_edgeTimer", void 0), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "logger", void 0), _defineProperty(this, "_pasued", true), _defineProperty(this, "hasStartPlaying", false), _defineProperty(this, "emitAudioEvent", (e2) => {
      var t2, i2;
      const r2 = { type: "audio", rawEvent: e2, readyState: (null === (t2 = this._audioDom) || void 0 === t2 ? void 0 : t2.readyState) || 0, userId: this.userId, eventName: e2.type, currentTime: (null === (i2 = this._audioDom) || void 0 === i2 ? void 0 : i2.currentTime) || 0 };
      var o2;
      ("playing" === e2.type && this.logger.info("AudioPlayerPlaying", "[userId-".concat(this.userId, "] audio element playing")), "pause" === e2.type) && (this.logger.info("AudioPlayerPause", "[userId-".concat(this.userId, "] audio element pause")), !this._pasued && null !== (o2 = this._audioDom) && void 0 !== o2 && null !== (o2 = o2.srcObject) && void 0 !== o2 && o2.active && this._internalPlay());
      isAndroid && isWeChat && ("canplay" === e2.type ? (clearTimeout(this._wechatTimer), this._wechatTimer = setTimeout(() => {
        this._autoPlayError("wechat");
      }, 500)) : "playing" === e2.type && clearTimeout(this._wechatTimer)), isMobile && isEdge && "error" === e2.type && (clearTimeout(this._edgeTimer), this._edgeTimer = setTimeout(() => {
        var e3;
        0 === (null === (e3 = this._audioDom) || void 0 === e3 ? void 0 : e3.currentTime) && this._autoPlayError("edge");
      }, 500)), this.emit("playback_event", r2);
    }), _defineProperty(this, "_internalPlay", () => {
      var e2, t2;
      if (reportRtcInvokeStatus(this.engineId, "audio _internalPlay", { paused: null === (e2 = this._audioDom) || void 0 === e2 ? void 0 : e2.paused, userId: this.userId, screen: this.isScreen }), null !== (t2 = this._audioDom) && void 0 !== t2 && t2.paused) try {
        var i2;
        let e3 = this._audioDom.play();
        const t3 = audioContextManager.getAudioContextInstance();
        if ("suspended" === t3.state) {
          const e4 = t3.resume(), i3 = setTimeout(() => {
            var e5;
            "suspended" === t3.state && (this._autoPlayError("AudioContext cannot resume"), null === (e5 = this._monitor) || void 0 === e5 || e5.report("rtc_error", { message: "audio autoplay failed, userId: ".concat(this.userId, ": Cannot resume the AudioContext - timeout"), error_code: RtcErrorCode.AUTOPLAY_FAILED }));
            clearTimeout(i3);
          });
          e4.catch((e5) => {
            var t4;
            this._autoPlayError("AudioContext cannot resume"), null === (t4 = this._monitor) || void 0 === t4 || t4.report("rtc_error", { message: "audio autoplay failed, userId: ".concat(this.userId, ": Cannot resume the AudioContext - rejected by: [").concat(null == e5 ? void 0 : e5.name, "]").concat(null == e5 ? void 0 : e5.message), error_code: RtcErrorCode.AUTOPLAY_FAILED });
          }).finally(() => {
            clearTimeout(i3);
          });
        }
        null !== (i2 = e3) && void 0 !== i2 && i2.then && (isAndroid && isMobile && (e3 = e3.then(() => new Promise((e4) => {
          setTimeout(async () => {
            var t4;
            null === (t4 = this._audioDom) || void 0 === t4 || t4.pause(), this._audioDom.volume = 1, await this._audioDom.play(), e4();
          }, 500);
        }))), e3.then(() => {
          reportRtcInvokeStatus(this.engineId, "_internalPlay successfully", { userId: this.userId, screen: this.isScreen }), this._pasued = false;
        }).catch((e4) => {
          var t4;
          this._autoPlayError(e4), null === (t4 = this._monitor) || void 0 === t4 || t4.report("rtc_error", { message: "audio autoplay failed, userId: ".concat(this.userId, ": ").concat(e4.message, " ").concat(e4.name), error_code: RtcErrorCode.AUTOPLAY_FAILED });
        }));
      } catch (e3) {
        var r2;
        this._autoPlayError(e3), null === (r2 = this._monitor) || void 0 === r2 || r2.report("rtc_error", { message: "audio autoplay failed, userId: ".concat(this.userId, ": ").concat(e3.message, " ").concat(e3.name), error_code: RtcErrorCode.AUTOPLAY_FAILED });
      }
    }), this.engineId = e, i) {
      const e2 = document.getElementById(i);
      if (!e2) throw new SDKError(ErrorCode.CANT_FIND_DOM, "can't find dom");
      this._containerDom = e2;
    } else this._containerDom = document.body;
    this.userId = t, this.muted = r, this.isScreen = o, this._monitor = getMonitor(e), this.logger = new Logger$1("Player", 0, e), this._initAudio();
  }
  _initAudio() {
    this._audioDom || (this._audioDom = createElement$1("audio", { style: { display: "none" }, attributes: AUDIO_ATTRIBUTES }), this._audioDom.volume = this.muted ? 0 : 1, this._audioDom.muted = this.muted, this._audioDom.id = "".concat(this.userId, "_").concat(genUuid()), this._containerDom.appendChild(this._audioDom)), this._initListeners();
  }
  _initListeners() {
    this._audioDom && MEDIA_EVENTS.forEach((e) => {
      var t;
      null === (t = this._audioDom) || void 0 === t || t.addEventListener(e, this.emitAudioEvent);
    });
  }
  _removeListeners() {
    this._audioDom && (MEDIA_EVENTS.forEach((e) => {
      var t;
      null === (t = this._audioDom) || void 0 === t || t.removeEventListener(e, this.emitAudioEvent);
    }), this._audioDom.removeEventListener("canplay", this._internalPlay), this._audioDom.removeEventListener("loadeddata", this._internalPlay));
  }
  async playAudio(e) {
    var t, i, r;
    this.logger.info("playAudio", "play audio track: ".concat(this.userId));
    let o = this._audioDom;
    if (o && o.srcObject instanceof MediaStream && o.srcObject.getTrackById(null === (t = e.preprocessingTrack) || void 0 === t ? void 0 : t.id)) return;
    o || (this._initAudio(), o = this._audioDom);
    const n = new MediaStream();
    e instanceof RemoteAudioTrack ? (this._fakeAudioDom = new Audio(), this._fakeAudioDom.muted = true, this._fakeAudioDom.srcObject = new MediaStream([e.originTrack]), n.addTrack(e.preprocessingTrack)) : n.addTrack(e.preprocessingTrack), isAndroid && isMobile && (this._audioDom.volume = 0), o.srcObject = n, null === (i = o) || void 0 === i || i.addEventListener("canplay", this._internalPlay), null === (r = o) || void 0 === r || r.addEventListener("loadeddata", this._internalPlay), setTimeout(() => this._internalPlay()), this.played = true, this.hasStartPlaying = false;
  }
  _autoPlayError(e) {
    var t, i;
    this._emitPlayFailed || (this._emitPlayFailed = true, this.emit("playback_event", { type: "audio", rawEvent: e, readyState: (null === (t = this._audioDom) || void 0 === t ? void 0 : t.readyState) || 0, userId: this.userId, eventName: "autoplay-error", currentTime: (null === (i = this._audioDom) || void 0 === i ? void 0 : i.currentTime) || 0 }));
  }
  pause() {
    if (!this._audioDom) throw new SDKError(ErrorCode.INVALID_PARAMS, "Player not found");
    this._pasued = true, this._audioDom.pause(), this.hasStartPlaying = false;
  }
  manuallyPause() {
    return this.pause();
  }
  manuallyPlay() {
    var e;
    if (this.logger.info("Invoke AudioPlayer.manuallyPlay"), this._emitPlayFailed = false, !this._audioDom) throw new SDKError(ErrorCode.INVALID_PARAMS, "Player not found");
    if (!this.played) return Promise.resolve();
    this._audioDom.volume = 1, this._audioDom.muted = false, null === (e = this._fakeAudioDom) || void 0 === e || e.play();
    const t = [], i = this._audioDom.play();
    null != i && i.then && t.push(i);
    const r = audioContextManager.getAudioContextInstance();
    if ("suspended" === r.state) {
      const e2 = r.resume();
      null != e2 && e2.then && t.push(e2);
    }
    const o = t.length > 0 ? Promise.all(t) : Promise.resolve(i);
    return o.then(() => {
      this._pasued = false;
    }), o;
  }
  async setPlaybackDevice(e) {
    this.logger.info("setPlaybackDevice", "setPlaybackDevice: ".concat(e));
    (await dd.enumerateAudioPlaybackDevices()).map((e2) => e2.deviceId).includes(e) && this._audioDom && this._audioDom.setSinkId && await this._audioDom.setSinkId(e);
  }
  stop() {
    const { _containerDom: e } = this;
    this.logger.info("stopAudio", "stop audio track: ".concat(this.userId)), this._audioDom && (this._audioDom.srcObject = null, null != e && e.contains(this._audioDom) && e.removeChild(this._audioDom)), this._fakeAudioDom && (this._fakeAudioDom.srcObject = null, this._fakeAudioDom = void 0), this.played = false, this.hasStartPlaying = false;
  }
  get domElement() {
    return this._audioDom;
  }
  destroy() {
    this.logger.info("destroy", "audio player: ".concat(this.userId)), this.stop(), super.removeAllListeners(), this._removeListeners(), this._audioDom && (this._audioDom.srcObject = null, delete this._audioDom), this._edgeTimer && clearTimeout(this._edgeTimer);
  }
};
var AudioProcessor = class {
  constructor() {
    _defineProperty(this, "_ac", void 0), _defineProperty(this, "_sourceNode", void 0), _defineProperty(this, "_gainNode", void 0), _defineProperty(this, "_destNode", void 0), this._ac = audioContextManager.getAudioContextInstance(), this._gainNode = this._ac.createGain(), this._destNode = this._ac.createMediaStreamDestination(), this._gainNode.connect(this._destNode);
  }
  setVolume(e) {
    this._gainNode.gain.value = e / 100;
  }
  getVolume() {
    return Math.round(100 * this._gainNode.gain.value);
  }
  updateInputTrack(e) {
    this._sourceNode && (this._sourceNode.mediaStream.getTracks().forEach((e2) => {
      e2.stop();
    }), delete this._sourceNode);
    const t = new MediaStream();
    t.addTrack(e), this._sourceNode = this._ac.createMediaStreamSource(t), this._sourceNode.connect(this._gainNode);
  }
  getOutputTrack() {
    return this._destNode.stream.getTracks()[0];
  }
  destroy() {
    var e, t;
    null === (e = this._sourceNode) || void 0 === e || e.mediaStream.getTracks().forEach((e2) => {
      e2.stop();
    }), 13 !== safariVersion && this._destNode.stream.getTracks().forEach((e2) => {
      e2.stop();
    }), null === (t = this._sourceNode) || void 0 === t || t.disconnect(), this._gainNode.disconnect(), delete this._sourceNode;
  }
};
var LocalAudioTrack = class extends LocalTrack {
  constructor(e, t, i) {
    super(e, t, _objectSpread2(_objectSpread2({}, i), {}, { mediaType: MediaType.AUDIO })), _defineProperty(this, "audioCaptureConfig", void 0), _defineProperty(this, "_ap", void 0), _defineProperty(this, "mixedAudioTrack", void 0), _defineProperty(this, "mixType", AudioMixingType.PLAYOUT_AND_PUBLISH), _defineProperty(this, "_audioFetchMap", /* @__PURE__ */ new Map()), _defineProperty(this, "_audioDataFetcher", void 0), _defineProperty(this, "_localPlaybackTrack", void 0), _defineProperty(this, "notSupportedWebAudio", false);
  }
  get withWebAudio() {
    return !!this._ap;
  }
  getAudioLevel() {
    var e;
    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : AudioReportMode.MICROPHONE;
    const i = t === AudioReportMode.AUDIOMIXING && this.mixType !== AudioMixingType.PLAYOUT && null !== (e = this.mixedAudioTrack) && void 0 !== e ? e : this.preprocessingTrack;
    let r = this._audioFetchMap.get(t);
    var o;
    r && r.currentTrackId === i.id || (null === (o = r) || void 0 === o || o.destroy(), r = new AudioLevelFetcher(i), this._audioFetchMap.set(t, r));
    return r.getAudioLevel();
  }
  async updateAudioCaptureConfig() {
    this.audioCaptureConfig && (this.logger.print("updateAudioCaptureConfig", "update localAudioTrack: ", this.audioCaptureConfig), await this.originTrack.applyConstraints(this.audioCaptureConfig));
  }
  setVolume(e) {
    const t = !getParameter("SKIP_WEB_AUDIO_IN_TRACK") && (isWebAudioSupported() || getParameter("ENFORCE_WEB_AUDIO_SUPPORTED"));
    t || (this.notSupportedWebAudio = true);
    const i = !this.withWebAudio && 100 !== e;
    try {
      t && i && (this.logger.print("Create AudioProcess"), this._ap = new AudioProcessor(), this._ap.updateInputTrack(this.originTrack), this.mediaTrack = this._ap.getOutputTrack());
    } catch (e2) {
      this.logger.warn("WebAudio may not supported, quired return"), this.notSupportedWebAudio = true;
    }
    var r;
    this.notSupportedWebAudio || (null === (r = this._ap) || void 0 === r || r.setVolume(e));
    t && i && this.emit("needReplaceTrack", this);
  }
  getVolume() {
    return this._ap ? this._ap.getVolume() : 100;
  }
  setUserId(e) {
    this.trackInfo.streamUserId = e;
  }
  setDataFetcher(e, t) {
    this.logger.info("setDataFetcher", "frameSize %s", e), null !== audioContextManager.isWorkletReady ? this._audioDataFetcher ? this._audioDataFetcher.setFrameSize(e) : (this._audioDataFetcher = new AudioDataFetcher(this.preprocessingTrack, e), this._audioDataFetcher.on("data", t)) : this.logger.info("setDataFetcher", "audioContextManager.isWorkletReady is null");
  }
  stopDataFetcher() {
    var e, t;
    null === (e = this._audioDataFetcher) || void 0 === e || e.removeAllListeners("data"), null === (t = this._audioDataFetcher) || void 0 === t || t.destroy(), this._audioDataFetcher = void 0;
  }
  play(e) {
    var t, i;
    this._localPlaybackTrack && this.stop();
    const r = e === EarMonitorPosition.AFTER_CAPTURE ? this.originTrack : e === EarMonitorPosition.AFTER_PROCESS ? this.preprocessingTrack : void 0;
    if (!r) return void this.logger.error("play()", "no target track for %s", e);
    this._localPlaybackTrack = new RemoteAudioTrack(this._ctx, r.clone(), _objectSpread2({}, this.trackInfo));
    const o = this._ctx.earMonitorSettings[null !== (t = this.streamIndex) && void 0 !== t ? t : StreamIndex$1.STREAM_INDEX_MAIN].volume;
    this.setPlaybackVolume(o);
    const n = new AudioPlayer(this._ctx.id, null !== (i = this.trackInfo.streamUserId) && void 0 !== i ? i : "", { isScreen: this.streamIndex === StreamIndex$1.STREAM_INDEX_SCREEN, muted: false });
    return n.on("playback_event", (e2) => {
      var t2;
      "autoplay-error" === e2.eventName && this.emit("autoplay-error", { kind: "audio", streamIndex: null !== (t2 = this.streamIndex) && void 0 !== t2 ? t2 : StreamIndex$1.STREAM_INDEX_MAIN, mediaType: MediaType.AUDIO });
    }), this._localPlaybackTrack.setPlayer(n), this._localPlaybackTrack.play();
  }
  stop() {
    var e;
    null === (e = this._localPlaybackTrack) || void 0 === e || e.destroy(), this._localPlaybackTrack = void 0;
  }
  setPlaybackVolume(e) {
    var t;
    return null === (t = this._localPlaybackTrack) || void 0 === t ? void 0 : t.setVolume(e);
  }
  destroy() {
    var e, t;
    this._audioFetchMap.forEach((e2) => e2.destroy()), this._audioFetchMap.clear(), null === (e = this._ap) || void 0 === e || e.destroy(), null === (t = this._audioDataFetcher) || void 0 === t || t.destroy(), this._audioDataFetcher = void 0, this.stop(), super.destroy();
  }
};
var RemoteAudioTrack = class extends RemoteTrack {
  constructor(e, t, i) {
    super(e, t, _objectSpread2(_objectSpread2({}, i), {}, { mediaType: MediaType.AUDIO })), _defineProperty(this, "_ap", void 0), _defineProperty(this, "_audioPlayer", void 0), _defineProperty(this, "_audioLevelFetcher", void 0), _defineProperty(this, "_audioDataFetcher", void 0), _defineProperty(this, "notSupportedWebAudio", false), _defineProperty(this, "_sourceNode", void 0);
  }
  get withWebAudio() {
    return !!this._ap;
  }
  getAudioLevel() {
    return this._audioLevelFetcher || (this._audioLevelFetcher = new AudioLevelFetcher(this.originTrack)), this._audioLevelFetcher.getAudioLevel();
  }
  setVolume(e) {
    const t = !getParameter("SKIP_WEB_AUDIO_IN_TRACK") && (isWebAudioSupported() || getParameter("ENFORCE_WEB_AUDIO_SUPPORTED"));
    t || (this.notSupportedWebAudio = true);
    const i = !this.withWebAudio && 100 !== e;
    try {
      t && i && (this.logger.print("Create AudioProcess"), this._ap = new AudioProcessor(), this._ap.updateInputTrack(this.originTrack), this.mediaTrack = this._ap.getOutputTrack());
    } catch (e2) {
      this.logger.warn("WebAudio may not supported, quite return"), this.notSupportedWebAudio = true;
    }
    if (this.notSupportedWebAudio) {
      var r;
      const t2 = null === (r = this._audioPlayer) || void 0 === r ? void 0 : r.domElement;
      t2 && (t2.volume = Math.min(e / 100, 1));
    } else {
      var o;
      null === (o = this._ap) || void 0 === o || o.setVolume(e);
    }
    var n;
    t && i && (this.emit("needReplaceTrack", this), null === (n = this._audioPlayer) || void 0 === n || n.playAudio(this));
  }
  getVolume() {
    var e, t;
    return this.notSupportedWebAudio ? 100 * (null !== (e = null === (t = this._audioPlayer) || void 0 === t || null === (t = t.domElement) || void 0 === t ? void 0 : t.volume) && void 0 !== e ? e : 1) : this._ap ? this._ap.getVolume() : 100;
  }
  setPlaybackDevice(e) {
    var t;
    return null === (t = this._audioPlayer) || void 0 === t ? void 0 : t.setPlaybackDevice(e);
  }
  setPlayer(e) {
    this._audioPlayer = e, this._wechatAutoplayWorkaround(e);
  }
  havePlayer() {
    return !!this._audioPlayer;
  }
  bindPlayerEvent(e) {
    var t;
    this._audioPlayer && e(this._audioPlayer, this.isPublic, null !== (t = this.streamIndex) && void 0 !== t ? t : StreamIndex$1.STREAM_INDEX_MAIN);
  }
  pause() {
    var e;
    return null === (e = this._audioPlayer) || void 0 === e ? void 0 : e.pause();
  }
  play() {
    var e;
    return null === (e = this._audioPlayer) || void 0 === e ? void 0 : e.playAudio(this);
  }
  manuallyPlay() {
    var e, t, i;
    return null !== (e = this._audioPlayer) && void 0 !== e && e.played ? null === (t = this._audioPlayer) || void 0 === t ? void 0 : t.manuallyPlay() : null === (i = this._audioPlayer) || void 0 === i ? void 0 : i.playAudio(this);
  }
  manuallyPause() {
    var e;
    return null === (e = this._audioPlayer) || void 0 === e ? void 0 : e.manuallyPause();
  }
  stop() {
    var e;
    return null === (e = this._audioPlayer) || void 0 === e ? void 0 : e.stop();
  }
  setDataFetcher(e, t) {
    this.logger.info("setDataFetcher", "frameSize %s", e), null !== audioContextManager.isWorkletReady ? this._audioDataFetcher ? this._audioDataFetcher.setFrameSize(e) : (this._audioDataFetcher = new AudioDataFetcher(this.originTrack, e), this._audioDataFetcher.on("data", t)) : this.logger.warn("setDataFetcher", "audioContextManager.isWorkletReady is null");
  }
  stopDataFetcher() {
    var e;
    this.logger.info("stopDataFetcher"), null === (e = this._audioDataFetcher) || void 0 === e || e.destroy(), this._audioDataFetcher = void 0;
  }
  destroy() {
    var e, t, i;
    null === (e = this._audioLevelFetcher) || void 0 === e || e.destroy(), null === (t = this._audioDataFetcher) || void 0 === t || t.destroy(), this._audioDataFetcher = void 0, this._ap && this._ap.destroy(), null === (i = this._audioPlayer) || void 0 === i || i.destroy(), this._audioPlayer = void 0, super.destroy();
  }
  _wechatAutoplayWorkaround(e) {
    isWeChat && e.on("playback_event", (e2) => {
      const t = audioContextManager.getAudioContextInstance();
      "autoplay-error" === e2.eventName ? t && "running" === t.state && (this._sourceNode || (this._sourceNode = t.createMediaStreamSource(new MediaStream([this.originTrack]))), this._sourceNode.connect(t.destination), reportRtcInvokeStatus(this._ctx.id, "wechatAutoplayWorkaround.connect", { userId: this.trackInfo.streamUserId, streamIndex: this.streamIndex, contextState: t.state, trackInfo: this.trackInfo })) : "playing" === e2.eventName && this._sourceNode && (this._sourceNode.disconnect(), this._sourceNode = void 0, reportRtcInvokeStatus(this._ctx.id, "wechatAutoplayWorkaround.disconnect", { userId: this.trackInfo.streamUserId, streamIndex: this.streamIndex, contextState: t.state, trackInfo: this.trackInfo }));
    });
  }
};
var logger$6 = new Logger$1("VERTC", 0);
var desktopCapturer;
var electron = null;
var inElectron = () => !!fetchElectronInstance();
function fetchElectronInstance() {
  if (electron) return electron;
  try {
    electron = window.require("electron");
    const { ipcRenderer: e } = electron;
    return desktopCapturer = { getSources: (t) => e.invoke("DESKTOP_CAPTURER_GET_SOURCES", t) }, electron;
  } catch (e) {
    return null;
  }
}
async function getElectronScreenStream(e, t, i) {
  let r;
  return t || (t = { width: 1920, height: 1080, frameRate: 15 }), r = i ? { audio: { mandatory: { chromeMediaSource: "desktop" } }, video: { mandatory: { chromeMediaSource: "desktop", maxHeight: t.height, maxWidth: t.width, maxFrameRate: t.frameRate } } } : { audio: false, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e, maxHeight: t.height, maxWidth: t.width, maxFrameRate: t.frameRate } } }, logger$6.info("getUserMediaConfig", JSON.stringify(r)), await navigator.mediaDevices.getUserMedia(r);
}
async function getElectronScreenSources(e) {
  let t = ["window", "screen"];
  "window" === e && (t = ["window"]), "screen" === e && (t = ["screen"]);
  if (!fetchElectronInstance()) throw new SDKError(ErrorCode.ERR_ELECTRON_IS_NULL, "Unable to get Electron object");
  let i = null;
  try {
    i = desktopCapturer.getSources({ types: t });
  } catch (e2) {
    i = null;
  }
  i && i.then || (i = new Promise((e2, i2) => {
    desktopCapturer.getSources({ types: t }, (t2, r) => {
      t2 ? i2(t2) : e2(r);
    });
  }));
  try {
    return await i;
  } catch (e2) {
    throw new SDKError(ErrorCode.ERR_ELECTRON_IS_NULL, e2.toString());
  }
}
function showElectronSelectSourceWindow(e) {
  return new Promise((t, i) => {
    const r = document.createElement("div");
    r.innerText = "share screen", r.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
    const o = document.createElement("div");
    o.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
    const n = document.createElement("div");
    n.innerText = "Web Screensharing wants to share the contents of your screen. Choose what you'd like to share.", n.setAttribute("style", "height: 12%;");
    const s = document.createElement("div");
    s.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
    const a = document.createElement("div");
    a.setAttribute("style", "text-align: right; padding: 16px 0;");
    const d = document.createElement("button");
    d.innerHTML = "cancel", d.setAttribute("style", "width: 85px;"), d.onclick = () => {
      document.body.removeChild(c2);
      const e2 = new Error("NotAllowedError");
      e2.name = "NotAllowedError", i(e2);
    }, a.appendChild(d), o.appendChild(n), o.appendChild(s), o.appendChild(a);
    const c2 = document.createElement("div");
    c2.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), c2.appendChild(r), c2.appendChild(o), document.body.appendChild(c2), e.map((e2) => {
      if (e2.id) {
        const i2 = document.createElement("div");
        i2.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;"), i2.innerHTML = "<div style='height: 120px; display: table-cell; vertical-align: middle;'> \n          <img style='width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);' src=\n          ".concat(e2.thumbnail.toDataURL(), "\n           />\n          </div>\n          <span style='	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;'>\n          ").concat(e2.name, "\n          </span>"), i2.onclick = () => {
          document.body.removeChild(c2), t(e2.id);
        }, s.appendChild(i2);
      }
    });
  });
}
async function getElectronScreenStreamByUserSelect(e, t) {
  const i = await getElectronScreenSources(), r = await showElectronSelectSourceWindow(i);
  return await getElectronScreenStream(r, e, t);
}
async function createDummyVideoLocalTrack(e, t) {
  const i = new LocalVideoTrack(e, t, { streamIndex: ExtendStreamIndex.MAIN, sourceType: SourceType.INTERNAL, isDummy: true });
  return await i.isTrackReady, i;
}
async function createDummyScreenVideoLocalTrack(e, t) {
  const i = new LocalVideoTrack(e, t, { isDummy: true, streamIndex: ExtendStreamIndex.SCREEN, sourceType: SourceType.INTERNAL });
  return await i.isTrackReady, i;
}
async function createCameraVideoTrack(e, t) {
  var i;
  let r;
  const o = (null === (i = (t = t || e.videoProfile.getCaptureConfig()).deviceId) || void 0 === i ? void 0 : i.exact) || "default", n = genUuid$1(), s = new Logger$1("TrackFactory", 0, e.id);
  try {
    var a, d, c2;
    s.info("createCameraVideoTrack", "constraints:", t), null === (a = e.monitor) || void 0 === a || a.report("rtc_video_capture_event", { event_type: "start", media_device_id: o, capture_session_id: n });
    const i2 = getServerNow();
    isFirefox && (t.frameRate = { ideal: 30, max: 30 }), r = await dd.getUserMedia({ video: t }), null === (d = e.monitor) || void 0 === d || d.report("rtc_video_capture_event", { event_type: "start_capture_result", media_device_id: o, media_device_name: (null === (c2 = r.getVideoTracks()[0]) || void 0 === c2 ? void 0 : c2.label) || "", reason: "success", elapse: getServerNow() - i2, capture_session_id: n });
  } catch (t2) {
    var l;
    throw null === (l = e.monitor) || void 0 === l || l.report("rtc_video_capture_event", { event_type: "running_failed", media_device_id: o, error_code: t2.code, reason: t2.name + t2.message, capture_session_id: n }), new SDKError(ErrorCode.GET_VIDEO_TRACK_FAILED, "throw error from getUserMedia. [".concat(t2.name || "unknown name", "]: ").concat(t2.message || "unknown message", "."), t2);
  }
  const u = r.getVideoTracks()[0], h = new LocalVideoTrack(e, u, { streamIndex: ExtendStreamIndex.MAIN, sourceType: SourceType.INTERNAL, captureSessionId: n });
  return await h.isTrackReady, h;
}
async function createMicrophoneAudioTrack(e, t) {
  var i;
  let r;
  new Logger$1("TrackFactory", 0, e.id).info("createMicrophoneAudioTrack", "constraints:", t);
  const o = (null === (i = t.deviceId) || void 0 === i ? void 0 : i.exact) || "default", n = genUuid$1();
  try {
    var s, a, d;
    null === (s = e.monitor) || void 0 === s || s.report("rtc_audio_device_event", { device_type: "audio_record", event_type: "start_begin", media_device_id: o, event_session_id: n });
    const i2 = getServerNow();
    e.extensionManager.getPluginByName(RTCExtensionType.PRE_PROCESSING, "RTCAIAnsExtension") && (t.autoGainControl = true, t.noiseSuppression = false), r = await dd.getUserMedia({ audio: t }), null === (a = e.monitor) || void 0 === a || a.report("rtc_audio_device_event", { device_type: "audio_record", event_type: "start_result", media_device_id: o, media_device_name: (null === (d = r.getAudioTracks()[0]) || void 0 === d ? void 0 : d.label) || "", reason: "success", elapse: getServerNow() - i2, event_session_id: n });
  } catch (t2) {
    var c2;
    throw null === (c2 = e.monitor) || void 0 === c2 || c2.report("rtc_audio_device_event", { device_type: "audio_record", event_type: "start_end", media_device_id: o, error_code: t2.code, reason: t2.name + t2.message, event_session_id: n }), new SDKError(ErrorCode.GET_AUDIO_TRACK_FAILED, "throw error from getUserMedia. [".concat(t2.name || "unknown name", "]: ").concat(t2.message || "unknown message", "."), t2);
  }
  const l = r.getAudioTracks()[0], u = new LocalAudioTrack(e, l, { streamIndex: ExtendStreamIndex.MAIN, sourceType: SourceType.INTERNAL, captureSessionId: n });
  return await u.isTrackReady, u;
}
async function createMicrophoneAndCameraTrack(e, t, i) {
  var r, o;
  let n;
  new Logger$1("TrackFactory", 0, e.id).print("createCameraAndMicrophoneTrack", "audioConstraints:", t, "videoConstraints:", i);
  const s = (null === (r = t.deviceId) || void 0 === r ? void 0 : r.exact) || "default", a = (null === (o = i.deviceId) || void 0 === o ? void 0 : o.exact) || "default", d = genUuid$1(), c2 = genUuid$1();
  try {
    var l, u, h, _, p, m;
    null === (l = e.monitor) || void 0 === l || l.report("rtc_video_capture_event", { event_type: "start", media_device_id: a, capture_session_id: d }), null === (u = e.monitor) || void 0 === u || u.report("rtc_audio_device_event", { device_type: "audio_record", event_type: "start_begin", media_device_id: s, event_session_id: c2 });
    const r2 = getServerNow();
    isFirefox && (i.frameRate = { ideal: 30, max: 30 });
    e.extensionManager.getPluginByName(RTCExtensionType.PRE_PROCESSING, "RTCAIAnsExtension") && (t.autoGainControl = true, t.noiseSuppression = false), n = await dd.getUserMedia({ audio: t, video: i }), null === (h = e.monitor) || void 0 === h || h.report("rtc_video_capture_event", { event_type: "start_capture_result", media_device_id: a, media_device_name: (null === (_ = n.getVideoTracks()[0]) || void 0 === _ ? void 0 : _.label) || "", reason: "success", elapse: getServerNow() - r2, capture_session_id: d }), null === (p = e.monitor) || void 0 === p || p.report("rtc_audio_device_event", { device_type: "audio_record", event_type: "start_result", media_device_id: s, media_device_name: (null === (m = n.getAudioTracks()[0]) || void 0 === m ? void 0 : m.label) || "", reason: "success", elapse: getServerNow() - r2, event_session_id: c2 });
  } catch (t2) {
    var S, g;
    throw null === (S = e.monitor) || void 0 === S || S.report("rtc_video_capture_event", { event_type: "running_failed", media_device_id: a, error_code: t2.code, reason: t2.name + t2.message, capture_session_id: d }), null === (g = e.monitor) || void 0 === g || g.report("rtc_audio_device_event", { device_type: "audio_record", event_type: "start_end", media_device_id: s, error_code: t2.code, reason: t2.name + t2.message, event_session_id: c2 }), new SDKError(ErrorCode.GET_VIDEO_TRACK_FAILED, "throw error from getUserMedia. [".concat(t2.name || "unknown name", "]: ").concat(t2.message || "unknown message", "."), t2);
  }
  const v3 = n.getVideoTracks()[0], f = new LocalVideoTrack(e, v3, { streamIndex: ExtendStreamIndex.MAIN, sourceType: SourceType.INTERNAL, captureSessionId: d }), y = n.getAudioTracks()[0], E = new LocalAudioTrack(e, y, { streamIndex: ExtendStreamIndex.MAIN, sourceType: SourceType.INTERNAL, captureSessionId: c2 });
  return await Promise.all([f.isTrackReady, E.isTrackReady]), { videoTrack: f, audioTrack: E };
}
async function createScreenTracks(e, t) {
  const i = new Logger$1("TrackFactory", 0, e.id);
  let r, o = e.videoProfile.getScreenEncodeConfig();
  i.info("createScreenTracks", "screenConfig: %o, constraints: %o", t, o);
  const n = genUuid$1(), { enableAudio: s = false, displaySurface: a, systemAudio: d, surfaceSwitching: c2, selfBrowserSurface: l, sourceId: u } = t, h = {};
  a && ["monitor", "browser", "window"].includes(a) && (o ? o.displaySurface = a : o = { displaySurface: a }), d && ["include", "exclude"].includes(d) && (h.systemAudio = d), c2 && ["include", "exclude"].includes(c2) && (h.surfaceSwitching = c2), l && ["include", "exclude"].includes(l) && (h.selfBrowserSurface = l);
  try {
    var _, p, m, S;
    null === (_ = e.monitor) || void 0 === _ || _.report("rtc_video_capture_event", { event_type: "start", media_device_id: "screen", capture_session_id: n });
    const t2 = getServerNow();
    r = inElectron() ? u ? await getElectronScreenStream(u, o, s) : await getElectronScreenStreamByUserSelect(o, s) : await navigator.mediaDevices.getDisplayMedia(_objectSpread2({ video: !(!o || isConstraintInGetDisplayMediaSupported) || o, audio: !!s && { channelCount: 2, noiseSuppression: false, echoCancellation: true, autoGainControl: false } }, h)), null === (p = e.monitor) || void 0 === p || p.report("rtc_video_capture_event", { event_type: "start_capture_result", media_device_id: "screen", media_device_name: "".concat((null === (m = r.getVideoTracks()[0]) || void 0 === m ? void 0 : m.label) || "", ", ").concat((null === (S = r.getAudioTracks()[0]) || void 0 === S ? void 0 : S.label) || ""), reason: "success", elapse: getServerNow() - t2, capture_session_id: n });
  } catch (t2) {
    var g;
    throw null === (g = e.monitor) || void 0 === g || g.report("rtc_video_capture_event", { event_type: "running_failed", media_device_id: "screen", error_code: t2.code, reason: t2.name + t2.message, capture_session_id: n }), new SDKError(ErrorCode.GET_SCREEN_TRACK_FAILED, "throw error from getDisplayMedia", t2);
  }
  const v3 = r.getVideoTracks()[0], f = new LocalVideoTrack(e, v3, { streamIndex: ExtendStreamIndex.SCREEN, sourceType: SourceType.INTERNAL, captureSessionId: n }), y = r.getAudioTracks()[0];
  if (r.getAudioTracks().length) {
    const t2 = new LocalAudioTrack(e, y, { streamIndex: ExtendStreamIndex.SCREEN, sourceType: SourceType.INTERNAL, captureSessionId: n });
    return await Promise.all([f.isTrackReady, t2.isTrackReady]), [f, t2];
  }
  return await f.isTrackReady, [f, void 0];
}
function createRemoteVideoTrack(e, t, i, r) {
  return new RemoteVideoTrack(e, t, i, _objectSpread2({}, r));
}
function createRemoteAudioTrack(e, t, i) {
  return new RemoteAudioTrack(e, t, _objectSpread2({}, i));
}
async function createCustomVideoLocalTrack(e, t) {
  const i = new LocalVideoTrack(e, t, { streamIndex: ExtendStreamIndex.MAIN, sourceType: SourceType.EXTERNAL });
  return await i.isTrackReady, i;
}
async function createCustomAudioLocalTrack(e, t) {
  const i = new LocalAudioTrack(e, t, { streamIndex: ExtendStreamIndex.MAIN, sourceType: SourceType.EXTERNAL });
  return await i.isTrackReady, i;
}
async function createCustomScreenVideoLocalTrack(e, t) {
  const i = new LocalVideoTrack(e, t, { sourceType: SourceType.EXTERNAL, streamIndex: ExtendStreamIndex.SCREEN });
  return await i.isTrackReady, i;
}
async function createCustomScreenAudioLocalTrack(e, t) {
  const i = new LocalAudioTrack(e, t, { sourceType: SourceType.EXTERNAL, streamIndex: ExtendStreamIndex.SCREEN });
  return await i.isTrackReady, i;
}
var encodedJs$1 = "IWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciB0PSJ1bmRlZmluZWQiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOiJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93P3dpbmRvdzoidW5kZWZpbmVkIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6InVuZGVmaW5lZCIhPXR5cGVvZiBzZWxmP3NlbGY6e307ZnVuY3Rpb24gZSh0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwiZGVmYXVsdCIpP3QuZGVmYXVsdDp0fXZhciBuPXtleHBvcnRzOnt9fSxyPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Lk1hdGg9PT1NYXRoJiZ0fSxvPXIoIm9iamVjdCI9PXR5cGVvZiBnbG9iYWxUaGlzJiZnbG9iYWxUaGlzKXx8cigib2JqZWN0Ij09dHlwZW9mIHdpbmRvdyYmd2luZG93KXx8cigib2JqZWN0Ij09dHlwZW9mIHNlbGYmJnNlbGYpfHxyKCJvYmplY3QiPT10eXBlb2YgdCYmdCl8fHIoIm9iamVjdCI9PXR5cGVvZiB0JiZ0KXx8ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKXx8RnVuY3Rpb24oInJldHVybiB0aGlzIikoKSxpPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4hIXQoKX1jYXRjaChlKXtyZXR1cm4hMH19LHU9IWkoKGZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oKXt9LmJpbmQoKTtyZXR1cm4iZnVuY3Rpb24iIT10eXBlb2YgdHx8dC5oYXNPd25Qcm9wZXJ0eSgicHJvdG90eXBlIil9KSksYT11LGM9RnVuY3Rpb24ucHJvdG90eXBlLHM9Yy5hcHBseSxmPWMuY2FsbCxsPSJvYmplY3QiPT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5hcHBseXx8KGE/Zi5iaW5kKHMpOmZ1bmN0aW9uKCl7cmV0dXJuIGYuYXBwbHkocyxhcmd1bWVudHMpfSkseT11LHA9RnVuY3Rpb24ucHJvdG90eXBlLGg9cC5jYWxsLGc9eSYmcC5iaW5kLmJpbmQoaCxoKSxkPXk/ZzpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gaC5hcHBseSh0LGFyZ3VtZW50cyl9fSxiPWQsdj1iKHt9LnRvU3RyaW5nKSxtPWIoIiIuc2xpY2UpLFM9ZnVuY3Rpb24odCl7cmV0dXJuIG0odih0KSw4LC0xKX0sdz1TLE89ZCxMPWZ1bmN0aW9uKHQpe2lmKCJGdW5jdGlvbiI9PT13KHQpKXJldHVybiBPKHQpfSxqPSJvYmplY3QiPT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmFsbCxBPXZvaWQgMD09PWomJnZvaWQgMCE9PWo/ZnVuY3Rpb24odCl7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHR8fHQ9PT1qfTpmdW5jdGlvbih0KXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgdH0sUD17fSxJPSFpKChmdW5jdGlvbigpe3JldHVybiA3IT09T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LDEse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pWzFdfSkpLEU9dSxUPUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLGs9RT9ULmJpbmQoVCk6ZnVuY3Rpb24oKXtyZXR1cm4gVC5hcHBseShULGFyZ3VtZW50cyl9LHg9e30sRj17fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxDPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsTj1DJiYhRi5jYWxsKHsxOjJ9LDEpO3guZj1OP2Z1bmN0aW9uKHQpe3ZhciBlPUModGhpcyx0KTtyZXR1cm4hIWUmJmUuZW51bWVyYWJsZX06Rjt2YXIgTSxSLFU9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6ZX19LEQ9aSxfPVMsRz1PYmplY3QsSD1kKCIiLnNwbGl0KSxCPUQoKGZ1bmN0aW9uKCl7cmV0dXJuIUcoInoiKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKX0pKT9mdW5jdGlvbih0KXtyZXR1cm4iU3RyaW5nIj09PV8odCk/SCh0LCIiKTpHKHQpfTpHLFY9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXR9LFc9Vix6PVR5cGVFcnJvcixLPWZ1bmN0aW9uKHQpe2lmKFcodCkpdGhyb3cgbmV3IHooIkNhbid0IGNhbGwgbWV0aG9kIG9uICIrdCk7cmV0dXJuIHR9LHE9QixKPUssWT1mdW5jdGlvbih0KXtyZXR1cm4gcShKKHQpKX0sWD1BLCQ9ZnVuY3Rpb24odCl7cmV0dXJuIm9iamVjdCI9PXR5cGVvZiB0P251bGwhPT10OlgodCl9LFE9e30sWj1RLHR0PW8sZXQ9QSxudD1mdW5jdGlvbih0KXtyZXR1cm4gZXQodCk/dDp2b2lkIDB9LHJ0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg8Mj9udChaW3RdKXx8bnQodHRbdF0pOlpbdF0mJlpbdF1bZV18fHR0W3RdJiZ0dFt0XVtlXX0sb3Q9ZCh7fS5pc1Byb3RvdHlwZU9mKSxpdD1vLm5hdmlnYXRvcix1dD1pdCYmaXQudXNlckFnZW50LGF0PW8sY3Q9dXQ/U3RyaW5nKHV0KToiIixzdD1hdC5wcm9jZXNzLGZ0PWF0LkRlbm8sbHQ9c3QmJnN0LnZlcnNpb25zfHxmdCYmZnQudmVyc2lvbix5dD1sdCYmbHQudjg7eXQmJihSPShNPXl0LnNwbGl0KCIuIikpWzBdPjAmJk1bMF08ND8xOisoTVswXStNWzFdKSksIVImJmN0JiYoIShNPWN0Lm1hdGNoKC9FZGdlXC8oXGQrKS8pKXx8TVsxXT49NzQpJiYoTT1jdC5tYXRjaCgvQ2hyb21lXC8oXGQrKS8pKSYmKFI9K01bMV0pO3ZhciBwdD1SLGh0PXB0LGd0PWksZHQ9by5TdHJpbmcsYnQ9ISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzJiYhZ3QoKGZ1bmN0aW9uKCl7dmFyIHQ9U3ltYm9sKCJzeW1ib2wgZGV0ZWN0aW9uIik7cmV0dXJuIWR0KHQpfHwhKE9iamVjdCh0KWluc3RhbmNlb2YgU3ltYm9sKXx8IVN5bWJvbC5zaGFtJiZodCYmaHQ8NDF9KSksdnQ9YnQmJiFTeW1ib2wuc2hhbSYmInN5bWJvbCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3IsbXQ9cnQsU3Q9QSx3dD1vdCxPdD1PYmplY3QsTHQ9dnQ/ZnVuY3Rpb24odCl7cmV0dXJuInN5bWJvbCI9PXR5cGVvZiB0fTpmdW5jdGlvbih0KXt2YXIgZT1tdCgiU3ltYm9sIik7cmV0dXJuIFN0KGUpJiZ3dChlLnByb3RvdHlwZSxPdCh0KSl9LGp0PVN0cmluZyxBdD1mdW5jdGlvbih0KXt0cnl7cmV0dXJuIGp0KHQpfWNhdGNoKGUpe3JldHVybiJPYmplY3QifX0sUHQ9QSxJdD1BdCxFdD1UeXBlRXJyb3IsVHQ9ZnVuY3Rpb24odCl7aWYoUHQodCkpcmV0dXJuIHQ7dGhyb3cgbmV3IEV0KEl0KHQpKyIgaXMgbm90IGEgZnVuY3Rpb24iKX0sa3Q9VHQseHQ9VixGdD1rLEN0PUEsTnQ9JCxNdD1UeXBlRXJyb3IsUnQ9e2V4cG9ydHM6e319LFV0PW8sRHQ9T2JqZWN0LmRlZmluZVByb3BlcnR5LF90PW8sR3Q9ZnVuY3Rpb24odCxlKXt0cnl7RHQoVXQsdCx7dmFsdWU6ZSxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KX1jYXRjaChuKXtVdFt0XT1lfXJldHVybiBlfSxIdD0iX19jb3JlLWpzX3NoYXJlZF9fIixCdD1SdC5leHBvcnRzPV90W0h0XXx8R3QoSHQse30pOyhCdC52ZXJzaW9uc3x8KEJ0LnZlcnNpb25zPVtdKSkucHVzaCh7dmVyc2lvbjoiMy4zOS4wIixtb2RlOiJwdXJlIixjb3B5cmlnaHQ6IsKpIDIwMTQtMjAyNCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSIsbGljZW5zZToiaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4zOS4wL0xJQ0VOU0UiLHNvdXJjZToiaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMifSk7dmFyIFZ0PVJ0LmV4cG9ydHMsV3Q9VnQsenQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gV3RbdF18fChXdFt0XT1lfHx7fSl9LEt0PUsscXQ9T2JqZWN0LEp0PWZ1bmN0aW9uKHQpe3JldHVybiBxdChLdCh0KSl9LFl0PUp0LFh0PWQoe30uaGFzT3duUHJvcGVydHkpLCR0PU9iamVjdC5oYXNPd258fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIFh0KFl0KHQpLGUpfSxRdD1kLFp0PTAsdGU9TWF0aC5yYW5kb20oKSxlZT1RdCgxLi50b1N0cmluZyksbmU9ZnVuY3Rpb24odCl7cmV0dXJuIlN5bWJvbCgiKyh2b2lkIDA9PT10PyIiOnQpKyIpXyIrZWUoKytadCt0ZSwzNil9LHJlPXp0LG9lPSR0LGllPW5lLHVlPWJ0LGFlPXZ0LGNlPW8uU3ltYm9sLHNlPXJlKCJ3a3MiKSxmZT1hZT9jZS5mb3J8fGNlOmNlJiZjZS53aXRob3V0U2V0dGVyfHxpZSxsZT1mdW5jdGlvbih0KXtyZXR1cm4gb2Uoc2UsdCl8fChzZVt0XT11ZSYmb2UoY2UsdCk/Y2VbdF06ZmUoIlN5bWJvbC4iK3QpKSxzZVt0XX0seWU9ayxwZT0kLGhlPUx0LGdlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dFtlXTtyZXR1cm4geHQobik/dm9pZCAwOmt0KG4pfSxkZT1mdW5jdGlvbih0LGUpe3ZhciBuLHI7aWYoInN0cmluZyI9PT1lJiZDdChuPXQudG9TdHJpbmcpJiYhTnQocj1GdChuLHQpKSlyZXR1cm4gcjtpZihDdChuPXQudmFsdWVPZikmJiFOdChyPUZ0KG4sdCkpKXJldHVybiByO2lmKCJzdHJpbmciIT09ZSYmQ3Qobj10LnRvU3RyaW5nKSYmIU50KHI9RnQobix0KSkpcmV0dXJuIHI7dGhyb3cgbmV3IE10KCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKX0sYmU9VHlwZUVycm9yLHZlPWxlKCJ0b1ByaW1pdGl2ZSIpLG1lPWZ1bmN0aW9uKHQsZSl7aWYoIXBlKHQpfHxoZSh0KSlyZXR1cm4gdDt2YXIgbixyPWdlKHQsdmUpO2lmKHIpe2lmKHZvaWQgMD09PWUmJihlPSJkZWZhdWx0Iiksbj15ZShyLHQsZSksIXBlKG4pfHxoZShuKSlyZXR1cm4gbjt0aHJvdyBuZXcgYmUoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpfXJldHVybiB2b2lkIDA9PT1lJiYoZT0ibnVtYmVyIiksZGUodCxlKX0sU2U9THQsd2U9ZnVuY3Rpb24odCl7dmFyIGU9bWUodCwic3RyaW5nIik7cmV0dXJuIFNlKGUpP2U6ZSsiIn0sT2U9JCxMZT1vLmRvY3VtZW50LGplPU9lKExlKSYmT2UoTGUuY3JlYXRlRWxlbWVudCksQWU9ZnVuY3Rpb24odCl7cmV0dXJuIGplP0xlLmNyZWF0ZUVsZW1lbnQodCk6e319LFBlPUFlLEllPSFJJiYhaSgoZnVuY3Rpb24oKXtyZXR1cm4gNyE9PU9iamVjdC5kZWZpbmVQcm9wZXJ0eShQZSgiZGl2IiksImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSkpLEVlPUksVGU9ayxrZT14LHhlPVUsRmU9WSxDZT13ZSxOZT0kdCxNZT1JZSxSZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1AuZj1FZT9SZTpmdW5jdGlvbih0LGUpe2lmKHQ9RmUodCksZT1DZShlKSxNZSl0cnl7cmV0dXJuIFJlKHQsZSl9Y2F0Y2gobil7fWlmKE5lKHQsZSkpcmV0dXJuIHhlKCFUZShrZS5mLHQsZSksdFtlXSl9O3ZhciBVZT1pLERlPUEsX2U9LyN8XC5wcm90b3R5cGVcLi8sR2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1CZVtIZSh0KV07cmV0dXJuIG49PT1XZXx8biE9PVZlJiYoRGUoZSk/VWUoZSk6ISFlKX0sSGU9R2Uubm9ybWFsaXplPWZ1bmN0aW9uKHQpe3JldHVybiBTdHJpbmcodCkucmVwbGFjZShfZSwiLiIpLnRvTG93ZXJDYXNlKCl9LEJlPUdlLmRhdGE9e30sVmU9R2UuTkFUSVZFPSJOIixXZT1HZS5QT0xZRklMTD0iUCIsemU9R2UsS2U9VHQscWU9dSxKZT1MKEwuYmluZCksWWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gS2UodCksdm9pZCAwPT09ZT90OnFlP0plKHQsZSk6ZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fSxYZT17fSwkZT1JJiZpKChmdW5jdGlvbigpe3JldHVybiA0MiE9PU9iamVjdC5kZWZpbmVQcm9wZXJ0eSgoZnVuY3Rpb24oKXt9KSwicHJvdG90eXBlIix7dmFsdWU6NDIsd3JpdGFibGU6ITF9KS5wcm90b3R5cGV9KSksUWU9JCxaZT1TdHJpbmcsdG49VHlwZUVycm9yLGVuPWZ1bmN0aW9uKHQpe2lmKFFlKHQpKXJldHVybiB0O3Rocm93IG5ldyB0bihaZSh0KSsiIGlzIG5vdCBhbiBvYmplY3QiKX0sbm49SSxybj1JZSxvbj0kZSx1bj1lbixhbj13ZSxjbj1UeXBlRXJyb3Isc249T2JqZWN0LmRlZmluZVByb3BlcnR5LGZuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsbG49ImVudW1lcmFibGUiLHluPSJjb25maWd1cmFibGUiLHBuPSJ3cml0YWJsZSI7WGUuZj1ubj9vbj9mdW5jdGlvbih0LGUsbil7aWYodW4odCksZT1hbihlKSx1bihuKSwiZnVuY3Rpb24iPT10eXBlb2YgdCYmInByb3RvdHlwZSI9PT1lJiYidmFsdWUiaW4gbiYmcG4gaW4gbiYmIW5bcG5dKXt2YXIgcj1mbih0LGUpO3ImJnJbcG5dJiYodFtlXT1uLnZhbHVlLG49e2NvbmZpZ3VyYWJsZTp5biBpbiBuP25beW5dOnJbeW5dLGVudW1lcmFibGU6bG4gaW4gbj9uW2xuXTpyW2xuXSx3cml0YWJsZTohMX0pfXJldHVybiBzbih0LGUsbil9OnNuOmZ1bmN0aW9uKHQsZSxuKXtpZih1bih0KSxlPWFuKGUpLHVuKG4pLHJuKXRyeXtyZXR1cm4gc24odCxlLG4pfWNhdGNoKHIpe31pZigiZ2V0ImluIG58fCJzZXQiaW4gbil0aHJvdyBuZXcgY24oIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIik7cmV0dXJuInZhbHVlImluIG4mJih0W2VdPW4udmFsdWUpLHR9O3ZhciBobj1YZSxnbj1VLGRuPUk/ZnVuY3Rpb24odCxlLG4pe3JldHVybiBobi5mKHQsZSxnbigxLG4pKX06ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0W2VdPW4sdH0sYm49byx2bj1sLG1uPUwsU249QSx3bj1QLmYsT249emUsTG49USxqbj1ZZSxBbj1kbixQbj0kdCxJbj1mdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbihuLHIsbyl7aWYodGhpcyBpbnN0YW5jZW9mIGUpe3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG5ldyB0O2Nhc2UgMTpyZXR1cm4gbmV3IHQobik7Y2FzZSAyOnJldHVybiBuZXcgdChuLHIpfXJldHVybiBuZXcgdChuLHIsbyl9cmV0dXJuIHZuKHQsdGhpcyxhcmd1bWVudHMpfTtyZXR1cm4gZS5wcm90b3R5cGU9dC5wcm90b3R5cGUsZX0sRW49ZnVuY3Rpb24odCxlKXt2YXIgbixyLG8saSx1LGEsYyxzLGYsbD10LnRhcmdldCx5PXQuZ2xvYmFsLHA9dC5zdGF0LGg9dC5wcm90byxnPXk/Ym46cD9ibltsXTpibltsXSYmYm5bbF0ucHJvdG90eXBlLGQ9eT9MbjpMbltsXXx8QW4oTG4sbCx7fSlbbF0sYj1kLnByb3RvdHlwZTtmb3IoaSBpbiBlKXI9IShuPU9uKHk/aTpsKyhwPyIuIjoiIyIpK2ksdC5mb3JjZWQpKSYmZyYmUG4oZyxpKSxhPWRbaV0sciYmKGM9dC5kb250Q2FsbEdldFNldD8oZj13bihnLGkpKSYmZi52YWx1ZTpnW2ldKSx1PXImJmM/YzplW2ldLChufHxofHx0eXBlb2YgYSE9dHlwZW9mIHUpJiYocz10LmJpbmQmJnI/am4odSxibik6dC53cmFwJiZyP0luKHUpOmgmJlNuKHUpP21uKHUpOnUsKHQuc2hhbXx8dSYmdS5zaGFtfHxhJiZhLnNoYW0pJiZBbihzLCJzaGFtIiwhMCksQW4oZCxpLHMpLGgmJihQbihMbixvPWwrIlByb3RvdHlwZSIpfHxBbihMbixvLHt9KSxBbihMbltvXSxpLHUpLHQucmVhbCYmYiYmKG58fCFiW2ldKSYmQW4oYixpLHUpKSl9LFRuPUVuLGtuPUkseG49WGUuZjtUbih7dGFyZ2V0OiJPYmplY3QiLHN0YXQ6ITAsZm9yY2VkOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSE9PXhuLHNoYW06IWtufSx7ZGVmaW5lUHJvcGVydHk6eG59KTt2YXIgRm49US5PYmplY3QsQ249bi5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gRm4uZGVmaW5lUHJvcGVydHkodCxlLG4pfTtGbi5kZWZpbmVQcm9wZXJ0eS5zaGFtJiYoQ24uc2hhbT0hMCk7dmFyIE5uPWUobi5leHBvcnRzKSxNbj1TLFJuPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHQpe3JldHVybiJBcnJheSI9PT1Nbih0KX0sVW49TWF0aC5jZWlsLERuPU1hdGguZmxvb3IsX249TWF0aC50cnVuY3x8ZnVuY3Rpb24odCl7dmFyIGU9K3Q7cmV0dXJuKGU+MD9EbjpVbikoZSl9LEduPWZ1bmN0aW9uKHQpe3ZhciBlPSt0O3JldHVybiBlIT1lfHwwPT09ZT8wOl9uKGUpfSxIbj1HbixCbj1NYXRoLm1pbixWbj1mdW5jdGlvbih0KXt2YXIgZT1Ibih0KTtyZXR1cm4gZT4wP0JuKGUsOTAwNzE5OTI1NDc0MDk5MSk6MH0sV249ZnVuY3Rpb24odCl7cmV0dXJuIFZuKHQubGVuZ3RoKX0sem49VHlwZUVycm9yLEtuPUkscW49WGUsSm49VSxZbj17fTtZbltsZSgidG9TdHJpbmdUYWciKV09InoiO3ZhciBYbj0iW29iamVjdCB6XSI9PT1TdHJpbmcoWW4pLCRuPVhuLFFuPUEsWm49Uyx0cj1sZSgidG9TdHJpbmdUYWciKSxlcj1PYmplY3QsbnI9IkFyZ3VtZW50cyI9PT1abihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpLHJyPSRuP1puOmZ1bmN0aW9uKHQpe3ZhciBlLG4scjtyZXR1cm4gdm9pZCAwPT09dD8iVW5kZWZpbmVkIjpudWxsPT09dD8iTnVsbCI6InN0cmluZyI9PXR5cGVvZihuPWZ1bmN0aW9uKHQsZSl7dHJ5e3JldHVybiB0W2VdfWNhdGNoKG4pe319KGU9ZXIodCksdHIpKT9uOm5yP1puKGUpOiJPYmplY3QiPT09KHI9Wm4oZSkpJiZRbihlLmNhbGxlZSk/IkFyZ3VtZW50cyI6cn0sb3I9QSxpcj1WdCx1cj1kKEZ1bmN0aW9uLnRvU3RyaW5nKTtvcihpci5pbnNwZWN0U291cmNlKXx8KGlyLmluc3BlY3RTb3VyY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHVyKHQpfSk7dmFyIGFyPWlyLmluc3BlY3RTb3VyY2UsY3I9ZCxzcj1pLGZyPUEsbHI9cnIseXI9YXIscHI9ZnVuY3Rpb24oKXt9LGhyPXJ0KCJSZWZsZWN0IiwiY29uc3RydWN0IiksZ3I9L15ccyooPzpjbGFzc3xmdW5jdGlvbilcYi8sZHI9Y3IoZ3IuZXhlYyksYnI9IWdyLnRlc3QocHIpLHZyPWZ1bmN0aW9uKHQpe2lmKCFmcih0KSlyZXR1cm4hMTt0cnl7cmV0dXJuIGhyKHByLFtdLHQpLCEwfWNhdGNoKGUpe3JldHVybiExfX0sbXI9ZnVuY3Rpb24odCl7aWYoIWZyKHQpKXJldHVybiExO3N3aXRjaChscih0KSl7Y2FzZSJBc3luY0Z1bmN0aW9uIjpjYXNlIkdlbmVyYXRvckZ1bmN0aW9uIjpjYXNlIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb24iOnJldHVybiExfXRyeXtyZXR1cm4gYnJ8fCEhZHIoZ3IseXIodCkpfWNhdGNoKGUpe3JldHVybiEwfX07bXIuc2hhbT0hMDt2YXIgU3I9IWhyfHxzcigoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gdnIodnIuY2FsbCl8fCF2cihPYmplY3QpfHwhdnIoKGZ1bmN0aW9uKCl7dD0hMH0pKXx8dH0pKT9tcjp2cix3cj1SbixPcj1TcixMcj0kLGpyPWxlKCJzcGVjaWVzIiksQXI9QXJyYXksUHI9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHdyKHQpJiYoZT10LmNvbnN0cnVjdG9yLChPcihlKSYmKGU9PT1Bcnx8d3IoZS5wcm90b3R5cGUpKXx8THIoZSkmJm51bGw9PT0oZT1lW2pyXSkpJiYoZT12b2lkIDApKSx2b2lkIDA9PT1lP0FyOmV9LElyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyhQcih0KSkoMD09PWU/MDplKX0sRXI9aSxUcj1wdCxrcj1sZSgic3BlY2llcyIpLHhyPUVuLEZyPWksQ3I9Um4sTnI9JCxNcj1KdCxScj1XbixVcj1mdW5jdGlvbih0KXtpZih0PjkwMDcxOTkyNTQ3NDA5OTEpdGhyb3cgem4oIk1heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCIpO3JldHVybiB0fSxEcj1mdW5jdGlvbih0LGUsbil7S24/cW4uZih0LGUsSm4oMCxuKSk6dFtlXT1ufSxfcj1JcixHcj1mdW5jdGlvbih0KXtyZXR1cm4gVHI+PTUxfHwhRXIoKGZ1bmN0aW9uKCl7dmFyIGU9W107cmV0dXJuKGUuY29uc3RydWN0b3I9e30pW2tyXT1mdW5jdGlvbigpe3JldHVybntmb286MX19LDEhPT1lW3RdKEJvb2xlYW4pLmZvb30pKX0sSHI9cHQsQnI9bGUoImlzQ29uY2F0U3ByZWFkYWJsZSIpLFZyPUhyPj01MXx8IUZyKChmdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0W0JyXT0hMSx0LmNvbmNhdCgpWzBdIT09dH0pKSxXcj1mdW5jdGlvbih0KXtpZighTnIodCkpcmV0dXJuITE7dmFyIGU9dFtCcl07cmV0dXJuIHZvaWQgMCE9PWU/ISFlOkNyKHQpfTt4cih7dGFyZ2V0OiJBcnJheSIscHJvdG86ITAsYXJpdHk6MSxmb3JjZWQ6IVZyfHwhR3IoImNvbmNhdCIpfSx7Y29uY2F0OmZ1bmN0aW9uKHQpe3ZhciBlLG4scixvLGksdT1Ncih0aGlzKSxhPV9yKHUsMCksYz0wO2ZvcihlPS0xLHI9YXJndW1lbnRzLmxlbmd0aDtlPHI7ZSsrKWlmKFdyKGk9LTE9PT1lP3U6YXJndW1lbnRzW2VdKSlmb3Iobz1ScihpKSxVcihjK28pLG49MDtuPG87bisrLGMrKyluIGluIGkmJkRyKGEsYyxpW25dKTtlbHNlIFVyKGMrMSksRHIoYSxjKyssaSk7cmV0dXJuIGEubGVuZ3RoPWMsYX19KTt2YXIgenI9cnIsS3I9U3RyaW5nLHFyPWZ1bmN0aW9uKHQpe2lmKCJTeW1ib2wiPT09enIodCkpdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmciKTtyZXR1cm4gS3IodCl9LEpyPXt9LFlyPUduLFhyPU1hdGgubWF4LCRyPU1hdGgubWluLFFyPVksWnI9ZnVuY3Rpb24odCxlKXt2YXIgbj1Zcih0KTtyZXR1cm4gbjwwP1hyKG4rZSwwKTokcihuLGUpfSx0bz1Xbixlbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3ZhciBvPVFyKGUpLGk9dG8obyk7aWYoMD09PWkpcmV0dXJuIXQmJi0xO3ZhciB1LGE9WnIocixpKTtpZih0JiZuIT1uKXtmb3IoO2k+YTspaWYoKHU9b1thKytdKSE9dSlyZXR1cm4hMH1lbHNlIGZvcig7aT5hO2ErKylpZigodHx8YSBpbiBvKSYmb1thXT09PW4pcmV0dXJuIHR8fGF8fDA7cmV0dXJuIXQmJi0xfX0sbm89e2luY2x1ZGVzOmVvKCEwKSxpbmRleE9mOmVvKCExKX0scm89e30sb289JHQsaW89WSx1bz1uby5pbmRleE9mLGFvPXJvLGNvPWQoW10ucHVzaCksc289ZnVuY3Rpb24odCxlKXt2YXIgbixyPWlvKHQpLG89MCxpPVtdO2ZvcihuIGluIHIpIW9vKGFvLG4pJiZvbyhyLG4pJiZjbyhpLG4pO2Zvcig7ZS5sZW5ndGg+bzspb28ocixuPWVbbysrXSkmJih+dW8oaSxuKXx8Y28oaSxuKSk7cmV0dXJuIGl9LGZvPVsiY29uc3RydWN0b3IiLCJoYXNPd25Qcm9wZXJ0eSIsImlzUHJvdG90eXBlT2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvTG9jYWxlU3RyaW5nIiwidG9TdHJpbmciLCJ2YWx1ZU9mIl0sbG89c28seW89Zm8scG89T2JqZWN0LmtleXN8fGZ1bmN0aW9uKHQpe3JldHVybiBsbyh0LHlvKX0saG89SSxnbz0kZSxibz1YZSx2bz1lbixtbz1ZLFNvPXBvO0pyLmY9aG8mJiFnbz9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbih0LGUpe3ZvKHQpO2Zvcih2YXIgbixyPW1vKGUpLG89U28oZSksaT1vLmxlbmd0aCx1PTA7aT51Oyliby5mKHQsbj1vW3UrK10scltuXSk7cmV0dXJuIHR9O3ZhciB3byxPbz1ydCgiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiKSxMbz1uZSxqbz16dCgia2V5cyIpLEFvPWZ1bmN0aW9uKHQpe3JldHVybiBqb1t0XXx8KGpvW3RdPUxvKHQpKX0sUG89ZW4sSW89SnIsRW89Zm8sVG89cm8sa289T28seG89QWUsRm89InByb3RvdHlwZSIsQ289InNjcmlwdCIsTm89QW8oIklFX1BST1RPIiksTW89ZnVuY3Rpb24oKXt9LFJvPWZ1bmN0aW9uKHQpe3JldHVybiI8IitDbysiPiIrdCsiPC8iK0NvKyI+In0sVW89ZnVuY3Rpb24odCl7dC53cml0ZShSbygiIikpLHQuY2xvc2UoKTt2YXIgZT10LnBhcmVudFdpbmRvdy5PYmplY3Q7cmV0dXJuIHQ9bnVsbCxlfSxEbz1mdW5jdGlvbigpe3RyeXt3bz1uZXcgQWN0aXZlWE9iamVjdCgiaHRtbGZpbGUiKX1jYXRjaChvKXt9dmFyIHQsZSxuO0RvPSJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQuZG9tYWluJiZ3bz9Vbyh3byk6KGU9eG8oImlmcmFtZSIpLG49ImphdmEiK0NvKyI6IixlLnN0eWxlLmRpc3BsYXk9Im5vbmUiLGtvLmFwcGVuZENoaWxkKGUpLGUuc3JjPVN0cmluZyhuKSwodD1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQpLm9wZW4oKSx0LndyaXRlKFJvKCJkb2N1bWVudC5GPU9iamVjdCIpKSx0LmNsb3NlKCksdC5GKTpVbyh3byk7Zm9yKHZhciByPUVvLmxlbmd0aDtyLS07KWRlbGV0ZSBEb1tGb11bRW9bcl1dO3JldHVybiBEbygpfTtUb1tOb109ITA7dmFyIF9vPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuIG51bGwhPT10PyhNb1tGb109UG8odCksbj1uZXcgTW8sTW9bRm9dPW51bGwsbltOb109dCk6bj1EbygpLHZvaWQgMD09PWU/bjpJby5mKG4sZSl9LEdvPXt9LEhvPXNvLEJvPWZvLmNvbmNhdCgibGVuZ3RoIiwicHJvdG90eXBlIik7R28uZj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc3x8ZnVuY3Rpb24odCl7cmV0dXJuIEhvKHQsQm8pfTt2YXIgVm89e30sV289ZChbXS5zbGljZSksem89UyxLbz1ZLHFvPUdvLmYsSm89V28sWW89Im9iamVjdCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXTtWby5mPWZ1bmN0aW9uKHQpe3JldHVybiBZbyYmIldpbmRvdyI9PT16byh0KT9mdW5jdGlvbih0KXt0cnl7cmV0dXJuIHFvKHQpfWNhdGNoKGUpe3JldHVybiBKbyhZbyl9fSh0KTpxbyhLbyh0KSl9O3ZhciBYbz17fTtYby5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7dmFyICRvPWRuLFFvPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiByJiZyLmVudW1lcmFibGU/dFtlXT1uOiRvKHQsZSxuKSx0fSxabz1YZSx0aT17fSxlaT1sZTt0aS5mPWVpO3ZhciBuaSxyaSxvaSxpaT1RLHVpPSR0LGFpPXRpLGNpPVhlLmYsc2k9ZnVuY3Rpb24odCl7dmFyIGU9aWkuU3ltYm9sfHwoaWkuU3ltYm9sPXt9KTt1aShlLHQpfHxjaShlLHQse3ZhbHVlOmFpLmYodCl9KX0sZmk9ayxsaT1ydCx5aT1sZSxwaT1RbyxoaT1mdW5jdGlvbigpe3ZhciB0PWxpKCJTeW1ib2wiKSxlPXQmJnQucHJvdG90eXBlLG49ZSYmZS52YWx1ZU9mLHI9eWkoInRvUHJpbWl0aXZlIik7ZSYmIWVbcl0mJnBpKGUsciwoZnVuY3Rpb24odCl7cmV0dXJuIGZpKG4sdGhpcyl9KSx7YXJpdHk6MX0pfSxnaT1ycixkaT1Ybj97fS50b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiJbb2JqZWN0ICIrZ2kodGhpcykrIl0ifSxiaT1Ybix2aT1YZS5mLG1pPWRuLFNpPSR0LHdpPWRpLE9pPWxlKCJ0b1N0cmluZ1RhZyIpLExpPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW4/dDp0JiZ0LnByb3RvdHlwZTtvJiYoU2kobyxPaSl8fHZpKG8sT2kse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTplfSksciYmIWJpJiZtaShvLCJ0b1N0cmluZyIsd2kpKX0samk9QSxBaT1vLldlYWtNYXAsUGk9amkoQWkpJiYvbmF0aXZlIGNvZGUvLnRlc3QoU3RyaW5nKEFpKSksSWk9byxFaT0kLFRpPWRuLGtpPSR0LHhpPVZ0LEZpPUFvLENpPXJvLE5pPSJPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCIsTWk9SWkuVHlwZUVycm9yLFJpPUlpLldlYWtNYXA7aWYoUGl8fHhpLnN0YXRlKXt2YXIgVWk9eGkuc3RhdGV8fCh4aS5zdGF0ZT1uZXcgUmkpO1VpLmdldD1VaS5nZXQsVWkuaGFzPVVpLmhhcyxVaS5zZXQ9VWkuc2V0LG5pPWZ1bmN0aW9uKHQsZSl7aWYoVWkuaGFzKHQpKXRocm93IG5ldyBNaShOaSk7cmV0dXJuIGUuZmFjYWRlPXQsVWkuc2V0KHQsZSksZX0scmk9ZnVuY3Rpb24odCl7cmV0dXJuIFVpLmdldCh0KXx8e319LG9pPWZ1bmN0aW9uKHQpe3JldHVybiBVaS5oYXModCl9fWVsc2V7dmFyIERpPUZpKCJzdGF0ZSIpO0NpW0RpXT0hMCxuaT1mdW5jdGlvbih0LGUpe2lmKGtpKHQsRGkpKXRocm93IG5ldyBNaShOaSk7cmV0dXJuIGUuZmFjYWRlPXQsVGkodCxEaSxlKSxlfSxyaT1mdW5jdGlvbih0KXtyZXR1cm4ga2kodCxEaSk/dFtEaV06e319LG9pPWZ1bmN0aW9uKHQpe3JldHVybiBraSh0LERpKX19dmFyIF9pPXtzZXQ6bmksZ2V0OnJpLGhhczpvaSxlbmZvcmNlOmZ1bmN0aW9uKHQpe3JldHVybiBvaSh0KT9yaSh0KTpuaSh0LHt9KX0sZ2V0dGVyRm9yOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgbjtpZighRWkoZSl8fChuPXJpKGUpKS50eXBlIT09dCl0aHJvdyBuZXcgTWkoIkluY29tcGF0aWJsZSByZWNlaXZlciwgIit0KyIgcmVxdWlyZWQiKTtyZXR1cm4gbn19fSxHaT1ZZSxIaT1CLEJpPUp0LFZpPVduLFdpPUlyLHppPWQoW10ucHVzaCksS2k9ZnVuY3Rpb24odCl7dmFyIGU9MT09PXQsbj0yPT09dCxyPTM9PT10LG89ND09PXQsaT02PT09dCx1PTc9PT10LGE9NT09PXR8fGk7cmV0dXJuIGZ1bmN0aW9uKGMscyxmLGwpe2Zvcih2YXIgeSxwLGg9QmkoYyksZz1IaShoKSxkPVZpKGcpLGI9R2kocyxmKSx2PTAsbT1sfHxXaSxTPWU/bShjLGQpOm58fHU/bShjLDApOnZvaWQgMDtkPnY7disrKWlmKChhfHx2IGluIGcpJiYocD1iKHk9Z1t2XSx2LGgpLHQpKWlmKGUpU1t2XT1wO2Vsc2UgaWYocClzd2l0Y2godCl7Y2FzZSAzOnJldHVybiEwO2Nhc2UgNTpyZXR1cm4geTtjYXNlIDY6cmV0dXJuIHY7Y2FzZSAyOnppKFMseSl9ZWxzZSBzd2l0Y2godCl7Y2FzZSA0OnJldHVybiExO2Nhc2UgNzp6aShTLHkpfXJldHVybiBpPy0xOnJ8fG8/bzpTfX0scWk9e2ZvckVhY2g6S2koMCksbWFwOktpKDEpLGZpbHRlcjpLaSgyKSxzb21lOktpKDMpLGV2ZXJ5OktpKDQpLGZpbmQ6S2koNSksZmluZEluZGV4OktpKDYpLGZpbHRlclJlamVjdDpLaSg3KX0sSmk9RW4sWWk9byxYaT1rLCRpPWQsUWk9SSxaaT1idCx0dT1pLGV1PSR0LG51PW90LHJ1PWVuLG91PVksaXU9d2UsdXU9cXIsYXU9VSxjdT1fbyxzdT1wbyxmdT1HbyxsdT1Wbyx5dT1YbyxwdT1QLGh1PVhlLGd1PUpyLGR1PXgsYnU9UW8sdnU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBaby5mKHQsZSxuKX0sbXU9enQsU3U9cm8sd3U9bmUsT3U9bGUsTHU9dGksanU9c2ksQXU9aGksUHU9TGksSXU9X2ksRXU9cWkuZm9yRWFjaCxUdT1BbygiaGlkZGVuIiksa3U9IlN5bWJvbCIseHU9InByb3RvdHlwZSIsRnU9SXUuc2V0LEN1PUl1LmdldHRlckZvcihrdSksTnU9T2JqZWN0W3h1XSxNdT1ZaS5TeW1ib2wsUnU9TXUmJk11W3h1XSxVdT1ZaS5SYW5nZUVycm9yLER1PVlpLlR5cGVFcnJvcixfdT1ZaS5RT2JqZWN0LEd1PXB1LmYsSHU9aHUuZixCdT1sdS5mLFZ1PWR1LmYsV3U9JGkoW10ucHVzaCksenU9bXUoInN5bWJvbHMiKSxLdT1tdSgib3Atc3ltYm9scyIpLHF1PW11KCJ3a3MiKSxKdT0hX3V8fCFfdVt4dV18fCFfdVt4dV0uZmluZENoaWxkLFl1PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1HdShOdSxlKTtyJiZkZWxldGUgTnVbZV0sSHUodCxlLG4pLHImJnQhPT1OdSYmSHUoTnUsZSxyKX0sWHU9UWkmJnR1KChmdW5jdGlvbigpe3JldHVybiA3IT09Y3UoSHUoe30sImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gSHUodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hfSkpP1l1Okh1LCR1PWZ1bmN0aW9uKHQsZSl7dmFyIG49enVbdF09Y3UoUnUpO3JldHVybiBGdShuLHt0eXBlOmt1LHRhZzp0LGRlc2NyaXB0aW9uOmV9KSxRaXx8KG4uZGVzY3JpcHRpb249ZSksbn0sUXU9ZnVuY3Rpb24odCxlLG4pe3Q9PT1OdSYmUXUoS3UsZSxuKSxydSh0KTt2YXIgcj1pdShlKTtyZXR1cm4gcnUobiksZXUoenUscik/KG4uZW51bWVyYWJsZT8oZXUodCxUdSkmJnRbVHVdW3JdJiYodFtUdV1bcl09ITEpLG49Y3Uobix7ZW51bWVyYWJsZTphdSgwLCExKX0pKTooZXUodCxUdSl8fEh1KHQsVHUsYXUoMSxjdShudWxsKSkpLHRbVHVdW3JdPSEwKSxYdSh0LHIsbikpOkh1KHQscixuKX0sWnU9ZnVuY3Rpb24odCxlKXtydSh0KTt2YXIgbj1vdShlKSxyPXN1KG4pLmNvbmNhdChyYShuKSk7cmV0dXJuIEV1KHIsKGZ1bmN0aW9uKGUpe1FpJiYhWGkodGEsbixlKXx8UXUodCxlLG5bZV0pfSkpLHR9LHRhPWZ1bmN0aW9uKHQpe3ZhciBlPWl1KHQpLG49WGkoVnUsdGhpcyxlKTtyZXR1cm4hKHRoaXM9PT1OdSYmZXUoenUsZSkmJiFldShLdSxlKSkmJighKG58fCFldSh0aGlzLGUpfHwhZXUoenUsZSl8fGV1KHRoaXMsVHUpJiZ0aGlzW1R1XVtlXSl8fG4pfSxlYT1mdW5jdGlvbih0LGUpe3ZhciBuPW91KHQpLHI9aXUoZSk7aWYobiE9PU51fHwhZXUoenUscil8fGV1KEt1LHIpKXt2YXIgbz1HdShuLHIpO3JldHVybiFvfHwhZXUoenUscil8fGV1KG4sVHUpJiZuW1R1XVtyXXx8KG8uZW51bWVyYWJsZT0hMCksb319LG5hPWZ1bmN0aW9uKHQpe3ZhciBlPUJ1KG91KHQpKSxuPVtdO3JldHVybiBFdShlLChmdW5jdGlvbih0KXtldSh6dSx0KXx8ZXUoU3UsdCl8fFd1KG4sdCl9KSksbn0scmE9ZnVuY3Rpb24odCl7dmFyIGU9dD09PU51LG49QnUoZT9LdTpvdSh0KSkscj1bXTtyZXR1cm4gRXUobiwoZnVuY3Rpb24odCl7IWV1KHp1LHQpfHxlJiYhZXUoTnUsdCl8fFd1KHIsenVbdF0pfSkpLHJ9O1ppfHwoTXU9ZnVuY3Rpb24oKXtpZihudShSdSx0aGlzKSl0aHJvdyBuZXcgRHUoIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciIpO3ZhciB0PWFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT91dShhcmd1bWVudHNbMF0pOnZvaWQgMCxlPXd1KHQpLG49ZnVuY3Rpb24odCl7dmFyIHI9dm9pZCAwPT09dGhpcz9ZaTp0aGlzO3I9PT1OdSYmWGkobixLdSx0KSxldShyLFR1KSYmZXUocltUdV0sZSkmJihyW1R1XVtlXT0hMSk7dmFyIG89YXUoMSx0KTt0cnl7WHUocixlLG8pfWNhdGNoKGkpe2lmKCEoaSBpbnN0YW5jZW9mIFV1KSl0aHJvdyBpO1l1KHIsZSxvKX19O3JldHVybiBRaSYmSnUmJlh1KE51LGUse2NvbmZpZ3VyYWJsZTohMCxzZXQ6bn0pLCR1KGUsdCl9LGJ1KFJ1PU11W3h1XSwidG9TdHJpbmciLChmdW5jdGlvbigpe3JldHVybiBDdSh0aGlzKS50YWd9KSksYnUoTXUsIndpdGhvdXRTZXR0ZXIiLChmdW5jdGlvbih0KXtyZXR1cm4gJHUod3UodCksdCl9KSksZHUuZj10YSxodS5mPVF1LGd1LmY9WnUscHUuZj1lYSxmdS5mPWx1LmY9bmEseXUuZj1yYSxMdS5mPWZ1bmN0aW9uKHQpe3JldHVybiAkdShPdSh0KSx0KX0sUWkmJnZ1KFJ1LCJkZXNjcmlwdGlvbiIse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQ3UodGhpcykuZGVzY3JpcHRpb259fSkpLEppKHtnbG9iYWw6ITAsY29uc3RydWN0b3I6ITAsd3JhcDohMCxmb3JjZWQ6IVppLHNoYW06IVppfSx7U3ltYm9sOk11fSksRXUoc3UocXUpLChmdW5jdGlvbih0KXtqdSh0KX0pKSxKaSh7dGFyZ2V0Omt1LHN0YXQ6ITAsZm9yY2VkOiFaaX0se3VzZVNldHRlcjpmdW5jdGlvbigpe0p1PSEwfSx1c2VTaW1wbGU6ZnVuY3Rpb24oKXtKdT0hMX19KSxKaSh7dGFyZ2V0OiJPYmplY3QiLHN0YXQ6ITAsZm9yY2VkOiFaaSxzaGFtOiFRaX0se2NyZWF0ZTpmdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lP2N1KHQpOlp1KGN1KHQpLGUpfSxkZWZpbmVQcm9wZXJ0eTpRdSxkZWZpbmVQcm9wZXJ0aWVzOlp1LGdldE93blByb3BlcnR5RGVzY3JpcHRvcjplYX0pLEppKHt0YXJnZXQ6Ik9iamVjdCIsc3RhdDohMCxmb3JjZWQ6IVppfSx7Z2V0T3duUHJvcGVydHlOYW1lczpuYX0pLEF1KCksUHUoTXUsa3UpLFN1W1R1XT0hMDt2YXIgb2E9YnQmJiEhU3ltYm9sLmZvciYmISFTeW1ib2wua2V5Rm9yLGlhPUVuLHVhPXJ0LGFhPSR0LGNhPXFyLHNhPXp0LGZhPW9hLGxhPXNhKCJzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5IikseWE9c2EoInN5bWJvbC10by1zdHJpbmctcmVnaXN0cnkiKTtpYSh7dGFyZ2V0OiJTeW1ib2wiLHN0YXQ6ITAsZm9yY2VkOiFmYX0se2ZvcjpmdW5jdGlvbih0KXt2YXIgZT1jYSh0KTtpZihhYShsYSxlKSlyZXR1cm4gbGFbZV07dmFyIG49dWEoIlN5bWJvbCIpKGUpO3JldHVybiBsYVtlXT1uLHlhW25dPWUsbn19KTt2YXIgcGE9RW4saGE9JHQsZ2E9THQsZGE9QXQsYmE9b2EsdmE9enQoInN5bWJvbC10by1zdHJpbmctcmVnaXN0cnkiKTtwYSh7dGFyZ2V0OiJTeW1ib2wiLHN0YXQ6ITAsZm9yY2VkOiFiYX0se2tleUZvcjpmdW5jdGlvbih0KXtpZighZ2EodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihkYSh0KSsiIGlzIG5vdCBhIHN5bWJvbCIpO2lmKGhhKHZhLHQpKXJldHVybiB2YVt0XX19KTt2YXIgbWE9Um4sU2E9QSx3YT1TLE9hPXFyLExhPWQoW10ucHVzaCksamE9RW4sQWE9cnQsUGE9bCxJYT1rLEVhPWQsVGE9aSxrYT1BLHhhPUx0LEZhPVdvLENhPWZ1bmN0aW9uKHQpe2lmKFNhKHQpKXJldHVybiB0O2lmKG1hKHQpKXtmb3IodmFyIGU9dC5sZW5ndGgsbj1bXSxyPTA7cjxlO3IrKyl7dmFyIG89dFtyXTsic3RyaW5nIj09dHlwZW9mIG8/TGEobixvKToibnVtYmVyIiE9dHlwZW9mIG8mJiJOdW1iZXIiIT09d2EobykmJiJTdHJpbmciIT09d2Eobyl8fExhKG4sT2EobykpfXZhciBpPW4ubGVuZ3RoLHU9ITA7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYodSlyZXR1cm4gdT0hMSxlO2lmKG1hKHRoaXMpKXJldHVybiBlO2Zvcih2YXIgcj0wO3I8aTtyKyspaWYobltyXT09PXQpcmV0dXJuIGV9fX0sTmE9YnQsTWE9U3RyaW5nLFJhPUFhKCJKU09OIiwic3RyaW5naWZ5IiksVWE9RWEoLy4vLmV4ZWMpLERhPUVhKCIiLmNoYXJBdCksX2E9RWEoIiIuY2hhckNvZGVBdCksR2E9RWEoIiIucmVwbGFjZSksSGE9RWEoMS4udG9TdHJpbmcpLEJhPS9bXHVEODAwLVx1REZGRl0vZyxWYT0vXltcdUQ4MDAtXHVEQkZGXSQvLFdhPS9eW1x1REMwMC1cdURGRkZdJC8semE9IU5hfHxUYSgoZnVuY3Rpb24oKXt2YXIgdD1BYSgiU3ltYm9sIikoInN0cmluZ2lmeSBkZXRlY3Rpb24iKTtyZXR1cm4iW251bGxdIiE9PVJhKFt0XSl8fCJ7fSIhPT1SYSh7YTp0fSl8fCJ7fSIhPT1SYShPYmplY3QodCkpfSkpLEthPVRhKChmdW5jdGlvbigpe3JldHVybiciXFx1ZGYwNlxcdWQ4MzQiJyE9PVJhKCJcdWRmMDZcdWQ4MzQiKXx8JyJcXHVkZWFkIichPT1SYSgiXHVkZWFkIil9KSkscWE9ZnVuY3Rpb24odCxlKXt2YXIgbj1GYShhcmd1bWVudHMpLHI9Q2EoZSk7aWYoa2Eocil8fHZvaWQgMCE9PXQmJiF4YSh0KSlyZXR1cm4gblsxXT1mdW5jdGlvbih0LGUpe2lmKGthKHIpJiYoZT1JYShyLHRoaXMsTWEodCksZSkpLCF4YShlKSlyZXR1cm4gZX0sUGEoUmEsbnVsbCxuKX0sSmE9ZnVuY3Rpb24odCxlLG4pe3ZhciByPURhKG4sZS0xKSxvPURhKG4sZSsxKTtyZXR1cm4gVWEoVmEsdCkmJiFVYShXYSxvKXx8VWEoV2EsdCkmJiFVYShWYSxyKT8iXFx1IitIYShfYSh0LDApLDE2KTp0fTtSYSYmamEoe3RhcmdldDoiSlNPTiIsc3RhdDohMCxhcml0eTozLGZvcmNlZDp6YXx8S2F9LHtzdHJpbmdpZnk6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUZhKGFyZ3VtZW50cyksbz1QYSh6YT9xYTpSYSxudWxsLHIpO3JldHVybiBLYSYmInN0cmluZyI9PXR5cGVvZiBvP0dhKG8sQmEsSmEpOm99fSk7dmFyIFlhPVhvLFhhPUp0O0VuKHt0YXJnZXQ6Ik9iamVjdCIsc3RhdDohMCxmb3JjZWQ6IWJ0fHxpKChmdW5jdGlvbigpe1lhLmYoMSl9KSl9LHtnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ZnVuY3Rpb24odCl7dmFyIGU9WWEuZjtyZXR1cm4gZT9lKFhhKHQpKTpbXX19KSxzaSgiYXN5bmNJdGVyYXRvciIpLHNpKCJoYXNJbnN0YW5jZSIpLHNpKCJpc0NvbmNhdFNwcmVhZGFibGUiKSxzaSgiaXRlcmF0b3IiKSxzaSgibWF0Y2giKSxzaSgibWF0Y2hBbGwiKSxzaSgicmVwbGFjZSIpLHNpKCJzZWFyY2giKSxzaSgic3BlY2llcyIpLHNpKCJzcGxpdCIpO3ZhciAkYT1oaTtzaSgidG9QcmltaXRpdmUiKSwkYSgpO3ZhciBRYT1ydCxaYT1MaTtzaSgidG9TdHJpbmdUYWciKSxaYShRYSgiU3ltYm9sIiksIlN5bWJvbCIpLHNpKCJ1bnNjb3BhYmxlcyIpLExpKG8uSlNPTiwiSlNPTiIsITApO3ZhciB0YyxlYyxuYyxyYz1RLlN5bWJvbCxvYz17fSxpYz1JLHVjPSR0LGFjPUZ1bmN0aW9uLnByb3RvdHlwZSxjYz1pYyYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixzYz11YyhhYywibmFtZSIpLGZjPXtFWElTVFM6c2MsUFJPUEVSOnNjJiYic29tZXRoaW5nIj09PWZ1bmN0aW9uKCl7fS5uYW1lLENPTkZJR1VSQUJMRTpzYyYmKCFpY3x8aWMmJmNjKGFjLCJuYW1lIikuY29uZmlndXJhYmxlKX0sbGM9IWkoKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuY29uc3RydWN0b3I9bnVsbCxPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IHQpIT09dC5wcm90b3R5cGV9KSkseWM9JHQscGM9QSxoYz1KdCxnYz1sYyxkYz1BbygiSUVfUFJPVE8iKSxiYz1PYmplY3QsdmM9YmMucHJvdG90eXBlLG1jPWdjP2JjLmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3ZhciBlPWhjKHQpO2lmKHljKGUsZGMpKXJldHVybiBlW2RjXTt2YXIgbj1lLmNvbnN0cnVjdG9yO3JldHVybiBwYyhuKSYmZSBpbnN0YW5jZW9mIG4/bi5wcm90b3R5cGU6ZSBpbnN0YW5jZW9mIGJjP3ZjOm51bGx9LFNjPWksd2M9QSxPYz0kLExjPV9vLGpjPW1jLEFjPVFvLFBjPWxlKCJpdGVyYXRvciIpLEljPSExO1tdLmtleXMmJigibmV4dCJpbihuYz1bXS5rZXlzKCkpPyhlYz1qYyhqYyhuYykpKSE9PU9iamVjdC5wcm90b3R5cGUmJih0Yz1lYyk6SWM9ITApO3ZhciBFYz0hT2ModGMpfHxTYygoZnVuY3Rpb24oKXt2YXIgdD17fTtyZXR1cm4gdGNbUGNdLmNhbGwodCkhPT10fSkpO3djKCh0Yz1FYz97fTpMYyh0YykpW1BjXSl8fEFjKHRjLFBjLChmdW5jdGlvbigpe3JldHVybiB0aGlzfSkpO3ZhciBUYz17SXRlcmF0b3JQcm90b3R5cGU6dGMsQlVHR1lfU0FGQVJJX0lURVJBVE9SUzpJY30sa2M9VGMuSXRlcmF0b3JQcm90b3R5cGUseGM9X28sRmM9VSxDYz1MaSxOYz1vYyxNYz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxSYz1FbixVYz1rLERjPWZjLF9jPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWUrIiBJdGVyYXRvciI7cmV0dXJuIHQucHJvdG90eXBlPXhjKGtjLHtuZXh0OkZjKCshcixuKX0pLENjKHQsbywhMSwhMCksTmNbb109TWMsdH0sR2M9bWMsSGM9TGksQmM9UW8sVmM9b2MsV2M9VGMsemM9RGMuUFJPUEVSLEtjPVdjLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMscWM9bGUoIml0ZXJhdG9yIiksSmM9ImtleXMiLFljPSJ2YWx1ZXMiLFhjPSJlbnRyaWVzIiwkYz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxRYz1mdW5jdGlvbih0LGUsbixyLG8saSx1KXtfYyhuLGUscik7dmFyIGEsYyxzLGY9ZnVuY3Rpb24odCl7aWYodD09PW8mJmcpcmV0dXJuIGc7aWYoIUtjJiZ0JiZ0IGluIHApcmV0dXJuIHBbdF07c3dpdGNoKHQpe2Nhc2UgSmM6Y2FzZSBZYzpjYXNlIFhjOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgbih0aGlzLHQpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG4odGhpcyl9fSxsPWUrIiBJdGVyYXRvciIseT0hMSxwPXQucHJvdG90eXBlLGg9cFtxY118fHBbIkBAaXRlcmF0b3IiXXx8byYmcFtvXSxnPSFLYyYmaHx8ZihvKSxkPSJBcnJheSI9PT1lJiZwLmVudHJpZXN8fGg7aWYoZCYmKGE9R2MoZC5jYWxsKG5ldyB0KSkpIT09T2JqZWN0LnByb3RvdHlwZSYmYS5uZXh0JiYoSGMoYSxsLCEwLCEwKSxWY1tsXT0kYyksemMmJm89PT1ZYyYmaCYmaC5uYW1lIT09WWMmJih5PSEwLGc9ZnVuY3Rpb24oKXtyZXR1cm4gVWMoaCx0aGlzKX0pLG8paWYoYz17dmFsdWVzOmYoWWMpLGtleXM6aT9nOmYoSmMpLGVudHJpZXM6ZihYYyl9LHUpZm9yKHMgaW4gYykoS2N8fHl8fCEocyBpbiBwKSkmJkJjKHAscyxjW3NdKTtlbHNlIFJjKHt0YXJnZXQ6ZSxwcm90bzohMCxmb3JjZWQ6S2N8fHl9LGMpO3JldHVybiB1JiZwW3FjXSE9PWcmJkJjKHAscWMsZyx7bmFtZTpvfSksVmNbZV09ZyxjfSxaYz1mdW5jdGlvbih0LGUpe3JldHVybnt2YWx1ZTp0LGRvbmU6ZX19LHRzPVksZXM9b2MsbnM9X2k7WGUuZjt2YXIgcnM9UWMsb3M9WmMsaXM9IkFycmF5IEl0ZXJhdG9yIix1cz1ucy5zZXQsYXM9bnMuZ2V0dGVyRm9yKGlzKTtycyhBcnJheSwiQXJyYXkiLChmdW5jdGlvbih0LGUpe3VzKHRoaXMse3R5cGU6aXMsdGFyZ2V0OnRzKHQpLGluZGV4OjAsa2luZDplfSl9KSwoZnVuY3Rpb24oKXt2YXIgdD1hcyh0aGlzKSxlPXQudGFyZ2V0LG49dC5pbmRleCsrO2lmKCFlfHxuPj1lLmxlbmd0aClyZXR1cm4gdC50YXJnZXQ9bnVsbCxvcyh2b2lkIDAsITApO3N3aXRjaCh0LmtpbmQpe2Nhc2Uia2V5cyI6cmV0dXJuIG9zKG4sITEpO2Nhc2UidmFsdWVzIjpyZXR1cm4gb3MoZVtuXSwhMSl9cmV0dXJuIG9zKFtuLGVbbl1dLCExKX0pLCJ2YWx1ZXMiKSxlcy5Bcmd1bWVudHM9ZXMuQXJyYXk7dmFyIGNzPXtDU1NSdWxlTGlzdDowLENTU1N0eWxlRGVjbGFyYXRpb246MCxDU1NWYWx1ZUxpc3Q6MCxDbGllbnRSZWN0TGlzdDowLERPTVJlY3RMaXN0OjAsRE9NU3RyaW5nTGlzdDowLERPTVRva2VuTGlzdDoxLERhdGFUcmFuc2Zlckl0ZW1MaXN0OjAsRmlsZUxpc3Q6MCxIVE1MQWxsQ29sbGVjdGlvbjowLEhUTUxDb2xsZWN0aW9uOjAsSFRNTEZvcm1FbGVtZW50OjAsSFRNTFNlbGVjdEVsZW1lbnQ6MCxNZWRpYUxpc3Q6MCxNaW1lVHlwZUFycmF5OjAsTmFtZWROb2RlTWFwOjAsTm9kZUxpc3Q6MSxQYWludFJlcXVlc3RMaXN0OjAsUGx1Z2luOjAsUGx1Z2luQXJyYXk6MCxTVkdMZW5ndGhMaXN0OjAsU1ZHTnVtYmVyTGlzdDowLFNWR1BhdGhTZWdMaXN0OjAsU1ZHUG9pbnRMaXN0OjAsU1ZHU3RyaW5nTGlzdDowLFNWR1RyYW5zZm9ybUxpc3Q6MCxTb3VyY2VCdWZmZXJMaXN0OjAsU3R5bGVTaGVldExpc3Q6MCxUZXh0VHJhY2tDdWVMaXN0OjAsVGV4dFRyYWNrTGlzdDowLFRvdWNoTGlzdDowfSxzcz1vLGZzPUxpLGxzPW9jO2Zvcih2YXIgeXMgaW4gY3MpZnMoc3NbeXNdLHlzKSxsc1t5c109bHMuQXJyYXk7dmFyIHBzPXJjLGhzPWxlLGdzPVhlLmYsZHM9aHMoIm1ldGFkYXRhIiksYnM9RnVuY3Rpb24ucHJvdG90eXBlO3ZvaWQgMD09PWJzW2RzXSYmZ3MoYnMsZHMse3ZhbHVlOm51bGx9KSxzaSgiYXN5bmNEaXNwb3NlIiksc2koImRpc3Bvc2UiKSxzaSgibWV0YWRhdGEiKTt2YXIgdnM9cHMsbXM9ZCxTcz1ydCgiU3ltYm9sIiksd3M9U3Mua2V5Rm9yLE9zPW1zKFNzLnByb3RvdHlwZS52YWx1ZU9mKSxMcz1Tcy5pc1JlZ2lzdGVyZWRTeW1ib2x8fGZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gdm9pZCAwIT09d3MoT3ModCkpfWNhdGNoKGUpe3JldHVybiExfX07RW4oe3RhcmdldDoiU3ltYm9sIixzdGF0OiEwfSx7aXNSZWdpc3RlcmVkU3ltYm9sOkxzfSk7Zm9yKHZhciBqcz16dCxBcz1ydCxQcz1kLElzPUx0LEVzPWxlLFRzPUFzKCJTeW1ib2wiKSxrcz1Ucy5pc1dlbGxLbm93blN5bWJvbCx4cz1BcygiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIpLEZzPVBzKFRzLnByb3RvdHlwZS52YWx1ZU9mKSxDcz1qcygid2tzIiksTnM9MCxNcz14cyhUcyksUnM9TXMubGVuZ3RoO05zPFJzO05zKyspdHJ5e3ZhciBVcz1Nc1tOc107SXMoVHNbVXNdKSYmRXMoVXMpfWNhdGNoKGJmKXt9dmFyIERzPWZ1bmN0aW9uKHQpe2lmKGtzJiZrcyh0KSlyZXR1cm4hMDt0cnl7Zm9yKHZhciBlPUZzKHQpLG49MCxyPXhzKENzKSxvPXIubGVuZ3RoO248bztuKyspaWYoQ3NbcltuXV09PWUpcmV0dXJuITB9Y2F0Y2goYmYpe31yZXR1cm4hMX07RW4oe3RhcmdldDoiU3ltYm9sIixzdGF0OiEwLGZvcmNlZDohMH0se2lzV2VsbEtub3duU3ltYm9sOkRzfSksc2koImN1c3RvbU1hdGNoZXIiKSxzaSgib2JzZXJ2YWJsZSIpLEVuKHt0YXJnZXQ6IlN5bWJvbCIsc3RhdDohMCxuYW1lOiJpc1JlZ2lzdGVyZWRTeW1ib2wifSx7aXNSZWdpc3RlcmVkOkxzfSksRW4oe3RhcmdldDoiU3ltYm9sIixzdGF0OiEwLG5hbWU6ImlzV2VsbEtub3duU3ltYm9sIixmb3JjZWQ6ITB9LHtpc1dlbGxLbm93bjpEc30pLHNpKCJtYXRjaGVyIiksc2koIm1ldGFkYXRhS2V5Iiksc2koInBhdHRlcm5NYXRjaCIpLHNpKCJyZXBsYWNlQWxsIik7dmFyIF9zPWUodnMpLEdzPWQsSHM9R24sQnM9cXIsVnM9SyxXcz1HcygiIi5jaGFyQXQpLHpzPUdzKCIiLmNoYXJDb2RlQXQpLEtzPUdzKCIiLnNsaWNlKSxxcz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuKXt2YXIgcixvLGk9QnMoVnMoZSkpLHU9SHMobiksYT1pLmxlbmd0aDtyZXR1cm4gdTwwfHx1Pj1hP3Q/IiI6dm9pZCAwOihyPXpzKGksdSkpPDU1Mjk2fHxyPjU2MzE5fHx1KzE9PT1hfHwobz16cyhpLHUrMSkpPDU2MzIwfHxvPjU3MzQzP3Q/V3MoaSx1KTpyOnQ/S3MoaSx1LHUrMik6by01NjMyMCsoci01NTI5Njw8MTApKzY1NTM2fX0sSnM9e2NvZGVBdDpxcyghMSksY2hhckF0OnFzKCEwKX0uY2hhckF0LFlzPXFyLFhzPV9pLCRzPVFjLFFzPVpjLFpzPSJTdHJpbmcgSXRlcmF0b3IiLHRmPVhzLnNldCxlZj1Ycy5nZXR0ZXJGb3IoWnMpOyRzKFN0cmluZywiU3RyaW5nIiwoZnVuY3Rpb24odCl7dGYodGhpcyx7dHlwZTpacyxzdHJpbmc6WXModCksaW5kZXg6MH0pfSksKGZ1bmN0aW9uKCl7dmFyIHQsZT1lZih0aGlzKSxuPWUuc3RyaW5nLHI9ZS5pbmRleDtyZXR1cm4gcj49bi5sZW5ndGg/UXModm9pZCAwLCEwKToodD1KcyhuLHIpLGUuaW5kZXgrPXQubGVuZ3RoLFFzKHQsITEpKX0pKTt2YXIgbmY9ZSh0aS5mKCJpdGVyYXRvciIpKTtmdW5jdGlvbiByZih0KXtyZXR1cm4ocmY9ImZ1bmN0aW9uIj09dHlwZW9mIF9zJiYic3ltYm9sIj09dHlwZW9mIG5mP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJiJmdW5jdGlvbiI9PXR5cGVvZiBfcyYmdC5jb25zdHJ1Y3Rvcj09PV9zJiZ0IT09X3MucHJvdG90eXBlPyJzeW1ib2wiOnR5cGVvZiB0fSkodCl9dmFyIG9mPWUodGkuZigidG9QcmltaXRpdmUiKSk7ZnVuY3Rpb24gdWYodCl7dmFyIGU9ZnVuY3Rpb24odCxlKXtpZigib2JqZWN0IiE9cmYodCl8fCF0KXJldHVybiB0O3ZhciBuPXRbb2ZdO2lmKHZvaWQgMCE9PW4pe3ZhciByPW4uY2FsbCh0LGV8fCJkZWZhdWx0Iik7aWYoIm9iamVjdCIhPXJmKHIpKXJldHVybiByO3Rocm93IG5ldyBUeXBlRXJyb3IoIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuIil9cmV0dXJuKCJzdHJpbmciPT09ZT9TdHJpbmc6TnVtYmVyKSh0KX0odCwic3RyaW5nIik7cmV0dXJuInN5bWJvbCI9PXJmKGUpP2U6ZSsiIn1mdW5jdGlvbiBhZih0LGUsbil7cmV0dXJuKGU9dWYoZSkpaW4gdD9Obih0LGUse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPW4sdH1jb25zdCBjZj17Z2V0TkFMVW5pdHModCl7bGV0IGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTtpZih0Lmxlbmd0aC10LnBvc2l0aW9uPDQpcmV0dXJuW107Y29uc3R7cG9zaXRpb246bn09dDtyZXR1cm4gMT09PXQuZ2V0SW50MzIobil8fDA9PT10LmdldEludDE2KG4pJiYxPT09dC5nZXRJbnQ4KG4rMik/Y2YuZ2V0QW5uZXhiTmFscyh0LGUpOmNmLmdldEF2Y2NOYWxzKHQsZSl9LGdldEFubmV4Yk5hbHModCxlKXtjb25zdCBuPVtdO2xldCByPWNmLmdldEhlYWRlclBvc2l0aW9uQW5uZXhCKHQpLG89ci5wb3MsaT1vO2Zvcig7bzx0Lmxlbmd0aC00Oyl7Y29uc3QgdT1uZXcgVWludDhBcnJheSh0LmJ1ZmZlci5zbGljZShvLG8rci5oZWFkZXJMZW5ndGgpKTtyLnBvcz09PXQucG9zaXRpb24mJnQuc2tpcChyLmhlYWRlckxlbmd0aCkscj1jZi5nZXRIZWFkZXJQb3NpdGlvbkFubmV4Qih0KSxpPXIucG9zO2NvbnN0IGE9e2hlYWRlcjp1LGJvZHk6bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIuc2xpY2Uobyt1LmJ5dGVMZW5ndGgsaSkpLHR5cGU6LTF9O2U/Y2YuYW5hbHlzZUgyNjVOYWwoYSk6Y2YuYW5hbHlzZU5hbChhKSwoYS50eXBlPD05fHxlJiZhLnR5cGU8PTQwKSYmMCE9PWEudHlwZSYmbi5wdXNoKGEpLHQuc2tpcChpLXQucG9zaXRpb24pLG89aX1yZXR1cm4gbn0sZ2V0QXZjY05hbHModCxlKXtjb25zdCBuPVtdO2Zvcig7dC5wb3NpdGlvbjx0Lmxlbmd0aC00Oyl7Y29uc3Qgcj10LmdldEludDMyKHQucG9zaXRpb24pO2lmKCEodC5sZW5ndGgtdC5wb3NpdGlvbj49cikpYnJlYWs7e2NvbnN0IG89bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIuc2xpY2UodC5wb3NpdGlvbix0LnBvc2l0aW9uKzQpKTt0LnNraXAoNCk7Y29uc3QgaT1uZXcgVWludDhBcnJheSh0LmJ1ZmZlci5zbGljZSh0LnBvc2l0aW9uLHQucG9zaXRpb24rcikpO3Quc2tpcChyKTtjb25zdCB1PXtoZWFkZXI6byxib2R5OmksdHlwZTotMX07ZT9jZi5hbmFseXNlSDI2NU5hbCh1KTpjZi5hbmFseXNlTmFsKHUpLHUudHlwZTw9OSYmMCE9PXUudHlwZSYmbi5wdXNoKHUpfX1yZXR1cm4gbn0sYW5hbHlzZU5hbCh0KXtjb25zdCBlPTMxJnQuYm9keVswXTtzd2l0Y2godC50eXBlPWUsZSl7Y2FzZSAxOnQubmRyPSEwO2JyZWFrO2Nhc2UgNTp0Lmlkcj0hMDticmVhaztjYXNlIDY6dC5zZWk9ITA7YnJlYWs7Y2FzZSA3OnQuc3BzPSEwO2JyZWFrO2Nhc2UgODp0LnBwcz0hMH19LGFuYWx5c2VIMjY1TmFsKHQpe2NvbnN0IGU9KDEyNiZ0LmJvZHlbMF0pPj4xO3N3aXRjaCh0LnR5cGU9ZSxlKXtjYXNlIDM5OmNhc2UgNDA6dC5zZWk9ITB9fSxnZXRIZWFkZXJQb3NpdGlvbkFubmV4Qih0KXtsZXQgZT10LnBvc2l0aW9uLG49MDtjb25zdCByPXQubGVuZ3RoO2Zvcig7MyE9PW4mJjQhPT1uJiZlPHItNDspMD09PXQuZ2V0SW50MTYoZSk/MT09PXQuZ2V0SW50MTYoZSsyKT9uPTQ6MT09PXQuZ2V0SW50OChlKzIpP249MzplKys6ZSsrO3JldHVybiBlPT09ci00JiYoMD09PXQuZ2V0SW50MTYoZSk/MT09PXQuZ2V0SW50MTYoZSsyKT9uPTQ6ZT1yOihlKyssMD09PXQuZ2V0SW50MTYoZSkmJjE9PT10LmdldEludDgoZSk/bj0zOmU9cikpLHtwb3M6ZSxoZWFkZXJMZW5ndGg6bn19LGlzSDI2NVZpZGVvRnJhbWUodCl7dmFyIGU7cmV0dXJuKChudWxsPT09KGU9dC5nZXRNZXRhZGF0YSl8fHZvaWQgMD09PWV8fG51bGw9PT0oZT1lLmNhbGwodCkpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLm1pbWVUeXBlKXx8IiIpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoImgyNjUiKX19LHNmPW5ldyBVaW50OEFycmF5KFsxMDksMTY3LDUzLDE5MCwxMDMsOTAsNzIsMSwxNzAsODksNjMsMTY0LDE5NCwxOTksMTksODVdKSxmZj1uZXcgVWludDhBcnJheShbMTA5LDE2Nyw1MywxOTAsMTAzLDkwLDcyLDEsMTcwLDg5LDYzLDE2NCwxOTQsMTk5LDE5LDg0XSksbGY9bmV3IFVpbnQ4QXJyYXkoWzMxLDIzOSwzLDUwLDI0MiwxMjAsNzYsODUsMTY5LDQyLDE2MSw5MSw3NSwxODYsMjJdKTtmdW5jdGlvbiB5Zih0KXtjb25zdCBlPVtdO2Zvcig7dD49MjU1Oyl0LT0yNTUsZS5wdXNoKDI1NSk7cmV0dXJuIGUucHVzaCh0KSxuZXcgVWludDhBcnJheShlKX1mdW5jdGlvbiBwZih0KXtsZXQgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MCxuPTA7Zm9yKDsyNTU9PT10W2VdJiZlPHQuYnl0ZUxlbmd0aDspZSsrLG4rPTI1NTtyZXR1cm4gZTx0LmJ5dGVMZW5ndGgmJihuKz10W2UrK10pLFtuLGVdfWNvbnN0IGhmPW5ldyBVaW50OEFycmF5KFs4MCwxXSk7Y2xhc3MgZ2Z7c3RhdGljIGdlbmVyYXRlU0VJKHQsZSl7bGV0IG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtjb25zdCByPW5ldyBVaW50OEFycmF5KFswLDAsMCwxXSksbz1lP2hmOm5ldyBVaW50OEFycmF5KFs2XSksaT1uZXcgVWludDhBcnJheShbNV0pLHU9Z2YuX191dWlkfHwobj9zZjpmZiksYT15Zih0LmJ5dGVMZW5ndGgrdS5ieXRlTGVuZ3RoKSxjPSh0PT57Y29uc3QgZT1bXTtsZXQgbj0wO2Zvcihjb25zdCByIG9mIHQpbj49MiYmcjw9MyYmKGUucHVzaCgzKSxuPTApLDA9PT1yP24rKzpuPTAsZS5wdXNoKHIpO3JldHVybiBuZXcgVWludDhBcnJheShlKX0pKHQpO3JldHVybiBuZXcgVWludDhBcnJheShbLi4uciwuLi5vLC4uLmksLi4uYSwuLi51LC4uLmMsMTI4XSl9c3RhdGljIGRlY29kZVNFSUJvZHkodCxlKXtjb25zdCBuPSh0PT57Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl0W25dPD0zJiYwPT09dFtuLTFdJiYwPT09dFtuLTJdfHxlLnB1c2godFtuXSk7cmV0dXJuIG5ldyBVaW50OEFycmF5KGUpfSkodD10LnNsaWNlKDAsdC5sZW5ndGgtMSkpO2lmKG4uYnl0ZUxlbmd0aDwyKXJldHVybjtsZXQgcj0wO2NvbnN0IG89ZT8yOjE7aWYoNSE9PW5bb10mJjEwMCE9PW5bb10pcmV0dXJuO3IrPTErbztjb25zdFtpLHVdPXBmKG4scik7cj11O2xldCBhPTI7Y29uc3QgYz1yK2k7bi5ieXRlTGVuZ3RoPj1mZi5ieXRlTGVuZ3RoJiZpPj1mZi5ieXRlTGVuZ3RoJiYobi5zbGljZShyLHIrZmYuYnl0ZUxlbmd0aCkudG9TdHJpbmcoKT09PWZmLnRvU3RyaW5nKCl8fG4uc2xpY2UocixyK2xmLmJ5dGVMZW5ndGgpLnRvU3RyaW5nKCk9PT1sZi50b1N0cmluZygpKT8ocis9ZmYuYnl0ZUxlbmd0aCxhPTEpOm4uYnl0ZUxlbmd0aD49ZmYuYnl0ZUxlbmd0aCYmaT49ZmYuYnl0ZUxlbmd0aCYmbi5zbGljZShyLHIrc2YuYnl0ZUxlbmd0aCkudG9TdHJpbmcoKT09PXNmLnRvU3RyaW5nKCkmJihyKz1zZi5ieXRlTGVuZ3RoLGE9MCk7cmV0dXJue3R5cGU6YSxwYXlsb2FkOm4uc2xpY2UocixjKX19c3RhdGljIHBhcnNlSW50ZXJuYWxTRUkodCl7Y29uc3QgZT1uZXcgTWFwO2xldCBuPTA7aWYoMD09PXQudHlwZSl7Zm9yKDt0LnBheWxvYWQuYnl0ZUxlbmd0aC1uPj0yOyl7Y29uc3RbcixvXT1wZih0LnBheWxvYWQsbik7bj1vO2NvbnN0W2ksdV09cGYodC5wYXlsb2FkLG4pO2lmKG49dSxlLmdldChyKXx8IShpPD10LnBheWxvYWQuYnl0ZUxlbmd0aC1uKSlicmVhaztlLnNldChyLHQucGF5bG9hZC5zbGljZShuLG4raSkpLG4rPWl9cmV0dXJuIGV9fXN0YXRpYyBtYWtlSW50ZXJuYWxTZWkodCl7Y29uc3QgZT1bXTtmb3IoY29uc3RbbyxpXW9mIHQpe2NvbnN0IHQ9eWYobyksbj15ZihpLmJ5dGVMZW5ndGgpO2UucHVzaCh0LG4saSl9Y29uc3Qgbj1lLnJlZHVjZSgoKHQsZSk9PnQrZS5ieXRlTGVuZ3RoKSwwKSxyPW5ldyBVaW50OEFycmF5KG4pO3JldHVybiBlLnJlZHVjZSgoKHQsZSk9PihyLnNldChlLHQpLHQrZS5ieXRlTGVuZ3RoKSksMCkscn19YWYoZ2YsIl9fdXVpZCIsdm9pZCAwKTtjbGFzcyBkZntjb25zdHJ1Y3Rvcih0KXthZih0aGlzLCJzZWlMaXN0IixbXSksYWYodGhpcywibWF4U0VJQ291bnQiLDEpLHRoaXMubWF4U0VJQ291bnQ9dC5tYXhTRUlDb3VudH1zZW5kU0VJVHJhbnNmb3JtKHQsZSl7Y29uc3R7bWF4U0VJQ291bnQ6bixzZWlMaXN0OnJ9PXRoaXM7aWYoIXRoaXMuc2VpTGlzdC5sZW5ndGgpcmV0dXJuIHZvaWQgZS5lbnF1ZXVlKHQpO2NvbnN0IG89W107bGV0IGk9MDtmb3IoY29uc3QgYyBvZiByKXtpZihvLmxlbmd0aD49bilicmVhaztjb25zdCBlPWdmLmdlbmVyYXRlU0VJKGMuY29udGVudCxjZi5pc0gyNjVWaWRlb0ZyYW1lKHQpKTtpKz1lLmJ5dGVMZW5ndGgsYy5yZXBlYXRDb3VudC0tLG8ucHVzaChlKX10aGlzLnNlaUxpc3Q9ci5maWx0ZXIoKHQ9PnQucmVwZWF0Q291bnQ+MCkpO2NvbnN0IHU9bmV3IFVpbnQ4QXJyYXkoaSt0LmRhdGEuYnl0ZUxlbmd0aCk7dS5zZXQobmV3IFVpbnQ4QXJyYXkodC5kYXRhKSk7bGV0IGE9dC5kYXRhLmJ5dGVMZW5ndGg7by5mb3JFYWNoKCh0PT57dS5zZXQodCxhKSxhKz10LmJ5dGVMZW5ndGh9KSksdC5kYXRhPXUuYnVmZmVyLGUuZW5xdWV1ZSh0KX1wdXNoU0VJKHQpe3RoaXMuc2VpTGlzdC5wdXNoKHQpfXJldm9rZVNFSSh0KXtjb25zdCBlPXRoaXMuc2VpTGlzdC5maW5kSW5kZXgoKGU9PmUudXVpZD09PXQpKTtyZXR1cm4tMSE9PWUmJih0aGlzLnNlaUxpc3Quc3BsaWNlKGUsMSksITApfX0idW5kZWZpbmVkIiE9dHlwZW9mIHNlbGYmJiJEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZSI9PT1zZWxmLmNvbnN0cnVjdG9yLm5hbWUmJnNlbGYuYWRkRXZlbnRMaXN0ZW5lcigicnRjdHJhbnNmb3JtIiwodD0+e2NvbnN0e3RyYW5zZm9ybWVyOmV9PXQse21heFNFSUNvdW50Om59PWUub3B0aW9ucyxyPW5ldyBkZih7bWF4U0VJQ291bnQ6bn0pLG89bmV3IFRyYW5zZm9ybVN0cmVhbSh7dHJhbnNmb3JtOnIuc2VuZFNFSVRyYW5zZm9ybS5iaW5kKHIpfSk7c2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwodD0+e2xldHtkYXRhOmV9PXQ7Y29uc3R7dHlwZTpuLGNvbnRlbnQ6b309ZTtpZigicHVzaCI9PT1uKXIucHVzaFNFSShvKTtlbHNlIGlmKCJyZXZva2UiPT09bil7Y29uc3QgdD1yLnJldm9rZVNFSShvKTtyZXR1cm4gc2VsZi5wb3N0TWVzc2FnZSh7dHlwZToicmV2b2tlLWFjayIsY29udGVudDp7dXVpZDpvLGlzTm90U2VuZDp0fX0pfX0pKSxlLnJlYWRhYmxlLnBpcGVUaHJvdWdoKG8pLnBpcGVUbyhlLndyaXRhYmxlKX0pKX0oKTsK";
var blob$1 = "undefined" != typeof window && window.Blob && new Blob([atob(encodedJs$1)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper$1() {
  let e;
  try {
    if (e = blob$1 && (_URL || window.webkitURL).createObjectURL(blob$1), !e) throw "";
    return new Worker(e);
  } catch (e2) {
    return new Worker("data:application/javascript;base64," + encodedJs$1);
  } finally {
    e && (_URL || window.webkitURL).revokeObjectURL(e);
  }
}
var Nalunit = { getNALUnits(e) {
  let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
  if (e.length - e.position < 4) return [];
  const { position: i } = e;
  return 1 === e.getInt32(i) || 0 === e.getInt16(i) && 1 === e.getInt8(i + 2) ? Nalunit.getAnnexbNals(e, t) : Nalunit.getAvccNals(e, t);
}, getAnnexbNals(e, t) {
  const i = [];
  let r = Nalunit.getHeaderPositionAnnexB(e), o = r.pos, n = o;
  for (; o < e.length - 4; ) {
    const s = new Uint8Array(e.buffer.slice(o, o + r.headerLength));
    r.pos === e.position && e.skip(r.headerLength), r = Nalunit.getHeaderPositionAnnexB(e), n = r.pos;
    const a = { header: s, body: new Uint8Array(e.buffer.slice(o + s.byteLength, n)), type: -1 };
    t ? Nalunit.analyseH265Nal(a) : Nalunit.analyseNal(a), (a.type <= 9 || t && a.type <= 40) && 0 !== a.type && i.push(a), e.skip(n - e.position), o = n;
  }
  return i;
}, getAvccNals(e, t) {
  const i = [];
  for (; e.position < e.length - 4; ) {
    const r = e.getInt32(e.position);
    if (!(e.length - e.position >= r)) break;
    {
      const o = new Uint8Array(e.buffer.slice(e.position, e.position + 4));
      e.skip(4);
      const n = new Uint8Array(e.buffer.slice(e.position, e.position + r));
      e.skip(r);
      const s = { header: o, body: n, type: -1 };
      t ? Nalunit.analyseH265Nal(s) : Nalunit.analyseNal(s), s.type <= 9 && 0 !== s.type && i.push(s);
    }
  }
  return i;
}, analyseNal(e) {
  const t = 31 & e.body[0];
  switch (e.type = t, t) {
    case 1:
      e.ndr = true;
      break;
    case 5:
      e.idr = true;
      break;
    case 6:
      e.sei = true;
      break;
    case 7:
      e.sps = true;
      break;
    case 8:
      e.pps = true;
  }
}, analyseH265Nal(e) {
  const t = (126 & e.body[0]) >> 1;
  switch (e.type = t, t) {
    case 39:
    case 40:
      e.sei = true;
  }
}, getHeaderPositionAnnexB(e) {
  let t = e.position, i = 0;
  const r = e.length;
  for (; 3 !== i && 4 !== i && t < r - 4; ) 0 === e.getInt16(t) ? 1 === e.getInt16(t + 2) ? i = 4 : 1 === e.getInt8(t + 2) ? i = 3 : t++ : t++;
  return t === r - 4 && (0 === e.getInt16(t) ? 1 === e.getInt16(t + 2) ? i = 4 : t = r : (t++, 0 === e.getInt16(t) && 1 === e.getInt8(t) ? i = 3 : t = r)), { pos: t, headerLength: i };
}, isH265VideoFrame(e) {
  var t;
  return ((null === (t = e.getMetadata) || void 0 === t || null === (t = t.call(e)) || void 0 === t ? void 0 : t.mimeType) || "").toLowerCase().includes("h265");
} };
var RTCDataView = class _RTCDataView {
  constructor(e) {
    _defineProperty(this, "_position", 0), _defineProperty(this, "_dataview", void 0), this._dataview = new DataView(e);
  }
  get length() {
    return this.buffer.byteLength;
  }
  get buffer() {
    return this._dataview.buffer;
  }
  set position(e) {
    this._position = e;
  }
  get position() {
    return this._position;
  }
  back(e) {
    this.position -= e;
  }
  getUint8(e) {
    return this._dataview.getUint8(e);
  }
  getInt8(e) {
    return this._dataview.getInt8(e);
  }
  getInt16(e) {
    return this._dataview.getInt16(e);
  }
  getUint16(e) {
    return this._dataview.getUint16(e);
  }
  getUint32(e) {
    return this._dataview.getUint32(e);
  }
  getInt32(e) {
    return this._dataview.getInt32(e);
  }
  skip(e) {
    const t = Math.floor(e / 4), i = e % 4;
    for (let e2 = 0; e2 < t; e2++) _RTCDataView.readByte(this, 4);
    i > 0 && _RTCDataView.readByte(this, i);
  }
  static readByte(e, t, i) {
    let r;
    switch (t) {
      case 1:
        r = i ? e.getInt8(e.position) : e.getUint8(e.position);
        break;
      case 2:
        r = i ? e.getInt16(e.position) : e.getUint16(e.position);
        break;
      case 3:
        if (i) throw new Error("not supported for readByte 3");
        r = e.getUint8(e.position) << 16, r |= e.getUint8(e.position + 1) << 8, r |= e.getUint8(e.position + 2);
        break;
      case 4:
        r = i ? e.getInt32(e.position) : e.getUint32(e.position);
        break;
      case 8:
        if (i) throw new Error("not supported for readBody 8");
        r = e.getUint32(e.position) << 32, r |= e.getUint32(e.position + 4);
        break;
      default:
        r = "";
    }
    return e.position += t, r;
  }
  readUint8() {
    return _RTCDataView.readByte(this, 1);
  }
  readUint16() {
    return _RTCDataView.readByte(this, 2);
  }
  readUint24() {
    return _RTCDataView.readByte(this, 3);
  }
  readUint32() {
    return _RTCDataView.readByte(this, 4);
  }
  readUint64() {
    return _RTCDataView.readByte(this, 8);
  }
  readInt8() {
    return _RTCDataView.readByte(this, 1, true);
  }
  readInt16() {
    return _RTCDataView.readByte(this, 2, true);
  }
  readInt32() {
    return _RTCDataView.readByte(this, 4, true);
  }
  writeUint32(e) {
    return new Uint8Array([e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e]);
  }
};
function receiveSEITransform(e) {
  let { postMessage: t, skipFilter: i } = e;
  return new TransformStream({ transform(e2, r) {
    const o = Nalunit.isH265VideoFrame(e2);
    Nalunit.getNALUnits(new RTCDataView(e2.data), o).forEach((e3) => {
      if (e3.sei) {
        const r2 = SEIHelper.decodeSEIBody(e3.body, o);
        r2 && (i || r2.type === RTC_SEI_TYPE.external) && t(r2);
      }
    }), r.enqueue(e2);
  } });
}
"undefined" != typeof self && "DedicatedWorkerGlobalScope" === self.constructor.name && self.addEventListener("rtctransform", (e) => {
  const { transformer: t } = e, { streamId: i, skipFilter: r } = t.options, o = receiveSEITransform({ postMessage: (e2) => {
    self.postMessage({ streamId: i, msg: e2 }, [e2.payload.buffer]);
  }, skipFilter: r });
  t.readable.pipeThrough(o).pipeTo(e.transformer.writable);
});
var EncodedTransformer = class {
  constructor(e) {
    _defineProperty(this, "seiList", []), _defineProperty(this, "maxSEICount", 1), this.maxSEICount = e.maxSEICount;
  }
  sendSEITransform(e, t) {
    const { maxSEICount: i, seiList: r } = this;
    if (!this.seiList.length) return void t.enqueue(e);
    const o = [];
    let n = 0;
    for (const t2 of r) {
      if (o.length >= i) break;
      const r2 = SEIHelper.generateSEI(t2.content, Nalunit.isH265VideoFrame(e));
      n += r2.byteLength, t2.repeatCount--, o.push(r2);
    }
    this.seiList = r.filter((e2) => e2.repeatCount > 0);
    const s = new Uint8Array(n + e.data.byteLength);
    s.set(new Uint8Array(e.data));
    let a = e.data.byteLength;
    o.forEach((e2) => {
      s.set(e2, a), a += e2.byteLength;
    }), e.data = s.buffer, t.enqueue(e);
  }
  pushSEI(e) {
    this.seiList.push(e);
  }
  revokeSEI(e) {
    const t = this.seiList.findIndex((t2) => t2.uuid === e);
    return -1 !== t && (this.seiList.splice(t, 1), true);
  }
};
"undefined" != typeof self && "DedicatedWorkerGlobalScope" === self.constructor.name && self.addEventListener("rtctransform", (e) => {
  const { transformer: t } = e, { maxSEICount: i } = t.options, r = new EncodedTransformer({ maxSEICount: i }), o = new TransformStream({ transform: r.sendSEITransform.bind(r) });
  self.addEventListener("message", (e2) => {
    let { data: t2 } = e2;
    const { type: i2, content: o2 } = t2;
    if ("push" === i2) r.pushSEI(o2);
    else if ("revoke" === i2) {
      const e3 = r.revokeSEI(o2);
      return self.postMessage({ type: "revoke-ack", content: { uuid: o2, isNotSend: e3 } });
    }
  }), t.readable.pipeThrough(o).pipeTo(t.writable);
});
var StreamBase = class extends EnhancedEventEmitter {
  constructor(e) {
    super(), _defineProperty(this, "uuid", genUuid$1()), _defineProperty(this, "isScreen", false), _defineProperty(this, "audioMid", void 0), _defineProperty(this, "videoMid", void 0), _defineProperty(this, "audioMLine", void 0), _defineProperty(this, "videoMLine", void 0), _defineProperty(this, "videoTransceiver", void 0), _defineProperty(this, "audioTransceiver", void 0), _defineProperty(this, "vendorHandler", void 0), _defineProperty(this, "vendorCode", 0), _defineProperty(this, "engineId", void 0), _defineProperty(this, "logger", void 0), _defineProperty(this, "__seiHelper", SEIHelper), _defineProperty(this, "logName", "StreamBase"), _defineProperty(this, "isPublicStream", false), this._ctx = e, this.engineId = e.id, this.logger = new Logger$1(this.constructor.name, 2, e.id);
  }
  stopReport(e) {
    this.statsReport.stopReport(e);
  }
  destroy() {
    var e, t;
    delete this.audioMid, delete this.videoMid, this.statsReport.destroy(), null === (e = this.observer) || void 0 === e || e.reset(), delete this.videoTransceiver, delete this.audioTransceiver, null === (t = this.vendorHandler) || void 0 === t || t.destroy(), this.vendorCode = 0, delete this.vendorHandler;
  }
};
var StreamState = ((e) => (e[e.INIT = 0] = "INIT", e[e.SUB_ING = 1] = "SUB_ING", e[e.SUB_ED = 2] = "SUB_ED", e))(StreamState || {});
var LocalStream = class extends StreamBase {
  constructor(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : StreamIndex.STREAM_INDEX_MAIN;
    super(e), _defineProperty(this, "id", void 0), _defineProperty(this, "stream", void 0), _defineProperty(this, "streamId", void 0), _defineProperty(this, "videoTrack", void 0), _defineProperty(this, "audioTrack", void 0), _defineProperty(this, "subVideoDescriptions", []), _defineProperty(this, "observer", void 0), _defineProperty(this, "statsReport", void 0), _defineProperty(this, "pubAudio", false), _defineProperty(this, "pubVideo", false), _defineProperty(this, "blackFrameRenderInterval", void 0), _defineProperty(this, "blackFrameLifetimeInterval", void 0), _defineProperty(this, "pubAttributes", void 0), _defineProperty(this, "pcSessionId", void 0), _defineProperty(this, "maxSeiCount", 1), _defineProperty(this, "preReports", { audio: {}, video: {} }), _defineProperty(this, "remoteSdp", void 0), _defineProperty(this, "currentVideoCodec", void 0), _defineProperty(this, "_changeCodecs", []), _defineProperty(this, "_videoCaps", []), _defineProperty(this, "_sendSEIHandler", void 0), _defineProperty(this, "_trackMatchingTimer", void 0), _defineProperty(this, "logName", "LocalStream"), this.stream = new MediaStream(), this.id = genUuid$1(), this.pubAttributes = { localaudio: false, localvideo: false, videostream: false, audiostream: false, extvideo: false, extaudio: false, videoDescriptions: [], videoType: VideoType.NORMAL }, this.isScreen = t === StreamIndex.STREAM_INDEX_SCREEN, this.statsReport = new LocalStatsReport(e, this);
    const i = getParameter("SEI_COUNT_FPS");
    "number" == typeof i && i <= 10 && (this.maxSeiCount = i), this._trackMatchingTimer = setInterval(this._checkTrackMatching.bind(this), 5e3);
  }
  get enableSimulcast() {
    return !this.isScreen && this._ctx.videoProfile.getSimulcastMode();
  }
  get videoEncodeConfig() {
    return this.isScreen ? [this._ctx.videoProfile.getScreenEncodeConfig()] : this._ctx.videoProfile.getVideoEncodeConfig();
  }
  get audioHasCapture() {
    return this.pubAttributes.localaudio;
  }
  get audioHasPublish() {
    return this.pubAttributes.audiostream;
  }
  get videoHasCapture() {
    return this.pubAttributes.localvideo;
  }
  get videoHasPublish() {
    return this.pubAttributes.videostream;
  }
  get isEmptyStream() {
    return !this.audioTrack && !this.videoTrack;
  }
  get initStreamId() {
    return this.stream.id;
  }
  async getSelectedCodec() {
    var e;
    const t = this._changeCodecs.length > 0 ? this._changeCodecs : this._videoCaps.length > 0 ? this._videoCaps : await internalGetSupportedCodecs(), i = this._ctx.videoProfile.getPreferCodec(this.isScreen), r = this.isScreen ? this._ctx.targetScreenCodec : this._ctx.targetCodec;
    if (i && i !== VideoCodecType.AUTO) {
      if (i === VideoCodecType.H264 && t.includes(VideoCodecName.H264)) return VideoCodecName.H264;
      if (i === VideoCodecType.VP8 && t.includes(VideoCodecName.VP8)) return VideoCodecName.VP8;
      if (i === VideoCodecType.ByteVC1 && t.includes(VideoCodecName.ByteVC1)) return VideoCodecName.ByteVC1;
    }
    if (null !== (e = this._ctx.serverConfig) && void 0 !== e && e.videoCodec && t.includes(this._ctx.serverConfig.videoCodec)) return this._ctx.serverConfig.videoCodec;
    if (i === VideoCodecType.AUTO && t.length > 0) return t[0];
    if (r && t.includes(r)) return r;
    if (t.includes(VideoCodecName.H264)) return VideoCodecName.H264;
    if (t.includes(VideoCodecName.VP8)) return VideoCodecName.VP8;
    throw new Error("no available codec");
  }
  startReport(e, t) {
    this.statsReport.setLocalStreamStatsEvtInterval(e, t);
  }
  getLocalStreamStats() {
    return this.statsReport.getLocalStats();
  }
  initVideoEncodedTransform() {
    if (getParameter("DISABLE_ENCODED_TRANSFORM")) return void this.logger.warn("initVideoEncodedTransform", "DISABLE_ENCODED_TRANSFORM");
    if (!this.videoTransceiver || !this.videoTransceiver.sender) return void this.logger.warn("initVideoEncodedTransform", "no sender found when trying to bind encodedTransform");
    const { sender: e } = this.videoTransceiver;
    if (this._ctx.pcKillSwitch.ctor_encodedinsetablestream_add && isLegacyEncodedTransformSupported()) {
      const { readable: t, writable: i } = e.createEncodedStreams();
      if (window.__createDecodeError__) t.pipeThrough(new TransformStream({ transform: (e2, t2) => {
        const i2 = e2.data, r = new DataView(i2, 16);
        r.setInt16(4, 10), r.setInt16(11, 20), t2.enqueue(e2);
      } })).pipeTo(i);
      else {
        const e2 = new EncodedTransformer({ maxSEICount: this.maxSeiCount }), r = new TransformStream({ transform: e2.sendSEITransform.bind(e2) });
        t.pipeThrough(r).pipeTo(i), this._sendSEIHandler = e2;
      }
    } else if (isEncodedTransformSupported()) {
      const e2 = new WorkerWrapper$1();
      this.videoTransceiver.sender.transform = new RTCRtpScriptTransform(e2, { maxSEICount: this.maxSeiCount }), this._sendSEIHandler = { pushSEI: (t) => {
        e2.postMessage({ type: "push", content: t }, [t.content.buffer]);
      }, revokeSEI: async (t) => (e2.postMessage({ type: "revoke", content: t }), new Promise((i) => {
        e2.addEventListener("message", (e3) => {
          let { data: r } = e3;
          const { type: o, content: n } = r, { uuid: s, isNotSend: a } = n;
          "revoke-ack" === o && s === t && i(a);
        });
      })) };
    }
  }
  initAudioEncodedTransform() {
    if (getParameter("DISABLE_ENCODED_TRANSFORM")) return void this.logger.warn("initAudioEncodedTransform", "DISABLE_ENCODED_TRANSFORM");
    if (!this.audioTransceiver || !this.audioTransceiver.sender) return void this.logger.warn("initAudioEncodedTransform", "no sender found when trying to bind encodedTransform");
    if (!this._ctx.pcKillSwitch.ctor_encodedinsetablestream_add) return void this.logger.warn("initAudioEncodedTransform", "legacy EncodedTransform is not supported");
    if (!isLegacyEncodedTransformSupported()) return void this.logger.warn("initAudioEncodedTransform", "legacy EncodedTransform is not supported");
    const { sender: e } = this.audioTransceiver, { readable: t, writable: i } = e.createEncodedStreams();
    t.pipeThrough(new TransformStream({ transform: (e2, t2) => {
      t2.enqueue(e2);
    } })).pipeTo(i);
  }
  clean() {
    reportRtcInvokeStatus(this.engineId, "localstream_clean", "".concat(new Error().stack), 0, this.streamId || ""), super.destroy(), this.subVideoDescriptions = [], clearTimeout(this.blackFrameLifetimeInterval), clearInterval(this.blackFrameRenderInterval);
  }
  switchTrackEnableState(e, t) {
    var i;
    let r;
    "audio" === e ? r = this.audioTrack : "video" === e && (r = this.videoTrack);
    const o = null === (i = r) || void 0 === i ? void 0 : i.mediaTrack;
    return !(!o || (null == o ? void 0 : o.enabled) === t) && (o.enabled = t, true);
  }
  resetStream() {
    this.stream = new MediaStream();
  }
  genBlackFrame() {
    var e, t;
    this.logger.info("genBlackFrame()");
    const i = null !== (e = this.videoEncodeConfig[0]) && void 0 !== e && e.frameRate ? constraints2number(null === (t = this.videoEncodeConfig[0]) || void 0 === t ? void 0 : t.frameRate) : 15, r = Math.ceil(1e3 / i), o = document.createElement("canvas"), n = o.getContext("2d");
    o.width = 16, o.height = 16;
    const s = (e2) => {
      e2.fillRect(0, 0, 16, 16);
    };
    n && (n.fillStyle = "#000", s(n), this.blackFrameRenderInterval = window.setInterval(() => {
      s(n);
    }, r), this.refreshBlackFrameLifetime());
    return o.captureStream(i).getVideoTracks()[0];
  }
  stopBlackFrame() {
    this.logger.info("stopBlackFrame()"), clearTimeout(this.blackFrameLifetimeInterval), clearInterval(this.blackFrameRenderInterval), delete this.blackFrameRenderInterval;
  }
  refreshBlackFrameLifetime() {
    this.logger.info("refreshBlackFrameLifetime()"), this.blackFrameRenderInterval && (clearTimeout(this.blackFrameLifetimeInterval), this.blackFrameLifetimeInterval = setTimeout(() => {
      clearInterval(this.blackFrameRenderInterval), delete this.blackFrameRenderInterval, this.emit("black-frame-ended");
    }, Config2.BLACK_FRAME_LIFETIME));
  }
  setChangeCodecs(e) {
    this._changeCodecs = e;
  }
  setVideoCaps(e) {
    if (!e) return;
    const t = e.split(",").map((e2) => {
      const t2 = _trimInstanceProperty(e2).call(e2).toUpperCase();
      return { H264: VideoCodecName.H264, VP8: VideoCodecName.VP8, BYTEVC1: VideoCodecName.ByteVC1 }[t2] || null;
    }).filter((e2) => null !== e2);
    this._videoCaps = t;
  }
  sendSEIMessage(e) {
    var t;
    this.logger.info("sendSEIMessage"), null === (t = this._sendSEIHandler) || void 0 === t || t.pushSEI(e);
  }
  async revokeSEIMessage(e) {
    var t;
    return this.logger.info("revokeSEIMessage"), this._sendSEIHandler ? null === (t = this._sendSEIHandler) || void 0 === t ? void 0 : t.revokeSEI(e) : (this.logger.warn("revokeSEIMessage", "no sei handler found"), false);
  }
  destroy() {
    clearInterval(this._trackMatchingTimer), super.removeAllListeners(), super.destroy();
  }
  _checkTrackMatching() {
    var e, t, i, r;
    const o = null === (e = this.audioTrack) || void 0 === e ? void 0 : e.preprocessingTrack.id, n = null === (t = this.videoTrack) || void 0 === t ? void 0 : t.preprocessingTrack.id, s = null === (i = this.audioTransceiver) || void 0 === i || null === (i = i.sender.track) || void 0 === i ? void 0 : i.id, a = null === (r = this.videoTransceiver) || void 0 === r || null === (r = r.sender.track) || void 0 === r ? void 0 : r.id;
    var d, c2;
    this.pubAudio && o !== s && (this.logger.error("_checkTrackMatching", "audio track id: ".concat(o, " not matching transceiver track id ").concat(s, ", streamId: ").concat(this.streamId)), null === (d = this._ctx.monitor) || void 0 === d || d.report("rtc_error", { message: "audio track id: ".concat(o, " not matching transceiver track id ").concat(s), error_code: -1, stream_id: this.streamId }));
    this.pubVideo && n !== a && (this.logger.error("_checkTrackMatching", "video track id: ".concat(n, " not matching transceiver track id ").concat(a, ", streamId: ").concat(this.streamId)), null === (c2 = this._ctx.monitor) || void 0 === c2 || c2.report("rtc_error", { message: "video track id: ".concat(n, " not matching transceiver track id ").concat(a), error_code: -1, stream_id: this.streamId }));
  }
};
var RemoteStream = class extends StreamBase {
  constructor(e, t, i, r, o, n) {
    super(e), _defineProperty(this, "streamId", void 0), _defineProperty(this, "userId", void 0), _defineProperty(this, "isPublic", void 0), _defineProperty(this, "hasVideo", void 0), _defineProperty(this, "hasAudio", void 0), _defineProperty(this, "_attributes", void 0), _defineProperty(this, "streamState", void 0), _defineProperty(this, "removeTrack", false), _defineProperty(this, "observer", void 0), _defineProperty(this, "statsReport", void 0), _defineProperty(this, "subVideo", void 0), _defineProperty(this, "subAudio", void 0), _defineProperty(this, "subMediaType", void 0), _defineProperty(this, "subLayer", void 0), _defineProperty(this, "_sequenceId", void 0), _defineProperty(this, "stream", void 0), _defineProperty(this, "videoTrack", void 0), _defineProperty(this, "audioTrack", void 0), _defineProperty(this, "recordedVideoFrames", void 0), _defineProperty(this, "stillExist", void 0), _defineProperty(this, "originalMediaType", void 0), _defineProperty(this, "priority", void 0), _defineProperty(this, "remoteSessionId", ""), _defineProperty(this, "originalStreamIndex", 0), _defineProperty(this, "virtual", void 0), _defineProperty(this, "pcSessionId", void 0), _defineProperty(this, "_virtualOccupy", void 0), _defineProperty(this, "_videoStallObserver", void 0), _defineProperty(this, "_audioStallObserver", void 0), _defineProperty(this, "preReports", { audio: {}, video: {} }), _defineProperty(this, "_installInfo", void 0), _defineProperty(this, "_seiWorkerHandler", void 0), this.virtual = false, this._virtualOccupy = false, this.userId = t, this.isScreen = r, this.isPublic = o, this.streamId = i, this.logName = "RemoteStream-".concat(i), this.hasAudio = n.audiostream && n.localaudio, this.hasVideo = n.videostream && n.localvideo, this._attributes = n, this.vendorCode = (null == n ? void 0 : n.vendorCode) || 0, this.subVideo = false, this.subAudio = false, this._sequenceId = 0, this.subMediaType = ExtendMediaType.NONE, this.subLayer = { spatialLayer: 0, spatialSubLayer: -1 }, this.streamState = 0, this.statsReport = new RemoteStatsReport(e, this), this.enableVendorMode && (this.pcSessionId = genUuid$1());
  }
  get vendor() {
    return this._attributes.vendorCode;
  }
  get audioHasCapture() {
    return this._attributes.localaudio;
  }
  get audioHasPublish() {
    return this._attributes.audiostream;
  }
  get videoHasCapture() {
    return this._attributes.localvideo;
  }
  get videoHasPublish() {
    return this._attributes.videostream;
  }
  get sequenceId() {
    return this._sequenceId || -1;
  }
  set sequenceId(e) {
    "number" == typeof e && (this._sequenceId = e);
  }
  get enableVendorMode() {
    return "number" == typeof this.attributes.vendorCode && 0 !== this.attributes.vendorCode;
  }
  get hasSubscribed() {
    return 2 === this.streamState;
  }
  get attributes() {
    return this._attributes;
  }
  set attributes(e) {
    this.hasVideo = e.localvideo && e.videostream, this.hasAudio = e.localaudio && e.audiostream, this._attributes = e, this.vendorCode = e.vendorCode || 0;
  }
  get virtualOccupy() {
    return this._virtualOccupy;
  }
  set virtualOccupy(e) {
    var t;
    if (this._virtualOccupy && !e) null === (t = this.observer) || void 0 === t || t.setPushTrack(false);
    else if (!this._virtualOccupy && e) {
      var i;
      null === (i = this.observer) || void 0 === i || i.setPushTrack(true);
    }
    this._virtualOccupy = e;
  }
  startReport(e, t) {
    this.statsReport.setRemoteStreamStatsEvtInterval(e, t);
  }
  getRemoteStreamStats() {
    return this.statsReport.getRemoteStreamStats();
  }
  initVideoEncodedTransform() {
    if (getParameter("DISABLE_ENCODED_TRANSFORM")) this.logger.warn("initVideoEncodedTransform", "DISABLE_ENCODED_TRANSFORM");
    else if (this.videoTransceiver && this.videoTransceiver.receiver) {
      if (this._ctx.pcKillSwitch.ctor_encodedinsetablestream_add && isLegacyEncodedTransformSupported()) {
        var e;
        null === (e = this._ctx.monitor) || void 0 === e || e.report("rtc_invoke_status", { sdk_api_name: "initVideoEncodedTransform", message: "using legacy EncodedTransform", error_code: 0, stream_id: this.streamId, elapse: 0 });
        const { receiver: t2 } = this.videoTransceiver, { readable: i, writable: r } = t2.createEncodedStreams();
        i.pipeThrough(receiveSEITransform({ postMessage: (e2) => {
          this.safeEmit("onSEIMessage", e2.payload);
        }, skipFilter: !!getParameter("SKIP_SEI_FILTER") })).pipeTo(r);
      } else if (isEncodedTransformSupported()) {
        var t;
        null === (t = this._ctx.monitor) || void 0 === t || t.report("rtc_invoke_status", { sdk_api_name: "initVideoEncodedTransform", message: "using standard EncodedTransform", error_code: 0, stream_id: this.streamId, elapse: 0 });
        const e2 = this._ctx.receiveSEIWorker;
        this.videoTransceiver.receiver.transform = new RTCRtpScriptTransform(e2, { streamId: this.streamId, skipFilter: !!getParameter("SKIP_SEI_FILTER") }), this._seiWorkerHandler = (e3) => {
          e3.data.streamId === this.streamId && this.safeEmit("onSEIMessage", e3.data.msg.payload);
        }, e2.addEventListener("message", this._seiWorkerHandler);
      }
    } else this.logger.warn("no receiver found when trying to bind encodedTransform");
  }
  initAudioEncodedTransform() {
    if (getParameter("DISABLE_ENCODED_TRANSFORM")) return void this.logger.warn("initVideoEncodedTransform", "DISABLE_ENCODED_TRANSFORM");
    if (!this.audioTransceiver || !this.audioTransceiver.receiver) return void this.logger.warn("no receiver found when trying to bind encodedTransform");
    if (!this._ctx.pcKillSwitch.ctor_encodedinsetablestream_add) return void this.logger.warn("legacy EncodedTransform is not supported");
    if (!isLegacyEncodedTransformSupported()) return void this.logger.warn("legacy EncodedTransform is not supported");
    const { receiver: e } = this.audioTransceiver, { readable: t, writable: i } = e.createEncodedStreams();
    t.pipeThrough(new TransformStream({ transform: (e2, t2) => {
      e2.data.byteLength <= 1e3 ? t2.enqueue(e2) : this.logger.print("too large audio frame", e2.data.byteLength);
    } })).pipeTo(i);
  }
  ontrack(e) {
    var t;
    try {
      reportRtcInvokeStatus(this.engineId, "Stream.ontrack", JSON.stringify({ uid: this.userId, streamId: this.streamId, streams: e.streams.reduce((e2, t2) => e2 + mediaStreamStringify(t2), ""), transceiver: mediaTransceiverStringify(e.transceiver), track: mediaTrackStringify(e.track) }), 0, this.streamId || "");
    } catch (e2) {
    }
    if (this.enableVendorMode || null !== (t = e.streams) && void 0 !== t && null !== (t = t[0]) && void 0 !== t && null !== (t = t.id) && void 0 !== t && t.includes(this.streamId)) {
      var i;
      const { track: t2 } = e;
      "video" === (null == t2 ? void 0 : t2.kind) ? this._setVideoTrack(t2) : "audio" === (null === (i = e.track) || void 0 === i ? void 0 : i.kind) && this._setAudioTrack(t2), this._setStream(e.streams[0]);
    }
    this.safeEmit("ontrack", e);
  }
  startVideoStallObserve(e) {
    this.logger.info("startVideoStallObserve", "invoke", e.playerId), this._videoStallObserver || (this._videoStallObserver = new VideoStallObserver(this.isScreen, this.engineId)), this._videoStallObserver.start(e);
  }
  stopVideoStallObserve() {
    var e;
    this.logger.info("stopVideoStallObserve", "invoke"), null === (e = this._videoStallObserver) || void 0 === e || e.stop();
  }
  updateVideoStallInfo(e, t, i) {
    let r;
    var o;
    i ? (r = null === (o = this._videoStallObserver) || void 0 === o ? void 0 : o.getStallInfo({ interval: e.stats_interval || 0, bitrate: e.bitrate, frameRateDecoded: e.frame_rate_decoded, frameRateReceived: e.frame_rate_received }), this._installInfo = r) : r = this._installInfo;
    if (r) {
      const o2 = Math.min(r.report.stallDuration, e.stats_interval || 0);
      if (e.play_time = r.pts, e.stall_count = r.report.stallCount, e.is_screen ? e.stuck_length = o2 : e.stall_duration = o2, e.pause_duration = Math.min(o2, r.pauseDuration), t.stallCount = r.callback.stallCount, t.stallDuration = r.callback.stallDuration, r.stall100ms) {
        const i2 = Math.min(r.stall100ms.duration, e.stats_interval || 0);
        e.stall_duration_100ms = i2, e.stall_count_100ms = r.stall100ms.count, t.stallDuration100MS = i2, t.stallCount100MS = r.stall100ms.count;
      }
      var n;
      if (0 !== r.report.stallCount || 0 !== r.report.stallDuration) this.logger.print("video_stall_report", this.userId, null === (n = this.videoTrack) || void 0 === n ? void 0 : n.observingPlayerId, JSON.stringify(r.report), i);
    }
  }
  getVideoRenderInfo() {
    var e;
    return (null === (e = this._videoStallObserver) || void 0 === e ? void 0 : e.getRecentRenderInfo4Report()) || {};
  }
  stopAudioStallObserve() {
    var e;
    this.logger.info("stopAudioStallObserve", "invoke"), null === (e = this._audioStallObserver) || void 0 === e || e.stop();
  }
  async updateAudioStallInfo(e, t, i) {
    if (this._audioStallObserver) {
      const i2 = await this._audioStallObserver.getAudioStallInfo();
      return e.concealedSamples === e.interval_concealed_samples && e.totalSamplesReceived === e.interval_samples_received ? (e.stall_count = 0, e.stall_duration = 0, t.stallCount = 0, t.stallDuration = 0) : (e.stall_count = i2.report.stall_count, e.stall_duration = i2.report.stall_duration, t.stallCount = i2.callback.stall_count, t.stallDuration = i2.callback.stall_duration), 0 === i2.report.stall_count && 0 === i2.report.stall_duration || this.logger.print("audio_stall_report", this.userId, JSON.stringify(_objectSpread2(_objectSpread2({}, i2.report), {}, { callbackList: i2.callback.list }))), i2.extra;
    }
    this._audioStallObserver = new AudioStallObserver(this), this._audioStallObserver.start(i.concealedSamples, i.totalSamplesReceived), this.logger.print("startAduioObserver", "start");
  }
  resetStream() {
    var e, t;
    null === (e = this.audioTransceiver) || void 0 === e || e.stop(), null === (t = this.videoTransceiver) || void 0 === t || t.stop(), this.audioTransceiver = void 0, this.videoTransceiver = void 0;
  }
  clean() {
    var e, t;
    this.logger.info("clean", "exec stream.clean ".concat(this.streamId, " ").concat(this.userId)), reportRtcInvokeStatus(this.engineId, "remotestream_clean", "".concat(new Error().stack), 0, this.streamId), super.destroy(), this.subAudio = false, this.subVideo = false, this.sequenceId = 0, null === (e = this.videoTrack) || void 0 === e || e.destroy(), this.videoTrack = void 0, null === (t = this.audioTrack) || void 0 === t || t.destroy(), this.audioTrack = void 0, this.stream = void 0, this.recordedVideoFrames = void 0, delete this.priority, this._seiWorkerHandler && this._ctx.receiveSEIWorker.removeEventListener("message", this._seiWorkerHandler);
  }
  destroy() {
    var e, t;
    this.clean(), null === (e = this._audioStallObserver) || void 0 === e || e.destroy(), delete this._audioStallObserver, null === (t = this._videoStallObserver) || void 0 === t || t.destroy(), delete this._videoStallObserver, this.attributes = { audiostream: false, localaudio: false, localvideo: false, videostream: false, extvideo: false, extaudio: false, videoDescriptions: [] }, super.removeAllListeners();
  }
  resetHasSubscribed() {
    this.streamState = 0;
  }
  _setStream(e) {
    this.stream = e, e.onaddtrack = (e2) => {
      "video" === e2.track.kind ? this._setVideoTrack(e2.track) : "audio" === e2.track.kind && this._setAudioTrack(e2.track);
    };
  }
  _setAudioTrack(e) {
    var t;
    if ((null === (t = this.audioTrack) || void 0 === t || null === (t = t.preprocessingTrack) || void 0 === t ? void 0 : t.id) !== e.id) {
      this.audioTrack = createRemoteAudioTrack(this._ctx, e, { streamIndex: this.isPublic ? ExtendStreamIndex.PUBLIC : this.virtual ? ExtendStreamIndex.VIRTUAL : this.isScreen ? ExtendStreamIndex.SCREEN : ExtendStreamIndex.MAIN, streamUserId: this.userId });
      const t2 = this._ctx._remoteAudioTrackDumpConfig[this.isScreen ? StreamIndex.STREAM_INDEX_SCREEN : StreamIndex.STREAM_INDEX_MAIN].get(this.userId);
      var i;
      if (null != t2 && t2.callback && null != t2 && t2.frameSize) null === (i = this.audioTrack) || void 0 === i || i.setDataFetcher(t2.frameSize, (e2) => {
        var i2;
        this.audioHasCapture && this.audioHasPublish && (null === (i2 = t2.callback) || void 0 === i2 || i2.call(t2, e2));
      });
      this.emit("ontrack", this.audioTrack);
    }
  }
  _setVideoTrack(e) {
    var t;
    (null === (t = this.videoTrack) || void 0 === t || null === (t = t.preprocessingTrack) || void 0 === t ? void 0 : t.id) !== e.id && (this.videoTrack = createRemoteVideoTrack(this._ctx, e, this, { streamIndex: this.isPublic ? ExtendStreamIndex.PUBLIC : this.virtual ? ExtendStreamIndex.VIRTUAL : this.isScreen ? ExtendStreamIndex.SCREEN : ExtendStreamIndex.MAIN, streamUserId: this.userId }), this.emit("ontrack", this.videoTrack));
  }
};
var RoomEvent = ((e) => (e.RESUBSCRIBE = "resubscribe", e.STREAM_FAILED = "stream_failed", e.SUBSCRIBE_PUSH_TRACK = "subscribe_push_track", e.REMOVE_PUSH_TRACK = "remove_push_track", e.VIDEO_FIRST_FRAME = "video_first_frame", e.ON_USER_PUBLISH_STATE_CHANGE = "on_user_publish_state_change", e.ON_USER_START_AUDIO_CAPTURE = "on_user_start_audio_capture", e.ON_USER_STOP_AUDIO_CAPTURE = "on_user_stop_audio_capture", e.ON_USER_START_VIDEO_CAPTURE = "on_user_start_video_capture", e.ON_USER_STOP_VIDEO_CAPTURE = "on_user_stop_video_capture", e.ON_SEI_MESSAGED_RECEIVED = "on_sei_messaged_received", e.ON_PUBLISH_RESULT = "on_publish_result", e.ON_SUBSCRIBE_RESULT = "ON_SUBSCRIBE_RESULT", e.ON_UPDATE_TOKEN_SUCCESS = "on_update_token_success", e.ON_REMOTE_STREAM_STATS = "ON_REMOTE_STREAM_STATS", e.ON_LOCAL_STREAM_STATS = "ON_LOCAL_STREAM_STATS", e.ON_USER_LEAVE = "on_user_leave", e.ON_ROOM_ERROR = "on_room_error", e.ON_NETWORK_QUALITY = "on_network_quality", e.ON_SIMULCAST_SUBSCRIBE_FALLBACK = "on_simulcast_subscribe_fallback", e.ON_REMOTE_VIDEO_SIZE_CHANGED = "on_remote_video_size_changed", e.ON_SUBTITLE_STATE_CHANGED = "ON_SUBTITLE_STATE_CHANGED", e.ON_SUBTITLE_MESSAGE_RECEIVED = "ON_SUBTITLE_MESSAGE_RECEIVED", e.ON_VIDEO_STREAM_BANNED = "ON_VIDEO_STREAM_BANNED", e.ON_AUDIO_STREAM_BANNED = "ON_AUDIO_STREAM_BANNED", e.ON_FORWARD_STREAM_ERROR = "ON_FORWARD_STREAM_ERROR", e.ON_REJOIN_WITH_TCP = "ON_REJOIN_WITH_TCP", e.PUB_RETRY = "PUB_RETRY", e.SUB_RETRY = "SUB_RETRY", e.VIDEO_TYPE_CHANGE = "VIDEO_TYPE_CHANGE", e.JOIN_SUCCESS = "JOIN_SUCCESS", e.UPDATE_PUBLISH = "UPDATE_PUBLISH", e))(RoomEvent || {});
var StreamMixingEventType = ((e) => (e[e.START = 1] = "START", e[e.START_SUCCESS = 2] = "START_SUCCESS", e[e.START_FAILED = 3] = "START_FAILED", e[e.UPDATE = 4] = "UPDATE", e[e.UPDATE_SUCCESS = 5] = "UPDATE_SUCCESS", e[e.UPDATE_FAILED = 6] = "UPDATE_FAILED", e[e.STOP = 7] = "STOP", e[e.STOP_SUCCESS = 8] = "STOP_SUCCESS", e[e.STOP_FAILED = 9] = "STOP_FAILED", e))(StreamMixingEventType || {});
var PubState = ((e) => (e[e.PUB = 0] = "PUB", e[e.UNPUB = 1] = "UNPUB", e))(PubState || {});
var reportFirstFrameRecvError = async (e, t, i, r) => {
  try {
    var o, n, s, a;
    let u = "", h = -1;
    const _ = "video" === t ? null == i || null === (o = i.videoTrack) || void 0 === o ? void 0 : o.originTrack : null == i || null === (n = i.audioTrack) || void 0 === n ? void 0 : n.originTrack, p = "video" === t ? null == i || null === (s = i.videoTransceiver) || void 0 === s ? void 0 : s.receiver : null == i || null === (a = i.audioTransceiver) || void 0 === a ? void 0 : a.receiver;
    try {
      var d, c2;
      const i2 = await (null === (d = e.peerConnection) || void 0 === d ? void 0 : d.getStatsWithLowFrequency(_, true, p)), r2 = (i2 || []).find((e2) => "inbound-rtp" === e2.type), o2 = await (null == p ? void 0 : p.getStats()), n2 = [];
      let s2;
      var l;
      if (null == o2 || o2.forEach((e2) => n2.push(e2.type)), 0 === (null == i2 ? void 0 : i2.length) && 0 !== n2.length) s2 = await (null === (l = e.peerConnection) || void 0 === l ? void 0 : l.getStatsWithLowFrequency(void 0, void 0, p));
      u = JSON.stringify({ type: t, reports: i2.map((e2) => e2.type), reports2: n2, pc: (null === (c2 = e.peerConnection) || void 0 === c2 ? void 0 : c2.getOriginRTCPeerConnection()) || null, track: (null == _ ? void 0 : _.id) || null, bytes: null == r2 ? void 0 : r2.bytesReceived, framesReceived: null == r2 ? void 0 : r2.framesReceived, packetsReceived: null == r2 ? void 0 : r2.packetsReceived, allReports: s2 });
    } catch (e2) {
      h = -999, u = e2.mseeage || JSON.stringify(e2);
    }
    null == r || r.report("rtc_invoke_status", { sdk_api_name: "first_frame_recv_timeout", error_code: h, message: u, stream_id: (null == i ? void 0 : i.streamId) || "", stream_user_id: null == i ? void 0 : i.userId, elapse: 0 });
  } catch (e2) {
  }
};
var reportFirstFrameSendError = async (e, t, i, r) => {
  try {
    var o, n, s, a;
    let u = "", h = -1;
    const _ = "video" === t ? null == i || null === (o = i.videoTrack) || void 0 === o ? void 0 : o.preprocessingTrack : null == i || null === (n = i.audioTrack) || void 0 === n ? void 0 : n.preprocessingTrack, p = "video" === t ? null == i || null === (s = i.videoTransceiver) || void 0 === s ? void 0 : s.sender : null == i || null === (a = i.audioTransceiver) || void 0 === a ? void 0 : a.sender;
    try {
      var d, c2;
      const i2 = await (null === (d = e.peerConnection) || void 0 === d ? void 0 : d.getStatsWithLowFrequency(_, true, p)), r2 = (i2 || []).find((e2) => "outbound-rtp" === e2.type), o2 = await (null == p ? void 0 : p.getStats()), n2 = [];
      let s2;
      var l;
      if (null == o2 || o2.forEach((e2) => n2.push(e2.type)), 0 === i2.length && 0 !== n2.length) s2 = await (null === (l = e.peerConnection) || void 0 === l ? void 0 : l.getStatsWithLowFrequency(void 0, void 0, p));
      u = JSON.stringify({ type: t, reports: i2.map((e2) => e2.type), reports2: n2, pc: (null === (c2 = e.peerConnection) || void 0 === c2 ? void 0 : c2.getOriginRTCPeerConnection()) || null, track: (null == _ ? void 0 : _.id) || null, bytes: null == r2 ? void 0 : r2.bytesSent, framesSent: null == r2 ? void 0 : r2.framesSent, packetsSent: null == r2 ? void 0 : r2.packetsSent, allReports: s2 });
    } catch (e2) {
      h = -999, u = e2.mseeage || JSON.stringify(e2);
    }
    null == r || r.report("rtc_invoke_status", { sdk_api_name: "first_frame_send_timeout", error_code: h, message: u, stream_id: (null == i ? void 0 : i.streamId) || "", stream_user_id: null == i ? void 0 : i.userId, elapse: 0 });
  } catch (e2) {
  }
};
var RecvFrameObserver = class extends eventemitter3Exports.EventEmitter {
  constructor(e, t) {
    super(), _defineProperty(this, "_audioEventSessionId", genEventSessionId()), _defineProperty(this, "_videoEventSessionId", genEventSessionId()), _defineProperty(this, "_stream", void 0), _defineProperty(this, "_firstAudioFrameTimer", void 0), _defineProperty(this, "_firstVideoFrameTimer", void 0), _defineProperty(this, "_transportDelayInterval", void 0), _defineProperty(this, "_transportDelay", void 0), _defineProperty(this, "_firstVideoFrameInterval", void 0), _defineProperty(this, "_firstAudioFrameInterval", void 0), _defineProperty(this, "_isScreen", false), _defineProperty(this, "_audioFirstFrameState", 0), _defineProperty(this, "_videoFirstFrameState", 0), _defineProperty(this, "_timeout", 1e4), _defineProperty(this, "_currentAudioRecv", { startTime: 0, eventSessionId: 0, type: "login" }), _defineProperty(this, "_currentVideoRecv", { startTime: 0, eventSessionId: 0, type: "login" }), _defineProperty(this, "_login", false), _defineProperty(this, "_unMuteAudio", false), _defineProperty(this, "_enableAudio", false), _defineProperty(this, "_unMuteVideo", false), _defineProperty(this, "_enableVideo", false), _defineProperty(this, "_remoteUnmuteAudio", false), _defineProperty(this, "_remoteUnmuteVideo", false), _defineProperty(this, "_audioExternal", false), _defineProperty(this, "_pushAudio", false), _defineProperty(this, "_videoExternal", false), _defineProperty(this, "_pushVideo", false), _defineProperty(this, "_autoSubscribeVideo", false), _defineProperty(this, "_autoSubscribeAudio", false), _defineProperty(this, "_autoSubscribe", false), _defineProperty(this, "_publishVideo", false), _defineProperty(this, "_publishAudio", false), _defineProperty(this, "_subscribeAudio", false), _defineProperty(this, "_subscribeVideo", false), _defineProperty(this, "_subscribe", false), _defineProperty(this, "_pushTrack", false), _defineProperty(this, "_multiChatMode", false), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "logger", void 0), this._ctx = e, this._stream = t, this.getTransportDelay(), this._monitor = getMonitor(t.engineId), this.logger = new Logger$1("RecvFrameObserver", 0, t.engineId);
  }
  async beginRecvFrame(e, t) {
    await this.getTransportDelay();
    let i = this._transportDelay, r = true;
    if (["login", "unmute", "subscribe", "push_track"].indexOf(t) >= 0 && (i = 0, r = false), "audio" === e) {
      var o, n, s, a, d, c2, l, u, h;
      r || this._audioEventSessionId++, this._currentAudioRecv = { startTime: Date.now(), eventSessionId: this._audioEventSessionId, type: t };
      const _2 = { media_type: e, event_type: "begin_recv", type: t, is_screen: !(null === (o = this._stream) || void 0 === o || !o.isScreen), start: null === (n = this._currentAudioRecv) || void 0 === n ? void 0 : n.startTime, event_session_id: this._audioEventSessionId, stream_user_id: null === (s = this._stream) || void 0 === s ? void 0 : s.userId, transport_delay: i, vendor_mode: (null === (a = this._stream) || void 0 === a ? void 0 : a.vendorCode) || 0, pc_session_id: (null === (d = this._stream) || void 0 === d ? void 0 : d.pcSessionId) || (null === (c2 = this._ctx.peerConnection) || void 0 === c2 ? void 0 : c2.getConnectionId()), remote_rtc_session_id: null === (l = this._stream) || void 0 === l ? void 0 : l.remoteSessionId, is_public_stream: null === (u = this._stream) || void 0 === u ? void 0 : u.isPublicStream };
      this._firstAudioFrameTimer && window.clearTimeout(this._firstAudioFrameTimer), this._firstAudioFrameTimer = setTimeout(() => {
        reportFirstFrameRecvError(this._ctx, "audio", this._stream, this._monitor), this.stopRecvFrame("audio", "timeout"), this._firstAudioFrameInterval && window.clearInterval(this._firstAudioFrameInterval);
      }, this._timeout), this.logger.info("rtcFirstFrameRecv", JSON.stringify(_2)), null === (h = this._monitor) || void 0 === h || h.report("rtc_first_frame", _2), this._watchForFirstAudioFrameRecv(), this._audioFirstFrameState = 1, this._login = true, this._unMuteAudio = true, this._enableAudio = true, this._remoteUnmuteAudio = true;
    } else if ("video" === e) {
      var _, p, m, S, g, v3, f, y, E;
      r || this._videoEventSessionId++, this._currentVideoRecv = { startTime: Date.now(), eventSessionId: this._videoEventSessionId, type: t };
      const o2 = { media_type: e, event_type: "begin_recv", type: t, is_screen: !(null === (_ = this._stream) || void 0 === _ || !_.isScreen), start: null === (p = this._currentVideoRecv) || void 0 === p ? void 0 : p.startTime, event_session_id: this._videoEventSessionId, stream_user_id: null === (m = this._stream) || void 0 === m ? void 0 : m.userId, transport_delay: i, vendor_mode: (null === (S = this._stream) || void 0 === S ? void 0 : S.vendorCode) || 0, pc_session_id: (null === (g = this._stream) || void 0 === g ? void 0 : g.pcSessionId) || (null === (v3 = this._ctx.peerConnection) || void 0 === v3 ? void 0 : v3.getConnectionId()), remote_rtc_session_id: null === (f = this._stream) || void 0 === f ? void 0 : f.remoteSessionId, is_public_stream: null === (y = this._stream) || void 0 === y ? void 0 : y.isPublicStream };
      this._firstVideoFrameTimer && window.clearTimeout(this._firstVideoFrameTimer), this._firstVideoFrameTimer = setTimeout(() => {
        reportFirstFrameRecvError(this._ctx, "video", this._stream, this._monitor), this.stopRecvFrame("video", "timeout"), this._firstVideoFrameInterval && window.clearInterval(this._firstVideoFrameInterval);
      }, this._timeout), this._watchForFirstVideoFrameRecv(), this.logger.info("rtcFirstFrameRecv", JSON.stringify(o2)), null === (E = this._monitor) || void 0 === E || E.report("rtc_first_frame", o2), this._videoFirstFrameState = 1, this._login = true, this._unMuteVideo = true, this._enableVideo = true, this._remoteUnmuteVideo = true;
    }
  }
  stopRecvFrame(e, t) {
    if ("audio" === e) {
      var i, r, o, n, s, a, d, c2, l, u;
      if (1 !== this._audioFirstFrameState) return;
      const h2 = { event_type: "recv_end", media_type: e, is_screen: !(null === (i = this._stream) || void 0 === i || !i.isScreen), start: null === (r = this._currentAudioRecv) || void 0 === r ? void 0 : r.startTime, reason: t, result: false, stream_user_id: null === (o = this._stream) || void 0 === o ? void 0 : o.userId, event_session_id: this._audioEventSessionId, type: null === (n = this._currentAudioRecv) || void 0 === n ? void 0 : n.type, vendor_mode: (null === (s = this._stream) || void 0 === s ? void 0 : s.vendorCode) || 0, pc_session_id: (null === (a = this._stream) || void 0 === a ? void 0 : a.pcSessionId) || (null === (d = this._ctx.peerConnection) || void 0 === d ? void 0 : d.getConnectionId()), remote_rtc_session_id: null === (c2 = this._stream) || void 0 === c2 ? void 0 : c2.remoteSessionId, is_public_stream: null === (l = this._stream) || void 0 === l ? void 0 : l.isPublicStream };
      this._firstAudioFrameTimer && window.clearTimeout(this._firstAudioFrameTimer), delete this._currentAudioRecv, this.logger.info("rtcFirstFrameRecv", JSON.stringify(h2)), null === (u = this._monitor) || void 0 === u || u.report("rtc_first_frame", h2), this._audioFirstFrameState = 2;
    } else if ("video" === e) {
      var h, _, p, m, S, g, v3, f, y, E, T, b, I, R, C, P, A, O, k, N;
      if (1 !== this._videoFirstFrameState) return;
      const i2 = { event_type: "recv_end", media_type: e, is_screen: !(null === (h = this._stream) || void 0 === h || !h.isScreen), start: null === (_ = this._currentVideoRecv) || void 0 === _ ? void 0 : _.startTime, reason: t, result: false, stream_user_id: null === (p = this._stream) || void 0 === p ? void 0 : p.userId, event_session_id: this._videoEventSessionId, type: null === (m = this._currentVideoRecv) || void 0 === m ? void 0 : m.type, vendor_mode: (null === (S = this._stream) || void 0 === S ? void 0 : S.vendorCode) || 0, pc_session_id: (null === (g = this._stream) || void 0 === g ? void 0 : g.pcSessionId) || (null === (v3 = this._ctx.peerConnection) || void 0 === v3 ? void 0 : v3.getConnectionId()), remote_rtc_session_id: null === (f = this._stream) || void 0 === f ? void 0 : f.remoteSessionId, codec: null === (y = this._stream) || void 0 === y || null === (y = y.getRemoteStreamStats()) || void 0 === y || null === (y = y.videoStats) || void 0 === y ? void 0 : y.codecType, stats_frame_size_width: null === (E = this._stream) || void 0 === E || null === (E = E.getRemoteStreamStats()) || void 0 === E || null === (E = E.videoStats) || void 0 === E ? void 0 : E.frame_size_width, stats_frame_size_height: null === (T = this._stream) || void 0 === T || null === (T = T.getRemoteStreamStats()) || void 0 === T || null === (T = T.videoStats) || void 0 === T ? void 0 : T.frame_size_height, stats_frame_rate_decode: null === (b = this._stream) || void 0 === b || null === (b = b.getRemoteStreamStats()) || void 0 === b || null === (b = b.videoStats) || void 0 === b ? void 0 : b.decoderOutputFrameRate, stats_frame_rate_receive: null === (I = this._stream) || void 0 === I || null === (I = I.getRemoteStreamStats()) || void 0 === I || null === (I = I.videoStats) || void 0 === I ? void 0 : I.receivedFrameRate, stats_frame_decoder_name: null === (R = this._stream) || void 0 === R || null === (R = R.getRemoteStreamStats()) || void 0 === R || null === (R = R.videoStats) || void 0 === R ? void 0 : R.decoderName, stats_gpu_url: Config2.GPU_URL || (null === (C = getGpuInfo()) || void 0 === C ? void 0 : C.renderer), track_frame_size_width: null === (P = this._stream) || void 0 === P || null === (P = P.videoTrack) || void 0 === P || null === (P = P.originTrack.getSettings()) || void 0 === P ? void 0 : P.width, track_frame_size_height: null === (A = this._stream) || void 0 === A || null === (A = A.videoTrack) || void 0 === A || null === (A = A.originTrack.getSettings()) || void 0 === A ? void 0 : A.height, track_frame_rate: null === (O = this._stream) || void 0 === O || null === (O = O.videoTrack) || void 0 === O || null === (O = O.originTrack.getSettings()) || void 0 === O ? void 0 : O.frameRate, is_public_stream: null === (k = this._stream) || void 0 === k ? void 0 : k.isPublicStream };
      this._firstVideoFrameTimer && window.clearTimeout(this._firstVideoFrameTimer), delete this._currentVideoRecv, this.logger.info("rtcFirstFrameRecv", JSON.stringify(i2)), null === (N = this._monitor) || void 0 === N || N.report("rtc_first_frame", i2), this._videoFirstFrameState = 2, setTimeout(() => {
        var i3, r2, o2, n2, s2, a2, d2, c3, l2, u2, h2, _2, p2, m2, S2, g2, v5, f2, y2, E2;
        const T2 = { event_type: "recv_end", media_type: e, is_screen: !(null === (i3 = this._stream) || void 0 === i3 || !i3.isScreen), start: null === (r2 = this._currentVideoRecv) || void 0 === r2 ? void 0 : r2.startTime, reason: t, result: false, stream_user_id: null === (o2 = this._stream) || void 0 === o2 ? void 0 : o2.userId, event_session_id: this._videoEventSessionId, type: null === (n2 = this._currentVideoRecv) || void 0 === n2 ? void 0 : n2.type, vendor_mode: (null === (s2 = this._stream) || void 0 === s2 ? void 0 : s2.vendorCode) || 0, pc_session_id: (null === (a2 = this._stream) || void 0 === a2 ? void 0 : a2.pcSessionId) || (null === (d2 = this._ctx.peerConnection) || void 0 === d2 ? void 0 : d2.getConnectionId()), remote_rtc_session_id: null === (c3 = this._stream) || void 0 === c3 ? void 0 : c3.remoteSessionId, codec: null === (l2 = this._stream) || void 0 === l2 || null === (l2 = l2.getRemoteStreamStats()) || void 0 === l2 || null === (l2 = l2.videoStats) || void 0 === l2 ? void 0 : l2.codecType, stats_frame_size_width: null === (u2 = this._stream) || void 0 === u2 || null === (u2 = u2.getRemoteStreamStats()) || void 0 === u2 || null === (u2 = u2.videoStats) || void 0 === u2 ? void 0 : u2.frame_size_width, stats_frame_size_height: null === (h2 = this._stream) || void 0 === h2 || null === (h2 = h2.getRemoteStreamStats()) || void 0 === h2 || null === (h2 = h2.videoStats) || void 0 === h2 ? void 0 : h2.frame_size_height, stats_frame_rate_decode: null === (_2 = this._stream) || void 0 === _2 || null === (_2 = _2.getRemoteStreamStats()) || void 0 === _2 || null === (_2 = _2.videoStats) || void 0 === _2 ? void 0 : _2.decoderOutputFrameRate, stats_frame_rate_receive: null === (p2 = this._stream) || void 0 === p2 || null === (p2 = p2.getRemoteStreamStats()) || void 0 === p2 || null === (p2 = p2.videoStats) || void 0 === p2 ? void 0 : p2.receivedFrameRate, stats_frame_decoder_name: null === (m2 = this._stream) || void 0 === m2 || null === (m2 = m2.getRemoteStreamStats()) || void 0 === m2 || null === (m2 = m2.videoStats) || void 0 === m2 ? void 0 : m2.decoderName, stats_gpu_url: Config2.GPU_URL || (null === (S2 = getGpuInfo()) || void 0 === S2 ? void 0 : S2.renderer), track_frame_size_width: null === (g2 = this._stream) || void 0 === g2 || null === (g2 = g2.videoTrack) || void 0 === g2 || null === (g2 = g2.originTrack.getSettings()) || void 0 === g2 ? void 0 : g2.width, track_frame_size_height: null === (v5 = this._stream) || void 0 === v5 || null === (v5 = v5.videoTrack) || void 0 === v5 || null === (v5 = v5.originTrack.getSettings()) || void 0 === v5 ? void 0 : v5.height, track_frame_rate: null === (f2 = this._stream) || void 0 === f2 || null === (f2 = f2.videoTrack) || void 0 === f2 || null === (f2 = f2.originTrack.getSettings()) || void 0 === f2 ? void 0 : f2.frameRate, is_public_stream: null === (y2 = this._stream) || void 0 === y2 ? void 0 : y2.isPublicStream };
        this.logger.info("rtc_first_frame_statistics", JSON.stringify(T2)), null === (E2 = this._monitor) || void 0 === E2 || E2.report("rtc_first_frame_statistics", T2);
      }, 8e3);
    }
  }
  async recvFrameFinish(e) {
    await this.getTransportDelay();
    let t = this._transportDelay;
    if ("audio" === e) {
      var i, r, o, n, s, a, d, c2;
      if (1 !== this._audioFirstFrameState) return;
      if (!this._currentAudioRecv) return;
      const { type: l2, startTime: u2 } = this._currentAudioRecv;
      ["login", "unmute", "subscribe", "push_track"].indexOf(l2) >= 0 && (t = 0);
      const h2 = { event_type: "recv_end", media_type: e, start: u2, result: true, is_screen: !(null === (i = this._stream) || void 0 === i || !i.isScreen), stream_user_id: null === (r = this._stream) || void 0 === r ? void 0 : r.userId, event_session_id: this._audioEventSessionId, type: l2, transport_delay: t, vendor_mode: (null === (o = this._stream) || void 0 === o ? void 0 : o.vendorCode) || 0, pc_session_id: (null === (n = this._stream) || void 0 === n ? void 0 : n.pcSessionId) || (null === (s = this._ctx.peerConnection) || void 0 === s ? void 0 : s.getConnectionId()), remote_rtc_session_id: null === (a = this._stream) || void 0 === a ? void 0 : a.remoteSessionId, is_public_stream: null === (d = this._stream) || void 0 === d ? void 0 : d.isPublicStream };
      delete this._currentAudioRecv, this._firstAudioFrameTimer && window.clearTimeout(this._firstAudioFrameTimer), this.logger.info("rtcFirstFrameRecv", JSON.stringify(h2)), null === (c2 = this._monitor) || void 0 === c2 || c2.report("rtc_first_frame", h2), this.emit("recvAudioFirstFrame"), this._audioFirstFrameState = 3;
    } else if ("video" === e) {
      var l, u, h, _, p, m, S, g, v3, f, y, E, T, b, I, R, C, P;
      if (1 !== this._videoFirstFrameState) return;
      if (!this._currentVideoRecv) return;
      const { type: i2, startTime: r2 } = this._currentVideoRecv;
      ["login", "unmute", "subscribe", "push_track"].indexOf(i2) >= 0 && (t = 0);
      const o2 = { event_type: "recv_end", media_type: e, is_screen: !(null === (l = this._stream) || void 0 === l || !l.isScreen), start: r2, result: true, stream_user_id: null === (u = this._stream) || void 0 === u ? void 0 : u.userId, event_session_id: this._videoEventSessionId, type: i2, transport_delay: t, vendor_mode: (null === (h = this._stream) || void 0 === h ? void 0 : h.vendorCode) || 0, pc_session_id: (null === (_ = this._stream) || void 0 === _ ? void 0 : _.pcSessionId) || (null === (p = this._ctx.peerConnection) || void 0 === p ? void 0 : p.getConnectionId()), remote_rtc_session_id: null === (m = this._stream) || void 0 === m ? void 0 : m.remoteSessionId, codec: null === (S = this._stream) || void 0 === S || null === (S = S.getRemoteStreamStats()) || void 0 === S || null === (S = S.videoStats) || void 0 === S ? void 0 : S.codecType, stats_frame_size_width: null === (g = this._stream) || void 0 === g || null === (g = g.getRemoteStreamStats()) || void 0 === g || null === (g = g.videoStats) || void 0 === g ? void 0 : g.frameSizeWidth, stats_frame_size_height: null === (v3 = this._stream) || void 0 === v3 || null === (v3 = v3.getRemoteStreamStats()) || void 0 === v3 || null === (v3 = v3.videoStats) || void 0 === v3 ? void 0 : v3.frameSizeHeight, stats_frame_rate_decode: null === (f = this._stream) || void 0 === f || null === (f = f.getRemoteStreamStats()) || void 0 === f || null === (f = f.videoStats) || void 0 === f ? void 0 : f.decoderOutputFrameRate, stats_frame_rate_receive: null === (y = this._stream) || void 0 === y || null === (y = y.getRemoteStreamStats()) || void 0 === y || null === (y = y.videoStats) || void 0 === y ? void 0 : y.receivedFrameRate, stats_frame_decoder_name: null === (E = this._stream) || void 0 === E || null === (E = E.getRemoteStreamStats()) || void 0 === E || null === (E = E.videoStats) || void 0 === E ? void 0 : E.decoderName, stats_gpu_url: Config2.GPU_URL || (null === (T = getGpuInfo()) || void 0 === T ? void 0 : T.renderer), track_frame_size_width: null === (b = this._stream) || void 0 === b || null === (b = b.videoTrack) || void 0 === b || null === (b = b.originTrack.getSettings()) || void 0 === b ? void 0 : b.width, track_frame_size_height: null === (I = this._stream) || void 0 === I || null === (I = I.videoTrack) || void 0 === I || null === (I = I.originTrack.getSettings()) || void 0 === I ? void 0 : I.height, track_frame_rate: null === (R = this._stream) || void 0 === R || null === (R = R.videoTrack) || void 0 === R || null === (R = R.originTrack.getSettings()) || void 0 === R ? void 0 : R.frameRate, is_public_stream: null === (C = this._stream) || void 0 === C ? void 0 : C.isPublicStream };
      delete this._currentVideoRecv, this._firstVideoFrameTimer && window.clearTimeout(this._firstVideoFrameTimer), this.logger.info("rtcFirstFrameRecv", JSON.stringify(o2)), null === (P = this._monitor) || void 0 === P || P.report("rtc_first_frame", o2), this.emit("recvVideoFirstFrame"), this._videoFirstFrameState = 3, setTimeout(() => {
        var o3, n2, s2, a2, d2, c3, l2, u2, h2, _2, p2, m2, S2, g2, v5, f2, y2, E2;
        const T2 = { event_type: "recv_end", media_type: e, is_screen: !(null === (o3 = this._stream) || void 0 === o3 || !o3.isScreen), start: r2, result: true, stream_user_id: null === (n2 = this._stream) || void 0 === n2 ? void 0 : n2.userId, event_session_id: this._videoEventSessionId, type: i2, transport_delay: t, vendor_mode: (null === (s2 = this._stream) || void 0 === s2 ? void 0 : s2.vendorCode) || 0, pc_session_id: (null === (a2 = this._stream) || void 0 === a2 ? void 0 : a2.pcSessionId) || (null === (d2 = this._ctx.peerConnection) || void 0 === d2 ? void 0 : d2.getConnectionId()), remote_rtc_session_id: null === (c3 = this._stream) || void 0 === c3 ? void 0 : c3.remoteSessionId, codec: null === (l2 = this._stream) || void 0 === l2 || null === (l2 = l2.getRemoteStreamStats()) || void 0 === l2 || null === (l2 = l2.videoStats) || void 0 === l2 ? void 0 : l2.codecType, stats_frame_size_width: null === (u2 = this._stream) || void 0 === u2 || null === (u2 = u2.getRemoteStreamStats()) || void 0 === u2 || null === (u2 = u2.videoStats) || void 0 === u2 ? void 0 : u2.frameSizeWidth, stats_frame_size_height: null === (h2 = this._stream) || void 0 === h2 || null === (h2 = h2.getRemoteStreamStats()) || void 0 === h2 || null === (h2 = h2.videoStats) || void 0 === h2 ? void 0 : h2.frameSizeHeight, stats_frame_rate_decode: null === (_2 = this._stream) || void 0 === _2 || null === (_2 = _2.getRemoteStreamStats()) || void 0 === _2 || null === (_2 = _2.videoStats) || void 0 === _2 ? void 0 : _2.decoderOutputFrameRate, stats_frame_rate_receive: null === (p2 = this._stream) || void 0 === p2 || null === (p2 = p2.getRemoteStreamStats()) || void 0 === p2 || null === (p2 = p2.videoStats) || void 0 === p2 ? void 0 : p2.receivedFrameRate, stats_frame_decoder_name: null === (m2 = this._stream) || void 0 === m2 || null === (m2 = m2.getRemoteStreamStats()) || void 0 === m2 || null === (m2 = m2.videoStats) || void 0 === m2 ? void 0 : m2.decoderName, stats_gpu_url: Config2.GPU_URL || (null === (S2 = getGpuInfo()) || void 0 === S2 ? void 0 : S2.renderer), track_frame_size_width: null === (g2 = this._stream) || void 0 === g2 || null === (g2 = g2.videoTrack) || void 0 === g2 || null === (g2 = g2.originTrack.getSettings()) || void 0 === g2 ? void 0 : g2.width, track_frame_size_height: null === (v5 = this._stream) || void 0 === v5 || null === (v5 = v5.videoTrack) || void 0 === v5 || null === (v5 = v5.originTrack.getSettings()) || void 0 === v5 ? void 0 : v5.height, track_frame_rate: null === (f2 = this._stream) || void 0 === f2 || null === (f2 = f2.videoTrack) || void 0 === f2 || null === (f2 = f2.originTrack.getSettings()) || void 0 === f2 ? void 0 : f2.frameRate, is_public_stream: null === (y2 = this._stream) || void 0 === y2 ? void 0 : y2.isPublicStream };
        this.logger.info("rtc_first_frame_statistics", JSON.stringify(T2)), null === (E2 = this._monitor) || void 0 === E2 || E2.report("rtc_first_frame_statistics", T2);
      }, 8e3);
    }
  }
  setLogin(e) {
    var t, i, r, o;
    let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { audio: true, video: true };
    this._login !== e && (this._login = e, e && null !== (t = this._stream) && void 0 !== t && t.hasAudio && n.audio && this.beginRecvFrame("audio", "login"), e && null !== (i = this._stream) && void 0 !== i && i.hasVideo && n.video && this.beginRecvFrame("video", "login"), !e && null !== (r = this._stream) && void 0 !== r && r.hasAudio && this.stopRecvFrame("audio", "leave_room"), !e && null !== (o = this._stream) && void 0 !== o && o.hasVideo && this.stopRecvFrame("video", "leave_room"));
  }
  setUnmuteAudio(e) {
    var t, i, r;
    if (this._unMuteAudio === e) return;
    this._unMuteAudio = e;
    const o = !(null === (t = this._stream) || void 0 === t || !t.hasAudio);
    null !== (i = this._stream) && void 0 !== i && i.audioHasCapture && null !== (r = this._stream) && void 0 !== r && r.audioHasPublish && (this._unMuteAudio && o ? this.beginRecvFrame("audio", "unmute") : o && this.stopRecvFrame("audio", "mute"));
  }
  setRemoteUnmuteAudio(e) {
    this._remoteUnmuteAudio !== e && (this._remoteUnmuteAudio = e, this._remoteUnmuteAudio ? this.beginRecvFrame("audio", "remote_unmute") : this.stopRecvFrame("audio", "remote_mute"));
  }
  setEnableAudio(e) {
    this._enableAudio !== e && (this._enableAudio = e, this._enableAudio ? this.beginRecvFrame("audio", "enable") : this.stopRecvFrame("audio", "disable"));
  }
  setUnmuteVideo(e) {
    var t, i, r;
    if (this._unMuteVideo === e) return;
    this._unMuteVideo = e;
    const o = !(null === (t = this._stream) || void 0 === t || !t.hasVideo);
    null !== (i = this._stream) && void 0 !== i && i.videoHasCapture && null !== (r = this._stream) && void 0 !== r && r.videoHasPublish && (this._unMuteVideo && o ? this.beginRecvFrame("video", "unmute") : o && this.stopRecvFrame("video", "mute"));
  }
  setRemoteUnmuteVideo(e) {
    this._remoteUnmuteVideo !== e && (this._remoteUnmuteVideo = e, this._remoteUnmuteVideo ? this.beginRecvFrame("video", "remote_unmute") : this.stopRecvFrame("video", "remote_mute"));
  }
  setEnableVideo(e) {
    this._enableVideo !== e && (this._enableVideo = e, this._enableVideo ? this.beginRecvFrame("video", "enable") : this.stopRecvFrame("video", "disable"));
  }
  setExternalAudioSource(e) {
    this._audioExternal = e;
  }
  setPushAudio(e) {
    var t;
    this._audioExternal && this._pushAudio !== e && (this._pushAudio = e), this._pushAudio && this.beginRecvFrame("audio", "push"), !e && null !== (t = this._stream) && void 0 !== t && t.hasAudio && this.stopRecvFrame("audio", "stop_push");
  }
  setExternalVideoSource(e) {
    this._videoExternal = e;
  }
  setPushVideo(e) {
    var t;
    this._videoExternal && this._pushVideo !== e && (this._pushVideo = e), this._pushVideo && this.beginRecvFrame("video", "push"), !e && null !== (t = this._stream) && void 0 !== t && t.hasVideo && this.stopRecvFrame("video", "stop_push");
  }
  setPublishVideo(e) {
    var t;
    this._publishVideo !== e && (this._publishVideo = e), this._publishVideo && this.beginRecvFrame("video", "publish"), !e && null !== (t = this._stream) && void 0 !== t && t.hasVideo && this.stopRecvFrame("video", "unpublish");
  }
  setPublishAudio(e) {
    var t;
    this._publishAudio !== e && (this._publishAudio = e), this._publishAudio && this.beginRecvFrame("audio", "publish"), !e && null !== (t = this._stream) && void 0 !== t && t.hasAudio && this.stopRecvFrame("audio", "unpublish");
  }
  setAutoSubscribe(e) {
    this._autoSubscribe = e;
  }
  setAutoSubscribeVideo(e) {
    this._autoSubscribeVideo = e;
  }
  setAutoSubscribeAudio(e) {
    this._autoSubscribeAudio = e;
  }
  setSubscribeAudio(e) {
    var t, i;
    this._autoSubscribeAudio || this._subscribeAudio === e || (this._subscribe = e, e && null !== (i = this._stream) && void 0 !== i && i.hasAudio && this.beginRecvFrame("audio", "subscribe"));
    !e && null !== (t = this._stream) && void 0 !== t && t.hasAudio && this.stopRecvFrame("audio", "unsubscribe");
  }
  setSubscribeVideo(e) {
    var t, i;
    this._autoSubscribeVideo || this._subscribeVideo === e || (this._subscribeVideo = e, e && null !== (i = this._stream) && void 0 !== i && i.hasVideo && this.beginRecvFrame("video", "subscribe"));
    !e && null !== (t = this._stream) && void 0 !== t && t.hasVideo && this.stopRecvFrame("video", "unsubscribe");
  }
  setPushTrack(e) {
    var t;
    this._pushTrack !== e && (this._pushTrack = e, e && !this._isScreen && this.beginRecvFrame("audio", "push_track"), !e && null !== (t = this._stream) && void 0 !== t && t.hasAudio && this.stopRecvFrame("audio", "remove_track"));
  }
  setMultiChatMode(e) {
    this._multiChatMode = e;
  }
  setTimeout(e) {
    this._timeout = e;
  }
  _watchForFirstVideoFrameRecv() {
    let e = -1, t = -1;
    this._firstVideoFrameInterval && window.clearInterval(this._firstVideoFrameInterval), this._firstVideoFrameInterval = window.setInterval(async () => {
      var i, r, o;
      const n = null !== (i = null === (r = this._stream) || void 0 === r || null === (r = r.vendorHandler) || void 0 === r ? void 0 : r.peer) && void 0 !== i ? i : this._ctx.peerConnection;
      if (n && null !== (o = this._stream) && void 0 !== o && null !== (o = o.videoTrack) && void 0 !== o && o.preprocessingTrack) {
        var s, a;
        const i2 = null === (s = this._stream.videoTransceiver) || void 0 === s ? void 0 : s.receiver, r2 = (await n.getStatsWithLowFrequency(null === (a = this._stream) || void 0 === a || null === (a = a.videoTrack) || void 0 === a ? void 0 : a.preprocessingTrack, true, i2)).find((e2) => "inbound-rtp" === e2.type);
        if (r2 && (r2.framesReceived > e || r2.packetsReceived > t)) {
          if (-1 === e && -1 === t) return e = r2.framesReceived, void (t = r2.packetsReceived);
          this.recvFrameFinish("video"), window.clearInterval(this._firstVideoFrameInterval);
        }
      }
    }, 200);
  }
  _watchForFirstAudioFrameRecv() {
    let e = -1, t = -1;
    this._firstAudioFrameInterval && window.clearInterval(this._firstAudioFrameInterval), this._firstAudioFrameInterval = window.setInterval(async () => {
      var i, r, o;
      const n = null !== (i = null === (r = this._stream) || void 0 === r || null === (r = r.vendorHandler) || void 0 === r ? void 0 : r.peer) && void 0 !== i ? i : this._ctx.peerConnection;
      if (n && null !== (o = this._stream) && void 0 !== o && null !== (o = o.audioTrack) && void 0 !== o && o.originTrack) {
        var s;
        const i2 = (await n.getStatsWithLowFrequency(null === (s = this._stream) || void 0 === s || null === (s = s.audioTrack) || void 0 === s ? void 0 : s.originTrack)).find((e2) => "inbound-rtp" === e2.type);
        if (i2 && (i2.totalSamplesReceived > e || i2.packetsReceived > t)) {
          if (-1 === e && -1 === t) return e = i2.totalSamplesReceived, void (t = i2.packetsReceived);
          this.recvFrameFinish("audio"), window.clearInterval(this._firstAudioFrameInterval);
        }
      }
    }, 200);
  }
  async getTransportDelay() {
    await this.getTransportDelayIntl(), window.clearInterval(this._transportDelayInterval), this._transportDelayInterval = window.setInterval(async () => {
      await this.getTransportDelayIntl();
    }, 2e3);
  }
  async getTransportDelayIntl() {
    const e = this._ctx.peerConnection;
    if (e) {
      var t;
      const i = null === (t = this._stream) || void 0 === t || null === (t = t.videoTransceiver) || void 0 === t ? void 0 : t.receiver, r = await e.getStatsWithLowFrequency(void 0, true, i), o = r.find((e2) => "transport" === e2.type && "connected" === e2.dtlsState), n = r.find((e2) => "candidate-pair" === e2.type && "succeeded" === e2.state && e2.id === (null == o ? void 0 : o.selectedCandidatePairId));
      n && (this._transportDelay = Math.round(1e3 * n.currentRoundTripTime / 2));
    }
  }
  setDisconnect() {
    this.stopRecvFrame("audio", "connection_lost"), this.stopRecvFrame("video", "connection_lost"), this.reset();
  }
  reset() {
    this._currentAudioRecv = { startTime: 0, eventSessionId: 0, type: "login" }, this._currentVideoRecv = { startTime: 0, eventSessionId: 0, type: "login" }, this._login = false, this._unMuteAudio = false, this._enableAudio = false, this._unMuteVideo = false, this._remoteUnmuteAudio = false, this._remoteUnmuteVideo = false, this._enableVideo = false, this._audioExternal = false, this._pushAudio = false, this._videoExternal = false, this._pushVideo = false, this._autoSubscribeVideo = false, this._autoSubscribeAudio = false, this._autoSubscribe = false, this._subscribeAudio = false, this._subscribeVideo = false, this._subscribe = false, this._pushTrack = false, this._multiChatMode = false, this._firstAudioFrameTimer && window.clearTimeout(this._firstAudioFrameTimer), this._firstVideoFrameTimer && window.clearTimeout(this._firstVideoFrameTimer), this._firstAudioFrameInterval && window.clearInterval(this._firstAudioFrameInterval), this._firstVideoFrameInterval && window.clearInterval(this._firstVideoFrameInterval), this._transportDelayInterval && window.clearInterval(this._transportDelayInterval);
  }
  get audioFirstFrameReceived() {
    return 3 === this._audioFirstFrameState;
  }
  get FirstFrameReceived() {
    return 3 === this._audioFirstFrameState;
  }
};
var SendFrameObserver = class {
  constructor(e, t) {
    _defineProperty(this, "_audioEventSessionId", genEventSessionId()), _defineProperty(this, "_videoEventSessionId", genEventSessionId()), _defineProperty(this, "_pcSessionId", void 0), _defineProperty(this, "_firstAudioFrameTimer", void 0), _defineProperty(this, "_firstVideoFrameTimer", void 0), _defineProperty(this, "_stream", void 0), _defineProperty(this, "_firstVideoFrameInterval", void 0), _defineProperty(this, "_firstAudioFrameInterval", void 0), _defineProperty(this, "_currentAudioSend", { startTime: 0, eventSessionId: 0, type: "login" }), _defineProperty(this, "_currentVideoSend", { startTime: 0, eventSessionId: 0, type: "login" }), _defineProperty(this, "_login", false), _defineProperty(this, "_publisher", false), _defineProperty(this, "_unMuteAudio", false), _defineProperty(this, "_enableAudio", false), _defineProperty(this, "_unMuteVideo", false), _defineProperty(this, "_enableVideo", false), _defineProperty(this, "_audioExternal", false), _defineProperty(this, "_pushAudio", false), _defineProperty(this, "_videoExternal", false), _defineProperty(this, "_pushVideo", false), _defineProperty(this, "_autoPublish", false), _defineProperty(this, "_publish", false), _defineProperty(this, "_timeout", 1e4), _defineProperty(this, "_audioFirstFrameState", 0), _defineProperty(this, "_videoFirstFrameState", 0), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "logger", void 0), this._ctx = e, this._stream = t, this._monitor = getMonitor(t.engineId), this.logger = new Logger$1("SendFrameObserver", 0, t.engineId);
  }
  beginSendFrame(e, t) {
    if ("audio" === e) {
      var i, r, o, n, s, a, d;
      this._audioEventSessionId++, this._currentAudioSend = { startTime: Date.now(), eventSessionId: this._audioEventSessionId, type: t };
      const c3 = { event_type: "begin_send", media_type: e, is_screen: !(null === (i = this._stream) || void 0 === i || !i.isScreen), type: t, start: this._currentAudioSend.startTime, event_session_id: this._audioEventSessionId, vendor_mode: (null === (r = this._stream) || void 0 === r ? void 0 : r.vendorCode) || 0, pc_session_id: (null === (o = this._stream) || void 0 === o ? void 0 : o.pcSessionId) || (null === (n = this._ctx.peerConnection) || void 0 === n ? void 0 : n.getConnectionId()), capture_session_id: null === (s = this._stream) || void 0 === s || null === (s = s.audioTrack) || void 0 === s ? void 0 : s.captureSessionId, is_public_stream: null === (a = this._stream) || void 0 === a ? void 0 : a.isPublicStream };
      this._firstAudioFrameTimer && window.clearTimeout(this._firstAudioFrameTimer), this._firstAudioFrameTimer = setTimeout(() => {
        reportFirstFrameSendError(this._ctx, "audio", this._stream, this._monitor), this.stopSendFrame("audio", "timeout"), this._firstAudioFrameInterval && window.clearInterval(this._firstAudioFrameInterval);
      }, this._timeout), this.logger.info("rtcFirstFrameSend", JSON.stringify(c3)), null === (d = this._monitor) || void 0 === d || d.report("rtc_first_frame", c3), this._watchForFirstAudioFrameSend(), this._audioFirstFrameState = 1, this._login = true, this._publisher = true, this._publish = true, this._unMuteAudio = true, this._pushAudio || (this._enableAudio = true);
    } else if ("video" === e) {
      var c2, l, u, h, _, p, m;
      this._videoEventSessionId++, this._currentVideoSend = { startTime: Date.now(), eventSessionId: this._videoEventSessionId, type: t };
      const i2 = { event_type: "begin_send", media_type: e, is_screen: !(null === (c2 = this._stream) || void 0 === c2 || !c2.isScreen), type: t, start: this._currentVideoSend.startTime, event_session_id: this._videoEventSessionId, vendor_mode: (null === (l = this._stream) || void 0 === l ? void 0 : l.vendorCode) || 0, pc_session_id: (null === (u = this._stream) || void 0 === u ? void 0 : u.pcSessionId) || (null === (h = this._ctx.peerConnection) || void 0 === h ? void 0 : h.getConnectionId()), capture_session_id: null === (_ = this._stream) || void 0 === _ || null === (_ = _.videoTrack) || void 0 === _ ? void 0 : _.captureSessionId, is_public_stream: null === (p = this._stream) || void 0 === p ? void 0 : p.isPublicStream };
      this._firstVideoFrameTimer && window.clearTimeout(this._firstVideoFrameTimer), this._firstVideoFrameTimer = setTimeout(() => {
        reportFirstFrameSendError(this._ctx, "video", this._stream, this._monitor), this.stopSendFrame("video", "timeout"), this._firstVideoFrameInterval && window.clearInterval(this._firstVideoFrameInterval);
      }, this._timeout), this._watchForFirstVideoFrameSend(), this.logger.info("rtcFirstFrameSend", JSON.stringify(i2)), null === (m = this._monitor) || void 0 === m || m.report("rtc_first_frame", i2), this._videoFirstFrameState = 1, this._login = true, this._publisher = true, this._publish = true, this._unMuteVideo = true, this._pushVideo || (this._enableVideo = true);
    }
  }
  stopSendFrame(e, t) {
    if ("audio" === e) {
      var i, r, o, n, s, a, d, c2, l;
      if (1 !== this._audioFirstFrameState) return;
      const u2 = { event_type: "sent_end", media_type: e, is_screen: !(null === (i = this._stream) || void 0 === i || !i.isScreen), start: null === (r = this._currentAudioSend) || void 0 === r ? void 0 : r.startTime, reason: t, result: false, event_session_id: this._audioEventSessionId, type: null === (o = this._currentAudioSend) || void 0 === o ? void 0 : o.type, vendor_mode: (null === (n = this._stream) || void 0 === n ? void 0 : n.vendorCode) || 0, pc_session_id: (null === (s = this._stream) || void 0 === s ? void 0 : s.pcSessionId) || (null === (a = this._ctx.peerConnection) || void 0 === a ? void 0 : a.getConnectionId()), capture_session_id: null === (d = this._stream) || void 0 === d || null === (d = d.audioTrack) || void 0 === d ? void 0 : d.captureSessionId, is_public_stream: null === (c2 = this._stream) || void 0 === c2 ? void 0 : c2.isPublicStream };
      this._firstAudioFrameTimer && window.clearTimeout(this._firstAudioFrameTimer), delete this._currentAudioSend, this.logger.info("rtcFirstFrameSend", JSON.stringify(u2)), null === (l = this._monitor) || void 0 === l || l.report("rtc_first_frame", u2), this._audioFirstFrameState = 2;
    } else if ("video" === e) {
      var u, h, _, p, m, S, g, v3, f, y, E, T, b, I, R, C, P, A, O, k;
      if (1 !== this._videoFirstFrameState) return;
      const i2 = { event_type: "sent_end", media_type: e, start: null === (u = this._currentVideoSend) || void 0 === u ? void 0 : u.startTime, is_screen: !(null === (h = this._stream) || void 0 === h || !h.isScreen), reason: t, result: false, event_session_id: this._videoEventSessionId, type: null === (_ = this._currentVideoSend) || void 0 === _ ? void 0 : _.type, vendor_mode: (null === (p = this._stream) || void 0 === p ? void 0 : p.vendorCode) || 0, pc_session_id: (null === (m = this._stream) || void 0 === m ? void 0 : m.pcSessionId) || (null === (S = this._ctx.peerConnection) || void 0 === S ? void 0 : S.getConnectionId()), capture_session_id: null === (g = this._stream) || void 0 === g || null === (g = g.videoTrack) || void 0 === g ? void 0 : g.captureSessionId, codec: null === (v3 = this._stream) || void 0 === v3 ? void 0 : v3.currentVideoCodec, track_frame_size_width: null === (f = this._stream) || void 0 === f || null === (f = f.videoTrack) || void 0 === f || null === (f = f.originTrack) || void 0 === f ? void 0 : f.getSettings().width, track_frame_size_height: null === (y = this._stream) || void 0 === y || null === (y = y.videoTrack) || void 0 === y || null === (y = y.originTrack) || void 0 === y ? void 0 : y.getSettings().height, track_frame_rate: null === (E = this._stream) || void 0 === E || null === (E = E.videoTrack) || void 0 === E || null === (E = E.originTrack) || void 0 === E ? void 0 : E.getSettings().frameRate, stats_frame_size_width: null === (T = this._stream) || void 0 === T || null === (T = T.getLocalStreamStats()) || void 0 === T || null === (T = T.videoStats) || void 0 === T ? void 0 : T.frame_size_width, stats_frame_size_height: null === (b = this._stream) || void 0 === b || null === (b = b.getLocalStreamStats()) || void 0 === b || null === (b = b.videoStats) || void 0 === b ? void 0 : b.frame_size_height, stats_frame_rate_input: null === (I = this._stream) || void 0 === I || null === (I = I.getLocalStreamStats()) || void 0 === I || null === (I = I.videoStats) || void 0 === I ? void 0 : I.inputFrameRate, stats_frame_rate_sent: null === (R = this._stream) || void 0 === R || null === (R = R.getLocalStreamStats()) || void 0 === R || null === (R = R.videoStats) || void 0 === R ? void 0 : R.sentFrameRate, stats_frame_rate_encode: null === (C = this._stream) || void 0 === C || null === (C = C.getLocalStreamStats()) || void 0 === C || null === (C = C.videoStats) || void 0 === C ? void 0 : C.encoderOutputFrameRate, stats_frame_encoder_name: null === (P = this._stream) || void 0 === P || null === (P = P.getLocalStreamStats()) || void 0 === P || null === (P = P.videoStats) || void 0 === P ? void 0 : P.encoderName, stats_is_hardware_encoder_enabled: Config2.H264_HW_ENCODER, stats_gpu_url: Config2.GPU_URL || (null === (A = getGpuInfo()) || void 0 === A ? void 0 : A.renderer), is_public_stream: null === (O = this._stream) || void 0 === O ? void 0 : O.isPublicStream };
      this._firstVideoFrameTimer && window.clearTimeout(this._firstVideoFrameTimer), delete this._currentVideoSend, this.logger.info("rtcFirstFrameSend", JSON.stringify(i2)), null === (k = this._monitor) || void 0 === k || k.report("rtc_first_frame", i2), this._videoFirstFrameState = 2, setTimeout(() => {
        var i3, r2, o2, n2, s2, a2, d2, c3, l2, u2, h2, _2, p2, m2, S2, g2, v5, f2, y2, E2;
        const T2 = { event_type: "sent_end", media_type: e, start: null === (i3 = this._currentVideoSend) || void 0 === i3 ? void 0 : i3.startTime, is_screen: !(null === (r2 = this._stream) || void 0 === r2 || !r2.isScreen), reason: t, result: false, event_session_id: this._videoEventSessionId, type: null === (o2 = this._currentVideoSend) || void 0 === o2 ? void 0 : o2.type, vendor_mode: (null === (n2 = this._stream) || void 0 === n2 ? void 0 : n2.vendorCode) || 0, pc_session_id: (null === (s2 = this._stream) || void 0 === s2 ? void 0 : s2.pcSessionId) || (null === (a2 = this._ctx.peerConnection) || void 0 === a2 ? void 0 : a2.getConnectionId()), capture_session_id: null === (d2 = this._stream) || void 0 === d2 || null === (d2 = d2.videoTrack) || void 0 === d2 ? void 0 : d2.captureSessionId, codec: null === (c3 = this._stream) || void 0 === c3 ? void 0 : c3.currentVideoCodec, track_frame_size_width: null === (l2 = this._stream) || void 0 === l2 || null === (l2 = l2.videoTrack) || void 0 === l2 || null === (l2 = l2.originTrack) || void 0 === l2 ? void 0 : l2.getSettings().width, track_frame_size_height: null === (u2 = this._stream) || void 0 === u2 || null === (u2 = u2.videoTrack) || void 0 === u2 || null === (u2 = u2.originTrack) || void 0 === u2 ? void 0 : u2.getSettings().height, track_frame_rate: null === (h2 = this._stream) || void 0 === h2 || null === (h2 = h2.videoTrack) || void 0 === h2 || null === (h2 = h2.originTrack) || void 0 === h2 ? void 0 : h2.getSettings().frameRate, stats_frame_size_width: null === (_2 = this._stream) || void 0 === _2 || null === (_2 = _2.getLocalStreamStats()) || void 0 === _2 || null === (_2 = _2.videoStats) || void 0 === _2 ? void 0 : _2.frame_size_width, stats_frame_size_height: null === (p2 = this._stream) || void 0 === p2 || null === (p2 = p2.getLocalStreamStats()) || void 0 === p2 || null === (p2 = p2.videoStats) || void 0 === p2 ? void 0 : p2.frame_size_height, stats_frame_rate_input: null === (m2 = this._stream) || void 0 === m2 || null === (m2 = m2.getLocalStreamStats()) || void 0 === m2 || null === (m2 = m2.videoStats) || void 0 === m2 ? void 0 : m2.inputFrameRate, stats_frame_rate_sent: null === (S2 = this._stream) || void 0 === S2 || null === (S2 = S2.getLocalStreamStats()) || void 0 === S2 || null === (S2 = S2.videoStats) || void 0 === S2 ? void 0 : S2.sentFrameRate, stats_frame_rate_encode: null === (g2 = this._stream) || void 0 === g2 || null === (g2 = g2.getLocalStreamStats()) || void 0 === g2 || null === (g2 = g2.videoStats) || void 0 === g2 ? void 0 : g2.encoderOutputFrameRate, stats_frame_encoder_name: null === (v5 = this._stream) || void 0 === v5 || null === (v5 = v5.getLocalStreamStats()) || void 0 === v5 || null === (v5 = v5.videoStats) || void 0 === v5 ? void 0 : v5.encoderName, stats_is_hardware_encoder_enabled: Config2.H264_HW_ENCODER, stats_gpu_url: Config2.GPU_URL || (null === (f2 = getGpuInfo()) || void 0 === f2 ? void 0 : f2.renderer), is_public_stream: null === (y2 = this._stream) || void 0 === y2 ? void 0 : y2.isPublicStream };
        this.logger.info("rtc_first_frame_statistics", JSON.stringify(T2)), null === (E2 = this._monitor) || void 0 === E2 || E2.report("rtc_first_frame_statistics", T2);
      }, 8e3);
    }
  }
  sendFrameFinish(e) {
    if ("audio" === e) {
      var t, i, r, o, n, s, a;
      if (1 !== this._audioFirstFrameState) return;
      if (!this._currentAudioSend) return;
      const { type: d2, startTime: c3 } = this._currentAudioSend, l2 = { event_type: "sent_end", media_type: e, is_screen: !(null === (t = this._stream) || void 0 === t || !t.isScreen), start: c3, result: true, event_session_id: this._audioEventSessionId, type: d2, vendor_mode: (null === (i = this._stream) || void 0 === i ? void 0 : i.vendorCode) || 0, pc_session_id: (null === (r = this._stream) || void 0 === r ? void 0 : r.pcSessionId) || (null === (o = this._ctx.peerConnection) || void 0 === o ? void 0 : o.getConnectionId()), capture_session_id: null === (n = this._stream) || void 0 === n || null === (n = n.audioTrack) || void 0 === n ? void 0 : n.captureSessionId, is_public_stream: null === (s = this._stream) || void 0 === s ? void 0 : s.isPublicStream };
      delete this._currentAudioSend, this._firstAudioFrameTimer && window.clearTimeout(this._firstAudioFrameTimer), this.logger.info("rtcFirstFrameSend", JSON.stringify(l2)), null === (a = this._monitor) || void 0 === a || a.report("rtc_first_frame", l2), this._audioFirstFrameState = 3;
    } else if ("video" === e) {
      var d, c2, l, u, h, _, p, m, S, g, v3, f, y, E, T, b, I, R;
      if (1 !== this._videoFirstFrameState) return;
      if (!this._currentVideoSend) return;
      const { type: t2, startTime: i2 } = this._currentVideoSend, r2 = { event_type: "sent_end", media_type: e, is_screen: !(null === (d = this._stream) || void 0 === d || !d.isScreen), start: i2, result: true, event_session_id: this._videoEventSessionId, type: t2, vendor_mode: (null === (c2 = this._stream) || void 0 === c2 ? void 0 : c2.vendorCode) || 0, pc_session_id: (null === (l = this._stream) || void 0 === l ? void 0 : l.pcSessionId) || (null === (u = this._ctx.peerConnection) || void 0 === u ? void 0 : u.getConnectionId()), capture_session_id: null === (h = this._stream) || void 0 === h || null === (h = h.videoTrack) || void 0 === h ? void 0 : h.captureSessionId, codec: null === (_ = this._stream) || void 0 === _ ? void 0 : _.currentVideoCodec, track_frame_size_width: null === (p = this._stream) || void 0 === p || null === (p = p.videoTrack) || void 0 === p || null === (p = p.originTrack) || void 0 === p ? void 0 : p.getSettings().width, track_frame_size_height: null === (m = this._stream) || void 0 === m || null === (m = m.videoTrack) || void 0 === m || null === (m = m.originTrack) || void 0 === m ? void 0 : m.getSettings().height, track_frame_rate: null === (S = this._stream) || void 0 === S || null === (S = S.videoTrack) || void 0 === S || null === (S = S.originTrack) || void 0 === S ? void 0 : S.getSettings().frameRate, stats_frame_size_width: null === (g = this._stream) || void 0 === g || null === (g = g.getLocalStreamStats()) || void 0 === g || null === (g = g.videoStats) || void 0 === g ? void 0 : g._captureResolutionWidth, stats_frame_size_height: null === (v3 = this._stream) || void 0 === v3 || null === (v3 = v3.getLocalStreamStats()) || void 0 === v3 || null === (v3 = v3.videoStats) || void 0 === v3 ? void 0 : v3._captureResolutionHeight, stats_frame_rate_input: null === (f = this._stream) || void 0 === f || null === (f = f.getLocalStreamStats()) || void 0 === f || null === (f = f.videoStats) || void 0 === f ? void 0 : f.inputFrameRate, stats_frame_rate_sent: null === (y = this._stream) || void 0 === y || null === (y = y.getLocalStreamStats()) || void 0 === y || null === (y = y.videoStats) || void 0 === y ? void 0 : y.sentFrameRate, stats_frame_rate_encode: null === (E = this._stream) || void 0 === E || null === (E = E.getLocalStreamStats()) || void 0 === E || null === (E = E.videoStats) || void 0 === E ? void 0 : E.encoderOutputFrameRate, stats_frame_encoder_name: null === (T = this._stream) || void 0 === T || null === (T = T.getLocalStreamStats()) || void 0 === T || null === (T = T.videoStats) || void 0 === T ? void 0 : T.encoderName, stats_is_hardware_encoder_enabled: Config2.H264_HW_ENCODER, stats_gpu_url: Config2.GPU_URL || (null === (b = getGpuInfo()) || void 0 === b ? void 0 : b.renderer), is_public_stream: null === (I = this._stream) || void 0 === I ? void 0 : I.isPublicStream };
      delete this._currentVideoSend, this._firstVideoFrameTimer && window.clearTimeout(this._firstVideoFrameTimer), this.logger.info("rtcFirstFrameSend", JSON.stringify(r2)), null === (R = this._monitor) || void 0 === R || R.report("rtc_first_frame", r2), this._videoFirstFrameState = 3, setTimeout(() => {
        var r3, o2, n2, s2, a2, d2, c3, l2, u2, h2, _2, p2, m2, S2, g2, v5, f2, y2;
        const E2 = { event_type: "sent_end", media_type: e, is_screen: !(null === (r3 = this._stream) || void 0 === r3 || !r3.isScreen), start: i2, result: true, event_session_id: this._videoEventSessionId, type: t2, vendor_mode: (null === (o2 = this._stream) || void 0 === o2 ? void 0 : o2.vendorCode) || 0, pc_session_id: (null === (n2 = this._stream) || void 0 === n2 ? void 0 : n2.pcSessionId) || (null === (s2 = this._ctx.peerConnection) || void 0 === s2 ? void 0 : s2.getConnectionId()), capture_session_id: null === (a2 = this._stream) || void 0 === a2 || null === (a2 = a2.videoTrack) || void 0 === a2 ? void 0 : a2.captureSessionId, codec: null === (d2 = this._stream) || void 0 === d2 ? void 0 : d2.currentVideoCodec, track_frame_size_width: null === (c3 = this._stream) || void 0 === c3 || null === (c3 = c3.videoTrack) || void 0 === c3 || null === (c3 = c3.originTrack) || void 0 === c3 ? void 0 : c3.getSettings().width, track_frame_size_height: null === (l2 = this._stream) || void 0 === l2 || null === (l2 = l2.videoTrack) || void 0 === l2 || null === (l2 = l2.originTrack) || void 0 === l2 ? void 0 : l2.getSettings().height, track_frame_rate: null === (u2 = this._stream) || void 0 === u2 || null === (u2 = u2.videoTrack) || void 0 === u2 || null === (u2 = u2.originTrack) || void 0 === u2 ? void 0 : u2.getSettings().frameRate, stats_frame_size_width: null === (h2 = this._stream) || void 0 === h2 || null === (h2 = h2.getLocalStreamStats()) || void 0 === h2 || null === (h2 = h2.videoStats) || void 0 === h2 ? void 0 : h2._captureResolutionWidth, stats_frame_size_height: null === (_2 = this._stream) || void 0 === _2 || null === (_2 = _2.getLocalStreamStats()) || void 0 === _2 || null === (_2 = _2.videoStats) || void 0 === _2 ? void 0 : _2._captureResolutionHeight, stats_frame_rate_input: null === (p2 = this._stream) || void 0 === p2 || null === (p2 = p2.getLocalStreamStats()) || void 0 === p2 || null === (p2 = p2.videoStats) || void 0 === p2 ? void 0 : p2.inputFrameRate, stats_frame_rate_sent: null === (m2 = this._stream) || void 0 === m2 || null === (m2 = m2.getLocalStreamStats()) || void 0 === m2 || null === (m2 = m2.videoStats) || void 0 === m2 ? void 0 : m2.sentFrameRate, stats_frame_rate_encode: null === (S2 = this._stream) || void 0 === S2 || null === (S2 = S2.getLocalStreamStats()) || void 0 === S2 || null === (S2 = S2.videoStats) || void 0 === S2 ? void 0 : S2.encoderOutputFrameRate, stats_frame_encoder_name: null === (g2 = this._stream) || void 0 === g2 || null === (g2 = g2.getLocalStreamStats()) || void 0 === g2 || null === (g2 = g2.videoStats) || void 0 === g2 ? void 0 : g2.encoderName, stats_is_hardware_encoder_enabled: Config2.H264_HW_ENCODER, stats_gpu_url: Config2.GPU_URL || (null === (v5 = getGpuInfo()) || void 0 === v5 ? void 0 : v5.renderer), is_public_stream: null === (f2 = this._stream) || void 0 === f2 ? void 0 : f2.isPublicStream };
        this.logger.info("rtc_first_frame_statistics", JSON.stringify(E2)), null === (y2 = this._monitor) || void 0 === y2 || y2.report("rtc_first_frame_statistics", E2);
      }, 8e3);
    }
  }
  setLogin(e) {
    if (this._login !== e) {
      var t, i;
      if (this._login = e, e) null !== (t = this._stream) && void 0 !== t && t.videoTrack && this._stream.pubVideo && this.beginSendFrame("video", "login"), null !== (i = this._stream) && void 0 !== i && i.audioTrack && this._stream.pubAudio && this.beginSendFrame("audio", "login");
      !e && this._audioSending && this.stopSendFrame("audio", "leave_room"), !e && this._videoSending && this.stopSendFrame("video", "leave_room");
    }
  }
  setPublish(e) {
    if (this._publish !== e) {
      var t, i;
      if (this._publish = e, e) (null === (t = this._stream) || void 0 === t ? void 0 : t.videoTrack) && this._stream.pubVideo && this.beginSendFrame("video", "publish"), (null === (i = this._stream) || void 0 === i ? void 0 : i.audioTrack) && this._stream.pubAudio && this.beginSendFrame("audio", "publish");
      !e && this._audioSending && this.stopSendFrame("audio", "unpublish"), !e && this._videoSending && this.stopSendFrame("video", "unpublish");
    }
  }
  setUnmuteAudio(e) {
    var t;
    this._unMuteAudio !== e && (this._unMuteAudio = e, null !== (t = this._stream) && void 0 !== t && t.audioHasCapture && (e && this.beginSendFrame("audio", "unmute"), !e && this._audioSending && this.stopSendFrame("audio", "mute")));
  }
  setEnableAudio(e) {
    var t;
    this._enableAudio !== e && null !== (t = this._stream) && void 0 !== t && t.pubAudio && (this._enableAudio = e, e && this.beginSendFrame("audio", "enable"), !e && this._audioSending && this.stopSendFrame("audio", "disable"));
  }
  setUnmuteVideo(e) {
    var t;
    this._unMuteVideo !== e && (this._unMuteVideo = e, null !== (t = this._stream) && void 0 !== t && t.videoHasCapture && (e && this.beginSendFrame("video", "unmute"), !e && this._videoSending && this.stopSendFrame("video", "mute")));
  }
  setEnableVideo(e) {
    var t;
    this._enableVideo !== e && null !== (t = this._stream) && void 0 !== t && t.pubVideo && (this._enableVideo = e, e && this.beginSendFrame("video", "enable"), !e && this._videoSending && this.stopSendFrame("video", "disable"));
  }
  setPushAudio(e) {
    this._pushAudio !== e && (this._pushAudio = e, e && this.beginSendFrame("audio", "push"), !e && this._audioSending && this.stopSendFrame("audio", "stop_push"));
  }
  setPushVideo(e) {
    this._pushVideo !== e && (this._pushVideo = e, e && this.beginSendFrame("video", "push"), !e && this._videoSending && this.stopSendFrame("video", "stop_push"));
  }
  setAutoPublish(e) {
    this._autoPublish = e;
  }
  setPublisher(e) {
    this._publisher !== e && (this._publisher = e, !e && this._audioSending && this.stopSendFrame("audio", "audience"), !e && this._videoSending && this.stopSendFrame("video", "audience"));
  }
  setDisconnect() {
    this._audioSending && this.stopSendFrame("audio", "connection_lost"), this._videoSending && this.stopSendFrame("video", "connection_lost"), this.reset();
  }
  setTimeout(e) {
    this._timeout = e;
  }
  setPCSessionId(e) {
    this._pcSessionId = e;
  }
  async _getFirstVideoFrameStats() {
    var e, t, i, r;
    const o = null === (e = this._stream) || void 0 === e || null === (e = e.videoTrack) || void 0 === e ? void 0 : e.preprocessingTrack, n = null === (t = this._stream) || void 0 === t || null === (t = t.videoTransceiver) || void 0 === t ? void 0 : t.sender, s = null !== (i = null === (r = this._stream) || void 0 === r || null === (r = r.vendorHandler) || void 0 === r ? void 0 : r.peer) && void 0 !== i ? i : this._ctx.peerConnection;
    if (s && o) {
      return (await s.getStatsWithLowFrequency(o, true, n)).filter((e2) => "outbound-rtp" === e2.type);
    }
  }
  async _getFirstAudioFrameStats() {
    var e, t, i, r;
    const o = null === (e = this._stream) || void 0 === e || null === (e = e.audioTrack) || void 0 === e ? void 0 : e.preprocessingTrack, n = null === (t = this._stream) || void 0 === t || null === (t = t.audioTransceiver) || void 0 === t ? void 0 : t.sender, s = null !== (i = null === (r = this._stream) || void 0 === r || null === (r = r.vendorHandler) || void 0 === r ? void 0 : r.peer) && void 0 !== i ? i : this._ctx.peerConnection;
    if (s && o) {
      return (await s.getStatsWithLowFrequency(o, true, n)).find((e2) => "outbound-rtp" === e2.type);
    }
  }
  _watchForFirstVideoFrameSend() {
    let e = -1, t = -1;
    this._firstVideoFrameInterval && window.clearInterval(this._firstVideoFrameInterval), this._firstVideoFrameInterval = window.setInterval(async () => {
      const i = await this._getFirstVideoFrameStats();
      let r = 0, o = 0;
      if (null == i || i.map((e2) => {
        r += e2.framesSent, o += e2.packetsSent;
      }), i && i.length > 0 && (r > e || o > t)) {
        if (-1 === e && -1 === t) return e = r, void (t = o);
        this.sendFrameFinish("video"), window.clearInterval(this._firstVideoFrameInterval);
      }
    }, 100);
  }
  _watchForFirstAudioFrameSend() {
    let e = -1;
    this._firstAudioFrameInterval && window.clearInterval(this._firstAudioFrameInterval), this._firstAudioFrameInterval = window.setInterval(async () => {
      const t = await this._getFirstAudioFrameStats();
      if (t && t.packetsSent > e) {
        if (-1 === e) return void (e = t.packetsSent);
        this.sendFrameFinish("audio"), window.clearInterval(this._firstAudioFrameInterval);
      }
    }, 100);
  }
  reset() {
    this._login = false, this._publisher = false, this._unMuteAudio = false, this._enableAudio = false, this._unMuteVideo = false, this._enableVideo = false, this._audioExternal = false, this._pushAudio = false, this._videoExternal = false, this._pushVideo = false, this._autoPublish = false, this._publish = false, this._audioFirstFrameState = 0, this._videoFirstFrameState = 0, this._currentAudioSend = { startTime: 0, eventSessionId: 0, type: "login" }, this._currentVideoSend = { startTime: 0, eventSessionId: 0, type: "login" }, window.clearTimeout(this._firstAudioFrameTimer), window.clearTimeout(this._firstVideoFrameTimer), window.clearInterval(this._firstAudioFrameInterval), window.clearInterval(this._firstVideoFrameInterval);
  }
  destroy() {
    this.reset(), delete this._stream;
  }
  get _audioSending() {
    return 1 === this._audioFirstFrameState;
  }
  get _videoSending() {
    return 1 === this._videoFirstFrameState;
  }
};
var CONFIG = { audio: { delay: 1200, stallRadio: 0.3 }, video: { delay: 1200, stallRadio: 0.6 }, screen_audio: { delay: 1600, stallRadio: 0.8 }, screen_video: { delay: 1600, stallRadio: 0.8 } };
var NetworkQualityManager = class {
  constructor(e) {
    _defineProperty(this, "_preUplinkStats", /* @__PURE__ */ new Map()), _defineProperty(this, "_preDownlinkStats", /* @__PURE__ */ new Map()), _defineProperty(this, "_timer", void 0), _defineProperty(this, "_delayTimer", void 0), _defineProperty(this, "reportor", void 0), this._ctx = e;
  }
  updateUplinkStats(e, t) {
    const { audioStats: i, videoStats: r, isScreen: o } = e;
    if (i.sendKBitrate > 0 && i.rtt) {
      const e2 = o ? "screen_audio" : "audio", { rtt: t2, _fractionLost: r2, _retransmittedRate: n } = i, s = this._getQosLevel(t2, r2 || 0, n || 0), a = this._preUplinkStats.get(e2) || [s];
      this._preUplinkStats.set(e2, [...a, s].slice(-2));
    }
    if (r.sentKBitrate > 0 && r.rtt) {
      const i2 = o ? "screen_video" : "video";
      let { _fractionLost: n } = r;
      const { rtt: s, _sendBandWidth: a, _retransmittedRate: d } = r;
      0 === a && (n = Math.max(0.65, n));
      const c2 = this._getQosLevel(s, n || 0, d || 0), l = this._getUplinkVideoQoE(e, t), u = this._getVideoUplinkNetworkQuality(c2, l), h = this._preUplinkStats.get(i2) || [u];
      this._preUplinkStats.set(i2, [...h, u].slice(-2));
    }
    this._startNetworkQualityReport();
  }
  updateDownlinkStats(e, t) {
    if (!t) return;
    const { audioActive: i, videoActive: r } = this._getStreamActiveState(t), { audioStats: o, videoStats: n, isScreen: s, userId: a } = e;
    let d, c2, l = true, u = true;
    if (i) if (0 === o.receivedKBitrate) l = false;
    else {
      const { rtt: e2, audioLossRate: t2, stallDuration: i2, statsInterval: r2, e2eDelay: a2 } = o, c3 = i2 / r2, l2 = s ? "screen_audio" : "audio", u2 = this._getQosLevel(e2, t2 || 0, n._retransmittedRate || 0), h2 = this._getDownlinkQoE(l2, c3, a2);
      d = this._getNetworkQuality(u2, h2);
    }
    if (r) if (0 === n.receivedKBitrate || 0 === n.rtt) u = false;
    else {
      const { rtt: e2, videoLossRate: t2, stallDuration: i2, statsInterval: r2, e2eDelay: o2, _retransmittedRate: a2 } = n, d2 = i2 / r2, l2 = s ? "screen_video" : "video", u2 = this._getQosLevel(e2, t2 || 0, a2 || 0), h2 = this._getDownlinkQoE(l2, d2, o2);
      c2 = this._getNetworkQuality(u2, h2);
    }
    const h = "".concat(a).concat(s ? "_screen" : "");
    if (!l && !u) return void this._preDownlinkStats.delete(h);
    const _ = d && c2 ? Math.ceil((d + c2) / 2) : d || c2;
    if (_) {
      const e2 = this._preDownlinkStats.get(h) || [_];
      this._preDownlinkStats.set(h, [...e2, _].slice(-2)), this._startNetworkQualityReport();
    }
  }
  destroy() {
    this._timer && (window.clearInterval(this._timer), delete this._timer), this._delayTimer && (window.clearTimeout(this._delayTimer), delete this._delayTimer), this._preUplinkStats.clear(), this._preDownlinkStats.clear();
  }
  _startNetworkQualityReport() {
    this._delayTimer || this._timer || (this._preUplinkStats.size > 0 || this._preDownlinkStats.size > 0) && (this._delayTimer = setTimeout(() => {
      delete this._delayTimer, this._reportNetworkQuality(), this._timer = window.setInterval(() => {
        this._reportNetworkQuality();
      }, 2e3);
    }, 300));
  }
  _reportNetworkQuality() {
    var e;
    let t, i;
    if (["connected", "connecting"].includes(null === (e = this._ctx.handler) || void 0 === e ? void 0 : e.getConnectionState())) {
      const e2 = this._getBetterQualityAndRemoveOldest("audio", "up"), r = this._getBetterQualityAndRemoveOldest("video", "up");
      t = e2 && r ? Math.ceil((e2 + r) / 2) : e2 || r || this._getBetterQualityAndRemoveOldest("screen_video", "up") || this._getBetterQualityAndRemoveOldest("screen_audio", "up") || NetworkQuality.EXCELLENT;
      const o = Array.from(this._preDownlinkStats.keys()).map((e3) => this._getBetterQualityAndRemoveOldest(e3, "down")).filter((e3) => e3);
      i = Math.ceil(o.reduce((e3, t2) => t2 + e3, 0) / o.length) || NetworkQuality.UNKNOWN;
    } else t = i = NetworkQuality.DOWN;
    navigator.onLine || (t = NetworkQuality.DOWN, i = NetworkQuality.DOWN), "function" == typeof this.reportor && this.reportor(t, i);
  }
  _getNetworkQuality(e, t) {
    return 1 === t ? Math.max(e - 2, 1) : 2 === t ? e : Math.min(e + 1, 5);
  }
  _getVideoUplinkNetworkQuality(e, t) {
    return 1 === t || 0 === t ? e : 2 === t ? Math.min(e + 1, 5) : Math.min(e + 2, 5);
  }
  _getQosLevel(e, t, i) {
    let r;
    return r = (!e || e <= 250) && t <= 0.15 ? 1 : (!e || e <= 500) && t <= 0.3 ? 2 : (!e || e <= 750) && t <= 0.45 ? 3 : (!e || e <= 1e3) && t <= 0.6 ? 4 : 5, i > 0.5 ? r = Math.max(r, 4) : i > 0.35 ? r = Math.max(r, 3) : i > 0.15 && (r = Math.max(r, 2)), r;
  }
  _getUplinkQoE(e, t) {
    let i = 0;
    switch (e) {
      case "audio":
      case "video":
        i = t < 0.05 ? 1 : t < 0.1 ? 2 : 3;
        break;
      case "screen_video":
      case "screen_audio":
        i = t < 0.04 ? 1 : t < 0.08 ? 2 : 3;
    }
    return i;
  }
  _getUplinkVideoQoE(e, t) {
    var i;
    const r = (null == e || null === (i = e.videoStats) || void 0 === i ? void 0 : i.rid) || "0";
    if (!t) return 0;
    const o = t.pubAttributes.videoDescriptions[r], n = e.videoStats, s = n.encodedFrameWidth * n.encodedFrameHeight / (o.width * o.height), a = n.sentFrameRate / o.framerate;
    let d = 0, c2 = 0;
    return "number" != typeof s || Number.isNaN(s) || (d = s >= 0.9 ? 1 : s < 0.9 && s >= 0.8 ? 2 : 3), "number" != typeof a || Number.isNaN(a) || (c2 = a >= 0.8 ? 1 : a < 0.8 && a >= 0.6 ? 2 : 3), Math.max(0, d, c2);
  }
  _getDownlinkQoE(e, t, i) {
    const r = CONFIG[e];
    return t > r.stallRadio || i > r.delay || t > r.stallRadio / 2 && i > r.delay / 2 ? 3 : (t > r.stallRadio / 2 || r.delay, 2);
  }
  _getBetterQualityAndRemoveOldest(e, t) {
    let i = NetworkQuality.UNKNOWN;
    const r = "up" === t ? this._preUplinkStats : this._preDownlinkStats, o = r.get(e);
    if (o) {
      const t2 = o.filter((e2) => e2);
      t2.length > 0 && (i = Math.min(...t2)), o.shift(), 0 === o.length && r.delete(e);
    }
    return i;
  }
  _getStreamActiveState(e) {
    let { subMediaType: t, _attributes: i, subVideo: r, subAudio: o } = e;
    return { audioActive: o && audioInMediaType(t) && i.localaudio && i.audiostream, videoActive: r && videoInMediaType(t) && i.localvideo && i.videostream };
  }
};
var VideoSizeObserver = class {
  constructor(e) {
    _defineProperty(this, "_timer", void 0), _defineProperty(this, "_remoteVideoSizeCache", {}), _defineProperty(this, "_remoteScreenSizeCache", {}), _defineProperty(this, "onchange", void 0), this._room = e, this._start();
  }
  destroy() {
    this._timer && (window.clearInterval(this._timer), delete this._timer), this._remoteVideoSizeCache = {}, this._remoteScreenSizeCache = {};
  }
  _start() {
    this._timer || (this._timer = window.setInterval(() => {
      const e = {}, t = {};
      this._room.remoteStreams.forEach((i, r) => {
        i.forEach((i2) => {
          var o;
          const n = null === (o = i2.videoTrack) || void 0 === o ? void 0 : o.preprocessingTrack;
          if (n) {
            const o2 = i2.isScreen ? this._remoteScreenSizeCache : this._remoteVideoSizeCache, { width: d = 0, height: c2 = 0 } = o2[r] || {};
            let l = 0, u = 0;
            if (isFirefox) {
              var s, a;
              ({ width: l, height: u } = null !== (s = null == i2 || null === (a = i2.videoTrack) || void 0 === a ? void 0 : a.getSizeByPlayer()) && void 0 !== s ? s : { width: 0, height: 0 });
            } else {
              const e2 = n.getSettings();
              l = e2.width || 0, u = e2.height || 0;
            }
            c2 === u && d === l || "function" == typeof this.onchange && this.onchange(r, i2.isScreen, l, u), delete o2[r], (i2.isScreen ? t : e)[r] = { width: l, height: u };
          }
        });
      }), Object.keys(this._remoteVideoSizeCache).forEach((e2) => {
        "function" == typeof this.onchange && this.onchange(e2, false, 0, 0);
      }), Object.keys(this._remoteScreenSizeCache).forEach((e2) => {
        "function" == typeof this.onchange && this.onchange(e2, true, 0, 0);
      }), this._remoteVideoSizeCache = e, this._remoteScreenSizeCache = t;
    }, 1e3));
  }
};
var SUBTITLE_PREFIX = Array.from(new TextEncoder().encode("subt"));
var ERROR_CODE_MAP = { 1: ErrorCode.SUBTITLE_ERR_POSTPROCESS, 2: ErrorCode.SUBTITLE_ERR_CONNECTION_ERROR, 3: ErrorCode.SUBTITLE_ERR_PROCESS_ERROR };
var logger$5 = new Logger$1("SubtitleTool", 1);
var checkSourceLanguage = (e) => {
  if (e.extraInfo) try {
    const t2 = JSON.parse(e.extraInfo);
    t2.source_language && ["zh", "en", "ja"].indexOf(t2.source_language);
  } catch (e2) {
  }
  else {
    var t;
    const i = (null === (t = navigator.language) || void 0 === t ? void 0 : t.substring(0, 2)) || "";
    ["zh", "en", "ja"].indexOf(i) > -1 && (e.extraInfo = JSON.stringify({ source_language: i }));
  }
};
var SubtitleTool = class _SubtitleTool {
  constructor(e, t) {
    _defineProperty(this, "_taskId", void 0), _defineProperty(this, "_sourceLanguage", "zh"), _defineProperty(this, "_updating", false), _defineProperty(this, "onEvent", void 0), _defineProperty(this, "onMessage", void 0), _defineProperty(this, "_preConfig", void 0), _defineProperty(this, "_timer", void 0), this._ctx = e, this._roomConf = t;
    const { extraInfo: i } = t.userInfo;
    if (i) try {
      const e2 = JSON.parse(i);
      e2.source_language && (this._sourceLanguage = e2.source_language);
    } catch (e2) {
    }
  }
  async start(e) {
    logger$5.info("start", "Invoke config: %o", e), checkEnum(e.mode, "mode", [SUBTITLE_MODE.ASR_ONLY, SUBTITLE_MODE.ASR_AND_TRANSLATION]);
    const t = Array.isArray(e.targetLanguage) ? e.targetLanguage : [e.targetLanguage || ""];
    if (e.mode === SUBTITLE_MODE.ASR_AND_TRANSLATION && t.findIndex((e2) => -1 === SUPPORT_LANG.indexOf(e2)) > -1) throw new SDKError(ErrorCode.INVALID_PARAMS, "Invalid targetLanguage.");
    if (this._taskId) throw new SDKError(ErrorCode.SUBTITLE_ALREADY_ON, "Already turned on subtitle");
    this._preConfig = { targetLanguage: t, mode: e.mode }, this._taskId = (Date.now().toString() + this._roomConf.roomId + this._roomConf.userId).substring(0, 20), await this._sendSubtitleSignalingWithRetry(e, this._taskId);
  }
  async update(e) {
    if (logger$5.info("update", "Invoke config: %o", e), !this._taskId) throw new SDKError(ErrorCode.SUBTITLE_NOT_TURNED_ON, "Start subtitle first.");
    this._sourceLanguage = e.sourceLanguage, this._updating = true;
    try {
      await this._ctx.signalingManager.sendSignaling("controlMessage", this._genChangeSubtitleLanguageSignaling(e, this._taskId));
    } catch (e2) {
      throw this._updating = false, e2;
    }
  }
  stop() {
    logger$5.info("stop", "Invoke"), this._taskId && this._ctx.signalingManager.sendSignaling("controlMessage", { type: "subtitle", action: "stopped", appId: this._ctx.appId, roomId: this._roomConf.roomId, userId: this._roomConf.userId, taskId: this._taskId }).finally(() => {
      var e;
      delete this._taskId, null === (e = this.onEvent) || void 0 === e || e.call(this, { event: SubtitleEventType.STOPPED }), this._clearTimer();
    });
  }
  async reconnect() {
    this._taskId && this._preConfig && (await this._ctx.signalingManager.sendSignaling("controlMessage", { type: "subtitle", action: "stopped", appId: this._ctx.appId, roomId: this._roomConf.roomId, userId: this._roomConf.userId, taskId: this._taskId }), delete this._taskId, this.start(this._preConfig));
  }
  getConfig() {
    return this._preConfig;
  }
  destroy() {
    logger$5.info("destroy", "Invoke"), this.stop(), delete this._preConfig, delete this._taskId;
  }
  onResult(e) {
    const { error: t, errorMessage: i, eventType: r } = e.body;
    if (0 !== t) {
      var o;
      const e2 = new SDKError(ERROR_CODE_MAP[t] || ErrorCode.SUBTITLE_ERR_UNKNOWN, i || "");
      null === (o = this.onEvent) || void 0 === o || o.call(this, { event: SubtitleEventType.ERROR, errorCode: e2.code, errorMessage: e2.message }), this._clearTimer();
    } else if ("SubtitleStarted" === r) {
      var n;
      null === (n = this.onEvent) || void 0 === n || n.call(this, { event: SubtitleEventType.STARTED }), this._clearTimer();
    } else if (this._updating && "LanguageChanged" === r) {
      var s;
      this._updating = false, null === (s = this.onEvent) || void 0 === s || s.call(this, { event: SubtitleEventType.UPDATED });
    }
  }
  onMessageRecv(e) {
    if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1] || this._taskId && this._preConfig) {
      const i = parseSubtitleMessage(e);
      if (!i || 0 === i.length) return false;
      if (this._taskId && this._preConfig) {
        const { mode: e2, targetLanguage: r } = this._preConfig, o = [];
        var t;
        if (i.forEach((t2) => {
          if (e2 === SUBTITLE_MODE.ASR_ONLY) t2.mode === e2 && o.push(t2);
          else {
            const e3 = r.includes(t2.language);
            (e3 || t2.mode === SUBTITLE_MODE.ASR_ONLY) && o.push(t2), t2.mode === SUBTITLE_MODE.ASR_ONLY && e3 && o.push(_objectSpread2(_objectSpread2({}, t2), {}, { mode: SUBTITLE_MODE.ASR_AND_TRANSLATION }));
          }
        }), o.length > 0) null === (t = this.onMessage) || void 0 === t || t.call(this, o);
      }
      return true;
    }
    return false;
  }
  async _sendSubtitleSignalingWithRetry(e, t) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    await this._ctx.signalingManager.sendSignaling("controlMessage", this._genSubtitleSignaling(e, t)), this._timer = self.setTimeout(() => {
      var r;
      2 === i ? (null === (r = this.onEvent) || void 0 === r || r.call(this, { event: SubtitleEventType.ERROR, errorCode: ErrorCode.TIME_OUT, errorMessage: "start subtitle timeout." }), delete this._timer, this.stop()) : this._sendSubtitleSignalingWithRetry(e, t, i + 1);
    }, _SubtitleTool.retryIntervel);
  }
  _genSubtitleSignaling(e, t) {
    return { taskId: t, type: "subtitle", action: "started", roomId: this._roomConf.roomId, appId: this._ctx.appId, userId: this._roomConf.userId, subtitleMeta: { subtitleConfig: { mode: e.mode, usersConfig: [{ userId: this._roomConf.userId, targetLanguages: Array.isArray(e.targetLanguage) ? e.targetLanguage : [e.targetLanguage || ""] }] }, vendorConfig: { type: 0 } } };
  }
  _genChangeSubtitleLanguageSignaling(e, t) {
    return { taskId: t, type: "subtitle", action: "subtitleUpdated", roomId: this._roomConf.roomId, appId: this._ctx.appId, userId: this._roomConf.userId, subtitleMeta: { protocol: 1, languageConfig: { sourceLanguages: [{ userId: this._roomConf.userId, languageCode: [e.sourceLanguage] }] } } };
  }
  _clearTimer() {
    this._timer && (self.clearTimeout(this._timer), delete this._timer);
  }
};
_defineProperty(SubtitleTool, "retryIntervel", 3e4);
var parseSubtitleMessage = (e) => {
  let { message: t } = e;
  if (t instanceof ArrayBuffer && t.byteLength > 8) try {
    const e2 = new DataView(t, 0);
    let i = 0;
    if (SUBTITLE_PREFIX.every((t2) => e2.getUint8(i++) === t2)) {
      const r = e2.getUint32(i);
      if (i += 4, r === e2.byteLength - 8) {
        const e3 = Utils.ab2str(t.slice(8)), { data: i2, type: r2 } = JSON.parse(e3);
        if ("subtitle" === r2) return i2;
      }
    }
  } catch (e2) {
  }
  return false;
};
var SUPPORT_LANG = ["zh", "zh-Hant", "tn", "vi", "iu", "it", "id", "hi", "en", "ho", "he", "es", "el", "uk", "ur", "tk", "tr", "ti", "ty", "tl", "to", "th", "ta", "te", "sl", "sk", "ss", "eo", "sm", "sg", "st", "sv", "ja", "tw", "qu", "pt", "pa", "no", "nb", "nr", "my", "bn", "mn", "mh", "mk", "ml", "mr", "ms", "lu", "ro", "lt", "lv", "lo", "kj", "hr", "kn", "ki", "cs", "ca", "nl", "ko", "ht", "gu", "ka", "kl", "km", "lg", "kg", "fi", "fj", "fr", "ru", "ng", "de", "tt", "da", "ts", "cv", "fa", "bs", "pl", "bi", "nd", "ba", "bg", "az", "ar", "af", "sq", "ab", "os", "ee", "et", "ay", "lzh", "am", "ckb", "cy", "gl", "ha", "hy", "ig", "kmr", "ln", "nso", "ny", "om", "sn", "so", "sr", "sw", "xh", "yo", "zu"];
function camel2Snake(e) {
  return e.replace(/[A-Z]/g, (e2) => "_".concat(e2.toLowerCase()));
}
function assignIn(e, t) {
  return _objectSpread2(_objectSpread2({}, e), t);
}
function cloneDeep(e) {
  const t = {};
  return Object.keys(e).forEach((i) => {
    const r = e[i];
    try {
      Array.isArray(r) ? t[i] = r.map((e2) => null !== e2 && "object" == typeof e2 ? cloneDeep(e2) : e2) : t[i] = null !== r && "object" == typeof r ? cloneDeep(r) : r;
    } catch (e2) {
    }
  }), t;
}
function values2(e) {
  return null === e ? [] : Object.keys(e).map((t) => e[t]);
}
var logger$4 = new Logger$1("Locker", 2);
var lockId = 1;
var PromiseLock2 = class {
  constructor(e) {
    _defineProperty(this, "lockingPromise", Promise.resolve()), _defineProperty(this, "locks", 0), _defineProperty(this, "name", ""), _defineProperty(this, "lockId", void 0), _defineProperty(this, "closeReason", void 0), this.lockId = lockId++, e && (this.name = e), logger$4.info("lock-".concat(this.name, "-").concat(this.lockId), "is created.");
  }
  get isLocked() {
    return this.locks > 0;
  }
  lock() {
    let e;
    this.locks += 1, logger$4.info("lock-".concat(this.name, "-").concat(this.lockId), "locked, current queue ".concat(this.locks, "."));
    const t = new Promise((t2) => {
      e = () => {
        this.locks -= 1, logger$4.info("lock-".concat(this.name, "-").concat(this.lockId), "unlocked, current queue ".concat(this.locks, ".")), t2();
      };
    }), i = this.lockingPromise.then(() => e);
    return this.lockingPromise = this.lockingPromise.then(() => t), i;
  }
};
var DC_MESSAGE_DIRECTION = ((e) => (e[e.SEND = 0] = "SEND", e[e.FEEDBACK = 1] = "FEEDBACK", e))(DC_MESSAGE_DIRECTION || {});
var DC_MESSAGE_FUNCTION_TYPE = ((e) => (e[e.P2P = 0] = "P2P", e[e.SIGNAL = 1] = "SIGNAL", e[e.BROADCAST = 2] = "BROADCAST", e[e.BUSINESS_SERVER = 3] = "BUSINESS_SERVER", e))(DC_MESSAGE_FUNCTION_TYPE || {});
var USER_MESSAGE_SEND_RESULT = ((e) => (e[e.SUCCESS = 0] = "SUCCESS", e[e.TIMEOUT = 1] = "TIMEOUT", e[e.BROKEN = 2] = "BROKEN", e[e.NO_RECEIVER = 3] = "NO_RECEIVER", e[e.NO_RELAYPATH = 4] = "NO_RELAYPATH", e[e.EXCEED_QPS = 5] = "EXCEED_QPS", e[e.SEND_TO_SERVER_ERROR = 17] = "SEND_TO_SERVER_ERROR", e[e.SERVER_RESPONSE_ERROR = 18] = "SERVER_RESPONSE_ERROR", e[e.NOT_JOIN = 100] = "NOT_JOIN", e[e.NOT_LOGIN = 105] = "NOT_LOGIN", e[e.SERVER_PARAMS_NOTSET = 106] = "SERVER_PARAMS_NOTSET", e[e.UNKNOWN = 1e3] = "UNKNOWN", e))(USER_MESSAGE_SEND_RESULT || {});
var USER_MESSAGE_SEND_RESULT_EXPLAIN = { 0: [0, "success"], 1: [ErrorCode.USER_MESSAGE_TIMEOUT, "timeout, failed to send."], 2: [ErrorCode.USER_MESSAGE_BROKEN, "dataChannel broken, failed to send."], 3: [ErrorCode.USER_MESSAGE_NO_RECEIVER, "cannot find the receiver."], 4: [ErrorCode.USER_MESSAGE_NO_RECEIVER, "cannot find relay path."], 5: [ErrorCode.USER_MESSAGE_EXCEED_QPS, "cannot find relay path."], 17: [ErrorCode.USER_MESSAGE_SEND_TO_SERVER_ERROR, "failed to send to business server."], 18: [ErrorCode.USER_MESSAGE_SERVER_RESPONSE_ERROR, "business server response error."], 100: [ErrorCode.USER_MESSAGE_NOT_JOIN, "not join room"], 105: [ErrorCode.USER_MESSAGE_NOT_LOGIN, "not login."], 106: [ErrorCode.USER_MESSAGE_SERVER_PARAMS_NOTSET, "server param is not set."], 1e3: [ErrorCode.USER_MESSAGE_UNKNOWN, "unknown."] };
var _excluded$4 = ["msg"];
var noPrintSignaling = [];
var noAckSignaling = [SignalEvent.ENGINE_CONTROL_MESSAGE];
var SIGNALING_FUNCTION_TYPE = ((e) => (e[e.C2S = 0] = "C2S", e[e.C2C = 1] = "C2C", e[e.C2GW = 2] = "C2GW", e[e.C2CDirect = 3] = "C2CDirect", e[e.C2RTM = 4] = "C2RTM", e))(SIGNALING_FUNCTION_TYPE || {});
var DataChannelSignaling = class extends eventemitter3Exports.EventEmitter {
  constructor(e, t, i) {
    super(), _defineProperty(this, "_singlingCache", /* @__PURE__ */ new Map()), _defineProperty(this, "_p2pCache", /* @__PURE__ */ new Map()), _defineProperty(this, "_rttIds", {}), _defineProperty(this, "_p2pMessageId", new MessageId()), _defineProperty(this, "_clearDataChannelListener", void 0), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "logger", void 0), this.id = e, this._dataChannel = t, this.connectionIds = i, this._clearDataChannelListener = this._handleHandler(), this._monitor = getMonitor(e), this.logger = new Logger$1("DataChannelSignaling", 3, e);
  }
  destroy() {
    this._clearDataChannelListener(), delete this._dataChannel, this._singlingCache.forEach((e, t) => {
      e.error(new SDKError(ErrorCode.OPERATION_CANCEL, "disconnect")), this._singlingCache.delete(t);
    }), this._singlingCache.clear(), this._p2pCache.clear(), this._rttIds = {};
  }
  sendSignaling(e, t, i) {
    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 6e4;
    return new Promise((o, n) => {
      var s;
      const a = this._genHeader(i);
      a.id = createRandomId();
      const d = a.id.join("-"), c2 = _objectSpread2({ error_code: 0, message: JSON.stringify(t), signaling_event: "call-".concat(e), signaling_type: "Send", stream_id: t.streamId, stream_user_id: t.streamUserId, direction: "up", event_session_id: d }, this.connectionIds);
      null === (s = this._monitor) || void 0 === s || s.report("rtc_signaling", c2);
      const l = "customMessage" === e;
      l && RTSMsgReportor.samplingOne2ManyMsg(this.id, Number(a.id.join("")), t);
      const u = setTimeout(() => {
        this._singlingCache.delete(d), n(new SDKError(ErrorCode.TIME_OUT, "".concat(e, " message time out"))), l && RTSMsgReportor.updateOne2ManyMsgAck(this.id, t, 999);
      }, r);
      this._singlingCache.set(d, { start: getServerNow(), signalingType: e, success: (e2) => {
        clearTimeout(u), o(e2), l && RTSMsgReportor.updateOne2ManyMsgAck(this.id, t, 0);
      }, error: (e2) => {
        clearTimeout(u), n(e2), l && RTSMsgReportor.updateOne2ManyMsgAck(this.id, t, e2.code);
      }, id: d }), this.logger.info("Signal", ">>>>>> [".concat(e, "{").concat(a.functionType, "}][").concat(d, "]"), t), this._sendMessage(e, a, t);
    });
  }
  sendPingSignaling() {
    return this.sendSignaling("CheckConnectivity", { ts: Date.now() }, { functionType: 2 });
  }
  async sendP2PMessage(e, t) {
    let { msg: i } = e, r = _objectWithoutProperties(e, _excluded$4);
    const o = i instanceof ArrayBuffer;
    return this._sendP2PMessage(RTSMsgReportor.samplingP2PMsg(this.id, _objectSpread2(_objectSpread2({ ver: 1, id: this._p2pMessageId.getMessageId(), time: Date.now(), dir: DC_MESSAGE_DIRECTION.SEND, type: DC_MESSAGE_FUNCTION_TYPE.P2P, err: USER_MESSAGE_SEND_RESULT.SUCCESS }, r), {}, { binary: o, msg: o ? await Utils.ab2b64str(i) : i })), t);
  }
  _sendP2PMessage(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const i = this._genHeader(_objectSpread2(_objectSpread2({ needAck: true, functionType: 1 }, t), {}, { id: createRandomId() }));
    return isRttMessage(e.msg) ? this._rttIds[e.id] = e.id : e.dir === DC_MESSAGE_DIRECTION.SEND && this.logger.info("_sendP2PMessage [DC Signaling p2p{".concat(i.functionType, "} >>]"), JSON.stringify(e)), new Promise((t2, r) => {
      if (e.dir === DC_MESSAGE_DIRECTION.SEND) {
        const i2 = setTimeout(() => {
          this._p2pCache.delete(e.id), r(new SDKError(ErrorCode.USER_MESSAGE_TIMEOUT, "P2P message timeout")), RTSMsgReportor.updateP2PMsgAck(this.id, e, 999);
        }, 12e3);
        this._p2pCache.set(e.id, { success: (r2, o) => {
          clearTimeout(i2), t2(o), RTSMsgReportor.updateP2PMsgAck(this.id, e, 0);
        }, error: (t3) => {
          clearTimeout(i2), RTSMsgReportor.updateP2PMsgAck(this.id, e, t3.err);
          const [o, n] = USER_MESSAGE_SEND_RESULT_EXPLAIN[t3.err] || [ErrorCode.USER_MESSAGE_UNKNOWN, "err: ".concat(t3.err, ", msg: ").concat(t3.msg)];
          r({ err: t3.err, code: o, message: t3.msg || n });
        } });
      }
      try {
        this._sendMessage("p2p", i, e);
      } catch (e2) {
        throw e2.code === ErrorCode.NOT_CONNECTED_YET && (e2.code = ErrorCode.USER_MESSAGE_BROKEN), e2;
      }
    });
  }
  _sendMessage(e, t, i) {
    if (!this._dataChannel || "open" !== this._dataChannel.readyState) throw new SDKError(ErrorCode.NOT_CONNECTED_YET, "DataChannel not open");
    const r = getParameter("SIGNAL_COMPRESSION") || t.zip, o = t.version + (Number(r) << 4) + (Number(t.encrypt) << 5), n = Number(t.needAck) + (Number(t.direction) << 1) + (Number(t.functionType) << 2) + (Number(t.binary) << 6), s = Utils.str2ab(JSON.stringify([e, i])), a = concatenate(Uint8Array, [o, n, ...t.id || []], r || t.zip ? pako$1.deflate(new Uint8Array(s)) : new Uint8Array(s));
    try {
      this._dataChannel.send(a.buffer);
    } catch (e2) {
      var d;
      throw null === (d = this._monitor) || void 0 === d || d.report("rtc_error", { message: "datachannel send error: ".concat(e2.message), error_code: RtcErrorCode.DC_SEND_ERROR }), e2;
    }
    "p2p" === e ? RTSMsgReportor.updateP2PMsgReq(this.id, i, a.buffer.byteLength) : "customMessage" === e && RTSMsgReportor.updateOne2ManyMsgReq(this.id, i, a.buffer.byteLength);
  }
  _dispartData(e) {
    const t = new Uint8Array(e);
    let i = 0;
    const r = t[i++], o = t[i++], n = { version: 15 & r, zip: !(16 & ~r), encrypt: !(32 & ~r), needAck: !(1 & ~o), direction: (2 & o) >> 1, functionType: (60 & o) >> 2, binary: !(64 & ~o) };
    if (n.needAck || 1 === n.direction) {
      for (; i <= 6; i++) if (!isByteId(t[i])) {
        i++;
        break;
      }
      n.id = Array.from(t.slice(2, i));
    }
    return { header: n, data: t.slice(i) };
  }
  _feedbackSignaling(e, t, i) {
    const r = this._genHeader({ needAck: true, direction: 1, id: e.split("-").map((e2) => Number(e2)) });
    noPrintSignaling.includes(t) || this.logger.info("Signal", ">>>>>> [".concat(t, "-res][").concat(e, "]")), this._sendMessage("".concat(t, "-res"), r, i);
  }
  async _handleMessage(e) {
    const t = Date.now(), { byteLength: i } = e, r = this._dispartData(e);
    let { data: o } = r;
    const { header: n } = r;
    if (n.zip) {
      const e2 = new pako$1.Inflate();
      e2.push(o, true), o = e2.result;
    }
    const s = Utils.ab2str(o);
    let a = [];
    try {
      a = JSON.parse(s);
    } catch (e2) {
      var d;
      if (e2 instanceof Error) null === (d = this._monitor) || void 0 === d || d.report("rtc_signaling_msg_error", _objectSpread2({ error_code: -1, message: e2.message, reason: "message parse failed" }, this.connectionIds));
      return;
    }
    switch (n.functionType) {
      case 0:
      case 4:
        this.C2S(n, a, s, i, t);
        break;
      case 1:
        this.C2C(a, i, t);
        break;
      case 2:
        this.C2GW(n, a, s);
    }
  }
  async C2S(e, t, i, r, o) {
    var n;
    const s = (null === (n = e.id) || void 0 === n ? void 0 : n.join("-")) || "";
    if (1 === e.direction) this._handleAckMessage(s, t[0] || {}, i, e.functionType);
    else if (Array.isArray(t)) {
      var a;
      const n2 = t[0];
      t = t[1], noPrintSignaling.includes(n2) || this.logger.info("Signal", "<<<<<< ".concat(n2, "{").concat(e.functionType, "}"), t, s), noAckSignaling.includes(n2) || this._feedbackSignaling(s, n2, n2 === SignalEvent.ON_CUSTOM_MESSAGE ? _objectSpread2(_objectSpread2({}, t), {}, { message: "" }) : ""), t.binary && "string" == typeof t.message && (t.message = await Utils.b64str2ab(t.message, this._monitor));
      const d = Date.now();
      this.emit(n2, _objectSpread2({}, t)), n2 === SignalEvent.ON_CUSTOM_MESSAGE && RTSMsgReportor.reportOne2ManyMsgRecv(this.id, t, { msg_size: r, recv_msg_ts: o, fwd_msg_ts: d }), null === (a = this._monitor) || void 0 === a || a.report("rtc_signaling", _objectSpread2({ error_code: 0, message: i, signaling_event: "on-".concat(n2), signaling_type: "Recv", stream_id: t.streamId, stream_user_id: t.clientId, direction: "down" }, this.connectionIds));
    }
  }
  async C2C(e, t, i) {
    var r, o, n, s;
    Array.isArray(e) && (e = e[1]);
    const a = null === (r = e) || void 0 === r ? void 0 : r.id;
    switch (this._rttIds[a] || (null === (o = e) || void 0 === o ? void 0 : o.dir) === DC_MESSAGE_DIRECTION.FEEDBACK || isRttMessage(null === (n = e) || void 0 === n ? void 0 : n.msg) ? delete this._rttIds[a] : this.logger.info("Signal", "<<<<<< p2p response", e), e.dir) {
      case DC_MESSAGE_DIRECTION.SEND:
        const r2 = Date.now();
        if (!isRttMessage(null === (s = e) || void 0 === s ? void 0 : s.msg)) {
          const { binary: t2, msg: i2, room: r3, to: o2, from: n2 } = e, s2 = "" === r3 ? t2 ? SignalEvent.USER_BINARY_MESSAGE_RECEIVED_OUTSIDE_ROOM : SignalEvent.USER_MESSAGE_RECEIVED_OUTSIDE_ROOM : t2 ? SignalEvent.USER_BINARY_MESSAGE_RECEIVED : SignalEvent.USER_MESSAGE_RECEIVED;
          o2 ? this.emit(s2, _objectSpread2(_objectSpread2({}, e), {}, { msg: t2 ? await Utils.b64str2ab(i2, this._monitor) : i2 })) : this.emit(SignalEvent.ON_CUSTOM_MESSAGE, { clientId: n2, binary: t2, message: t2 ? await Utils.b64str2ab(i2, this._monitor) : i2 });
        }
        this._sendP2PMessage(_objectSpread2(_objectSpread2({}, e), {}, { dir: DC_MESSAGE_DIRECTION.FEEDBACK, msg: "" })), RTSMsgReportor.reportP2PMsgRecv(this.id, e, { msg_size: t, recv_msg_ts: i, fwd_msg_ts: r2 });
        break;
      case DC_MESSAGE_DIRECTION.FEEDBACK:
        this._handleP2PMsgFeedback(e);
    }
  }
  C2GW(e, t, i) {
    if (1 === e.direction) {
      var r;
      const o2 = (null === (r = e.id) || void 0 === r ? void 0 : r.join("-")) || "";
      this._handleAckMessage(o2, t[0] || {}, i, e.functionType);
    } else {
      const [r2, n = {}] = t;
      if ("RXMediaMsg" === r2) {
        var o;
        const { type: e2, data: t2 } = n;
        switch (null === (o = this._monitor) || void 0 === o || o.report("rtc_signaling", _objectSpread2({ error_code: 0, message: i, signaling_event: "on-".concat(e2), signaling_type: "Recv", stream_id: "", stream_user_id: "", direction: "down" }, this.connectionIds)), e2) {
          case "RSCP":
            try {
              const i2 = JSON.parse(t2);
              Array.isArray(i2) && this.emit(e2, i2);
            } catch (e3) {
            }
            break;
          case "RTT":
            try {
              const i2 = JSON.parse(t2);
              i2.length && this.emit(e2, i2[0]);
            } catch (e3) {
            }
            break;
          case "SSC":
            try {
              const i2 = JSON.parse(t2);
              i2.length && (this.logger.info("Signal", "<<<<<< ".concat(e2), i2), this.emit(e2, i2[0]));
            } catch (e3) {
            }
        }
      } else "engineControlMessage" === r2 && this.C2S(e, t, i, 0, 0);
    }
  }
  _handleHandler() {
    const e = (e2) => {
      this.logger.warn("_handleHandler", "dataChannel close", e2);
    }, t = (e2) => {
      this.logger.error("_handleHandler", "dataChannel error", e2);
    }, i = (e2) => {
      this._handleMessage(e2.data);
    };
    return this._dataChannel.addEventListener("close", e), this._dataChannel.addEventListener("error", t), this._dataChannel.addEventListener("message", i), () => {
      const r = this._dataChannel;
      null == r || r.removeEventListener("close", e), null == r || r.removeEventListener("error", t), null == r || r.removeEventListener("message", i);
    };
  }
  _genHeader() {
    return _objectSpread2({ version: 2, zip: false, encrypt: false, needAck: true, direction: 0, functionType: 0, binary: false }, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {});
  }
  _handleAckMessage(e, t, i, r) {
    var o;
    const n = this._singlingCache.get(e);
    n && (this._singlingCache.delete(e), 200 === t.code ? n.success(t) : n.error(t), this.logger.info("Signal", "<<<<<< [".concat(n.signalingType, "{").concat(r, "}-ack] ").concat(e), t));
    const s = _objectSpread2({ error_code: 0, message: i, signaling_event: null == n ? void 0 : n.signalingType, signaling_type: "Ack", stream_id: "", stream_user_id: "", direction: "down", elapse: n ? getServerNow() - n.start : 0 }, this.connectionIds);
    null != n && n.id && (s.event_session_id = n.id), null === (o = this._monitor) || void 0 === o || o.report("rtc_signaling", s);
  }
  _handleP2PMsgFeedback(e) {
    const t = this._p2pCache.get(e.id);
    t && (this._p2pCache.delete(e.id), e.err === USER_MESSAGE_SEND_RESULT.SUCCESS ? t.success(e.id, e) : t.error(e));
  }
};
var RoomContext = class {
  constructor(e, t) {
    _defineProperty(this, "roomId", void 0), _defineProperty(this, "userInfo", void 0), _defineProperty(this, "userId", void 0), _defineProperty(this, "sessionId", genUuid$1()), _defineProperty(this, "token", void 0), _defineProperty(this, "rtcVid", void 0), _defineProperty(this, "joinPromise", void 0), _defineProperty(this, "startJoinTimestamp", void 0), _defineProperty(this, "_liveControlMessage", void 0), _defineProperty(this, "_userStreamMap", /* @__PURE__ */ new Map()), _defineProperty(this, "_roomConfig", { isAutoPublish: true, isAutoSubscribeAudio: true, isAutoSubscribeVideo: true, roomProfileType: RoomProfileType.communication }), _defineProperty(this, "_vendorConfig", { enableMultiVendor: false, vendorCode: 0 }), _defineProperty(this, "_roomAttr", { multiChatMode: false, bigRoomMode: false }), _defineProperty(this, "_tokenPublishPrivilegeExpired", false), _defineProperty(this, "_tokenSubscribePrivilegeExpired", false), _defineProperty(this, "_streamQueueMap", /* @__PURE__ */ new Map()), _defineProperty(this, "_monitor", void 0), this._ctx = t, this.roomId = e.roomId, this.userInfo = e.userInfo, this.userId = e.userInfo.userId, this.token = e.token, this._monitor = getMonitor(t.id);
  }
  async checkJoinRoom() {
    await this.joinPromise;
  }
  get vendorConfig() {
    return this._vendorConfig;
  }
  setVendorConfig(e) {
    this._vendorConfig = e;
  }
  updateRoomAttributes(e) {
    this._roomAttr = _objectSpread2(_objectSpread2({}, this._roomAttr), e);
  }
  setLiveControlMessage(e) {
    this._liveControlMessage = e;
  }
  getLiveControlMessage() {
    return this._liveControlMessage;
  }
  isMultiChatMode() {
    return this._roomAttr.multiChatMode;
  }
  updateRoomConfig(e) {
    return this._roomConfig = assignIn(this._roomConfig, e), this._roomConfig;
  }
  get isAutoPublish() {
    return !this.isRTSOnlyRoom() && this._roomConfig.isAutoPublish;
  }
  get isAutoSubscribeAudio() {
    return !this.isRTSOnlyRoom() && this._roomConfig.isAutoSubscribeAudio;
  }
  get isAutoSubscribeVideo() {
    return !this.isRTSOnlyRoom() && this._roomConfig.isAutoSubscribeVideo;
  }
  get remoteVideoConfig() {
    return this._roomConfig.remoteVideoConfig;
  }
  get roomProfileType() {
    return this._roomConfig.roomProfileType || RoomProfileType.communication;
  }
  isRTSOnlyRoom() {
    return this._roomConfig.roomMode === RoomMode.ROOM_MODE_RTS_ONLY;
  }
  get rtsOnlySignalHeader() {
    return this.isRTSOnlyRoom() ? { functionType: SIGNALING_FUNCTION_TYPE.C2RTM } : void 0;
  }
  updateUserPubInfo(e) {
    const t = this._userStreamMap.get(e.clientId) || {};
    e.screen ? (t.screenAudio = e.attributes.audiostream, t.screenVideo = e.attributes.videostream) : (t.audio = e.attributes.audiostream, t.video = e.attributes.videostream), this._userStreamMap.set(e.clientId, t);
  }
  getUserPubInfo(e) {
    return _objectSpread2({ audio: false, video: false, screenAudio: false, screenVideo: false }, this._userStreamMap.get(e) || {});
  }
  resetUserPubInfo() {
    this._userStreamMap.clear();
  }
  get tokenPublishPrivilegeExpired() {
    return this._tokenPublishPrivilegeExpired;
  }
  get tokenSubscribePrivilegeExpired() {
    return this._tokenSubscribePrivilegeExpired;
  }
  setTokenPublishPrivilegeExpired(e) {
    this._tokenPublishPrivilegeExpired = e;
  }
  setTokenSubscribePrivilegeExpired(e) {
    this._tokenSubscribePrivilegeExpired = e;
  }
  getStayRoomDuration() {
    return this.startJoinTimestamp ? getServerNow() - this.startJoinTimestamp : 0;
  }
  getStreamQueueLock(e) {
    let t = this._streamQueueMap.get(e);
    return t || (t = new PromiseLock2(e), this._streamQueueMap.set(e, t)), t;
  }
  report(e, t, i) {
    var r;
    null === (r = this._monitor) || void 0 === r || r.report(e, _objectSpread2({ room_id: this.roomId, user_id: this.userId, rtc_session_id: this.sessionId, rtc_vid: this.rtcVid }, t), i);
  }
};
var logRemoteStream = (e, t, i) => {
  i.info(e, "userId: %o, subAudio: %o, subVideo: %o, audioMid: %o, videoMid: %o, sequenceId: %o", t.userId, t.subAudio, t.subVideo, t.audioMid, t.videoMid, t.sequenceId);
};
function checkRoomState(e, t, i) {
  const r = i.value;
  return i.value = async function() {
    if (!this._ctx.signalingManager.isConnected()) throw new SDKError(ErrorCode.NOT_CONNECTED_YET, "error in ".concat(t, ": try again after connect"));
    try {
      await (this._roomConf || this.config).checkJoinRoom();
    } catch (e3) {
      throw new SDKError(ErrorCode.JOIN_ROOM_FAILED, "error in ".concat(t, ": try again after joined"));
    }
    for (var e2 = arguments.length, i2 = new Array(e2), o = 0; o < e2; o++) i2[o] = arguments[o];
    return r.apply(this, i2);
  }, i;
}
function streamQueue(e, t, i) {
  const r = i.value;
  return i.value = async function() {
    const e2 = this._roomConf, i2 = this._logger;
    for (var o = arguments.length, n = new Array(o), s = 0; s < o; s++) n[s] = arguments[s];
    const a = getStreamIdentification(n[0]);
    if (!a) return null == r ? void 0 : r.apply(this, n);
    i2.info("streamQueue", "lock stream %o, task %o", a.slice(-5), t);
    const d = await e2.getStreamQueueLock(a).lock();
    try {
      return await (null == r ? void 0 : r.apply(this, n));
    } finally {
      i2.info("streamQueue", "unlock stream %o, task %o", a.slice(-5), t), d();
    }
  }, i;
}
function getStreamIdentification(e) {
  return e instanceof LocalStream ? e.id : null == e ? void 0 : e.streamId;
}
var __defProp$9 = Object.defineProperty;
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __decorateClass$9 = (e, t, i, r) => {
  for (var o, n = r > 1 ? void 0 : r ? __getOwnPropDesc$9(t, i) : t, s = e.length - 1; s >= 0; s--) (o = e[s]) && (n = (r ? o(t, i, n) : o(n)) || n);
  return r && n && __defProp$9(t, i, n), n;
};
var ForwardStreamManager = class extends EnhancedEventEmitter {
  constructor(e, t) {
    super(), _defineProperty(this, "_forwardDstRooms", /* @__PURE__ */ new Map()), _defineProperty(this, "forwardStreamState", "stopped"), this._ctx = e, this._roomConf = t;
  }
  async startForwardStream2Rooms(e) {
    if ("running" === this.forwardStreamState || "paused" === this.forwardStreamState) throw new SDKError(ErrorCode.UNEXPECTED_INVOKE_FORWARD_STREAM, "should not invoke startForwardStreamToRooms in state: ".concat(this.forwardStreamState));
    const t = await this._sendForwardStreamSignaling("start", this._roomConf.roomId, e);
    this._updateDstRooms(e, t);
    const i = this._transformForwardStreamResult(t);
    return this.forwardStreamState = "running", i;
  }
  async updateForwardStream2Rooms(e) {
    if ("stopped" === this.forwardStreamState) throw new SDKError(ErrorCode.UNEXPECTED_INVOKE_FORWARD_STREAM, "should not invoke updateForwardStreamToRooms in state: ".concat(this.forwardStreamState));
    let t = this._mockForwardStreamResult(e);
    "running" === this.forwardStreamState && (t = await this._sendForwardStreamSignaling("update", this._roomConf.roomId, e)), this._updateDstRooms(e, t);
    return this._transformForwardStreamResult(t);
  }
  async stopForwardStream2Rooms() {
    if ("stopped" === this.forwardStreamState) throw new SDKError(ErrorCode.UNEXPECTED_INVOKE_FORWARD_STREAM, "should not invoke stopForwardStreamToRooms in state: ".concat(this.forwardStreamState));
    let e = this._mockForwardStreamResult([]);
    if ("running" === this.forwardStreamState && (e = await this._sendForwardStreamSignaling("stop", this._roomConf.roomId)), this._updateDstRooms([], e), [...this._forwardDstRooms.keys()].length > 0) throw new SDKError(ErrorCode.UNEXPECTED_ERROR, "stopforwardstream failed: ".concat(JSON.stringify(e)));
    const t = this._transformForwardStreamResult(e);
    return this.forwardStreamState = "stopped", t;
  }
  async pauseForwardStream2AllRooms() {
    if ("paused" === this.forwardStreamState || "stopped" === this.forwardStreamState) throw new SDKError(ErrorCode.UNEXPECTED_INVOKE_FORWARD_STREAM, "should not invoke pauseForwardStreamToAllRooms in state: ".concat(this.forwardStreamState));
    const e = await this._sendForwardStreamSignaling("stop", this._roomConf.roomId), t = this._transformForwardStreamResult(e);
    return this.forwardStreamState = "paused", t;
  }
  async resumeForwardStream2AllRooms() {
    if (!(arguments.length > 0 && void 0 !== arguments[0] && arguments[0]) && ["running", "stopped"].includes(this.forwardStreamState)) throw new SDKError(ErrorCode.UNEXPECTED_INVOKE_FORWARD_STREAM, "should not invoke resumeForwardStreamToAllRooms in state: ".concat(this.forwardStreamState));
    const e = this._getDstRooms(), t = await this._sendForwardStreamSignaling("start", this._roomConf.roomId, e);
    this._updateDstRooms(e, t);
    const i = this._transformForwardStreamResult(t);
    return this.forwardStreamState = "running", i;
  }
  resumeFromReconnect() {
    "running" === this.forwardStreamState && this.resumeForwardStream2AllRooms(true).then((e) => {
      e.forEach((e2) => {
        e2.state === ForwardStreamState.FORWARD_STREAM_STATE_FAILURE && this.safeEmit(RoomEvent.ON_FORWARD_STREAM_ERROR, e2);
      });
    });
  }
  onForwardDstRoomUserKick(e) {
    const t = [{ dstRoomId: e.dstRoomId, code: 200, forwardStreamType: "stop" }];
    this._updateDstRooms([], t), this.safeEmit(RoomEvent.ON_FORWARD_STREAM_ERROR, { roomId: e.dstRoomId, state: ForwardStreamState.FORWARD_STREAM_STATE_FAILURE, error: ForwardStreamError.FORWARD_STREAM_ERROR_REMOTE_KICKED });
  }
  destoy() {
    super.removeAllListeners(), this._forwardDstRooms.clear(), this.forwardStreamState = "stopped";
  }
  _mockForwardStreamResult(e) {
    const t = [];
    return this._forwardDstRooms.forEach((e2, i) => {
      t.push({ dstRoomId: i, forwardStreamType: "stop", code: 200 });
    }), e.forEach((e2) => {
      const i = t.findIndex((t2) => t2.dstRoomId === e2.roomId);
      -1 === i ? t.push({ dstRoomId: e2.roomId, forwardStreamType: "start", code: e2.roomId === this._roomConf.roomId ? 400 : 200 }) : t[i].forwardStreamType = "update";
    }), t;
  }
  _transformForwardStreamResult(e) {
    e || (e = []);
    const t = [];
    for (const { dstRoomId: i, code: r } of e) {
      const e2 = { roomId: i, state: ForwardStreamState.FORWARD_STREAM_STATE_SUCCESS, error: ForwardStreamError.FORWARD_STREAM_ERROR_OK };
      200 === r || (400 === r ? (e2.state = ForwardStreamState.FORWARD_STREAM_STATE_FAILURE, e2.error = ForwardStreamError.FORWARD_STREAM_ERROR_REMOTE_KICKED) : r >= 700 && r < 800 ? (e2.state = ForwardStreamState.FORWARD_STREAM_STATE_FAILURE, e2.error = ForwardStreamError.FORWARD_STREAM_ERROR_INVALID_TOKEN) : (e2.state = ForwardStreamState.FORWARD_STREAM_STATE_FAILURE, e2.error = ForwardStreamError.FORWARD_STREAM_ERROR_RESPONSE)), t.push(e2);
    }
    return t;
  }
  _updateDstRooms(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    0 === t.length && this._forwardDstRooms.clear(), t.forEach((t2) => {
      let { dstRoomId: i, code: r, forwardStreamType: o } = t2;
      if (200 === r) if ("stop" === o) this._forwardDstRooms.delete(i);
      else {
        var n;
        const t3 = e.find((e2) => e2.roomId === i);
        if (!t3 && !this._forwardDstRooms.has(i)) throw new SDKError(ErrorCode.UNEXPECTED_ERROR, "unknow roomid ".concat(i, " in signaling return"));
        let r2 = null !== (n = this._forwardDstRooms.get(i)) && void 0 !== n ? n : { token: void 0 };
        r2 = Object.assign(r2, t3), this._forwardDstRooms.set(i, r2);
      }
      else this._forwardDstRooms.has(i) && this._forwardDstRooms.delete(i);
    });
  }
  _getDstRooms() {
    const e = [];
    return this._forwardDstRooms.forEach((t, i) => {
      e.push({ roomId: i, token: t.token });
    }), e;
  }
  async _sendForwardStreamSignaling(e, t, i) {
    const r = "".concat(genEventSessionId());
    if ("stop" !== e) {
      const e2 = i.map((e3) => e3.roomId);
      this._roomConf.report("rtc_forward_stream", { type: "begin", dst_rooms: "{ ".concat(e2.map((e3) => '"'.concat(e3, '"')).join(","), " }"), event_session_id: r });
    }
    const o = { forwardStreamType: e, roomId: t };
    ("start" === e || "update" === e) && (o.dstRoomInfos = null == i ? void 0 : i.map((e2) => ({ dstRoomId: e2.roomId, dstToken: Utils.token2auth(this._ctx.appId, e2.roomId, this._roomConf.userId, e2.token) })));
    const n = await this._ctx.signalingManager.sendSignaling("forwardStream", o), s = [];
    if (200 !== (null == n ? void 0 : n.code)) throw "stop" !== e && (null == i || i.forEach((e2) => {
      s.push({ dst_room_id: e2.roomId, result: "server error ".concat(null == n ? void 0 : n.code) });
    }), this._roomConf.report("rtc_forward_stream", { type: "end", dst_rooms: JSON.stringify(s), event_session_id: r })), new SDKError(ErrorCode.UNEXPECTED_ERROR, "server side internal error, error code: ".concat(n));
    var a, d;
    "stop" !== e && (null === (a = n.forwardStreamResults) || void 0 === a || a.forEach((e2) => {
      s.push({ dst_room_id: e2.dstRoomId, result: "dst room lost" });
    }), null === (d = n.forwardStreamResults) || void 0 === d || d.forEach((e2) => {
      const t2 = s.find((t3) => t3.dst_room_id === e2.dstRoomId);
      t2 && (200 === e2.code ? "update" === e2.forwardStreamType ? t2.result = "update" : t2.result = "success" : t2.result = "server error ".concat(e2.code));
    }), this._roomConf.report("rtc_forward_stream", { type: "end", dst_rooms: JSON.stringify(s), event_session_id: r }));
    return n.forwardStreamResults;
  }
};
__decorateClass$9([checkRoomState], ForwardStreamManager.prototype, "startForwardStream2Rooms", 1), __decorateClass$9([checkRoomState], ForwardStreamManager.prototype, "updateForwardStream2Rooms", 1), __decorateClass$9([checkRoomState], ForwardStreamManager.prototype, "stopForwardStream2Rooms", 1), __decorateClass$9([checkRoomState], ForwardStreamManager.prototype, "pauseForwardStream2AllRooms", 1), __decorateClass$9([checkRoomState], ForwardStreamManager.prototype, "resumeForwardStream2AllRooms", 1);
var simulcastFormats = [{ maxLayers: 3, totalPixels: 2073600 }, { maxLayers: 3, totalPixels: 921600 }, { maxLayers: 3, totalPixels: 518400 }, { maxLayers: 2, totalPixels: 230400 }, { maxLayers: 2, totalPixels: 129600 }, { maxLayers: 1, totalPixels: 57600 }, { maxLayers: 1, totalPixels: 0 }];
var getSimulcastLayers = (e, t) => {
  const i = simulcastFormats.findIndex((i2) => e * t >= i2.totalPixels), r = e * t;
  if (0 === i) return simulcastFormats[i].maxLayers;
  const o = simulcastFormats[i - 1].totalPixels;
  return (o - r) / (o - simulcastFormats[i].totalPixels) < 0.1 ? simulcastFormats[i - 1].maxLayers : simulcastFormats[i].maxLayers;
};
function calculateKbps(e, t, i) {
  var r;
  const o = e ? null === (r = i.find((t2) => t2.rid === e)) || void 0 === r ? void 0 : r.maxkbps : i[0].maxkbps;
  return Math.min(null != o ? o : Number.POSITIVE_INFINITY, t);
}
var getSubLayerByVideoConfig = (e, t) => {
  var i, r, o, n;
  let s = 0, a = -1;
  const { videoDescriptions: d, subVideoDescriptions: c2 } = (null == t ? void 0 : t.attributes) || {}, l = Array.isArray(c2) ? c2 : d;
  let u = -1;
  const h = e.width * e.height;
  for (let e2 = 0; e2 < (null == l ? void 0 : l.length); e2++) {
    var _, p;
    if (h >= (null === (_ = l[e2]) || void 0 === _ ? void 0 : _.width) * (null === (p = l[e2]) || void 0 === p ? void 0 : p.height)) {
      u = e2;
      break;
    }
  }
  let m = l[0];
  if (-1 === u) u = l.length - 1, m = l[u];
  else if (0 !== u) {
    const e2 = l[u - 1].width * l[u - 1].height, t2 = (e2 - h) / (e2 - l[u].width * l[u].height);
    m = t2 < 0.1 ? l[u - 1] : l[u], u = t2 < 0.1 ? u - 1 : u;
  }
  return a = null !== (i = null === (r = m) || void 0 === r ? void 0 : r.sub_index) && void 0 !== i ? i : -1, s = null !== (o = null === (n = m) || void 0 === n ? void 0 : n.video_index) && void 0 !== o ? o : u, { spatialLayer: s, spatialSubLayer: a };
};
var videoCaptureConf2EncodeConf = (e) => ({ width: constraints2number(e.width), height: constraints2number(e.height), frameRate: constraints2number(e.frameRate), maxKbps: e.maxKbps });
var getResolution = (e) => {
  let { width: t, height: i } = e;
  return constraints2number(t) * constraints2number(i);
};
var checkVideoConfigQuotient = (e, t) => {
  const i = constraints2number(e.width) / constraints2number(t.width) || 1, r = constraints2number(e.height) / constraints2number(t.height) || 1;
  Math.floor(i) === i && Math.floor(r) === r || warnDevelopers("setLocalSimulcastMode: The resolution setting needs to be an integer multiple");
};
var AudioProfileManager = class {
  constructor(e) {
    _defineProperty(this, "_roomId", void 0), _defineProperty(this, "_constraints", {}), _defineProperty(this, "_profile", void 0), _defineProperty(this, "_customMaxBitrate", 0), this._appId = e;
  }
  setRoomId(e) {
    this._roomId = e;
  }
  setAudioProfile(e) {
    this._profile = e, this._customMaxBitrate = 0;
  }
  get customMaxBitrate() {
    return this._customMaxBitrate;
  }
  setCustomMaxBitrate(e) {
    const { audio_encode: t } = sdkCache.getEngineWebConfig(this._appId, this._roomId || "");
    this._customMaxBitrate = null != t && t.bitrate ? 0 : 1e3 * e;
  }
  getOpusConfigStr() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    const { audio_encode: t } = sdkCache.getEngineWebConfig(this._appId, this._roomId || ""), { sampleRate: i, channelCount: r } = this.getConstraints(), o = "number" == typeof i ? i : null == i ? void 0 : i.exact, n = "number" == typeof r ? r : null == r ? void 0 : r.exact, s = {};
    e.split(";").forEach((e2) => {
      const [t2, i2] = e2.split("=");
      t2 && i2 && (s[t2] = i2);
    });
    const a = (null == t ? void 0 : t.bitrate) || this._customMaxBitrate || this._getConfigByAudioProfile().bitrate;
    a && (s.maxaveragebitrate = a);
    const d = (null == t ? void 0 : t.enc_sample_rate) || o;
    d && (s["sprop-maxcapturerate"] = d);
    const c2 = (null == t ? void 0 : t.playback_rate) || o;
    return c2 && (s.maxplaybackrate = c2), (n && n > 1 || null != t && t.stereo) && (s["sprop-stereo"] = 1, s.stereo = 1), null != t && t.dtx && (s.usedtx = 1), Object.keys(s).map((e2) => "".concat(e2, "=").concat(s[e2])).join(";");
  }
  updateConstraints(e) {
    this._constraints = _objectSpread2(_objectSpread2({}, this._constraints), e);
  }
  getConstraints() {
    const e = _objectSpread2({}, this._constraints), { audio_capture: t } = sdkCache.getEngineWebConfig(this._appId, this._roomId || "");
    isUndefined(null == t ? void 0 : t.sample_rate) || (e.sampleRate = t.sample_rate), isUndefined(null == t ? void 0 : t.channel) || (e.channelCount = t.channel), isUndefined(null == t ? void 0 : t.agc) || (e.autoGainControl = t.agc), isUndefined(null == t ? void 0 : t.ans) || (e.noiseSuppression = t.ans), isUndefined(null == t ? void 0 : t.aec) || (e.echoCancellation = t.aec);
    const { sampleRate: i, channel: r } = this._getConfigByAudioProfile();
    return isUndefined(e.sampleRate) && !isUndefined(i) && (e.sampleRate = i), isUndefined(e.channelCount) && !isUndefined(r) && (e.channelCount = r), e;
  }
  _getConfigByAudioProfile() {
    const e = {};
    switch (this._profile) {
      case AudioProfileType.fluent:
        e.sampleRate = 16e3, e.bitrate = 24e3;
        break;
      case AudioProfileType.standard:
        e.sampleRate = 48e3, e.bitrate = 48e3;
        break;
      case AudioProfileType.hd:
        e.sampleRate = 48e3, e.bitrate = 128e3, e.channel = 2;
        break;
      case AudioProfileType.standardStereo:
        e.sampleRate = 48e3, e.bitrate = 8e4, e.channel = 2;
        break;
      case AudioProfileType.hdMono:
        e.sampleRate = 48e3, e.bitrate = 128e3;
    }
    return e;
  }
};
var defaultConfig = { start_interval: 100, multiplier: 2, max_interval: 3e4 };
var RetryLimiter = class {
  constructor() {
    _defineProperty(this, "_times", 0), _defineProperty(this, "_config", defaultConfig), _defineProperty(this, "initTs", getServerNow());
  }
  getRetryDelay() {
    return Math.min(this._config.max_interval, Math.pow(this._config.multiplier, this._times++) * this._config.start_interval);
  }
  setConfig(e) {
    this._config = e;
  }
  reset() {
    this._times = 0;
  }
};
var DecisionConfig = class {
  constructor(e) {
    _defineProperty(this, "_logger", void 0), _defineProperty(this, "_monitor", void 0), this._ctx = e;
    const t = sdkCache.getServerConfig(this._ctx.appId);
    this._logger = new Logger$1("DecisionConfig", 1, this._ctx.id), this._monitor = getMonitor(this._ctx.id), setTimeout(() => {
      this.updateConfig(t, true);
    }, 0);
  }
  updateConfig(e, t) {
    !t && sdkCache.setServerConfig(this._ctx.appId, e), e.rts_report && RTSMsgReportor.setConfig(e.rts_report), this._ctx.joinRoomConfig.setServerConfig(e.web_join_room), this._setRtsConfig(e.rts_config), this._setRtsQpsConfig(e.rts_qps), this._preConnect(e), this._getServerConfigExecutor(e, t);
  }
  _setRtsConfig(e) {
    null != e && e.rts_mode && e.rts_mode !== this._ctx.rtsMode && (this._logger.print("_setRtsConfig", "setRtsMode to %o", e.rts_mode), this._ctx.setRTSMode(e.rts_mode === RTS_MODE.NORMAL_MODE ? RTS_MODE.NORMAL_MODE : RTS_MODE.LIMIT_MODE));
  }
  _setRtsQpsConfig(e) {
    this._logger.print("_setRtsQpsConfig", JSON.stringify(e)), this._ctx.setRtsQpsConf(e), Object.keys(this._ctx.rtsLimiter).length > 0 && reportRtcInvokeStatus(this._ctx.id, "setRtsQpsConf", JSON.stringify(e));
  }
  _getServerConfigExecutor(e, t) {
    var i, r, o, n, s, a, d, c2, l, u, h;
    const { upload_console_length_cut: _, upload_report_limit: p } = (null == e ? void 0 : e.web_rtc_config) || {};
    if (CoreConfig.setParameter("UPLOAD_CONSOLE_ON", !(null == e || null === (i = e.web_rtc_config) || void 0 === i || !i.upload_console_on)), _ && CoreConfig.setParameter("UPLOAD_CONSOLE_LENGTH_CUT", _), p && CoreConfig.setParameter("UPLOAD_REPORT_LIMIT", p), CoreConfig.setParameter("ENABLE_REPORT_IDB_BUFFER", !(null == e || null === (r = e.web_rtc_config) || void 0 === r || !r.enable_report_idb_buffer)), false === (null == e || null === (o = e.web_rtc_config) || void 0 === o ? void 0 : o.sdk_codec_negotiation) && setParameter("SDK_CODEC_NEGOTIATION", false), void 0 !== (null == e || null === (n = e.web_rtc_config) || void 0 === n ? void 0 : n.ainr_enable_dump) && setParameter("AINR_ENABLE_DUMP", e.web_rtc_config.ainr_enable_dump), void 0 !== (null == e || null === (s = e.web_rtc_config) || void 0 === s ? void 0 : s.ainr_overload_threshold) && setParameter("AINR_OVERLOAD_THRESHOLD", e.web_rtc_config.ainr_overload_threshold), void 0 !== (null == e || null === (a = e.web_rtc_config) || void 0 === a ? void 0 : a.ainr_urls)) try {
      setParameter("AINR_URLS", JSON.parse(e.web_rtc_config.ainr_urls));
    } catch (e2) {
      this._logger.warn("_getServerConfigExecutor", "parse AINR_URLS error %o", e2);
    }
    var m, S;
    (void 0 !== (null == e || null === (d = e.web_rtc_config) || void 0 === d ? void 0 : d.ainr_cache_time) && setParameter("AINR_CACHE_TIME", e.web_rtc_config.ainr_cache_time), void 0 !== (null == e || null === (c2 = e.web_rtc_config) || void 0 === c2 ? void 0 : c2.ainr_dump_time) && setParameter("AINR_DUMP_TIME", e.web_rtc_config.ainr_dump_time), null != e && null !== (l = e.web_rtc_config) && void 0 !== l && l.web_pc_killswitch && (this._logger.print("web_pc_killswitch update: ", JSON.stringify(e.web_rtc_config.web_pc_killswitch)), this._ctx.pcKillSwitch = _objectSpread2(_objectSpread2({}, this._ctx.pcKillSwitch), e.web_rtc_config.web_pc_killswitch)), "boolean" == typeof (null == e || null === (u = e.web_rtc_config) || void 0 === u ? void 0 : u.fallback)) && (false === (null == e ? void 0 : e.web_rtc_config.fallback) ? this._ctx.enableFallbackHandler = false : Array.isArray(null == e || null === (m = e.web_rtc_config) || void 0 === m ? void 0 : m.fallback_ua_reg) ? this._ctx.enableFallbackHandler = null == e ? void 0 : e.web_rtc_config.fallback_ua_reg.every((e2) => "string" == typeof e2 && new RegExp(e2).test(navigator.userAgent)) : this._ctx.enableFallbackHandler = false);
    "boolean" == typeof (null == e || null === (h = e.web_rtc_config) || void 0 === h ? void 0 : h.standard) && (false === (null == e ? void 0 : e.web_rtc_config.standard) ? this._ctx.enableStandardHandler = false : Array.isArray(null == e || null === (S = e.web_rtc_config) || void 0 === S ? void 0 : S.standard_ua_reg) ? this._ctx.enableStandardHandler = null == e ? void 0 : e.web_rtc_config.standard_ua_reg.every((e2) => "string" == typeof e2 && new RegExp(e2).test(navigator.userAgent)) : this._ctx.enableStandardHandler = false);
  }
  _preConnect(e) {
    var t;
    let i = getParameter("PRE_ICE");
    var r;
    ("boolean" == typeof (null == e || null === (t = e.web_rtc_config) || void 0 === t ? void 0 : t.pre_ice) && (i = e.web_rtc_config.pre_ice), i) && (this._logger.print("preConnect", "start pre ice connection."), this._ctx.signalingManager.connect(), null === (r = this._monitor) || void 0 === r || r.set({ pre_connection: true }), this._ctx.isPreConnection = true);
  }
};
var IceConfigRequestManager = class {
  constructor(e) {
    _defineProperty(this, "_reconnectTimer", void 0), _defineProperty(this, "_retryFunc", void 0), _defineProperty(this, "_abortControllers", []), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "logger", void 0), _defineProperty(this, "_groupConfigId", genUuid()), _defineProperty(this, "_retryLimiter", new RetryLimiter()), _defineProperty(this, "_timer", void 0), _defineProperty(this, "_destroyed", false), _defineProperty(this, "_onlineListener", () => {
      this._reconnectTimer && this._retryFunc && (clearTimeout(this._reconnectTimer), this._retryFunc());
    }), _defineProperty(this, "_decisionConfig", void 0), this._ctx = e, this._monitor = getMonitor(e.id), this.logger = new Logger$1("ICERequest", 4, e.id), this._decisionConfig = new DecisionConfig(e), window.addEventListener("online", this._onlineListener);
  }
  async getICENode(e) {
    let t;
    this.logger.info("getICENode", "invoke");
    try {
      if (t = await this._getAccessWithRetry(e), 0 === t.length) throw new Error("server return empty nodes.");
    } catch (e2) {
      throw this._reportRtcInvokeStatus("es.join.getNodeFailed", e2), new SDKError(ErrorCode.ICE_SERVER_WRONG, "get ICE config failed: ".concat(e2.message), e2);
    }
    return this.logger.success("getICENode", "success"), this._reportRtcInvokeStatus("es.join.getNodeSuccess", t), t;
  }
  _getAccessWithRetry(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return 0 !== t && this.logger.info("_getAccessWithRetry()", "invoke feedbackInfo: %o, 201count: %o", e, t), new Promise((i, r) => {
      this._getAccessNode(e).then((e2) => {
        this._retryLimiter.reset(), i(e2);
      }).catch((o) => {
        if (this._destroyed) return;
        if (Array.isArray(o) && o.length > 0) {
          if (o.findIndex((e2) => 400 <= e2.code && e2.code < 500) > -1) return this._retryLimiter.reset(), r(new Error("HTTP request failed(4xx)"));
          if (o.every((e2) => {
            var t2;
            return 201 === e2.code || 201 === (null === (t2 = e2.error) || void 0 === t2 ? void 0 : t2.code);
          }) && t++, 3 === t) return this._retryLimiter.reset(), r(new Error("HTTP request failed(201)"));
        }
        const n = this._retryLimiter.getRetryDelay();
        this.logger.warn("_getAccessWithRetry()", "_getAccessWithRetry error, will retry after ".concat(n, "ms"), o), this._retryFunc = () => {
          this._getAccessWithRetry(e, t).then(i).catch(r);
        }, this._reconnectTimer = self.setTimeout(this._retryFunc, n);
      });
    });
  }
  async _getAccessNode(e) {
    return new Promise((t, i) => {
      const r = sdkCache.getAccessNode(this._ctx.appId);
      if (r) {
        const i2 = (Array.isArray(r) ? r : [r]).map((e2) => (e2.cache_status = true, e2));
        this.logger.info("getAccessNode", "use cache node."), t(i2), this._timer = setTimeout(() => {
          this._getAccessNodeFromServer(e).catch(() => {
          }), this._reportRtcInvokeStatus("es.R.node.cache", r), delete this._timer;
        }, 0);
      } else this._getAccessNodeFromServer(e).then(t).catch(i);
    });
  }
  async _getAccessNodeFromServer(e) {
    const { urls: t, needFallback: i } = this._getAccessUrls();
    return this.getICEConfigFromServer(t, e).then((e2) => {
      const { nodes: t2, decisionConfig: i2 } = e2;
      return !this._ctx.useCloudProxy && (null == t2 ? void 0 : t2.length) > 0 && sdkCache.setAccessNode(this._ctx.appId, t2, e2.ttl || 11200), i2 && this._decisionConfig.updateConfig(i2, false), e2.dispatchDomains && !this._ctx.useCloudProxy && sdkCache.setAccessUrls(e2.dispatchDomains), t2;
    }).catch((t2) => {
      if (i) return this._reportRtcInvokeStatus("es.R.req.fallback", ""), sdkCache.clearAccessUrls(), this._getAccessNodeFromServer(e);
      throw t2;
    });
  }
  _getAccessUrls() {
    let e = sdkCache.getAccessUrls() || [], t = true;
    return 0 !== e.length ? this._reportRtcInvokeStatus("es.R.req.cache.urls", e) : (t = false, e = Config2.ICE_CONFIG_REQUEST_URLS, 0 !== e.length ? this._reportRtcInvokeStatus("es.R.req.external.urls", e) : (e = Config2.ICE_CONFIG_REQUEST_URLS_INTERNAL, this._reportRtcInvokeStatus("es.R.req.internal.urls", e))), { urls: e, needFallback: t };
  }
  async getICEConfigFromServer(e, t) {
    var i;
    const r = { appID: this._ctx.appId, deviceID: sdkCache.getDeviceId(), os: "web", sdkVersion: Config2.VERSION, isOversea: Config2.OVERSEA, expectedAddr: getParameter("EXPECTED_ADDR"), productPlatform: "VolcEngine", enableCloudProxy: this._ctx.useCloudProxy, expectedIDC: this._ctx.expectedIDC, decisionKeys: ["rts_report", "web_join_room", "web_rtc_config", "rts_qps", "rts_config"], accessParams: JSON.stringify({ requireICEUfragV2: true }), userAgent: null === (i = navigator) || void 0 === i ? void 0 : i.userAgent };
    var o;
    t && (r.feedbackInfo = t, "ICE_FAILED" !== (null === (o = t[0]) || void 0 === o || null === (o = o.feedbackReason) || void 0 === o ? void 0 : o.type) && delete r.expectedAddr);
    "AREA_CODE_US_OPCO" === getParameter("AREA_CODE") && (r.mediaArea = JSON.stringify([{ AreaList: ["GEO:US_OPCO"], Attribute: "include" }]), r.accessArea = JSON.stringify([{ AreaList: ["GEO:US_OPCO"], Attribute: "include" }]));
    const n = e.map((e2) => this._httpRequest(e2, r));
    return promiseAny(n);
  }
  async _httpRequest(e, t) {
    var i;
    const r = genUuid();
    t.connectSessionID = r;
    const o = Date.now();
    null === (i = this._monitor) || void 0 === i || i.report("rtc_get_access", { error_code: 0, message: JSON.stringify(t), elapse: 0, type: "request", host: e, config_id: r, group_config_id: this._groupConfigId });
    const n = new AbortController();
    let s;
    this._abortControllers.push(n);
    try {
      var a;
      try {
        s = await fetch(e, { method: "POST", headers: { "Content-Type": "application/json" }, mode: "cors", body: JSON.stringify(t), signal: n.signal });
      } catch (e2) {
        var d;
        if (!isNativeFunction(fetch)) null === (d = this._monitor) || void 0 === d || d.report("rtc_error", { error_code: RtcErrorCode.Fetch_MODIFY, message: "get access failed, possibly due to modifying the browser's Fetch API." }, { origin_error: e2 });
        throw e2;
      }
      if (this._abortControllers = this._abortControllers.filter((e2) => e2 !== n), 200 !== s.status) throw { message: s.statusText, code: s.status };
      const i2 = await s.json();
      if (200 !== i2.code) throw i2;
      return null === (a = this._monitor) || void 0 === a || a.report("rtc_get_access", { error_code: 200, message: JSON.stringify(i2), elapse: Date.now() - o, type: "response", host: e, config_id: r, group_config_id: this._groupConfigId }), i2;
    } catch (t2) {
      var c2;
      throw null === (c2 = this._monitor) || void 0 === c2 || c2.report("rtc_get_access", { error_code: Number((null == t2 ? void 0 : t2.code) || (null == t2 ? void 0 : t2.server_code)), message: null == t2 ? void 0 : t2.message, elapse: Date.now() - o, type: "response", host: e, config_id: r, group_config_id: this._groupConfigId }, { error: JSON.stringify(t2) }), t2;
    }
  }
  destroy() {
    this._destroyed = true, window.removeEventListener("online", this._onlineListener), this._abortControllers.forEach((e) => e.abort("engine destroy")), this._reconnectTimer && (window.clearTimeout(this._reconnectTimer), delete this._reconnectTimer), this._timer && (window.clearTimeout(this._timer), delete this._timer);
  }
  _reportRtcInvokeStatus(e, t) {
    var i;
    null === (i = this._monitor) || void 0 === i || i.report("rtc_invoke_status", { sdk_api_name: e, message: t, error_code: 0, stream_id: "", elapse: 0, group_config_id: this._groupConfigId });
  }
};
var lib = {};
var parser$1 = {};
var grammar$3 = { exports: {} };
var grammar$2 = grammar$3.exports = { v: [{ name: "version", reg: /^(\d*)$/ }], o: [{ name: "origin", reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/, names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"], format: "%s %s %d %s IP%d %s" }], s: [{ name: "name" }], i: [{ name: "description" }], u: [{ name: "uri" }], e: [{ name: "email" }], p: [{ name: "phone" }], z: [{ name: "timezones" }], r: [{ name: "repeats" }], t: [{ name: "timing", reg: /^(\d*) (\d*)/, names: ["start", "stop"], format: "%d %d" }], c: [{ name: "connection", reg: /^IN IP(\d) (\S*)/, names: ["version", "ip"], format: "IN IP%d %s" }], b: [{ push: "bandwidth", reg: /^(TIAS|AS|CT|RR|RS):(\d*)/, names: ["type", "limit"], format: "%s:%s" }], m: [{ reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/, names: ["type", "port", "protocol", "payloads"], format: "%s %d %s %s" }], a: [{ push: "rtp", reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/, names: ["payload", "codec", "rate", "encoding"], format: function(e) {
  return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
} }, { push: "fmtp", reg: /^fmtp:(\d*) ([\S| ]*)/, names: ["payload", "config"], format: "fmtp:%d %s" }, { name: "control", reg: /^control:(.*)/, format: "control:%s" }, { name: "rtcp", reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/, names: ["port", "netType", "ipVer", "address"], format: function(e) {
  return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
} }, { push: "rtcpFbTrrInt", reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/, names: ["payload", "value"], format: "rtcp-fb:%s trr-int %d" }, { push: "rtcpFb", reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/, names: ["payload", "type", "subtype"], format: function(e) {
  return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
} }, { push: "ext", reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/, names: ["value", "direction", "encrypt-uri", "uri", "config"], format: function(e) {
  return "extmap:%d" + (e.direction ? "/%s" : "%v") + (e["encrypt-uri"] ? " %s" : "%v") + " %s" + (e.config ? " %s" : "");
} }, { name: "extmapAllowMixed", reg: /^(extmap-allow-mixed)/ }, { push: "crypto", reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/, names: ["id", "suite", "config", "sessionConfig"], format: function(e) {
  return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
} }, { name: "setup", reg: /^setup:(\w*)/, format: "setup:%s" }, { name: "connectionType", reg: /^connection:(new|existing)/, format: "connection:%s" }, { name: "mid", reg: /^mid:([^\s]*)/, format: "mid:%s" }, { name: "msid", reg: /^msid:(.*)/, format: "msid:%s" }, { name: "ptime", reg: /^ptime:(\d*(?:\.\d*)*)/, format: "ptime:%d" }, { name: "maxptime", reg: /^maxptime:(\d*(?:\.\d*)*)/, format: "maxptime:%d" }, { name: "direction", reg: /^(sendrecv|recvonly|sendonly|inactive)/ }, { name: "icelite", reg: /^(ice-lite)/ }, { name: "iceUfrag", reg: /^ice-ufrag:(\S*)/, format: "ice-ufrag:%s" }, { name: "icePwd", reg: /^ice-pwd:(\S*)/, format: "ice-pwd:%s" }, { name: "fingerprint", reg: /^fingerprint:(\S*) (\S*)/, names: ["type", "hash"], format: "fingerprint:%s %s" }, { push: "candidates", reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/, names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"], format: function(e) {
  var t = "candidate:%s %d %s %d %s %d typ %s";
  return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), t += null != e["network-id"] ? " network-id %d" : "%v", t += null != e["network-cost"] ? " network-cost %d" : "%v";
} }, { name: "endOfCandidates", reg: /^(end-of-candidates)/ }, { name: "remoteCandidates", reg: /^remote-candidates:(.*)/, format: "remote-candidates:%s" }, { name: "iceOptions", reg: /^ice-options:(\S*)/, format: "ice-options:%s" }, { push: "ssrcs", reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/, names: ["id", "attribute", "value"], format: function(e) {
  var t = "ssrc:%d";
  return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t;
} }, { push: "ssrcGroups", reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/, names: ["semantics", "ssrcs"], format: "ssrc-group:%s %s" }, { name: "msidSemantic", reg: /^msid-semantic:\s?(\w*) (\S*)/, names: ["semantic", "token"], format: "msid-semantic: %s %s" }, { push: "groups", reg: /^group:(\w*) (.*)/, names: ["type", "mids"], format: "group:%s %s" }, { name: "rtcpMux", reg: /^(rtcp-mux)/ }, { name: "rtcpRsize", reg: /^(rtcp-rsize)/ }, { name: "sctpmap", reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/, names: ["sctpmapNumber", "app", "maxMessageSize"], format: function(e) {
  return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
} }, { name: "xGoogleFlag", reg: /^x-google-flag:([^\s]*)/, format: "x-google-flag:%s" }, { push: "rids", reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/, names: ["id", "direction", "params"], format: function(e) {
  return e.params ? "rid:%s %s %s" : "rid:%s %s";
} }, { push: "imageattrs", reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"), names: ["pt", "dir1", "attrs1", "dir2", "attrs2"], format: function(e) {
  return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "");
} }, { name: "simulcast", reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"), names: ["dir1", "list1", "dir2", "list2"], format: function(e) {
  return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "");
} }, { name: "simulcast_03", reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/, names: ["value"], format: "simulcast: %s" }, { name: "framerate", reg: /^framerate:(\d+(?:$|\.\d+))/, format: "framerate:%s" }, { name: "sourceFilter", reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/, names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"], format: "source-filter: %s %s %s %s %s" }, { name: "bundleOnly", reg: /^(bundle-only)/ }, { name: "label", reg: /^label:(.+)/, format: "label:%s" }, { name: "sctpPort", reg: /^sctp-port:(\d+)$/, format: "sctp-port:%s" }, { name: "maxMessageSize", reg: /^max-message-size:(\d+)$/, format: "max-message-size:%s" }, { push: "tsRefClocks", reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/, names: ["clksrc", "clksrcExt"], format: function(e) {
  return "ts-refclk:%s" + (null != e.clksrcExt ? "=%s" : "");
} }, { name: "mediaClk", reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/, names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"], format: function(e) {
  var t = "mediaclk:";
  return t += null != e.id ? "id=%s %s" : "%v%s", t += null != e.mediaClockValue ? "=%s" : "", t += null != e.rateNumerator ? " rate=%s" : "", t += null != e.rateDenominator ? "/%s" : "";
} }, { name: "keywords", reg: /^keywds:(.+)$/, format: "keywds:%s" }, { name: "content", reg: /^content:(.+)/, format: "content:%s" }, { name: "bfcpFloorCtrl", reg: /^floorctrl:(c-only|s-only|c-s)/, format: "floorctrl:%s" }, { name: "bfcpConfId", reg: /^confid:(\d+)/, format: "confid:%s" }, { name: "bfcpUserId", reg: /^userid:(\d+)/, format: "userid:%s" }, { name: "bfcpFloorId", reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/, names: ["id", "mStream"], format: "floorid:%s mstrm:%s" }, { push: "invalid", names: ["value"] }] };
Object.keys(grammar$2).forEach(function(e) {
  grammar$2[e].forEach(function(e2) {
    e2.reg || (e2.reg = /(.*)/), e2.format || (e2.format = "%s");
  });
});
var grammarExports = grammar$3.exports;
!function(e) {
  var t = function(e2) {
    return String(Number(e2)) === e2 ? Number(e2) : e2;
  }, i = function(e2, i2, r2) {
    var o2 = e2.name && e2.names;
    e2.push && !i2[e2.push] ? i2[e2.push] = [] : o2 && !i2[e2.name] && (i2[e2.name] = {});
    var n2 = e2.push ? {} : o2 ? i2[e2.name] : i2;
    !function(e3, i3, r3, o3) {
      if (o3 && !r3) i3[o3] = t(e3[1]);
      else for (var n3 = 0; n3 < r3.length; n3 += 1) null != e3[n3 + 1] && (i3[r3[n3]] = t(e3[n3 + 1]));
    }(r2.match(e2.reg), n2, e2.names, e2.name), e2.push && i2[e2.push].push(n2);
  }, r = grammarExports, o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
  e.parse = function(e2) {
    var t2 = {}, n2 = [], s = t2;
    return e2.split(/(\r\n|\r|\n)/).filter(o).forEach(function(e3) {
      var t3 = e3[0], o2 = e3.slice(2);
      "m" === t3 && (n2.push({ rtp: [], fmtp: [] }), s = n2[n2.length - 1]);
      for (var a = 0; a < (r[t3] || []).length; a += 1) {
        var d = r[t3][a];
        if (d.reg.test(o2)) return i(d, s, o2);
      }
    }), t2.media = n2, t2;
  };
  var n = function(e2, i2) {
    var r2 = i2.split(/=(.+)/, 2);
    return 2 === r2.length ? e2[r2[0]] = t(r2[1]) : 1 === r2.length && i2.length > 1 && (e2[r2[0]] = void 0), e2;
  };
  e.parseParams = function(e2) {
    return e2.split(/;\s?/).reduce(n, {});
  }, e.parseFmtpConfig = e.parseParams, e.parsePayloads = function(e2) {
    return e2.toString().split(" ").map(Number);
  }, e.parseRemoteCandidates = function(e2) {
    for (var i2 = [], r2 = e2.split(" ").map(t), o2 = 0; o2 < r2.length; o2 += 3) i2.push({ component: r2[o2], ip: r2[o2 + 1], port: r2[o2 + 2] });
    return i2;
  }, e.parseImageAttributes = function(e2) {
    return e2.split(" ").map(function(e3) {
      return e3.substring(1, e3.length - 1).split(",").reduce(n, {});
    });
  }, e.parseSimulcastStreamList = function(e2) {
    return e2.split(";").map(function(e3) {
      return e3.split(",").map(function(e4) {
        var i2, r2 = false;
        return "~" !== e4[0] ? i2 = t(e4) : (i2 = t(e4.substring(1, e4.length)), r2 = true), { scid: i2, paused: r2 };
      });
    });
  };
}(parser$1);
var grammar$1 = grammarExports;
var formatRegExp = /%[sdv%]/g;
var format = function(e) {
  var t = 1, i = arguments, r = i.length;
  return e.replace(formatRegExp, function(e2) {
    if (t >= r) return e2;
    var o = i[t];
    switch (t += 1, e2) {
      case "%%":
        return "%";
      case "%s":
        return String(o);
      case "%d":
        return Number(o);
      case "%v":
        return "";
    }
  });
};
var makeLine = function(e, t, i) {
  var r = [e + "=" + (t.format instanceof Function ? t.format(t.push ? i : i[t.name]) : t.format)];
  if (t.names) for (var o = 0; o < t.names.length; o += 1) {
    var n = t.names[o];
    t.name ? r.push(i[t.name][n]) : r.push(i[t.names[o]]);
  }
  else r.push(i[t.name]);
  return format.apply(null, r);
};
var defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"];
var defaultInnerOrder = ["i", "c", "b", "a"];
var writer$1 = function(e, t) {
  t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach(function(e2) {
    null == e2.payloads && (e2.payloads = "");
  });
  var i = t.outerOrder || defaultOuterOrder, r = t.innerOrder || defaultInnerOrder, o = [];
  return i.forEach(function(t2) {
    grammar$1[t2].forEach(function(i2) {
      i2.name in e && null != e[i2.name] ? o.push(makeLine(t2, i2, e)) : i2.push in e && null != e[i2.push] && e[i2.push].forEach(function(e2) {
        o.push(makeLine(t2, i2, e2));
      });
    });
  }), e.media.forEach(function(e2) {
    o.push(makeLine("m", grammar$1.m[0], e2)), r.forEach(function(t2) {
      grammar$1[t2].forEach(function(i2) {
        i2.name in e2 && null != e2[i2.name] ? o.push(makeLine(t2, i2, e2)) : i2.push in e2 && null != e2[i2.push] && e2[i2.push].forEach(function(e3) {
          o.push(makeLine(t2, i2, e3));
        });
      });
    });
  }), o.join("\r\n") + "\r\n";
};
var parser = parser$1;
var writer = writer$1;
var grammar = grammarExports;
lib.grammar = grammar, lib.write = writer, lib.parse = parser.parse, lib.parseParams = parser.parseParams, lib.parseFmtpConfig = parser.parseFmtpConfig, lib.parsePayloads = parser.parsePayloads, lib.parseRemoteCandidates = parser.parseRemoteCandidates, lib.parseImageAttributes = parser.parseImageAttributes, lib.parseSimulcastStreamList = parser.parseSimulcastStreamList;
var logger$3 = new Logger$1("FirefoxHandler", 3);
var SSRC_MAX = Math.pow(2, 32);
var clientCname = "kp34Za0H+aVf862l";
var serverCname = "o/i14u9pJrxRKAsu";
var generateRandomSsrc = () => Math.floor(Math.random() * SSRC_MAX + 1e4);
function generateAllSsrc(e) {
  return e > SSRC_MAX - 18 ? (logger$3.warn("generateAllSsrc", "reset start id", e), generateAllSsrc(e = e - SSRC_MAX + 1e4 + 18)) : { audio: e, audioFec: e + 1, audioRtx: e + 2, video: e + 3, videoFec: e + 4, videoRtx: e + 5, next: e + 18 };
}
var generateSsrc = function(e, t, i) {
  return [{ id: i, attribute: "cname", value: arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : serverCname }, { id: i, attribute: "msid", value: "".concat(e, " ").concat(e, "-").concat(t) }, { id: i, attribute: "mslabel", value: "".concat(e) }, { id: i, attribute: "label", value: "".concat(e, "-").concat(t) }];
};
var generateSsrcs = function(e, t) {
  let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
  const r = t.video, o = t.videoRtx, n = t.videoFec, s = [r, o], { cname: a, flexfec: d } = i;
  d && s.push(n);
  const c2 = s.reduce((t2, i2) => t2.concat(generateSsrc(e, "video", i2, a)), []), l = [{ semantics: "FID", ssrcs: "".concat(r, " ").concat(o) }];
  return d && l.push({ semantics: "FEC-FR", ssrcs: "".concat(r, " ").concat(n) }), { ssrcs: c2, ssrcGroups: l };
};
function closeMline(e) {
  return e.direction = "inactive", e.port = 0, delete e.ext, delete e.ssrcs, delete e.ssrcGroups, delete e.simulcast, delete e.simulcast_03, delete e.rids, delete e.extmapAllowMixed, delete e.msid, delete e.bundleOnly, e;
}
var getLocalPartialSdp = function(e, t, i) {
  let r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
  const o = _objectSpread2(_objectSpread2({}, e), {}, { media: [] });
  return r && (o.invalid = [{ value: "realx-exts:rscp" }]), t && o.media.push(cloneDeep(t)), i && o.media.push(cloneDeep(i)), delete o.groups, delete o.msidSemantic, H265ToByteVC1(o);
};
function parseAnswerIceParams(e) {
  const t = {}, { publicIPs: i, certFingerprint: r, iceParams: o, iceConfig: n } = e;
  return t.fingerprint = { type: "sha-256", hash: r }, t.icePwd = o.serverIcePwd, t.iceUfrag = getServerUfrag(o.serverIceUfrag), t.candidates = genCandidates(i, n), t.setup = "active", t.iceOptions = "renomination", t;
}
function genCandidates(e, t) {
  if (!Array.isArray(e)) return [];
  let i = 0;
  const r = 2130706431, o = [];
  return e.forEach((e2) => {
    const n = { component: 1, ip: e2.ip, type: "host", generation: e2.generation };
    e2.udpPorts && !t.tcpOnly && e2.udpPorts.forEach((e3) => {
      o.push(_objectSpread2(_objectSpread2({}, n), {}, { foundation: i++, transport: "udp", port: e3, priority: r }));
    }), e2.tcpPorts && e2.tcpPorts.forEach((e3) => {
      o.push(_objectSpread2(_objectSpread2({}, n), {}, { foundation: i++, transport: "tcp", port: e3, tcptype: "passive", priority: 2130705431 }));
    });
  }), o;
}
var getServerUfrag = (e) => {
  const t = new TextEncoder().encode("PREC"), i = base64ToUint8(e), r = new Uint8Array(4);
  crypto.getRandomValues(r);
  const o = new Uint8Array(2);
  o[0] = 0, o[1] = 1;
  return uint8ToBase64(concatenate(Uint8Array, t, i, r, o));
};
var ICEConfigType = ((e) => (e[e.kICEConfigTypeSrtpDtlsType = 0] = "kICEConfigTypeSrtpDtlsType", e[e.kICEConfigTypeRenominationType = 1] = "kICEConfigTypeRenominationType", e[e.kICEConfigTypeTcpType = 2] = "kICEConfigTypeTcpType", e[e.kICEConfigTypeMultiSendType = 3] = "kICEConfigTypeMultiSendType", e[e.kICEConfigTypeKcpType = 4] = "kICEConfigTypeKcpType", e[e.kICEConfigTypeSrtpSdesType = 5] = "kICEConfigTypeSrtpSdesType", e))(ICEConfigType || {});
function getServerUfragV2(e) {
  let { random: t, serverUfrag: i, serverPwd: r, clientPwd: o, options: n } = e, s = 0;
  const a = new TextEncoder().encode("WPRE");
  s += 4, t || (t = new Uint8Array(4), crypto.getRandomValues(t)), s += 4;
  const d = base64ToUint8(i);
  s += 1, s += d.byteLength;
  const c2 = aesCtrEncrypt(base64ToUint8(o), base64ToUint8(r).subarray(0, 16), base64ToUint8(i).subarray(0, 16));
  s += 1, s += c2.byteLength;
  const l = new Uint8Array(Object.keys(n).reduce((e2, t2) => {
    const i2 = Number(t2);
    return e2.push(i2), e2.push(n[i2] ? 1 : 0), e2;
  }, []));
  s += l.byteLength;
  let u = concatenate(Uint8Array, a, t, [d.byteLength], d, [c2.byteLength], c2, l);
  u.byteLength % 3 != 0 && (u = concatenate(Uint8Array, u, new Uint8Array(3 - u.byteLength % 3).fill(255)));
  return [uint8ToBase64(u), uint8ToBase64(concatenate(Uint8Array, t, d.subarray(0, 20)))];
}
var setAudioCodecPreferences = (e, t) => {
  if (!Array.isArray(e.fmtp) || !Array.isArray(e.rtp)) return;
  for (let i2 = 0; i2 < e.rtp.length; i2++) {
    if (e.rtp[i2].codec.toUpperCase() === t.toUpperCase()) {
      e.rtp.unshift(e.rtp.splice(i2, 1)[0]);
      break;
    }
  }
  const i = [];
  e.rtp.forEach((e2) => i.push(e2.payload)), e.payloads = i.join(" ");
};
var setCodecPreferences = (e, t) => {
  let i = 0;
  if (!Array.isArray(e.fmtp) || !Array.isArray(e.rtp)) return;
  for (const t2 of e.fmtp) if (t2.config.includes("level-asymmetry-allowed=1") && t2.config.includes("packetization-mode=1") && t2.config.includes("profile-level-id=42e0")) {
    i = t2.payload;
    break;
  }
  for (let r2 = 0; r2 < e.rtp.length; r2++) {
    const o = e.rtp[r2];
    if ("H264" === t) {
      if (o.payload === i) {
        e.rtp.unshift(e.rtp.splice(r2, 1)[0]);
        break;
      }
    } else if (o.codec === t) {
      e.rtp.unshift(e.rtp.splice(r2, 1)[0]);
      break;
    }
  }
  const r = [];
  e.rtp.forEach((e2) => r.push(e2.payload)), e.payloads = r.join(" ");
};
var cropSdpMediaSection = (e) => {
  const t = lib.parse(e);
  return t.media = t.media.map((e2) => {
    if ("audio" === e2.type) {
      return cropAudioMediaSection(e2, t);
    }
    return cropVideoMediaSection(e2, ["H264", "VP8", "ByteVC1"], t);
  }), lib.write(t);
};
var pushRRTR = (e) => {
  e.media.forEach((e2) => {
    "audio" !== e2.type && "video" !== e2.type || e2.rtp.forEach((t) => {
      e2.rtcpFb || (e2.rtcpFb = []), e2.rtcpFb.find((e3) => e3.payload === t.payload && "rrtr" === e3.type) || e2.rtcpFb.push({ payload: t.payload, type: "rrtr" });
    });
  });
};
var cropVideoMediaSection = function(e, t, i) {
  let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : { rrtr: false };
  const o = {}, n = {};
  let s = -1;
  const a = [];
  return Array.isArray(e.fmtp) && e.fmtp.forEach((e2) => {
    let { payload: t2, config: i2 } = e2;
    if (i2.startsWith("apt=")) {
      const e3 = i2.slice(4);
      o[t2] = e3;
    } else i2.includes("42e0") && i2.includes("packetization-mode=1") && (s = t2);
  }), Array.isArray(e.rtp) && (e.rtp = e.rtp.filter((e2) => {
    const i2 = e2.codec, r2 = e2.payload;
    let d;
    switch (i2) {
      case "H264":
        return d = false, t.map((e3) => {
          "H264" === e3 && r2 === s && (n[r2] = r2, a.push(r2), d = true);
        }), d;
      case "rtx":
        return !!n[o[r2]] && (n[r2] = r2, true);
      case "red":
      case "ulpfec":
      case "flexfec-03":
        return n[r2] = r2, true;
      default:
        return d = false, t.map((e3) => {
          e3 === i2 && (n[r2] = r2, a.push(r2), d = true);
        }), d;
    }
  })), Array.isArray(e.fmtp) && (e.fmtp = e.fmtp.filter((e2) => n[e2.payload])), Array.isArray(e.rtcpFb) ? e.rtcpFb = e.rtcpFb.filter((e2) => n[e2.payload]) : e.rtcpFb = [], r.rrtr && a.forEach((t2) => {
    var i2;
    null === (i2 = e.rtcpFb) || void 0 === i2 || i2.push({ payload: t2, type: "rrtr" });
  }), deleteProperty(e, i), Array.isArray(e.ext) && (e.ext = e.ext.filter((e2) => {
    if ("http://www.webrtc.org/experiments/rtp-hdrext/video-content-type" !== e2.uri && "http://www.webrtc.org/experiments/rtp-hdrext/video-timing" !== e2.uri && "http://www.webrtc.org/experiments/rtp-hdrext/color-space" !== e2.uri) return e2;
  })), "string" == typeof e.payloads && (e.payloads = e.payloads.split(" ").filter((e2) => n[e2]).join(" ")), e;
};
var cropAudioMediaSection = function(e, t) {
  let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : { rrtr: false };
  const r = {};
  if (Array.isArray(e.rtp) && (e.rtp = e.rtp.filter((e2) => {
    const t2 = e2.codec, i2 = e2.payload;
    return ("opus" === t2 || "red" === t2) && (r[i2] = i2, true);
  })), Array.isArray(e.rtcpFb) || (e.rtcpFb = []), i.rrtr && Object.keys(r).forEach((t2) => {
    var i2;
    null === (i2 = e.rtcpFb) || void 0 === i2 || i2.push({ payload: Number(t2), type: "rrtr" });
  }), deleteProperty(e, t), "string" == typeof e.payloads) {
    const t2 = [];
    e.payloads.split(" ").forEach((e2) => {
      r[e2] && t2.push(e2);
    }), e.payloads = t2.join(" ");
  }
  return e;
};
var deleteProperty = (e, t) => {
  e.iceOptions && delete e.iceOptions, e.icePwd && (t.icePwd = e.icePwd, delete e.icePwd), e.iceUfrag && (t.iceUfrag = e.iceUfrag, delete e.iceUfrag), e.fingerprint && (t.fingerprint = e.fingerprint, delete e.fingerprint);
};
var H265ToByteVC1 = (e) => vcodecTransform(e, "H265", "ByteVC1");
var ByteVC1ToH265 = (e) => vcodecTransform(e, "ByteVC1", "H265");
var vcodecTransform = (e, t, i) => {
  const r = "string" == typeof e ? lib.parse(e) : e;
  return r.media = r.media.map((e2) => ("video" === e2.type && (e2.rtp = e2.rtp.map((e3) => (e3.codec === t && (e3.codec = i), e3))), e2)), lib.write(r);
};
function DCHECK(e, t) {
  const i = new Error().stack;
  reportGlobalError("[DCHECK FAILED] ".concat(t), -1, { stack: i });
}
var encodedTransformSupported$3 = isLegacyEncodedTransformSupported();
var peerConnectionConfiguration = { iceServers: [], iceTransportPolicy: "all", bundlePolicy: "max-bundle", rtcpMuxPolicy: "require" };
var ConnectFailCode = ((e) => (e[e.DC_ERROR = 0] = "DC_ERROR", e[e.DC_CLOSE = 1] = "DC_CLOSE", e[e.ICE_FAILED = 2] = "ICE_FAILED", e[e.DESTROY = 3] = "DESTROY", e[e.TIMEOUT = 4] = "TIMEOUT", e))(ConnectFailCode || {});
var PeerConnectionGUID = 0;
var PeerConnection = class extends EnhancedEventEmitter {
  constructor(e, t) {
    let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    super(), _defineProperty(this, "uuid", (PeerConnectionGUID++).toString()), _defineProperty(this, "_peerConnectionId", ""), _defineProperty(this, "audioTrack4ff", void 0), _defineProperty(this, "_pc", void 0), _defineProperty(this, "_dc", void 0), _defineProperty(this, "_iceNode", void 0), _defineProperty(this, "_initSctpEvents", false), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "_offerIce", {}), _defineProperty(this, "_answerIce", {}), _defineProperty(this, "_offerSession", void 0), _defineProperty(this, "_answerSession", void 0), _defineProperty(this, "_offerMlines", []), _defineProperty(this, "_answerMlines", []), _defineProperty(this, "_connectReject", void 0), _defineProperty(this, "_logger", void 0), _defineProperty(this, "_destroyed", false), _defineProperty(this, "_reportTimer", void 0), _defineProperty(this, "_onLineCheckerTimer", void 0), _defineProperty(this, "_clearPeerListeners", void 0), _defineProperty(this, "_peerConfig", void 0), _defineProperty(this, "_iceStartTs", 0), _defineProperty(this, "_icePreStepTs", 0), this._ctx = e, this._groupConnectionId = t, this._isReconnect = i, this._monitor = getMonitor(e.id), this._logger = new Logger$1("PeerConnection_".concat(this.uuid), 4, e.id), this._ctx.enableFallbackHandler && this._logger.warn("ctor", "PeerConnection running in fallback mode"), this._peerConfig = genPeerConfig(e), this._pc = new RTCPeerConnection(this._peerConfig), this._pc.ontrack = (e2) => {
      var t2;
      const i2 = null === (t2 = e2.streams) || void 0 === t2 || null === (t2 = t2[0]) || void 0 === t2 ? void 0 : t2.id;
      this._print("pc.ontrack", "".concat(e2.track.kind, " ").concat(e2.track.id, " ").concat(i2)), "ff-stream" === i2 && (this.audioTrack4ff = e2.track), this.emit("ontrack", e2);
    }, this._pc.onconnectionstatechange = () => {
      this._print("onconnectionstatechange", "".concat(this._pc.connectionState, ". ice -> ").concat(this._pc.iceConnectionState)), "failed" !== this._pc.iceConnectionState && "closed" !== this._pc.iceConnectionState && "failed" !== this._pc.connectionState ? "disconnected" !== this._pc.connectionState ? "connecting" !== this._pc.connectionState && "connected" !== this._pc.connectionState || clearInterval(this._onLineCheckerTimer) : navigator.onLine ? this.emit("disconnect", InternalReconnectReason.ICE_FAILED) : this._onLineCheckerTimer = setInterval(() => {
        navigator.onLine && (clearInterval(this._onLineCheckerTimer), this.emit("disconnect", InternalReconnectReason.ICE_FAILED));
      }, 1e3) : this.emit("disconnect", InternalReconnectReason.ICE_FAILED);
    }, this._pc.oniceconnectionstatechange = () => {
      const e2 = this._pc.iceConnectionState;
      this._report("rtc_pre_ice_state", { message: e2, ice_state: e2.toUpperCase() }), this.emit("ice_state", e2);
    };
  }
  static checkSupported() {
    if (!RTCPeerConnection) throw new SDKError(ErrorCode.NOT_SUPPORTED, "missing RTCPeerConnection API.");
    ["addTransceiver", "createDataChannel", "createOffer", "setLocalDescription", "setRemoteDescription"].forEach((e) => {
      var t;
      if (null === (t = RTCPeerConnection) || void 0 === t || null === (t = t.prototype) || void 0 === t || !t[e]) throw new SDKError(ErrorCode.NOT_SUPPORTED, "missing peer.".concat(e, " API."));
    });
  }
  getOriginRTCPeerConnection() {
    return this._pc;
  }
  getConnectionId() {
    return this._peerConnectionId;
  }
  getGroupConnectionId() {
    return this._groupConnectionId;
  }
  getIceConnectionState() {
    return this._pc.iceConnectionState;
  }
  async createOfferSdp() {
    let { sdp: e } = await this._pc.createOffer();
    return e;
  }
  async startIceConnect(e) {
    if (this._ctx.enableStandardHandler && !this._ctx.enableFallbackHandler) return this.startIceConnectStandard(e);
    this._print("connect", "invoke. %o", e), this._iceNode = e;
    const t = this._pc.createDataChannel("signaling", { negotiated: true, id: 100 });
    t.binaryType = "arraybuffer", this._dc = t;
    const { offerIce: i, answerIce: r } = this._genIceInfo(e);
    this._offerIce = i, this._answerIce = r, isFirefox && firefoxVersion < 138 && (this._pc.addTransceiver("audio", { direction: "recvonly" }), this._pc.addTransceiver("video", { direction: "recvonly" }));
    const o = await this.createOfferSdp();
    if (!o) throw new SDKError(ErrorCode.NOT_SUPPORTED, "create offer sdp failed.");
    const n = lib.parse(o);
    this._peerConnectionId = r.iceUfrag || "";
    const s = !i.iceUfrag && !i.icePwd;
    if (s) {
      var a, d;
      const t2 = "renomination" === (null === (a = n.media[0]) || void 0 === a ? void 0 : a.iceOptions) || !this._ctx.enableFallbackHandler && this._ctx.pcKillSwitch.sld_iceoption_renomination;
      t2 || (delete i.iceOptions, delete r.iceOptions), delete i.iceUfrag, delete i.icePwd;
      const [o2, s2] = getServerUfragV2({ serverUfrag: e.iceParams.serverIceUfrag, serverPwd: e.iceParams.serverIcePwd, clientPwd: null === (d = n.media[0]) || void 0 === d ? void 0 : d.icePwd, options: { [ICEConfigType.kICEConfigTypeSrtpDtlsType]: true, [ICEConfigType.kICEConfigTypeRenominationType]: t2 } });
      this._peerConnectionId = s2, r.iceUfrag = o2, this._logger.info("use serverUfrag v2", JSON.stringify({ dtls: true, renomination: t2 }));
    }
    this.reportRtcPreIce("ice_start");
    const [c2] = n.media;
    if (this._offerIce.fingerprint = n.fingerprint || c2.fingerprint, isFirefox || this._ctx.enableFallbackHandler) {
      n.media = n.media.map((e3) => {
        const t2 = _objectSpread2(_objectSpread2({}, e3), this._offerIce);
        var i2, r2, o2, n2;
        "video" === t2.type && (isTransportCCSupport ? (t2.ext = null === (i2 = t2.ext) || void 0 === i2 ? void 0 : i2.filter((e4) => -1 === e4.uri.indexOf("abs-send-time")), t2.rtcpFb = null === (r2 = t2.rtcpFb) || void 0 === r2 ? void 0 : r2.filter((e4) => "goog-remb" !== e4.type)) : (t2.rtcpFb = null === (o2 = t2.rtcpFb) || void 0 === o2 ? void 0 : o2.filter((e4) => "transport-cc" !== e4.type), t2.ext = null === (n2 = t2.ext) || void 0 === n2 ? void 0 : n2.filter((e4) => -1 === e4.uri.indexOf("transport"))));
        return t2;
      }), isRRTRSupported && pushRRTR(n);
      const e2 = _objectSpread2({}, n);
      e2.fingerprint = this._answerIce.fingerprint, e2.media = e2.media.map((e3) => (delete (e3 = _objectSpread2(_objectSpread2({}, e3), this._answerIce)).bundleOnly, e3.port = 9, "application" === e3.type ? e3.sctpmap = { sctpmapNumber: 5e3, app: "webrtc-datachannel", maxMessageSize: 262144 } : ("audio" === e3.type && (e3.msid = "ff-stream ff-stream-audio"), e3.direction = "sendonly"), e3)), isRRTRSupported && pushRRTR(e2), this._ctx.enableFallbackHandler ? await this.setLocalDescription(o) : await this.setLocalDescription(lib.write(n)), await this.setRemoteDescription(lib.write(e2));
    } else {
      delete n.media, this._offerSession = _objectSpread2({}, n), this._answerSession = _objectSpread2({}, n), this._answerSession.fingerprint && (this._answerSession.fingerprint = this._answerIce.fingerprint);
      const e2 = 0;
      s && (this._offerIce.iceUfrag = c2.iceUfrag, this._offerIce.icePwd = c2.icePwd), this._offerMlines = [_objectSpread2(_objectSpread2(_objectSpread2({}, c2), this._offerIce), {}, { mid: "".concat(e2) })], this._answerMlines = [_objectSpread2(_objectSpread2(_objectSpread2({}, c2), this._answerIce), {}, { sctpmap: { sctpmapNumber: 5e3, app: "webrtc-datachannel", maxMessageSize: 262144 }, mid: "".concat(e2) })], this.setDescription();
    }
    return this._reportTransportStats(), await new Promise((e2, i2) => {
      this._connectReject = i2;
      const r2 = setTimeout(() => {
        var e3;
        this.reportRtcPreIce("timeout"), null === (e3 = this._connectReject) || void 0 === e3 || e3.call(this, { code: 4, message: "connect timeout" }), delete this._connectReject;
      }, 8e3), o2 = () => {
        this._print("connect", "dataChannel open"), this._reportRtcInvokeStatus("es.dc.open", ""), this.reportRtcPreIce("datachannel_opened"), clearTimeout(r2), e2(""), delete this._connectReject;
      }, n2 = (e3) => {
        var t2, i3, o3, n3;
        this._report("rtc_signaling_msg_error", { error_code: null == e3 || null === (t2 = e3.error) || void 0 === t2 ? void 0 : t2.sdpLineNumber, message: null == e3 || null === (i3 = e3.error) || void 0 === i3 ? void 0 : i3.errorDetail, reason: "invalid data" }), this._reportRtcInvokeStatus("es.dc.error", ""), null === (o3 = this._connectReject) || void 0 === o3 || o3.call(this, { message: "dc.onerror, ".concat(null === (n3 = e3.error) || void 0 === n3 ? void 0 : n3.errorDetail), code: 0 }), this.emit("disconnect", InternalReconnectReason.DC_ERROR), delete this._connectReject, clearTimeout(r2);
      }, s2 = () => {
        var e3;
        this._reportRtcInvokeStatus("es.dc.close", ""), null === (e3 = this._connectReject) || void 0 === e3 || e3.call(this, { message: "dc.onclose", code: 1 }), this.reportRtcPreIce("datachannel_closed"), this.emit("disconnect", InternalReconnectReason.DC_CLOSE), delete this._connectReject, clearTimeout(r2);
      }, a2 = () => {
        "connected" === this._pc.iceConnectionState ? this.reportRtcPreIce("ice_connected") : "failed" !== this._pc.iceConnectionState && "closed" !== this._pc.iceConnectionState || this.reportRtcPreIce("ice_failed");
      }, d2 = () => {
        var e3;
        "failed" !== this._pc.iceConnectionState && "closed" !== this._pc.iceConnectionState && "failed" !== this._pc.connectionState || (null === (e3 = this._connectReject) || void 0 === e3 || e3.call(this, { message: "pc.connectionstatechange -> ".concat(this._pc.connectionState, ", ice -> ").concat(this._pc.iceConnectionState), code: 2 }), delete this._connectReject, clearTimeout(r2));
      };
      t.addEventListener("open", o2), t.addEventListener("error", n2), t.addEventListener("close", s2), this._pc.addEventListener("iceconnectionstatechange", a2), this._pc.addEventListener("connectionstatechange", d2), this._clearPeerListeners = () => {
        t.removeEventListener("open", o2), t.removeEventListener("error", n2), t.removeEventListener("close", s2), this._pc.removeEventListener("iceconnectionstatechange", a2), this._pc.removeEventListener("connectionstatechange", d2);
      };
    }), this._print("connect", "dataChannel establish success"), t;
  }
  async startIceConnectStandard(e) {
    this._print("connect", "standard invoke. %o", e), this._iceNode = e;
    const t = this._pc.createDataChannel("signaling", { negotiated: true, id: 100 });
    t.binaryType = "arraybuffer", this._dc = t;
    const { offerIce: i, answerIce: r } = this._genIceInfo(e);
    this._offerIce = i, this._answerIce = r, isFirefox && firefoxVersion < 138 && (this._pc.addTransceiver("audio", { direction: "recvonly" }), this._pc.addTransceiver("video", { direction: "recvonly" }));
    const o = await this.createOfferSdp();
    if (!o) throw new SDKError(ErrorCode.NOT_SUPPORTED, "create offer sdp failed.");
    const n = lib.parse(o);
    this._answerSession = _objectSpread2({}, n), this._answerSession.fingerprint && (this._answerSession.fingerprint = this._answerIce.fingerprint);
    const s = n.media.find((e2) => "application" === e2.type);
    this._peerConnectionId = r.iceUfrag || "";
    if (!i.iceUfrag && !i.icePwd) {
      const t2 = this._ctx.pcKillSwitch.sld_iceoption_renomination || "renomination" === (null == s ? void 0 : s.iceOptions);
      t2 || (delete i.iceOptions, delete r.iceOptions), delete i.iceUfrag, delete i.icePwd;
      const [o2, n2] = getServerUfragV2({ serverUfrag: e.iceParams.serverIceUfrag, serverPwd: e.iceParams.serverIcePwd, clientPwd: null == s ? void 0 : s.icePwd, options: { [ICEConfigType.kICEConfigTypeSrtpDtlsType]: true, [ICEConfigType.kICEConfigTypeRenominationType]: t2 } });
      this._peerConnectionId = n2, r.iceUfrag = o2, this._logger.info("use serverUfrag v2", JSON.stringify({ dtls: true, renomination: t2 }));
    }
    this.reportRtcPreIce("ice_start"), this._offerIce.fingerprint = n.fingerprint || s.fingerprint;
    const a = _objectSpread2({}, n);
    return a.fingerprint = this._answerIce.fingerprint, a.media = a.media.map((e2) => {
      if ("application" === (e2 = _objectSpread2(_objectSpread2({}, e2), this._answerIce)).type && (e2.sctpmap = { sctpmapNumber: 5e3, app: "webrtc-datachannel", maxMessageSize: 262144 }), isFirefox) {
        if (delete e2.bundleOnly, e2.port = 9, "audio" === e2.type) e2.msid = "ff-stream ff-stream-audio", e2.direction = "sendonly";
        else if ("video" === e2.type) {
          var t2, i2, r2, o2;
          if (isTransportCCSupport) e2.ext = null === (t2 = e2.ext) || void 0 === t2 ? void 0 : t2.filter((e3) => -1 === e3.uri.indexOf("abs-send-time")), e2.rtcpFb = null === (i2 = e2.rtcpFb) || void 0 === i2 ? void 0 : i2.filter((e3) => "goog-remb" !== e3.type);
          else e2.rtcpFb = null === (r2 = e2.rtcpFb) || void 0 === r2 ? void 0 : r2.filter((e3) => "transport-cc" !== e3.type), e2.ext = null === (o2 = e2.ext) || void 0 === o2 ? void 0 : o2.filter((e3) => -1 === e3.uri.indexOf("transport"));
          e2.direction = "sendonly";
        }
      }
      return e2;
    }), "v1" === this.getIceVersion() || this._ctx.pcKillSwitch.sld_iceoption_renomination ? (n.media = n.media.map((e2) => e2 = _objectSpread2(_objectSpread2({}, e2), this._offerIce)), await this.setLocalDescription(lib.write(n))) : await this.setLocalDescription(o), await this.setRemoteDescription(lib.write(a)), this._reportTransportStats(), await new Promise((e2, i2) => {
      this._connectReject = i2;
      const r2 = setTimeout(() => {
        var e3;
        this.reportRtcPreIce("timeout"), null === (e3 = this._connectReject) || void 0 === e3 || e3.call(this, { code: 4, message: "connect timeout" }), delete this._connectReject;
      }, 8e3), o2 = () => {
        this._print("connect", "dataChannel open"), this._reportRtcInvokeStatus("es.dc.open", ""), this.reportRtcPreIce("datachannel_opened"), clearTimeout(r2), e2(""), delete this._connectReject;
      }, n2 = (e3) => {
        var t2, i3, o3, n3;
        this._report("rtc_signaling_msg_error", { error_code: null == e3 || null === (t2 = e3.error) || void 0 === t2 ? void 0 : t2.sdpLineNumber, message: null == e3 || null === (i3 = e3.error) || void 0 === i3 ? void 0 : i3.errorDetail, reason: "invalid data" }), this._reportRtcInvokeStatus("es.dc.error", ""), null === (o3 = this._connectReject) || void 0 === o3 || o3.call(this, { message: "dc.onerror, ".concat(null === (n3 = e3.error) || void 0 === n3 ? void 0 : n3.errorDetail), code: 0 }), this.emit("disconnect", InternalReconnectReason.DC_ERROR), delete this._connectReject, clearTimeout(r2);
      }, s2 = () => {
        var e3;
        this._reportRtcInvokeStatus("es.dc.close", ""), null === (e3 = this._connectReject) || void 0 === e3 || e3.call(this, { message: "dc.onclose", code: 1 }), this.reportRtcPreIce("datachannel_closed"), this.emit("disconnect", InternalReconnectReason.DC_CLOSE), delete this._connectReject, clearTimeout(r2);
      }, a2 = () => {
        "connected" === this._pc.iceConnectionState ? this.reportRtcPreIce("ice_connected") : "failed" !== this._pc.iceConnectionState && "closed" !== this._pc.iceConnectionState || this.reportRtcPreIce("ice_failed");
      }, d = () => {
        var e3;
        "failed" !== this._pc.iceConnectionState && "closed" !== this._pc.iceConnectionState && "failed" !== this._pc.connectionState || (null === (e3 = this._connectReject) || void 0 === e3 || e3.call(this, { message: "pc.connectionstatechange -> ".concat(this._pc.connectionState, ", ice -> ").concat(this._pc.iceConnectionState), code: 2 }), delete this._connectReject, clearTimeout(r2));
      };
      t.addEventListener("open", o2), t.addEventListener("error", n2), t.addEventListener("close", s2), this._pc.addEventListener("iceconnectionstatechange", a2), this._pc.addEventListener("connectionstatechange", d), this._clearPeerListeners = () => {
        t.removeEventListener("open", o2), t.removeEventListener("error", n2), t.removeEventListener("close", s2), this._pc.removeEventListener("iceconnectionstatechange", a2), this._pc.removeEventListener("connectionstatechange", d);
      };
    }), this._print("connect", "dataChannel establish success"), t;
  }
  async setDescription(e) {
    this._print("setDescription", "invoke."), this._offerSession.media = this._offerMlines, this._answerSession.media = this._answerMlines;
    const t = [];
    this._offerMlines.forEach((e2) => {
      "inactive" !== e2.direction && e2.mid && t.push(e2.mid);
    }), this._offerSession.groups && this._answerSession.groups && (this._offerSession.groups[0].mids = t.join(" "), this._answerSession.groups[0].mids = t.join(" "));
    const i = getServerNow();
    e && this._report("rtc_begin_create_offer", { direction: "local" === e.streamUserId ? "up" : "down", stream_id: e.streamId, stream_user_id: e.streamUserId, pc_session_id: this._peerConnectionId, vendor_mode: 0 }), e && this._report("rtc_create_offer", { error_code: 0, direction: "local" === e.streamUserId ? "up" : "down", stream_id: e.streamId, stream_user_id: e.streamUserId, elapse: getServerNow() - i }), await this.setLocalDescription(lib.write(this._offerSession), e), await this.setRemoteDescription(lib.write(this._answerSession), e);
  }
  async setLocalDescription(e, t) {
    const i = getServerNow();
    try {
      if (await this._pc.setLocalDescription({ type: "offer", sdp: e }), this._report("rtc_set_description", { error_code: 0, message: e, is_local: "1", direction: "local" === (null == t ? void 0 : t.streamUserId) ? "up" : "down", stream_id: (null == t ? void 0 : t.streamId) || "", stream_user_id: (null == t ? void 0 : t.streamUserId) || "", elapse: getServerNow() - i }, { type: "offer" }), !this._initSctpEvents) {
        var r;
        this._initSctpEvents = true;
        const e2 = null === (r = this._pc) || void 0 === r ? void 0 : r.sctp;
        e2 && (e2.onstatechange = () => {
          this._reportRtcInvokeStatus("sctp", "sctp state change TO: ".concat(e2.state));
        }, e2.transport && (e2.transport.onstatechange = () => {
          var t2;
          this._reportRtcInvokeStatus("dtls", "dtls state change TO: ".concat(null == e2 || null === (t2 = e2.transport) || void 0 === t2 ? void 0 : t2.state));
        }));
      }
    } catch (r2) {
      throw console.error("setLocal", r2), this._report("rtc_set_description", { error_code: -1, message: r2.message + e, is_local: "1", direction: "local" === (null == t ? void 0 : t.streamUserId) ? "up" : "down", stream_id: "", stream_user_id: "", elapse: getServerNow() - i }, { type: "offer" }), r2;
    }
  }
  async setRemoteDescription(e, t) {
    const i = getServerNow();
    try {
      e = ByteVC1ToH265(e), await this._pc.setRemoteDescription({ type: "answer", sdp: e }), this._report("rtc_set_description", { error_code: 0, message: e, is_local: "0", direction: "local" === (null == t ? void 0 : t.streamUserId) ? "up" : "down", stream_id: (null == t ? void 0 : t.streamId) || "", stream_user_id: (null == t ? void 0 : t.streamUserId) || "", elapse: getServerNow() - i }, { type: "answer" });
    } catch (r) {
      throw console.error("setRemote", r), this._report("rtc_set_description", { error_code: -1, message: r.message + e, is_local: "0", direction: "local" === (null == t ? void 0 : t.streamUserId) ? "up" : "down", stream_id: (null == t ? void 0 : t.streamId) || "", stream_user_id: (null == t ? void 0 : t.streamUserId) || "", elapse: getServerNow() - i }, { type: "answer" }), r;
    }
  }
  closeIceConnect() {
    var e, t, i, r;
    null === (e = this._connectReject) || void 0 === e || e.call(this, { code: 3, message: "invoke destroy()" }), delete this._connectReject, null === (t = this._pc) || void 0 === t || t.close(), null === (i = this._dc) || void 0 === i || i.close(), delete this._dc, this._pc.ontrack = null, this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, clearPeerCache(this._pc), null === (r = this._clearPeerListeners) || void 0 === r || r.call(this), delete this._clearPeerListeners;
  }
  reportRtcPreIce(e) {
    var t;
    const i = getServerNow();
    "ice_start" === e && (this._iceStartTs = i, this._icePreStepTs = i), this._report("rtc_pre_ice", { connect_event: e, message: e, elapse: i - this._icePreStepTs, total_elapse: i - this._iceStartTs, cache_status: !(null === (t = this._iceNode) || void 0 === t || !t.cache_status), is_reconnect: this._isReconnect }), this._icePreStepTs = i;
  }
  getStatsWithLowFrequency(e, t, i) {
    return getStats$1(this._pc, e, t, i);
  }
  getIceVersion() {
    var e, t;
    return null !== (e = this._iceNode) && void 0 !== e && e.iceParams.clientIceUfrag || null !== (t = this._iceNode) && void 0 !== t && t.iceParams.clientIcePwd ? "v1" : "v2";
  }
  createAnswerSdp(e, t) {
    DCHECK(this._answerSession, "_answerSession should be existed");
    const i = _objectSpread2({}, this._answerSession);
    i.media = e, i.groups = t;
    return lib.write(i);
  }
  destroy() {
    this._print("destroy", this._peerConnectionId), super.removeAllListeners(), this.closeIceConnect(), this._destroyed = true, this._reportTimer && (clearTimeout(this._reportTimer), delete this._reportTimer), this._onLineCheckerTimer && (clearInterval(this._onLineCheckerTimer), delete this._onLineCheckerTimer), delete this._pc;
  }
  _genIceInfo(e) {
    var t, i;
    return { offerIce: { iceUfrag: null === (t = e.iceParams) || void 0 === t ? void 0 : t.clientIceUfrag, icePwd: null === (i = e.iceParams) || void 0 === i ? void 0 : i.clientIcePwd, iceOptions: "renomination" }, answerIce: parseAnswerIceParams(e) };
  }
  async _reportTransportStats() {
    const e = await this.getStatsWithLowFrequency(), t = {};
    var i;
    (e.forEach((e2) => {
      "transport" === e2.type ? (t.dtls_state = e2.dtlsState, t.bytes_received = e2.bytesReceived, t.bytes_sent = e2.bytesSent, t.ice_state = e2.iceState, t.packets_received = e2.packetsReceived, t.packets_sent = e2.packetsSent, t.selected_candidate_pair_changes = e2.selectedCandidatePairChanges) : "local-candidate" === e2.type || "remote-candidate" === e2.type ? t.candidates_info = [...t.candidates_info || [], { id: e2.id, is_remote: e2.isRemote, port: e2.port, protocol: e2.protocol, candidate_type: e2.candidateType, priority: e2.priority, network_type: e2.networkType, candidate_ip: e2.ip }] : "candidate-pair" === e2.type && (t.candidatePairsInfo = {}, t.candidatePairsInfo.candidate_state = e2.state, t.candidatePairsInfo.writable_state = e2.writable, t.candidatePairsInfo.sent_ping_requests_total = e2.requestsSent, t.candidatePairsInfo.recv_ping_requests = e2.requestsReceived, t.candidatePairsInfo.sent_ping_responses = e2.responsesSent, t.candidatePairsInfo.recv_ping_responses = e2.responsesReceived, t.candidatePairsInfo.current_rtt = e2.currentRoundTripTime, t.candidatePairsInfo.total_rtt = e2.totalRoundTripTime, ["localCandidateId", "remoteCandidateId", "bytesSent", "bytesReceived", "availableOutgoingBitrate", "availableIncomingBitrate", "bytesDiscardedOnSend", "consentRequestsSent", "packetsDiscardedOnSend", "lastPacketReceivedTimestamp", "lastPacketSentTimestamp"].forEach((i2) => {
        void 0 !== e2[i2] && (t.candidatePairsInfo[camel2Snake(i2)] = e2[i2]);
      }));
    }), Object.keys(t).length > 0) && (null === (i = this._monitor) || void 0 === i || i.report("rtc_transport_statistics", t));
    if (!this._destroyed) {
      const e2 = "connected" === this._pc.iceConnectionState && "connected" === this._pc.connectionState;
      this._reportTimer = setTimeout(() => {
        this._reportTransportStats();
      }, e2 ? 5e3 : 1e3);
    }
  }
  _print(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    this._logger.info("".concat(e), ...i);
  }
  _report(e, t, i) {
    var r, o, n;
    null === (r = this._monitor) || void 0 === r || r.report(e, _objectSpread2(_objectSpread2({}, t), {}, { connection_id: this._peerConnectionId, group_connection_id: this._groupConnectionId }), _objectSpread2(_objectSpread2({}, i), {}, { tcp_only: null === (o = this._iceNode) || void 0 === o ? void 0 : o.iceConfig.tcpOnly, ms_addr: JSON.stringify((null === (n = this._iceNode) || void 0 === n ? void 0 : n.publicIPs.map((e2) => ({ ip: e2.ip, tcp: e2.tcpPorts, udp: e2.udpPorts }))) || []) }));
  }
  _reportRtcInvokeStatus(e, t) {
    this._report("rtc_invoke_status", { sdk_api_name: e, message: t, error_code: 0, stream_id: "", elapse: 0 });
  }
};
var genPeerConfig = (e) => {
  const t = _objectSpread2({}, peerConnectionConfiguration);
  return e.pcKillSwitch.ctor_sdpsemantics_add && (t.sdpSemantics = "unified-plan"), e.pcKillSwitch.ctor_encodedinsetablestream_add && encodedTransformSupported$3 && !getParameter("DISABLE_ENCODED_TRANSFORM") && (t.encodedInsertableStreams = true), t;
};
var InternalReconnectReason = ((e) => (e.ICE_FAILED = "ice failed", e.DC_ERROR = "datachannel onerror", e.DC_CLOSE = "datachannel onclose", e.NODE_CHANGE = "recv nodeChange signaling", e.NOTIFY_RECONNECT = "recv notifyReconnect signaling", e.JOIN_TIMEOUT = "joinRoom timeout, retry with tcp only", e))(InternalReconnectReason || {});
var ConnectionManager = class extends EnhancedEventEmitter {
  constructor(e) {
    super(), _defineProperty(this, "id", void 0), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "logger", void 0), _defineProperty(this, "_getAccessManager", void 0), _defineProperty(this, "_connectionPool", /* @__PURE__ */ new Map()), _defineProperty(this, "_curConnection", void 0), _defineProperty(this, "_hasReportBrowerWarning", false), _defineProperty(this, "_reconnectTimer", void 0), _defineProperty(this, "_connecting", false), _defineProperty(this, "_isFirstTimeConnected", true), _defineProperty(this, "_feedbackNodes", []), _defineProperty(this, "_preIceStartTime", -1), _defineProperty(this, "_tcpOnlyTimer", void 0), _defineProperty(this, "_destroyed", false), this._ctx = e, this.id = e.id, this._monitor = getMonitor(this.id), this.logger = new Logger$1("ConnectionManager", 3, this.id), this.logger.info("constructor", "invoke"), this._getAccessManager = new IceConfigRequestManager(e);
  }
  startup() {
    this.logger.info("connect", "invoke");
    try {
      PeerConnection.checkSupported();
    } catch (e) {
      this.asyncEmit("disconnected", e);
    }
    this._connecting || (this._onConnectStart(), Promise.resolve().then(() => this.emit("__onGetIceConfigHook")), this._getAccess());
  }
  async reconnectByNodeChange(e) {
    var t, i, r;
    this.logger.info("reconnectByNodeChange", "invoke %o", e);
    const { nodes: o, reason: n } = e;
    null === (t = this._monitor) || void 0 === t || t.report("rtc_node_change", { error_code: 0, message: JSON.stringify(e), reason: JSON.stringify(n) }), sdkCache.clearAccessNode(this._ctx.appId), null === (i = this._curConnection) || void 0 === i || i.pc.reportRtcPreIce("node_change");
    const s = (null === (r = this._curConnection) || void 0 === r || null === (r = r.node.publicIPs[0]) || void 0 === r ? void 0 : r.ip) || "";
    this._closeCurrentConnection(), this._clearConnectionPool(), this._clearReconnectTimer(), this._onConnectStart("recv nodeChange signaling"), Array.isArray(o) && o.length > 0 ? this._startIceConnect(o) : this._getAccess([{ feedbackIP: s, feedbackReason: { type: "NODE_CHANGED", reason: n } }]);
  }
  async reconnect(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.logger.info("reconnect", "invoke. ".concat(t ? "ICE over TCP" : "")), this._closeCurrentConnection(), this._clearConnectionPool(), this._clearReconnectTimer(), this._onConnectStart(e), this._getAccess(void 0, t);
  }
  shotdown() {
    this.logger.info("destroy", "invoke"), this._destroyed = true, this.asyncEmit("disconnected", new SDKError(ErrorCode.OPERATION_CANCEL, "destroy")).then(() => {
      super.removeAllListeners();
    }), this._clearReconnectTimer(), this._clearConnectionPool(), this._getAccessManager.destroy(), this._closeCurrentConnection();
  }
  _getAccess(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this._getAccessManager.getICENode(e).then((e2) => {
      this.emit("__onGetIceSuccessHook", e2), this._startIceConnect(e2, t);
    }).catch((e2) => {
      this.asyncEmit("disconnected", e2);
    }).finally(() => {
      this._feedbackNodes = [];
    });
  }
  _startIceConnect(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (this._destroyed) return;
    this.logger.info("_startIceConnect", "invoke");
    const i = genUuid$1();
    this._preIceStartTime = getServerNow();
    const r = this._ctx.joinRoomConfig.useTcpJoin, o = this._ctx.joinRoomConfig.useTcpJoinDelay, n = async (r2) => {
      t && ((r2 = cloneDeep(r2)).iceConfig.tcpOnly = true);
      const o2 = { node: r2 };
      try {
        const t2 = new PeerConnection(this._ctx, i, !this._isFirstTimeConnected);
        o2.pc = t2, this._connectionPool.set(t2.uuid, o2);
        const n2 = await t2.startIceConnect(r2), s = new DataChannelSignaling(this.id, n2, { connection_id: t2.getConnectionId(), group_connection_id: i });
        o2.signaling = s, t2.reportRtcPreIce("datachannel_send_ping"), await s.sendPingSignaling(), t2.reportRtcPreIce("datachannel_recv_pong"), this._onConnectSuccess({ node: r2, pc: t2, signaling: s, dc: n2 }), this.safeEmit("__onConnectSuccessHook", e.length);
      } catch (e2) {
        this._onConnectionFailed(o2, e2);
      }
    };
    this.emit("__onIceConnectStartHook"), e.forEach(n), r && !t && (this.logger.info("_startIceConnect", "tcp-only will try after ".concat(o, "ms")), this._tcpOnlyTimer = setTimeout(() => {
      this.emit("connectWidthTcp"), e.forEach((e2) => {
        (e2 = cloneDeep(e2)).iceConfig.tcpOnly = true, n(e2);
      }), delete this._tcpOnlyTimer;
    }, o));
  }
  _onConnectSuccess(e) {
    var t;
    (this.logger.info("connect", "peer_%s connect success.", e.pc.uuid), this.emit("__onIceConnectSuccessHook", e), this._curConnection) ? (e.pc.destroy(), e.signaling.destroy(), this._connectionPool.delete(e.pc.uuid)) : (this._curConnection = e, this._addConnectionHandler(e.pc), null === (t = this._monitor) || void 0 === t || t.set({ connection_id: e.pc.getConnectionId() }), this._connectionPool.delete(e.pc.uuid), this._feedbackNodes.forEach((e2) => this._feedbackBySignaling(e2)), this._feedbackNodes = [], this._onConnectEnded(e));
  }
  _onConnectionFailed(e, t) {
    var i, r;
    (this.logger.info("connect", "peer_%s connect failed. %s", (null === (i = e.pc) || void 0 === i ? void 0 : i.uuid) || "", t.message), this.emit("__onIceConnectFailedHook", e), t.code !== ConnectFailCode.DESTROY && t.code !== ErrorCode.OPERATION_CANCEL) && (this._curConnection ? this._feedbackBySignaling(e.node) : this._feedbackNodes.push(e.node), this.logger.info("connect", "remove cache node"), sdkCache.deleteAccessNode(this._ctx.appId, e.node), e.pc && (this._connectionPool.delete(e.pc.uuid), e.pc.destroy()), null === (r = e.signaling) || void 0 === r || r.destroy(), 0 !== this._connectionPool.size || this._curConnection || this._destroyed || (this.logger.error("connect", "establish peerConnection failed"), this._checkBrowserUA(), getServerNow() - this._preIceStartTime < 1e3 ? (this._clearReconnectTimer(), this._reconnectTimer = setTimeout(() => {
      delete this._reconnectTimer, this._reconnectWithIceFailed(this._feedbackNodes);
    }, 1e3)) : this._reconnectWithIceFailed(this._feedbackNodes)));
  }
  _feedbackBySignaling(e) {
    var t;
    null === (t = this._curConnection) || void 0 === t || t.signaling.sendSignaling("scheduleMessage", { type: "feedback", body: { feedbackIP: e.publicIPs[0].ip, feedbackReason: { type: "ICE_FAILED", reason: {} } } });
  }
  async _reconnectWithIceFailed(e) {
    this._onConnectStart("ice failed"), this.logger.warn("reconnect", "because of ice failed"), this._getAccess(e.map((e2) => ({ feedbackIP: e2.publicIPs[0].ip, feedbackReason: { type: "ICE_FAILED", reason: {} } })));
  }
  _checkBrowserUA() {
    var e;
    !this._hasReportBrowerWarning && this._ctx.joinRoomConfig.isBlackBrower() && (this._hasReportBrowerWarning = true, null === (e = this._monitor) || void 0 === e || e.report("rtc_error", { error_code: RtcErrorCode.BLACK_BROWSER, message: "failed to establish data-channel, and the current browser is on the browser blacklist." }));
  }
  _onConnectStart(e) {
    var t;
    this.logger.info("_onConnectStart", "invoke, reason: ".concat(e || "init")), this._connecting = true, e ? this.asyncEmit("reconnecting", e) : this.asyncEmit("connecting");
    const i = genUuid$1();
    var r;
    (null === (t = this._monitor) || void 0 === t || t.set({ connect_session_id: i }), this._isFirstTimeConnected) || (null === (r = this._monitor) || void 0 === r || r.report("rtc_reconnect", { error_code: 1002, message: "peerconnection reconnecting", reconnect_id: i, reconnect_type: "peerconnection" }, { reason: e }));
  }
  _onConnectEnded(e) {
    var t;
    (this.logger.info("_onConnectEnded", "invoke"), this._connecting = false, this._isFirstTimeConnected) || (null === (t = this._monitor) || void 0 === t || t.report("rtc_reconnected", { message: "peerconnection reconnected", reconnect_type: "peerconnection" }));
    this._isFirstTimeConnected = false, this.asyncEmit("connected", e), e.node.iceConfig.tcpOnly && (this.logger.info("_onConnectEnded", "use tcp only"), reportRtcInvokeStatus(this._ctx.id, "connected_with_tcp_only", JSON.stringify(e.node))), this._tcpOnlyTimer && (window.clearTimeout(this._tcpOnlyTimer), delete this._tcpOnlyTimer), this._clearConnectionPool();
  }
  _addConnectionHandler(e) {
    e.on("disconnect", (e2) => {
      this._closeCurrentConnection(), this._clearReconnectTimer(), navigator.onLine ? this.reconnect(e2) : this._reconnectTimer = setTimeout(() => this.reconnect(e2), 3e3);
    });
  }
  _closeCurrentConnection() {
    var e, t;
    null === (e = this._curConnection) || void 0 === e || e.pc.destroy(), null === (t = this._curConnection) || void 0 === t || t.signaling.destroy(), delete this._curConnection;
  }
  _clearConnectionPool() {
    this._connectionPool.forEach((e, t) => {
      var i, r;
      null === (i = e.signaling) || void 0 === i || i.destroy(), null === (r = e.pc) || void 0 === r || r.destroy(), this._connectionPool.delete(t);
    });
  }
  _clearReconnectTimer() {
    this._reconnectTimer && (window.clearTimeout(this._reconnectTimer), delete this._reconnectTimer);
  }
};
var WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;
var asyncIterator$4 = WrappedWellKnownSymbolModule.f("asyncIterator");
var parent$8 = asyncIterator$4;
var asyncIterator$3 = parent$8;
var parent$7 = asyncIterator$3;
var asyncIterator$2 = parent$7;
var parent$6 = asyncIterator$2;
var asyncIterator$1 = parent$6;
var asyncIterator = asyncIterator$1;
var _Symbol$asyncIterator = getDefaultExportFromCjs(asyncIterator);
var hasOwn$1 = hasOwnProperty_1;
var ownKeys2 = ownKeys$3;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule = objectDefineProperty;
var copyConstructorProperties$1 = function(e, t, i) {
  for (var r = ownKeys2(t), o = definePropertyModule.f, n = getOwnPropertyDescriptorModule.f, s = 0; s < r.length; s++) {
    var a = r[s];
    hasOwn$1(e, a) || i && hasOwn$1(i, a) || o(e, a, n(t, a));
  }
};
var isObject$2 = isObject$g;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$7;
var installErrorCause$1 = function(e, t) {
  isObject$2(t) && "cause" in t && createNonEnumerableProperty$2(e, "cause", t.cause);
};
var uncurryThis = functionUncurryThis;
var $Error$1 = Error;
var replace = uncurryThis("".replace);
var TEST = String(new $Error$1("zxcasd").stack);
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
var errorStackClear = function(e, t) {
  if (IS_V8_OR_CHAKRA_STACK && "string" == typeof e && !$Error$1.prepareStackTrace) for (; t--; ) e = replace(e, V8_OR_CHAKRA_STACK_ENTRY, "");
  return e;
};
var fails$2 = fails$s;
var createPropertyDescriptor$1 = createPropertyDescriptor$8;
var errorStackInstallable = !fails$2(function() {
  var e = new Error("a");
  return !("stack" in e) || (Object.defineProperty(e, "stack", createPropertyDescriptor$1(1, 7)), 7 !== e.stack);
});
var createNonEnumerableProperty$1 = createNonEnumerableProperty$7;
var clearErrorStack = errorStackClear;
var ERROR_STACK_INSTALLABLE = errorStackInstallable;
var captureStackTrace = Error.captureStackTrace;
var errorStackInstall = function(e, t, i, r) {
  ERROR_STACK_INSTALLABLE && (captureStackTrace ? captureStackTrace(e, t) : createNonEnumerableProperty$1(e, "stack", clearErrorStack(i, r)));
};
var bind$3 = functionBindContext;
var call$5 = functionCall;
var anObject$2 = anObject$d;
var tryToString$1 = tryToString$6;
var isArrayIteratorMethod = isArrayIteratorMethod$2;
var lengthOfArrayLike = lengthOfArrayLike$9;
var isPrototypeOf$1 = objectIsPrototypeOf;
var getIterator = getIterator$3;
var getIteratorMethod = getIteratorMethod$4;
var iteratorClose = iteratorClose$2;
var $TypeError$2 = TypeError;
var Result = function(e, t) {
  this.stopped = e, this.result = t;
};
var ResultPrototype = Result.prototype;
var iterate$6 = function(e, t, i) {
  var r, o, n, s, a, d, c2, l = i && i.that, u = !(!i || !i.AS_ENTRIES), h = !(!i || !i.IS_RECORD), _ = !(!i || !i.IS_ITERATOR), p = !(!i || !i.INTERRUPTED), m = bind$3(t, l), S = function(e2) {
    return r && iteratorClose(r, "normal", e2), new Result(true, e2);
  }, g = function(e2) {
    return u ? (anObject$2(e2), p ? m(e2[0], e2[1], S) : m(e2[0], e2[1])) : p ? m(e2, S) : m(e2);
  };
  if (h) r = e.iterator;
  else if (_) r = e;
  else {
    if (!(o = getIteratorMethod(e))) throw new $TypeError$2(tryToString$1(e) + " is not iterable");
    if (isArrayIteratorMethod(o)) {
      for (n = 0, s = lengthOfArrayLike(e); s > n; n++) if ((a = g(e[n])) && isPrototypeOf$1(ResultPrototype, a)) return a;
      return new Result(false);
    }
    r = getIterator(e, o);
  }
  for (d = h ? e.next : r.next; !(c2 = call$5(d, r)).done; ) {
    try {
      a = g(c2.value);
    } catch (e2) {
      iteratorClose(r, "throw", e2);
    }
    if ("object" == typeof a && a && isPrototypeOf$1(ResultPrototype, a)) return a;
  }
  return new Result(false);
};
var toString4 = toString$e;
var normalizeStringArgument$1 = function(e, t) {
  return void 0 === e ? arguments.length < 2 ? "" : t : toString4(e);
};
var $$c = _export;
var isPrototypeOf = objectIsPrototypeOf;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf = objectSetPrototypeOf;
var copyConstructorProperties = copyConstructorProperties$1;
var create3 = objectCreate;
var createNonEnumerableProperty = createNonEnumerableProperty$7;
var createPropertyDescriptor = createPropertyDescriptor$8;
var installErrorCause = installErrorCause$1;
var installErrorStack = errorStackInstall;
var iterate$5 = iterate$6;
var normalizeStringArgument = normalizeStringArgument$1;
var wellKnownSymbol$4 = wellKnownSymbol$q;
var TO_STRING_TAG = wellKnownSymbol$4("toStringTag");
var $Error = Error;
var push2 = [].push;
var $AggregateError = function(e, t) {
  var i, r = isPrototypeOf(AggregateErrorPrototype, this);
  setPrototypeOf ? i = setPrototypeOf(new $Error(), r ? getPrototypeOf(this) : AggregateErrorPrototype) : (i = r ? this : create3(AggregateErrorPrototype), createNonEnumerableProperty(i, TO_STRING_TAG, "Error")), void 0 !== t && createNonEnumerableProperty(i, "message", normalizeStringArgument(t)), installErrorStack(i, $AggregateError, i.stack, 1), arguments.length > 2 && installErrorCause(i, arguments[2]);
  var o = [];
  return iterate$5(e, push2, { that: o }), createNonEnumerableProperty(i, "errors", o), i;
};
setPrototypeOf ? setPrototypeOf($AggregateError, $Error) : copyConstructorProperties($AggregateError, $Error, { name: true });
var AggregateErrorPrototype = $AggregateError.prototype = create3($Error.prototype, { constructor: createPropertyDescriptor(1, $AggregateError), message: createPropertyDescriptor(1, ""), name: createPropertyDescriptor(1, "AggregateError") });
$$c({ global: true, constructor: true, arity: 2 }, { AggregateError: $AggregateError });
var $location;
var defer;
var channel;
var port;
var globalThis$7 = globalThis_1;
var userAgent$3 = environmentUserAgent;
var classof = classofRaw$2;
var userAgentStartsWith = function(e) {
  return userAgent$3.slice(0, e.length) === e;
};
var environment = userAgentStartsWith("Bun/") ? "BUN" : userAgentStartsWith("Cloudflare-Workers") ? "CLOUDFLARE" : userAgentStartsWith("Deno/") ? "DENO" : userAgentStartsWith("Node.js/") ? "NODE" : globalThis$7.Bun && "string" == typeof Bun.version ? "BUN" : globalThis$7.Deno && "object" == typeof Deno.version ? "DENO" : "process" === classof(globalThis$7.process) ? "NODE" : globalThis$7.window && globalThis$7.document ? "BROWSER" : "REST";
var ENVIRONMENT$1 = environment;
var environmentIsNode = "NODE" === ENVIRONMENT$1;
var getBuiltIn$3 = getBuiltIn$h;
var defineBuiltInAccessor = defineBuiltInAccessor$4;
var wellKnownSymbol$3 = wellKnownSymbol$q;
var DESCRIPTORS = descriptors;
var SPECIES$2 = wellKnownSymbol$3("species");
var setSpecies$1 = function(e) {
  var t = getBuiltIn$3(e);
  DESCRIPTORS && t && !t[SPECIES$2] && defineBuiltInAccessor(t, SPECIES$2, { configurable: true, get: function() {
    return this;
  } });
};
var isConstructor3 = isConstructor$3;
var tryToString = tryToString$6;
var $TypeError$1 = TypeError;
var aConstructor$1 = function(e) {
  if (isConstructor3(e)) return e;
  throw new $TypeError$1(tryToString(e) + " is not a constructor");
};
var anObject$1 = anObject$d;
var aConstructor = aConstructor$1;
var isNullOrUndefined = isNullOrUndefined$5;
var wellKnownSymbol$2 = wellKnownSymbol$q;
var SPECIES$1 = wellKnownSymbol$2("species");
var speciesConstructor$2 = function(e, t) {
  var i, r = anObject$1(e).constructor;
  return void 0 === r || isNullOrUndefined(i = anObject$1(r)[SPECIES$1]) ? t : aConstructor(i);
};
var userAgent$2 = environmentUserAgent;
var environmentIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);
var globalThis$6 = globalThis_1;
var apply$1 = functionApply;
var bind$2 = functionBindContext;
var isCallable$3 = isCallable$l;
var hasOwn2 = hasOwnProperty_1;
var fails$1 = fails$s;
var html = html$2;
var arraySlice = arraySlice$5;
var createElement = documentCreateElement$1;
var validateArgumentsLength = validateArgumentsLength$5;
var IS_IOS$1 = environmentIsIos;
var IS_NODE$2 = environmentIsNode;
var set2 = globalThis$6.setImmediate;
var clear = globalThis$6.clearImmediate;
var process$2 = globalThis$6.process;
var Dispatch = globalThis$6.Dispatch;
var Function$1 = globalThis$6.Function;
var MessageChannel$1 = globalThis$6.MessageChannel;
var String$1 = globalThis$6.String;
var counter = 0;
var queue$2 = {};
var ONREADYSTATECHANGE = "onreadystatechange";
fails$1(function() {
  $location = globalThis$6.location;
});
var run = function(e) {
  if (hasOwn2(queue$2, e)) {
    var t = queue$2[e];
    delete queue$2[e], t();
  }
};
var runner = function(e) {
  return function() {
    run(e);
  };
};
var eventListener = function(e) {
  run(e.data);
};
var globalPostMessageDefer = function(e) {
  globalThis$6.postMessage(String$1(e), $location.protocol + "//" + $location.host);
};
set2 && clear || (set2 = function(e) {
  validateArgumentsLength(arguments.length, 1);
  var t = isCallable$3(e) ? e : Function$1(e), i = arraySlice(arguments, 1);
  return queue$2[++counter] = function() {
    apply$1(t, void 0, i);
  }, defer(counter), counter;
}, clear = function(e) {
  delete queue$2[e];
}, IS_NODE$2 ? defer = function(e) {
  process$2.nextTick(runner(e));
} : Dispatch && Dispatch.now ? defer = function(e) {
  Dispatch.now(runner(e));
} : MessageChannel$1 && !IS_IOS$1 ? (port = (channel = new MessageChannel$1()).port2, channel.port1.onmessage = eventListener, defer = bind$2(port.postMessage, port)) : globalThis$6.addEventListener && isCallable$3(globalThis$6.postMessage) && !globalThis$6.importScripts && $location && "file:" !== $location.protocol && !fails$1(globalPostMessageDefer) ? (defer = globalPostMessageDefer, globalThis$6.addEventListener("message", eventListener, false)) : defer = ONREADYSTATECHANGE in createElement("script") ? function(e) {
  html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
    html.removeChild(this), run(e);
  };
} : function(e) {
  setTimeout(runner(e), 0);
});
var task$1 = { set: set2, clear };
var Queue$2 = function() {
  this.head = null, this.tail = null;
};
Queue$2.prototype = { add: function(e) {
  var t = { item: e, next: null }, i = this.tail;
  i ? i.next = t : this.head = t, this.tail = t;
}, get: function() {
  var e = this.head;
  if (e) return null === (this.head = e.next) && (this.tail = null), e.item;
} };
var notify$1;
var toggle;
var node;
var promise$5;
var then;
var queue$1 = Queue$2;
var userAgent$1 = environmentUserAgent;
var environmentIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && "undefined" != typeof Pebble;
var userAgent = environmentUserAgent;
var environmentIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);
var globalThis$5 = globalThis_1;
var safeGetBuiltIn = safeGetBuiltIn$2;
var bind$1 = functionBindContext;
var macrotask = task$1.set;
var Queue$1 = queue$1;
var IS_IOS = environmentIsIos;
var IS_IOS_PEBBLE = environmentIsIosPebble;
var IS_WEBOS_WEBKIT = environmentIsWebosWebkit;
var IS_NODE$1 = environmentIsNode;
var MutationObserver = globalThis$5.MutationObserver || globalThis$5.WebKitMutationObserver;
var document$2 = globalThis$5.document;
var process$1 = globalThis$5.process;
var Promise$2 = globalThis$5.Promise;
var microtask$1 = safeGetBuiltIn("queueMicrotask");
if (!microtask$1) {
  queue = new Queue$1(), flush = function() {
    var e, t;
    for (IS_NODE$1 && (e = process$1.domain) && e.exit(); t = queue.get(); ) try {
      t();
    } catch (e2) {
      throw queue.head && notify$1(), e2;
    }
    e && e.enter();
  };
  IS_IOS || IS_NODE$1 || IS_WEBOS_WEBKIT || !MutationObserver || !document$2 ? !IS_IOS_PEBBLE && Promise$2 && Promise$2.resolve ? ((promise$5 = Promise$2.resolve(void 0)).constructor = Promise$2, then = bind$1(promise$5.then, promise$5), notify$1 = function() {
    then(flush);
  }) : IS_NODE$1 ? notify$1 = function() {
    process$1.nextTick(flush);
  } : (macrotask = bind$1(macrotask, globalThis$5), notify$1 = function() {
    macrotask(flush);
  }) : (toggle = true, node = document$2.createTextNode(""), new MutationObserver(flush).observe(node, { characterData: true }), notify$1 = function() {
    node.data = toggle = !toggle;
  }), microtask$1 = function(e) {
    queue.head || notify$1(), queue.add(e);
  };
}
var queue;
var flush;
var microtask_1 = microtask$1;
var hostReportErrors$1 = function(e, t) {
  try {
    1 === arguments.length ? console.error(e) : console.error(e, t);
  } catch (e2) {
  }
};
var perform$6 = function(e) {
  try {
    return { error: false, value: e() };
  } catch (e2) {
    return { error: true, value: e2 };
  }
};
var globalThis$4 = globalThis_1;
var promiseNativeConstructor = globalThis$4.Promise;
var globalThis$3 = globalThis_1;
var NativePromiseConstructor$5 = promiseNativeConstructor;
var isCallable$2 = isCallable$l;
var isForced = isForced_1;
var inspectSource = inspectSource$2;
var wellKnownSymbol$1 = wellKnownSymbol$q;
var ENVIRONMENT = environment;
var V8_VERSION = environmentV8Version;
var NativePromisePrototype$2 = NativePromiseConstructor$5 && NativePromiseConstructor$5.prototype;
var SPECIES = wellKnownSymbol$1("species");
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$2(globalThis$3.PromiseRejectionEvent);
var FORCED_PROMISE_CONSTRUCTOR$5 = isForced("Promise", function() {
  var e = inspectSource(NativePromiseConstructor$5), t = e !== String(NativePromiseConstructor$5);
  if (!t && 66 === V8_VERSION) return true;
  if (!NativePromisePrototype$2.catch || !NativePromisePrototype$2.finally) return true;
  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(e)) {
    var i = new NativePromiseConstructor$5(function(e2) {
      e2(1);
    }), r = function(e2) {
      e2(function() {
      }, function() {
      });
    };
    if ((i.constructor = {})[SPECIES] = r, !(SUBCLASSING = i.then(function() {
    }) instanceof r)) return true;
  }
  return !(t || "BROWSER" !== ENVIRONMENT && "DENO" !== ENVIRONMENT || NATIVE_PROMISE_REJECTION_EVENT$1);
});
var promiseConstructorDetection = { CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5, REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1, SUBCLASSING };
var newPromiseCapability$2 = {};
var aCallable$6 = aCallable$c;
var $TypeError = TypeError;
var PromiseCapability = function(e) {
  var t, i;
  this.promise = new e(function(e2, r) {
    if (void 0 !== t || void 0 !== i) throw new $TypeError("Bad Promise constructor");
    t = e2, i = r;
  }), this.resolve = aCallable$6(t), this.reject = aCallable$6(i);
};
newPromiseCapability$2.f = function(e) {
  return new PromiseCapability(e);
};
var $$b = _export;
var IS_NODE = environmentIsNode;
var globalThis$2 = globalThis_1;
var call$4 = functionCall;
var defineBuiltIn = defineBuiltIn$8;
var setToStringTag = setToStringTag$9;
var setSpecies = setSpecies$1;
var aCallable$5 = aCallable$c;
var isCallable$1 = isCallable$l;
var isObject$1 = isObject$g;
var anInstance = anInstance$3;
var speciesConstructor$1 = speciesConstructor$2;
var task = task$1.set;
var microtask = microtask_1;
var hostReportErrors = hostReportErrors$1;
var perform$5 = perform$6;
var Queue = queue$1;
var InternalStateModule = internalState;
var NativePromiseConstructor$4 = promiseNativeConstructor;
var PromiseConstructorDetection = promiseConstructorDetection;
var newPromiseCapabilityModule$7 = newPromiseCapability$2;
var PROMISE = "Promise";
var FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
PromiseConstructorDetection.SUBCLASSING;
var Internal;
var OwnPromiseCapability;
var PromiseWrapper;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var NativePromisePrototype$1 = NativePromiseConstructor$4 && NativePromiseConstructor$4.prototype;
var PromiseConstructor = NativePromiseConstructor$4;
var PromisePrototype = NativePromisePrototype$1;
var TypeError$1 = globalThis$2.TypeError;
var document$1 = globalThis$2.document;
var process = globalThis$2.process;
var newPromiseCapability$1 = newPromiseCapabilityModule$7.f;
var newGenericPromiseCapability = newPromiseCapability$1;
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && globalThis$2.dispatchEvent);
var UNHANDLED_REJECTION = "unhandledrejection";
var REJECTION_HANDLED = "rejectionhandled";
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var isThenable = function(e) {
  var t;
  return !(!isObject$1(e) || !isCallable$1(t = e.then)) && t;
};
var callReaction = function(e, t) {
  var i, r, o, n = t.value, s = t.state === FULFILLED, a = s ? e.ok : e.fail, d = e.resolve, c2 = e.reject, l = e.domain;
  try {
    a ? (s || (t.rejection === UNHANDLED && onHandleUnhandled(t), t.rejection = HANDLED), true === a ? i = n : (l && l.enter(), i = a(n), l && (l.exit(), o = true)), i === e.promise ? c2(new TypeError$1("Promise-chain cycle")) : (r = isThenable(i)) ? call$4(r, i, d, c2) : d(i)) : c2(n);
  } catch (e2) {
    l && !o && l.exit(), c2(e2);
  }
};
var notify = function(e, t) {
  e.notified || (e.notified = true, microtask(function() {
    for (var i, r = e.reactions; i = r.get(); ) callReaction(i, e);
    e.notified = false, t && !e.rejection && onUnhandled(e);
  }));
};
var dispatchEvent = function(e, t, i) {
  var r, o;
  DISPATCH_EVENT ? ((r = document$1.createEvent("Event")).promise = t, r.reason = i, r.initEvent(e, false, true), globalThis$2.dispatchEvent(r)) : r = { promise: t, reason: i }, !NATIVE_PROMISE_REJECTION_EVENT && (o = globalThis$2["on" + e]) ? o(r) : e === UNHANDLED_REJECTION && hostReportErrors("Unhandled promise rejection", i);
};
var onUnhandled = function(e) {
  call$4(task, globalThis$2, function() {
    var t, i = e.facade, r = e.value;
    if (isUnhandled(e) && (t = perform$5(function() {
      IS_NODE ? process.emit("unhandledRejection", r, i) : dispatchEvent(UNHANDLED_REJECTION, i, r);
    }), e.rejection = IS_NODE || isUnhandled(e) ? UNHANDLED : HANDLED, t.error)) throw t.value;
  });
};
var isUnhandled = function(e) {
  return e.rejection !== HANDLED && !e.parent;
};
var onHandleUnhandled = function(e) {
  call$4(task, globalThis$2, function() {
    var t = e.facade;
    IS_NODE ? process.emit("rejectionHandled", t) : dispatchEvent(REJECTION_HANDLED, t, e.value);
  });
};
var bind = function(e, t, i) {
  return function(r) {
    e(t, r, i);
  };
};
var internalReject = function(e, t, i) {
  e.done || (e.done = true, i && (e = i), e.value = t, e.state = REJECTED, notify(e, true));
};
var internalResolve = function(e, t, i) {
  if (!e.done) {
    e.done = true, i && (e = i);
    try {
      if (e.facade === t) throw new TypeError$1("Promise can't be resolved itself");
      var r = isThenable(t);
      r ? microtask(function() {
        var i2 = { done: false };
        try {
          call$4(r, t, bind(internalResolve, i2, e), bind(internalReject, i2, e));
        } catch (t2) {
          internalReject(i2, t2, e);
        }
      }) : (e.value = t, e.state = FULFILLED, notify(e, false));
    } catch (t2) {
      internalReject({ done: false }, t2, e);
    }
  }
};
FORCED_PROMISE_CONSTRUCTOR$4 && (PromisePrototype = (PromiseConstructor = function(e) {
  anInstance(this, PromisePrototype), aCallable$5(e), call$4(Internal, this);
  var t = getInternalPromiseState(this);
  try {
    e(bind(internalResolve, t), bind(internalReject, t));
  } catch (e2) {
    internalReject(t, e2);
  }
}).prototype, (Internal = function(e) {
  setInternalState(this, { type: PROMISE, done: false, notified: false, parent: false, reactions: new Queue(), rejection: false, state: PENDING, value: null });
}).prototype = defineBuiltIn(PromisePrototype, "then", function(e, t) {
  var i = getInternalPromiseState(this), r = newPromiseCapability$1(speciesConstructor$1(this, PromiseConstructor));
  return i.parent = true, r.ok = !isCallable$1(e) || e, r.fail = isCallable$1(t) && t, r.domain = IS_NODE ? process.domain : void 0, i.state === PENDING ? i.reactions.add(r) : microtask(function() {
    callReaction(r, i);
  }), r.promise;
}), OwnPromiseCapability = function() {
  var e = new Internal(), t = getInternalPromiseState(e);
  this.promise = e, this.resolve = bind(internalResolve, t), this.reject = bind(internalReject, t);
}, newPromiseCapabilityModule$7.f = newPromiseCapability$1 = function(e) {
  return e === PromiseConstructor || e === PromiseWrapper ? new OwnPromiseCapability(e) : newGenericPromiseCapability(e);
}), $$b({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, { Promise: PromiseConstructor }), setToStringTag(PromiseConstructor, PROMISE, false, true), setSpecies(PROMISE);
var wellKnownSymbol = wellKnownSymbol$q;
var ITERATOR = wellKnownSymbol("iterator");
var SAFE_CLOSING = false;
try {
  called = 0, iteratorWithReturn = { next: function() {
    return { done: !!called++ };
  }, return: function() {
    SAFE_CLOSING = true;
  } };
  iteratorWithReturn[ITERATOR] = function() {
    return this;
  }, Array.from(iteratorWithReturn, function() {
    throw 2;
  });
} catch (e) {
}
var called;
var iteratorWithReturn;
var checkCorrectnessOfIteration$1 = function(e, t) {
  try {
    if (!t && !SAFE_CLOSING) return false;
  } catch (e2) {
    return false;
  }
  var i = false;
  try {
    var r = {};
    r[ITERATOR] = function() {
      return { next: function() {
        return { done: i = true };
      } };
    }, e(r);
  } catch (e2) {
  }
  return i;
};
var NativePromiseConstructor$3 = promiseNativeConstructor;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function(e) {
  NativePromiseConstructor$3.all(e).then(void 0, function() {
  });
});
var $$a = _export;
var call$3 = functionCall;
var aCallable$4 = aCallable$c;
var newPromiseCapabilityModule$6 = newPromiseCapability$2;
var perform$4 = perform$6;
var iterate$4 = iterate$6;
var PROMISE_STATICS_INCORRECT_ITERATION$3 = promiseStaticsIncorrectIteration;
$$a({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$3 }, { all: function(e) {
  var t = this, i = newPromiseCapabilityModule$6.f(t), r = i.resolve, o = i.reject, n = perform$4(function() {
    var i2 = aCallable$4(t.resolve), n2 = [], s = 0, a = 1;
    iterate$4(e, function(e2) {
      var d = s++, c2 = false;
      a++, call$3(i2, t, e2).then(function(e3) {
        c2 || (c2 = true, n2[d] = e3, --a || r(n2));
      }, o);
    }), --a || r(n2);
  });
  return n.error && o(n.value), i.promise;
} });
var $$9 = _export;
var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
promiseNativeConstructor && promiseNativeConstructor.prototype, $$9({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, { catch: function(e) {
  return this.then(void 0, e);
} });
var $$8 = _export;
var call$2 = functionCall;
var aCallable$3 = aCallable$c;
var newPromiseCapabilityModule$5 = newPromiseCapability$2;
var perform$3 = perform$6;
var iterate$3 = iterate$6;
var PROMISE_STATICS_INCORRECT_ITERATION$2 = promiseStaticsIncorrectIteration;
$$8({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$2 }, { race: function(e) {
  var t = this, i = newPromiseCapabilityModule$5.f(t), r = i.reject, o = perform$3(function() {
    var o2 = aCallable$3(t.resolve);
    iterate$3(e, function(e2) {
      call$2(o2, t, e2).then(i.resolve, r);
    });
  });
  return o.error && r(o.value), i.promise;
} });
var $$7 = _export;
var newPromiseCapabilityModule$4 = newPromiseCapability$2;
var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;
$$7({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, { reject: function(e) {
  var t = newPromiseCapabilityModule$4.f(this);
  return (0, t.reject)(e), t.promise;
} });
var anObject = anObject$d;
var isObject = isObject$g;
var newPromiseCapability = newPromiseCapability$2;
var promiseResolve$2 = function(e, t) {
  if (anObject(e), isObject(t) && t.constructor === e) return t;
  var i = newPromiseCapability.f(e);
  return (0, i.resolve)(t), i.promise;
};
var $$6 = _export;
var getBuiltIn$2 = getBuiltIn$h;
var IS_PURE = isPure;
var NativePromiseConstructor$1 = promiseNativeConstructor;
var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
var promiseResolve$1 = promiseResolve$2;
var PromiseConstructorWrapper = getBuiltIn$2("Promise");
var CHECK_WRAPPER = !FORCED_PROMISE_CONSTRUCTOR;
$$6({ target: "Promise", stat: true, forced: IS_PURE }, { resolve: function(e) {
  return promiseResolve$1(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor$1 : this, e);
} });
var $$5 = _export;
var call$1 = functionCall;
var aCallable$2 = aCallable$c;
var newPromiseCapabilityModule$3 = newPromiseCapability$2;
var perform$2 = perform$6;
var iterate$2 = iterate$6;
var PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;
$$5({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, { allSettled: function(e) {
  var t = this, i = newPromiseCapabilityModule$3.f(t), r = i.resolve, o = i.reject, n = perform$2(function() {
    var i2 = aCallable$2(t.resolve), o2 = [], n2 = 0, s = 1;
    iterate$2(e, function(e2) {
      var a = n2++, d = false;
      s++, call$1(i2, t, e2).then(function(e3) {
        d || (d = true, o2[a] = { status: "fulfilled", value: e3 }, --s || r(o2));
      }, function(e3) {
        d || (d = true, o2[a] = { status: "rejected", reason: e3 }, --s || r(o2));
      });
    }), --s || r(o2);
  });
  return n.error && o(n.value), i.promise;
} });
var $$4 = _export;
var call = functionCall;
var aCallable$1 = aCallable$c;
var getBuiltIn$1 = getBuiltIn$h;
var newPromiseCapabilityModule$2 = newPromiseCapability$2;
var perform$1 = perform$6;
var iterate$1 = iterate$6;
var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;
var PROMISE_ANY_ERROR = "No one promise resolved";
$$4({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, { any: function(e) {
  var t = this, i = getBuiltIn$1("AggregateError"), r = newPromiseCapabilityModule$2.f(t), o = r.resolve, n = r.reject, s = perform$1(function() {
    var r2 = aCallable$1(t.resolve), s2 = [], a = 0, d = 1, c2 = false;
    iterate$1(e, function(e2) {
      var l = a++, u = false;
      d++, call(r2, t, e2).then(function(e3) {
        u || c2 || (c2 = true, o(e3));
      }, function(e3) {
        u || c2 || (u = true, s2[l] = e3, --d || n(new i(s2, PROMISE_ANY_ERROR)));
      });
    }), --d || n(new i(s2, PROMISE_ANY_ERROR));
  });
  return s.error && n(s.value), r.promise;
} });
var $$3 = _export;
var globalThis$1 = globalThis_1;
var apply = functionApply;
var slice = arraySlice$5;
var newPromiseCapabilityModule$1 = newPromiseCapability$2;
var aCallable = aCallable$c;
var perform = perform$6;
var Promise$1 = globalThis$1.Promise;
var ACCEPT_ARGUMENTS = false;
var FORCED = !Promise$1 || !Promise$1.try || perform(function() {
  Promise$1.try(function(e) {
    ACCEPT_ARGUMENTS = 8 === e;
  }, 8);
}).error || !ACCEPT_ARGUMENTS;
$$3({ target: "Promise", stat: true, forced: FORCED }, { try: function(e) {
  var t = arguments.length > 1 ? slice(arguments, 1) : [], i = newPromiseCapabilityModule$1.f(this), r = perform(function() {
    return apply(aCallable(e), void 0, t);
  });
  return (r.error ? i.reject : i.resolve)(r.value), i.promise;
} });
var $$2 = _export;
var newPromiseCapabilityModule = newPromiseCapability$2;
$$2({ target: "Promise", stat: true }, { withResolvers: function() {
  var e = newPromiseCapabilityModule.f(this);
  return { promise: e.promise, resolve: e.resolve, reject: e.reject };
} });
var $$1 = _export;
var NativePromiseConstructor = promiseNativeConstructor;
var fails = fails$s;
var getBuiltIn = getBuiltIn$h;
var isCallable = isCallable$l;
var speciesConstructor = speciesConstructor$2;
var promiseResolve = promiseResolve$2;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var NON_GENERIC = !!NativePromiseConstructor && fails(function() {
  NativePromisePrototype.finally.call({ then: function() {
  } }, function() {
  });
});
$$1({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, { finally: function(e) {
  var t = speciesConstructor(this, getBuiltIn("Promise")), i = isCallable(e);
  return this.then(i ? function(i2) {
    return promiseResolve(t, e()).then(function() {
      return i2;
    });
  } : e, i ? function(i2) {
    return promiseResolve(t, e()).then(function() {
      throw i2;
    });
  } : e);
} });
var path$1 = path$e;
var promise$4 = path$1.Promise;
var parent$5 = promise$4;
var promise$3 = parent$5;
var parent$4 = promise$3;
var promise$2 = parent$4;
var parent$3 = promise$2;
var promise$1 = parent$3;
var promise = promise$1;
var _Promise = getDefaultExportFromCjs(promise);
function _asyncIterator(e) {
  var t, i, r, o = 2;
  for (void 0 !== _Symbol && (i = _Symbol$asyncIterator, r = _Symbol$iterator); o--; ) {
    if (i && null != (t = e[i])) return t.call(e);
    if (r && null != (t = e[r])) return new AsyncFromSyncIterator(t.call(e));
    i = "@@asyncIterator", r = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(e) {
  function t(e2) {
    if (Object(e2) !== e2) return _Promise.reject(new TypeError(e2 + " is not an object."));
    var t2 = e2.done;
    return _Promise.resolve(e2.value).then(function(e3) {
      return { value: e3, done: t2 };
    });
  }
  return (AsyncFromSyncIterator = function(e2) {
    this.s = e2, this.n = e2.next;
  }).prototype = { s: null, n: null, next: function() {
    return t(this.n.apply(this.s, arguments));
  }, return: function(e2) {
    var i = this.s.return;
    return void 0 === i ? _Promise.resolve({ value: e2, done: true }) : t(i.apply(this.s, arguments));
  }, throw: function(e2) {
    var i = this.s.return;
    return void 0 === i ? _Promise.reject(e2) : t(i.apply(this.s, arguments));
  } }, new AsyncFromSyncIterator(e);
}
var AudioMixingDualMonoMode = ((e) => (e[e.AUTO = 0] = "AUTO", e[e.MODE_L = 1] = "MODE_L", e[e.MODE_R = 2] = "MODE_R", e[e.MODE_MIX = 3] = "MODE_MIX", e))(AudioMixingDualMonoMode || {});
var AudioMixingType = ((e) => (e[e.PLAYOUT = 0] = "PLAYOUT", e[e.PUBLISH = 1] = "PUBLISH", e[e.PLAYOUT_AND_PUBLISH = 2] = "PLAYOUT_AND_PUBLISH", e))(AudioMixingType || {});
var AudioMixingState = ((e) => (e[e.AUDIO_MIXING_STATE_PRELOADED = 0] = "AUDIO_MIXING_STATE_PRELOADED", e[e.AUDIO_MIXING_STATE_PLAYING = 1] = "AUDIO_MIXING_STATE_PLAYING", e[e.AUDIO_MIXING_STATE_PAUSED = 2] = "AUDIO_MIXING_STATE_PAUSED", e[e.AUDIO_MIXING_STATE_STOPPED = 3] = "AUDIO_MIXING_STATE_STOPPED", e[e.AUDIO_MIXING_STATE_FAILED = 4] = "AUDIO_MIXING_STATE_FAILED", e[e.AUDIO_MIXING_STATE_FINISHED = 5] = "AUDIO_MIXING_STATE_FINISHED", e[e.AUDIO_MIXING_STATE_PCM_ENABLED = 6] = "AUDIO_MIXING_STATE_PCM_ENABLED", e[e.AUDIO_MIXING_STATE_PCM_DISABLED = 7] = "AUDIO_MIXING_STATE_PCM_DISABLED", e))(AudioMixingState || {});
var BasicHandler = class extends eventemitter3Exports.EventEmitter {
  constructor(e, t) {
    super(), _defineProperty(this, "_context", void 0), _defineProperty(this, "peerConnectionMode", 0), _defineProperty(this, "id", void 0), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "logger", void 0), _defineProperty(this, "_nextSsrc", generateRandomSsrc()), _defineProperty(this, "_aSendonlyAnswerTpl", void 0), _defineProperty(this, "_vSendonlyAnswerTpl", void 0), _defineProperty(this, "_enableSubFlexfec", false), _defineProperty(this, "audioTrack4ff", void 0), _defineProperty(this, "setLocalDescription", void 0), _defineProperty(this, "setRemoteDescription", void 0), this.peer = t, this.id = e.id, this._monitor = getMonitor(this.id), this.logger = new Logger$1("BasicHandler", 3, e.id), this.setLocalDescription = t.setLocalDescription.bind(t), this.setRemoteDescription = t.setRemoteDescription.bind(t), this._context = e, this.peer.on("ontrack", (e2) => {
      this.emit("ontrack", e2);
    });
  }
  destroy() {
    this.logger.info("destroy", this.peerConnectionId || ""), super.removeAllListeners();
  }
  get _peerConnection() {
    return this.peer.getOriginRTCPeerConnection();
  }
  getTransceivers() {
    return this._peerConnection.getTransceivers();
  }
  getConnectionState() {
    return this._peerConnection.connectionState;
  }
  internalPublish(e) {
    const { stream: t, videoTrack: i, audioTrack: r, pubAudio: o, pubVideo: n } = e, s = { direction: "sendonly", streams: [t] }, a = { direction: "sendonly", streams: [t] }, { sendEncodings: d, videoDescriptions: c2, subVideoDescriptions: l, activeSimulcastStreams: u } = this._context.videoProfile.genVideoDescriptions(e);
    a.sendEncodings = d, this._context.videoProfile.activeSimStreams = u, this.logger.info("publish videoTransceiverInit videoDescriptions", "", a, c2);
    let h = null == r ? void 0 : r.preprocessingTrack;
    (null == r ? void 0 : r.mixType) !== AudioMixingType.PLAYOUT && null != r && r.mixedAudioTrack && (h = null == r ? void 0 : r.mixedAudioTrack), h = o && h ? h : "audio";
    let _ = null == i ? void 0 : i.preprocessingTrack;
    _ = n && _ ? _ : "video";
    try {
      this._reportRtcInvokeStatus("Handler.internalPublish", JSON.stringify({ aTrack: mediaTrackStringify(h), vTrack: mediaTrackStringify(_), audioTransceiverInit: s, videoTransceiverInit: a }));
    } catch (e2) {
    }
    return { semantics: "unified-plan", videoDescriptions: c2, subVideoDescriptions: l, audioTransceiverInit: { track: h, init: s }, videoTransceiverInit: { track: _, init: a } };
  }
  async setCurrentDescription() {
  }
  createAVMlineAnswerTpl(e) {
    const t = lib.parse(e);
    t.media.forEach((e2) => {
      if ("audio" === e2.type) {
        if ("sendonly" === e2.direction) {
          const t2 = null == e2 ? void 0 : e2.rtp.find((e3) => "opus" === e3.codec);
          if (t2 && null != e2 && e2.fmtp) {
            const i = null == e2 ? void 0 : e2.fmtp.find((e3) => e3.payload === t2.payload);
            i && this._context && (i.config += ";stereo=1;sprop-stereo=1");
          }
          this._aSendonlyAnswerTpl = e2;
        }
      } else "video" === e2.type && ("sendonly" === e2.direction && (this._vSendonlyAnswerTpl = e2), Array.isArray(e2.rtp) && e2.rtp.forEach((e3) => {
        var t2;
        null !== (t2 = e3.codec) && void 0 !== t2 && t2.includes("flexfec") && (this._enableSubFlexfec = true);
      }));
    }), isRRTRSupported && pushRRTR(t);
  }
  get peerConnectionId() {
    return this.peer.getConnectionId() || "";
  }
  addBitrateLimit(e, t) {
    null == e || e.rtp.forEach((i) => {
      let { codec: r, payload: o } = i;
      if (["vp8", "h264"].includes(r.toLocaleLowerCase())) {
        const i2 = e.fmtp.find((e2) => e2.payload === o);
        i2 ? i2.config = [...i2.config.split(";"), "x-google-min-bitrate=100", "x-google-start-bitrate=".concat(t)].join(";") : e.fmtp.push({ payload: o, config: "x-google-min-bitrate=100;x-google-start-bitrate=".concat(t) });
      }
    });
  }
  _report(e, t, i) {
    var r;
    null === (r = this._monitor) || void 0 === r || r.report(e, _objectSpread2(_objectSpread2({}, t), {}, { connection_id: this.peer.getConnectionId(), group_connection_id: this.peer.getGroupConnectionId() }), i);
  }
  _reportRtcInvokeStatus(e, t) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "", o = arguments.length > 4 ? arguments[4] : void 0;
    this._report("rtc_invoke_status", { sdk_api_name: e, message: t, error_code: i, stream_id: r, elapse: 0 }, o);
  }
};
var logger$2 = new Logger$1("queue", 4);
var SdpStrategy = ((e) => (e[e.ADD = 0] = "ADD", e[e.CLOSE = 1] = "CLOSE", e))(SdpStrategy || {});
var SdpAction = ((e) => (e.publish = "publish", e.unpublish = "unpublish", e.subscribe = "subscribe", e.unsubscribe = "unsubscribe", e.pushtrack = "pushtrack", e.removetrack = "removetrack", e))(SdpAction || {});
var negativedAction = { publish: "unpublish", subscribe: "unsubscribe", pushtrack: "removetrack" };
var aggregationSdpStrategy = { publish: 0, subscribe: 0, pushtrack: 0, unpublish: 1, unsubscribe: 1, removetrack: 1 };
var SdpQueue = class extends EventEmitter2 {
  constructor() {
    super(), _defineProperty(this, "_queue", void 0), this._queue = [];
  }
  get queue() {
    return this._queue;
  }
  enqueue(e) {
    const t = this._queue.length;
    let i = "";
    return this._queue = this._queue.filter((t2) => t2.streamId !== e.streamId || e.action !== negativedAction[t2.action] || (i = t2.streamId, logger$2.info("offsetStreamId", i), false)), this._queue.length === t && this._queue.push(e), this.emit("start"), i;
  }
  dequeue() {
    if (!this._queue.length) return null;
    let e = this._queue.length;
    isChrome && chromeVersion >= 86 && chromeVersion <= 92 && (e = Math.min(this._queue.length, 5));
    const t = aggregationSdpStrategy[this._queue[0].action];
    for (let i = 1; i < e; i++) if (aggregationSdpStrategy[this._queue[i].action] !== t) return { sdpStrategy: t, items: this._queue.splice(0, i) };
    return { sdpStrategy: t, items: this._queue.splice(0, e) };
  }
  destroy() {
    this._queue = [];
  }
};
var encodedTransformSupported$2 = isLegacyEncodedTransformSupported() || isEncodedTransformSupported();
var ChromeHandler = class extends BasicHandler {
  constructor(e, t) {
    var i;
    super(e, t), _defineProperty(this, "name", "chrome"), _defineProperty(this, "_queueBusy", false), _defineProperty(this, "_sdpQueue", void 0), _defineProperty(this, "_aSendonlyOfferTpl", void 0), _defineProperty(this, "_vSendonlyOfferTpl", void 0), _defineProperty(this, "_aRecvonlyOfferTpl", void 0), _defineProperty(this, "_vRecvonlyOfferTpl", void 0), _defineProperty(this, "_mid", 10), _defineProperty(this, "_inactiveMlineIndex", []), _defineProperty(this, "setDescription", void 0), this.logger = new Logger$1("ChromeHandler", 3, e.id), this.setDescription = t.setDescription.bind(t), this._sdpQueue = new SdpQueue(), this._sdpQueue.on("start", () => {
      this._queueBusy || "stable" !== this._peerConnection.signalingState || (this.logger.info("dequeue start"), this.dequeue());
    }), null === (i = this._context.monitor) || void 0 === i || i.set({ handler_mode: "chrome" });
  }
  destroy() {
    super.destroy(), this._sdpQueue.destroy();
  }
  async publish(e) {
    var t;
    const { stream: i, enableSimulcast: r } = e, { videoDescriptions: o, subVideoDescriptions: n, audioTransceiverInit: s, videoTransceiverInit: a } = super.internalPublish(e), d = generateAllSsrc(this._nextSsrc);
    this._nextSsrc = d.next;
    const c2 = "".concat(this._mid++), l = "".concat(this._mid++), u = _objectSpread2(_objectSpread2(_objectSpread2({}, this._aSendonlyOfferTpl), this.peer._offerIce), {}, { mid: c2, msid: "".concat(i.id, " ").concat(i.id, "-audio"), ssrcs: generateSsrc(i.id, "audio", d.audio, clientCname) }), h = _objectSpread2(_objectSpread2(_objectSpread2({}, this._vSendonlyOfferTpl), this.peer._offerIce), {}, { mid: l, msid: "".concat(i.id, " ").concat(i.id, "-video") });
    if (r) {
      this.logger.info("subVideoDesc", "desc: %o ", n), delete h.ssrcGroups, delete h.ssrcs;
      const e2 = [];
      h.rids = o.map((t2) => {
        let { rid: i2 } = t2;
        return e2.unshift(i2), { id: i2, direction: "send" };
      }), h.simulcast = { dir1: "send", list1: e2.join(";") };
    } else {
      const { ssrcs: e2, ssrcGroups: t2 } = generateSsrcs(i.id, d, { cname: clientCname });
      h.ssrcs = e2, h.ssrcGroups = t2;
    }
    if (null !== (t = this._context.serverConfig) && void 0 !== t && t.audioRed && Array.isArray(u.rtp)) {
      this.logger.info("audioCodec", "use Red");
      const e2 = u.rtp.findIndex((e3) => "red" === e3.codec);
      if (-1 !== e2) {
        const [t3] = u.rtp.splice(e2, 1);
        u.rtp.unshift(t3);
      }
      const t2 = [];
      u.rtp.forEach((e3) => t2.push(e3.payload)), u.payloads = t2.join(" ");
    }
    Array.isArray(h.ext) && (getParameter("IOS_SAFARI_ORIENTATION") || !isSafari && !isIOS || (h.ext = h.ext.filter((e2) => {
      var t2;
      return !(null != e2 && null !== (t2 = e2.uri) && void 0 !== t2 && t2.includes("video-orientation"));
    })), h.ext = h.ext.filter((e2) => {
      var t2;
      return !(null != e2 && null !== (t2 = e2.uri) && void 0 !== t2 && t2.includes("framemarking"));
    }));
    const _ = null == u ? void 0 : u.rtp.find((e2) => "opus" === e2.codec);
    if (_ && u.fmtp) {
      const e2 = u.fmtp.find((e3) => e3.payload === _.payload);
      e2 && this._context.audioProfileManager && (e2.config = this._context.audioProfileManager.getOpusConfigStr(e2.config));
    }
    return r || isSafari || this.addBitrateLimit(h, e.videoEncodeConfig[0].maxKbps), e.audioMLine = u, e.videoMLine = h, { partialSdp: getLocalPartialSdp(this.peer._offerSession, u, h), audioMid: c2, videoMid: l, type: "incroffer", semantics: "unified-plan", videoDescriptions: o, subVideoDescriptions: n, audioTransceiverInit: s, videoTransceiverInit: a, peerConnectionMode: this.peerConnectionMode };
  }
  async subscribe(e, t) {
    var i, r;
    this.logger.info("subscribe");
    if (!this._aRecvonlyOfferTpl || !this._vRecvonlyOfferTpl) {
      const e2 = await this._genOfferSdp();
      await this.createAVMlineOfferTpl(e2);
    }
    let o, n, s, a, d = "", c2 = "", l = false, u = false;
    e.audioMLine = o, e.videoMLine = n, e.virtual ? (d = "".concat(this._mid++), l = true) : t.multiChatMode ? (d = "".concat(this._mid++), c2 = "".concat(this._mid++), u = true) : (l = true, u = true, d = "".concat(this._mid++), c2 = "".concat(this._mid++)), d && (o = _objectSpread2(_objectSpread2({}, cloneDeep(this._aRecvonlyOfferTpl)), {}, { mid: d })), l && (e.audioMLine = o, s = { track: "audio", init: { direction: "recvonly" } }), c2 && (n = _objectSpread2(_objectSpread2({}, cloneDeep(this._vRecvonlyOfferTpl)), {}, { mid: c2 })), u && (e.videoMLine = n, a = { track: "video", init: { direction: "recvonly" } });
    const h = getLocalPartialSdp(this.peer._offerSession, o, n);
    let _, p;
    if (!e.enableVendorMode && !t.multiChatMode && !e.virtual && this._aSendonlyAnswerTpl && this._vSendonlyAnswerTpl) {
      var m;
      _ = generateAllSsrc(this._nextSsrc), this._nextSsrc = _.next;
      const t2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this._aSendonlyAnswerTpl), this.peer._answerIce), {}, { mid: d, msid: "".concat(e.streamId).concat(this._context.avSync ? "" : "-audio", " ").concat(e.streamId, "-audio"), ssrcs: generateSsrc(e.streamId, "audio", _.audio) }), i2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this._vSendonlyAnswerTpl), this.peer._answerIce), {}, { mid: c2, msid: "".concat(e.streamId).concat(this._context.avSync ? "" : "-video", " ").concat(e.streamId, "-video") }, generateSsrcs(e.streamId, _, { flexfec: this._enableSubFlexfec }));
      p = { sdp: lib.write(_objectSpread2(_objectSpread2({}, this.peer._answerSession), {}, { media: [t2, i2] })), sequenceId: e.sequenceId ? ++e.sequenceId : 0 }, null === (m = _) || void 0 === m || delete m.next;
    }
    const S = null === (i = o) || void 0 === i ? void 0 : i.rtp.find((e2) => "opus" === e2.codec);
    if (S && null !== (r = o) && void 0 !== r && r.fmtp) {
      var g;
      const e2 = null === (g = o) || void 0 === g ? void 0 : g.fmtp.find((e3) => e3.payload === S.payload);
      e2 && this._context && (e2.config += ";stereo=1;sprop-stereo=1");
    }
    if (e.isPublic && chromeVersion >= 86) {
      var v3, f;
      const e2 = null === (v3 = n) || void 0 === v3 ? void 0 : v3.rtp.filter((e3) => "H264" === e3.codec);
      var y;
      if (null != e2 && e2.length && null !== (f = n) && void 0 !== f && f.fmtp) null === (y = n) || void 0 === y || y.fmtp.forEach((t2) => {
        e2.find((e3) => e3.payload === t2.payload) && (t2.config += ";sps-pps-idr-in-keyframe=1");
      });
    }
    return { partialSdp: h, audioMid: d, videoMid: c2, type: "incroffer", semantics: "unified-plan", audioTransceiverInit: s, videoTransceiverInit: a, allSsrc: _, peerConnectionMode: this.peerConnectionMode, signalingAck: p };
  }
  async handleAck(e) {
    return this.logger.info("handleAck()", "item: %o", e), this._sdpQueue.enqueue(e);
  }
  async dequeue() {
    this._queueBusy = true;
    const e = this._sdpQueue.dequeue();
    if (this.logger.info("dequeue()", "ret: %o", e), !e) return void (this._queueBusy = false);
    const t = [];
    try {
      const { items: u, sdpStrategy: h } = e, _ = [], p = [], m = [];
      if (h === SdpStrategy.ADD) {
        delete _objectSpread2({}, this.peer._answerIce).candidates;
        var i, r = false, o = false;
        try {
          for (var n, s = _asyncIterator(u); r = !(n = await s.next()).done; r = false) {
            const e2 = n.value;
            {
              var a;
              const { audioMid: i2, videoMid: r2, action: o2, audioTransceiverInit: n2, videoTransceiverInit: s2, signalingAck: l2, stream: u2, videoCodec: h2, onSuccess: S, onFail: g } = e2, v3 = u2 instanceof RemoteStream;
              if (S && m.push(S), g && t.push(g), v3 && l2.sequenceId < u2.sequenceId) break;
              const f = lib.parse(l2.sdp);
              if (!Array.isArray(f.media)) break;
              _sortInstanceProperty(a = f.media).call(a, (e3, t2) => {
                var i3;
                return null == e3 || null === (i3 = e3.type) || void 0 === i3 ? void 0 : i3.localeCompare(null == t2 ? void 0 : t2.type);
              });
              const y = f.media.find((e3) => "audio" === e3.type), E = f.media.find((e3) => "video" === e3.type);
              if (!y || !E) break;
              const T = _objectSpread2(_objectSpread2(_objectSpread2({}, y), this.peer._answerIce), {}, { mid: i2 }), b = _objectSpread2(_objectSpread2(_objectSpread2({}, E), this.peer._answerIce), {}, { mid: r2 }), { audioMLine: I, videoMLine: R, audioTransceiver: C, videoTransceiver: P } = u2;
              if (I) {
                let e3 = this.peer._offerMlines.findIndex((e4) => e4.mid === i2);
                var d;
                if (C) {
                  if (this._reportRtcInvokeStatus("chromeHandler.updateTrack", JSON.stringify({ audioStreamTrack: mediaTrackStringify(null === (d = u2.audioTrack) || void 0 === d ? void 0 : d.preprocessingTrack) })), -1 === e3) {
                    this.logger.error("dequeue", "audio mid not found when update sdp, %s from %o", i2, this.peer._offerMlines);
                    continue;
                  }
                } else n2 && I && (u2.audioTransceiver = this._peerConnection.addTransceiver(n2.track, n2.init), this._reportRtcInvokeStatus("chromeHandler.addTrack", JSON.stringify({ audioStreamTrack: mediaTrackStringify(n2.track) })), e3 = this._inactiveMlineIndex.shift(), e3 || (e3 = this.peer._offerMlines.length), encodedTransformSupported$2 && u2.initAudioEncodedTransform());
                o2 === SdpAction.publish && "OPUS" !== getParameter("AUDIO_CODEC") && (setAudioCodecPreferences(I, getParameter("AUDIO_CODEC")), setAudioCodecPreferences(T, getParameter("AUDIO_CODEC"))), this.peer._offerMlines[e3] = _objectSpread2({}, I), this.peer._answerMlines[e3] = _objectSpread2({}, T);
              }
              if (R) {
                let e3 = this.peer._offerMlines.findIndex((e4) => e4.mid === r2);
                var c2;
                if (P) {
                  if (this._reportRtcInvokeStatus("chromeHandler.updateTrack", JSON.stringify({ audioStreamTrack: mediaTrackStringify(null === (c2 = u2.videoTrack) || void 0 === c2 ? void 0 : c2.preprocessingTrack) })), -1 === e3) {
                    this.logger.error("dequeue", "video mid not found when update sdp, %s from %o", r2, this.peer._offerMlines);
                    continue;
                  }
                } else s2 && R && (u2.videoTransceiver = this._peerConnection.addTransceiver(s2.track, s2.init), this._reportRtcInvokeStatus("chromeHandler.addTrack", JSON.stringify({ videoStreamTrack: mediaTrackStringify(s2.track) })), e3 = this._inactiveMlineIndex.shift(), e3 || (e3 = this.peer._offerMlines.length), encodedTransformSupported$2 && u2.initVideoEncodedTransform());
                this.peer._offerMlines[e3] = _objectSpread2({}, R), o2 === SdpAction.publish && h2 && (setCodecPreferences(R, h2), setCodecPreferences(b, h2)), this.peer._answerMlines[e3] = b;
              }
              _.push(u2.streamId || ""), p.push(v3 ? u2.userId : "local"), v3 && (u2.sequenceId = l2.sequenceId);
            }
          }
        } catch (e2) {
          o = true, i = e2;
        } finally {
          try {
            r && null != s.return && await s.return();
          } finally {
            if (o) throw i;
          }
        }
      } else {
        var l;
        const e2 = {};
        u.forEach((t2) => {
          const { audioMid: i2, videoMid: r2, action: o2 } = t2;
          e2[i2] = i2, o2 !== SdpAction.removetrack && (e2[r2] = r2), e2[i2] = i2;
        }), this.peer._offerMlines = this.peer._offerMlines.map((t2, i2) => (t2.mid && e2[t2.mid] && (t2 = closeMline(t2), this._inactiveMlineIndex.push(i2)), t2)), this._inactiveMlineIndex = [...new Set(this._inactiveMlineIndex)], _sortInstanceProperty(l = this._inactiveMlineIndex).call(l, (e3, t2) => e3 - t2), this.peer._answerMlines = this.peer._answerMlines.map((t2) => (t2.mid && e2[t2.mid] && (t2 = closeMline(t2)), t2));
      }
      try {
        await this.peer.getOriginRTCPeerConnection().createOffer(), await this.setDescription(_.length ? { streamId: _.join(","), streamUserId: p.join(",") } : void 0);
      } catch (e2) {
        throw "have-local-offer" === this._peerConnection.signalingState && await this._peerConnection.setLocalDescription({ type: "rollback" }), e2;
      }
      try {
        m.forEach((e2) => e2());
      } catch (e2) {
      }
      this.logger.info("dequeue", "loop");
    } catch (e2) {
      this.logger.error("dequeue", "unknown error: %o", e2), t.forEach((t2) => t2(e2));
    } finally {
      this.dequeue();
    }
  }
  async getDefaultSdp() {
    const e = await this._genOfferSdp();
    this.createAVMlineOfferTpl(e);
    const t = lib.parse(e), i = [];
    return t.media = t.media.filter((e2) => "recvonly" === e2.direction && (Array.isArray(e2.ext) && (e2.ext = e2.ext.filter((e3) => "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id" !== e3.uri)), i.push("".concat(e2.mid)), true)), t.groups = [{ mids: i.join(" "), type: "BUNDLE" }], isRRTRSupported && pushRRTR(t), { sdp: lib.write(t), semantics: "unified-plan", type: "incroffer" };
  }
  async rollback(e) {
    let { stream: t } = e;
    t instanceof LocalStream || await this.handleAck({ action: SdpAction.unsubscribe, streamId: t.streamId, audioMid: t.audioMid, videoMid: t.videoMid, stream: t }), delete t.audioMLine, delete t.videoMLine;
  }
  createAVMlineOfferTpl(e) {
    const t = lib.parse(e);
    t.media.forEach((e2) => {
      e2.icePwd = this.peer._offerIce.icePwd, e2.iceUfrag = this.peer._offerIce.iceUfrag, "audio" === e2.type ? "sendonly" === e2.direction ? this._aSendonlyOfferTpl = e2 : (Array.isArray(e2.ext) && (e2.ext = e2.ext.filter((e3) => "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id" !== e3.uri)), this._aRecvonlyOfferTpl = e2) : "video" === e2.type && ("sendonly" === e2.direction ? this._vSendonlyOfferTpl = e2 : (Array.isArray(e2.ext) && (e2.ext = e2.ext.filter((e3) => "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id" !== e3.uri)), this._vRecvonlyOfferTpl = e2));
    }), isRRTRSupported && pushRRTR(t);
  }
  async _genOfferSdp() {
    let e;
    try {
      if (e = await createDefaultSdp(true), !e) throw "pc.createOffer() return empty.";
    } catch (e2) {
      const t = "Get offer Error. ".concat(e2.message | e2);
      throw new SDKError(ErrorCode.NOT_SUPPORTED, t);
    }
    return e;
  }
};
var FirefoxHandler = class extends BasicHandler {
  constructor(e, t) {
    var i;
    super(e, t), _defineProperty(this, "name", "firefox"), _defineProperty(this, "_aRecvonlyOfferTpl", void 0), this.logger = new Logger$1("FirefoxHandler", 3, e.id), null === (i = this._context.monitor) || void 0 === i || i.set({ handler_mode: "firefox" });
  }
  async publish(e) {
    var t, i;
    const { videoDescriptions: r, subVideoDescriptions: o, audioTransceiverInit: n, videoTransceiverInit: s } = super.internalPublish(e);
    e.audioTransceiver = this._peerConnection.addTransceiver(n.track, n.init), Array.isArray(s.init.sendEncodings) && 1 === s.init.sendEncodings.length && (s.init.sendEncodings = s.init.sendEncodings.map((e2) => (delete e2.rid, e2))), e.videoTransceiver = this._peerConnection.addTransceiver(s.track, s.init);
    const a = getServerNow();
    this._report("rtc_begin_create_offer", { direction: "up", stream_id: "", stream_user_id: "", pc_session_id: this.peerConnectionId, vendor_mode: 0 });
    const d = await this.peer.createOfferSdp();
    this._report("rtc_create_offer", { direction: "up", error_code: 0, stream_id: "", stream_user_id: "", elapse: getServerNow() - a });
    const c2 = lib.parse(d);
    c2.media = null === (t = c2.media) || void 0 === t ? void 0 : t.map((e2) => _objectSpread2(_objectSpread2({}, e2), this.peer._offerIce)), pushRRTR(c2), await this.setLocalDescription(lib.write(c2));
    const l = e.audioTransceiver.mid, u = e.videoTransceiver.mid;
    let h = null, _ = null;
    return c2.media = null === (i = c2.media) || void 0 === i ? void 0 : i.map((e2) => {
      if ("".concat(e2.mid) === l) {
        var t2;
        h = e2;
        const r2 = null === (t2 = h) || void 0 === t2 ? void 0 : t2.rtp.find((e3) => "opus" === e3.codec);
        if (r2 && h.fmtp) {
          var i2;
          const e3 = h.fmtp.find((e4) => e4.payload === r2.payload);
          e3 && null !== (i2 = this._context) && void 0 !== i2 && i2.audioProfileManager && (e3.config = this._context.audioProfileManager.getOpusConfigStr(e3.config));
        }
      } else "".concat(e2.mid) === u && (_ = e2);
      return e2;
    }), this.addBitrateLimit(_, e.videoEncodeConfig[0].maxKbps), await this.setLocalDescription(lib.write(c2)), e.initVideoEncodedTransform(), e.initAudioEncodedTransform(), { partialSdp: getLocalPartialSdp(c2, h, _), audioMid: l, videoMid: u, type: "incroffer", semantics: "unified-plan", videoDescriptions: r, subVideoDescriptions: o, audioTransceiverInit: n, videoTransceiverInit: s, peerConnectionMode: this.peerConnectionMode };
  }
  async _internalChangePubCodec() {
    const { localDescription: e } = this._peerConnection;
    e && (await this.peer.createOfferSdp(), await this._peerConnection.setLocalDescription(e));
  }
  async subscribe(e, t) {
    var i, r, o, n;
    this.logger.info("subscribe()");
    let s, a, d = "", c2 = "", l = false, u = false;
    e.virtual ? l = true : (t.multiChatMode || (l = true), u = true), l && (e.audioTransceiver = this._peerConnection.addTransceiver("audio", { direction: "recvonly" })), u && (e.videoTransceiver = this._peerConnection.addTransceiver("video", { direction: "recvonly" }));
    const h = getServerNow();
    this._report("rtc_begin_create_offer", { direction: "up", stream_id: e.streamId, stream_user_id: e.userId, pc_session_id: this.peerConnectionId, vendor_mode: 0 });
    const _ = await this.peer.createOfferSdp();
    this._report("rtc_create_offer", { error_code: 0, direction: "up", stream_id: e.streamId, stream_user_id: e.userId, elapse: getServerNow() - h });
    const p = lib.parse(_);
    let m, S;
    if (p.media = null === (i = p.media) || void 0 === i ? void 0 : i.map((e2) => _objectSpread2(_objectSpread2({}, e2), this.peer._offerIce)), p.media.map((e2) => {
      var t2, i2, r2, o2;
      "video" === e2.type && (isTransportCCSupport ? (e2.ext = null === (t2 = e2.ext) || void 0 === t2 ? void 0 : t2.filter((e3) => -1 === e3.uri.indexOf("abs-send-time")), e2.rtcpFb = null === (i2 = e2.rtcpFb) || void 0 === i2 ? void 0 : i2.filter((e3) => "goog-remb" !== e3.type)) : (e2.rtcpFb = null === (r2 = e2.rtcpFb) || void 0 === r2 ? void 0 : r2.filter((e3) => "transport-cc" !== e3.type), e2.ext = null === (o2 = e2.ext) || void 0 === o2 ? void 0 : o2.filter((e3) => -1 === e3.uri.indexOf("transport"))));
    }), isRRTRSupported && pushRRTR(p), await this.setLocalDescription(lib.write(p), { streamId: e.streamId || "", streamUserId: e.userId }), d = null === (r = e.audioTransceiver) || void 0 === r ? void 0 : r.mid, c2 = null === (o = e.videoTransceiver) || void 0 === o ? void 0 : o.mid, null === (n = p.media) || void 0 === n || n.forEach((e2) => {
      "".concat(e2.mid) === d ? s = e2 : "".concat(e2.mid) === c2 && (a = e2);
    }), d && s || (d = "audio_".concat(c2), s = _objectSpread2(_objectSpread2({}, this._aRecvonlyOfferTpl), {}, { mid: d })), e.audioMid = d, e.videoMid = c2, !t.multiChatMode && !e.virtual && this._aSendonlyAnswerTpl && this._aSendonlyAnswerTpl) {
      var g, v3, f;
      m = generateAllSsrc(this._nextSsrc), this._nextSsrc = m.next;
      const t2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this._aSendonlyAnswerTpl), this.peer._answerIce), {}, { mid: d, msid: "".concat(e.streamId).concat(null !== (g = this._context) && void 0 !== g && g.avSync ? "" : "-audio", " ").concat(e.streamId, "-audio"), ssrcs: generateSsrc(e.streamId, "audio", m.audio) }), i2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this._vSendonlyAnswerTpl), this.peer._answerIce), {}, { mid: c2, msid: "".concat(e.streamId).concat(null !== (v3 = this._context) && void 0 !== v3 && v3.avSync ? "" : "-video", " ").concat(e.streamId, "-video") }, generateSsrcs(e.streamId, m, { flexfec: this._enableSubFlexfec }));
      S = { sdp: lib.write(_objectSpread2(_objectSpread2({}, this.peer._answerSession), {}, { media: [t2, i2] })), sequenceId: e.sequenceId ? ++e.sequenceId : 0 }, null === (f = m) || void 0 === f || delete f.next;
    }
    return e.initVideoEncodedTransform(), e.initAudioEncodedTransform(), { partialSdp: getLocalPartialSdp(p, s, a, false), audioMid: d, videoMid: c2, type: "incroffer", semantics: "unified-plan", audioTransceiverInit: e.audioTransceiver ? { track: "audio", init: { direction: "recvonly" } } : void 0, videoTransceiverInit: e.videoTransceiver ? { track: "video", init: { direction: "recvonly" } } : void 0, allSsrc: m, peerConnectionMode: this.peerConnectionMode, signalingAck: S };
  }
  async handleAck(e) {
    const { stream: t, action: i } = e;
    if (i === SdpAction.removetrack) return "";
    if (i === SdpAction.unpublish || i === SdpAction.unsubscribe) {
      try {
        await this.close(t), "function" == typeof e.onSuccess && e.onSuccess();
      } catch (t2) {
        "function" == typeof e.onFail && e.onFail(t2);
      }
      return t.streamId || "";
    }
    const { signalingAck: r, videoCodec: o } = e, n = lib.parse(r.sdp);
    try {
      await this._internalSetRemoteDescription(n.media, t, o), "function" == typeof e.onSuccess && e.onSuccess();
    } catch (t2) {
      "function" == typeof e.onFail && e.onFail(t2);
    }
    return "";
  }
  async _internalSetRemoteDescription(e, t, i) {
    var r, o;
    const n = {}, s = lib.parse(null === (r = this._peerConnection.remoteDescription) || void 0 === r ? void 0 : r.sdp);
    s.media.forEach((e2) => {
      void 0 !== e2.mid && (n[e2.mid] = e2);
    }), e.forEach((e2) => {
      if ("audio" === (e2 = _objectSpread2(_objectSpread2({}, e2), this.peer._answerIce)).type && (t.audioMid ? (e2.mid = t.audioMid, n[t.audioMid] = e2) : n[e2.mid] = e2), "video" === e2.type) {
        if (t instanceof LocalStream && firefoxVersion <= 87) {
          const t2 = {};
          Array.isArray(e2.rtp) && (e2.rtp = e2.rtp.filter((e3) => "rtx" !== e3.codec || (t2[e3.payload] = e3.payload, false))), "string" == typeof e2.payloads && (e2.payloads = e2.payloads.split(" ").filter((e3) => !t2[e3]).join(" ")), Array.isArray(e2.fmtp) && (e2.fmtp = e2.fmtp.filter((e3) => !t2[e3.payload])), Array.isArray(e2.rtcpFb) && (e2.fmtp = e2.fmtp.filter((e3) => !t2[e3.payload]));
        }
        i && setCodecPreferences(e2, i), t.videoMid ? (e2.mid = t.videoMid, n[t.videoMid] = e2) : n[e2.mid] = e2;
      }
    });
    const a = lib.parse(null === (o = this._peerConnection.localDescription) || void 0 === o ? void 0 : o.sdp), d = a.media.map((e2) => {
      const t2 = n[e2.mid];
      return "inactive" === e2.direction ? e2 : t2;
    });
    s.groups = a.groups, s.media = d, s.media.map((e2) => {
      if ("video" === e2.type) {
        var t2, i2, r2, o2, n2;
        if (isTransportCCSupport) e2.ext = null === (t2 = e2.ext) || void 0 === t2 ? void 0 : t2.filter((e3) => -1 === e3.uri.indexOf("abs-send-time")), e2.rtcpFb = null === (i2 = e2.rtcpFb) || void 0 === i2 ? void 0 : i2.filter((e3) => "goog-remb" !== e3.type);
        else e2.rtcpFb = null === (r2 = e2.rtcpFb) || void 0 === r2 ? void 0 : r2.filter((e3) => "transport-cc" !== e3.type), e2.ext = null === (o2 = e2.ext) || void 0 === o2 ? void 0 : o2.filter((e3) => -1 === e3.uri.indexOf("transport"));
        if (firefoxVersion >= 138) e2.ext = null === (n2 = e2.ext) || void 0 === n2 ? void 0 : n2.filter((e3) => !e3.uri.includes("sdes:mid"));
      }
    }), isRRTRSupported && pushRRTR(s), await this.setRemoteDescription(lib.write(s));
  }
  async getDefaultSdp() {
    const e = new RTCPeerConnection();
    e.addTransceiver("audio", { direction: "recvonly" }), e.addTransceiver("video", { direction: "recvonly" });
    const t = await e.createOffer(), i = lib.parse(t.sdp);
    this.createAVMlineOfferTpl(t.sdp);
    const r = [];
    return i.media = i.media.filter((e2) => {
      if ("recvonly" === e2.direction) {
        const t2 = "template_".concat(e2.type);
        return e2.mid = t2, r.push(t2), true;
      }
      return false;
    }), isRRTRSupported && pushRRTR(i), i.groups = [{ mids: r.join(" "), type: "BUNDLE" }], e.close(), { sdp: lib.write(i), semantics: "unified-plan", type: "incroffer" };
  }
  async rollback(e) {
    let { msid: t, stream: i, audioMid: r, videoMid: o } = e;
    return this.logger.warn("rollback()"), this.close(i, r, o);
  }
  async close(e, t, i) {
    var r;
    this.logger.info("close()");
    const o = e.audioMid || t, n = e.videoMid || i, s = {};
    e.audioTransceiver && o && (e.audioTransceiver.stop(), s[o] = o), e.videoTransceiver && n && (e.videoTransceiver.stop(), s[n] = n);
    const a = [], d = await this.peer.createOfferSdp(), c2 = lib.parse(d);
    c2.media = c2.media.map((e2) => (s[e2.mid] && (e2 = closeMline(e2)), "inactive" !== e2.direction && a.push(e2.mid), _objectSpread2(_objectSpread2({}, e2), this.peer._offerIce)));
    const l = lib.parse(null === (r = this._peerConnection.remoteDescription) || void 0 === r ? void 0 : r.sdp), u = {};
    l.media.forEach((e2) => {
      void 0 !== e2.mid && (u[e2.mid] = e2);
    }), l.media = c2.media.map((e2) => "inactive" === e2.direction ? e2 : u[e2.mid]), c2.groups && l.groups && (c2.groups[0].mids = a.join(" "), l.groups[0].mids = a.join(" ")), await this.setLocalDescription(lib.write(c2)), await this.setRemoteDescription(lib.write(l));
  }
  async setCurrentDescription() {
    await this.peer.createOfferSdp(), this._peerConnection.localDescription && this._peerConnection.remoteDescription && (await this._peerConnection.setLocalDescription(this._peerConnection.localDescription), await this._peerConnection.setRemoteDescription(this._peerConnection.remoteDescription));
  }
  createAVMlineOfferTpl(e) {
    const t = lib.parse(e);
    t.media.forEach((e2) => {
      "audio" === e2.type && (this._aRecvonlyOfferTpl = e2);
    }), isRRTRSupported && pushRRTR(t);
  }
};
var FallbackHandler = class extends BasicHandler {
  constructor(e, t) {
    var i, r;
    super(e, t), _defineProperty(this, "name", "fallback"), _defineProperty(this, "_aRecvonlyOfferTpl", void 0), this.logger = new Logger$1("FallbackHandler", 3, e.id), this.logger.warn("ctor", "using fallback handler"), null === (i = this._context.monitor) || void 0 === i || i.report("rtc_error", { message: "using fallback handler", error_code: -1 }), null === (r = this._context.monitor) || void 0 === r || r.set({ handler_mode: "fallback" });
  }
  async publish(e) {
    var t;
    const { videoDescriptions: i, subVideoDescriptions: r, audioTransceiverInit: o, videoTransceiverInit: n } = super.internalPublish(e);
    e.audioTransceiver = this._peerConnection.addTransceiver(o.track, o.init), Array.isArray(n.init.sendEncodings) && 1 === n.init.sendEncodings.length && (n.init.sendEncodings = n.init.sendEncodings.map((e2) => (delete e2.rid, e2))), e.videoTransceiver = this._peerConnection.addTransceiver(n.track, n.init);
    const s = getServerNow();
    this._report("rtc_begin_create_offer", { direction: "up", stream_id: "", stream_user_id: "", pc_session_id: this.peerConnectionId, vendor_mode: 0 });
    const a = await this.peer.createOfferSdp();
    this._report("rtc_create_offer", { direction: "up", error_code: 0, stream_id: "", stream_user_id: "", elapse: getServerNow() - s });
    const d = lib.parse(a);
    await this.setLocalDescription(a);
    const c2 = e.audioTransceiver.mid, l = e.videoTransceiver.mid;
    let u = null, h = null;
    return d.media = null === (t = d.media) || void 0 === t ? void 0 : t.map((e2) => ("".concat(e2.mid) === c2 ? u = e2 : "".concat(e2.mid) === l && (h = e2), e2)), e.initVideoEncodedTransform(), e.initAudioEncodedTransform(), { partialSdp: getLocalPartialSdp(d, u, h), audioMid: c2, videoMid: l, type: "incroffer", semantics: "unified-plan", videoDescriptions: i, subVideoDescriptions: r, audioTransceiverInit: o, videoTransceiverInit: n, peerConnectionMode: this.peerConnectionMode };
  }
  async _internalChangePubCodec() {
    const { localDescription: e } = this._peerConnection;
    e && (await this.peer.createOfferSdp(), await this._peerConnection.setLocalDescription(e));
  }
  async subscribe(e, t) {
    var i, r, o;
    this.logger.info("subscribe()");
    let n, s, a = "", d = "", c2 = false, l = false;
    e.virtual ? c2 = true : (t.multiChatMode || (c2 = true), l = true), c2 && (e.audioTransceiver = this._peerConnection.addTransceiver("audio", { direction: "recvonly" })), l && (e.videoTransceiver = this._peerConnection.addTransceiver("video", { direction: "recvonly" }));
    const u = getServerNow();
    this._report("rtc_begin_create_offer", { direction: "up", stream_id: e.streamId, stream_user_id: e.userId, pc_session_id: this.peerConnectionId, vendor_mode: 0 });
    const h = await this.peer.createOfferSdp();
    this._report("rtc_create_offer", { error_code: 0, direction: "up", stream_id: e.streamId, stream_user_id: e.userId, elapse: getServerNow() - u });
    const _ = lib.parse(h);
    let p, m;
    if (await this.setLocalDescription(h, { streamId: e.streamId || "", streamUserId: e.userId }), a = null === (i = e.audioTransceiver) || void 0 === i ? void 0 : i.mid, d = null === (r = e.videoTransceiver) || void 0 === r ? void 0 : r.mid, null === (o = _.media) || void 0 === o || o.forEach((e2) => {
      "".concat(e2.mid) === a ? n = e2 : "".concat(e2.mid) === d && (s = e2);
    }), a && n || (a = "audio_".concat(d), n = _objectSpread2(_objectSpread2({}, this._aRecvonlyOfferTpl), {}, { mid: a })), e.audioMid = a, e.videoMid = d, !t.multiChatMode && !e.virtual && this._aSendonlyAnswerTpl && this._aSendonlyAnswerTpl) {
      var S, g, v3;
      p = generateAllSsrc(this._nextSsrc), this._nextSsrc = p.next;
      const t2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this._aSendonlyAnswerTpl), this.peer._answerIce), {}, { mid: a, msid: "".concat(e.streamId).concat(null !== (S = this._context) && void 0 !== S && S.avSync ? "" : "-audio", " ").concat(e.streamId, "-audio"), ssrcs: generateSsrc(e.streamId, "audio", p.audio) }), i2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this._vSendonlyAnswerTpl), this.peer._answerIce), {}, { mid: d, msid: "".concat(e.streamId).concat(null !== (g = this._context) && void 0 !== g && g.avSync ? "" : "-video", " ").concat(e.streamId, "-video") }, generateSsrcs(e.streamId, p, { flexfec: this._enableSubFlexfec }));
      m = { sdp: lib.write(_objectSpread2(_objectSpread2({}, this.peer._answerSession), {}, { media: [t2, i2] })), sequenceId: e.sequenceId ? ++e.sequenceId : 0 }, null === (v3 = p) || void 0 === v3 || delete v3.next;
    }
    return e.initVideoEncodedTransform(), e.initAudioEncodedTransform(), { partialSdp: getLocalPartialSdp(_, n, s, false), audioMid: a, videoMid: d, type: "incroffer", semantics: "unified-plan", audioTransceiverInit: e.audioTransceiver ? { track: "audio", init: { direction: "recvonly" } } : void 0, videoTransceiverInit: e.videoTransceiver ? { track: "video", init: { direction: "recvonly" } } : void 0, allSsrc: p, peerConnectionMode: this.peerConnectionMode, signalingAck: m };
  }
  async handleAck(e) {
    const { stream: t, action: i } = e;
    if (i === SdpAction.removetrack) return "";
    if (i === SdpAction.unpublish || i === SdpAction.unsubscribe) {
      try {
        await this.close(t), "function" == typeof e.onSuccess && e.onSuccess();
      } catch (t2) {
        "function" == typeof e.onFail && e.onFail(t2);
      }
      return t.streamId || "";
    }
    const { signalingAck: r, videoCodec: o } = e, n = lib.parse(r.sdp);
    try {
      await this._internalSetRemoteDescription(n.media, t, o), "function" == typeof e.onSuccess && e.onSuccess();
    } catch (t2) {
      "function" == typeof e.onFail && e.onFail(t2);
    }
    return "";
  }
  async _internalSetRemoteDescription(e, t, i) {
    var r, o;
    const n = {}, s = lib.parse(null === (r = this._peerConnection.remoteDescription) || void 0 === r ? void 0 : r.sdp);
    s.media.forEach((e2) => {
      void 0 !== e2.mid && (n[e2.mid] = e2);
    }), e.forEach((e2) => {
      "audio" === (e2 = _objectSpread2(_objectSpread2({}, e2), this.peer._answerIce)).type && (t.audioMid ? (e2.mid = t.audioMid, n[t.audioMid] = e2) : n[e2.mid] = e2), "video" === e2.type && (i && setCodecPreferences(e2, i), t.videoMid ? (e2.mid = t.videoMid, n[t.videoMid] = e2) : n[e2.mid] = e2);
    });
    const a = lib.parse(null === (o = this._peerConnection.localDescription) || void 0 === o ? void 0 : o.sdp), d = a.media.map((e2) => {
      const t2 = n[e2.mid];
      return "inactive" === e2.direction ? e2 : t2;
    });
    s.groups = a.groups, s.media = d, s.media.map((e2) => {
      var t2, i2, r2, o2;
      "video" === e2.type && (isTransportCCSupport ? (e2.ext = null === (t2 = e2.ext) || void 0 === t2 ? void 0 : t2.filter((e3) => -1 === e3.uri.indexOf("abs-send-time")), e2.rtcpFb = null === (i2 = e2.rtcpFb) || void 0 === i2 ? void 0 : i2.filter((e3) => "goog-remb" !== e3.type)) : (e2.rtcpFb = null === (r2 = e2.rtcpFb) || void 0 === r2 ? void 0 : r2.filter((e3) => "transport-cc" !== e3.type), e2.ext = null === (o2 = e2.ext) || void 0 === o2 ? void 0 : o2.filter((e3) => -1 === e3.uri.indexOf("transport"))));
    }), await this.setRemoteDescription(lib.write(s));
  }
  async getDefaultSdp() {
    const e = new RTCPeerConnection();
    e.addTransceiver("audio", { direction: "recvonly" }), e.addTransceiver("video", { direction: "recvonly" });
    const t = await e.createOffer(), i = lib.parse(t.sdp);
    this.createAVMlineOfferTpl(t.sdp);
    const r = [];
    return i.media = i.media.filter((e2) => {
      if ("recvonly" === e2.direction) {
        const t2 = "template_".concat(e2.type);
        return e2.mid = t2, r.push(t2), true;
      }
      return false;
    }), i.groups = [{ mids: r.join(" "), type: "BUNDLE" }], e.close(), { sdp: lib.write(i), semantics: "unified-plan", type: "incroffer" };
  }
  async rollback(e) {
    let { msid: t, stream: i, audioMid: r, videoMid: o } = e;
    return this.logger.warn("rollback()"), this.close(i, r, o);
  }
  async close(e, t, i) {
    var r;
    this.logger.info("close()");
    const o = e.audioMid || t, n = e.videoMid || i, s = {};
    e.audioTransceiver && o && (e.audioTransceiver.stop(), s[o] = o), e.videoTransceiver && n && (e.videoTransceiver.stop(), s[n] = n);
    const a = [], d = await this.peer.createOfferSdp(), c2 = lib.parse(d);
    c2.media = c2.media.map((e2) => (s[e2.mid] && (e2 = closeMline(e2)), "inactive" !== e2.direction && a.push(e2.mid), _objectSpread2(_objectSpread2({}, e2), this.peer._offerIce)));
    const l = lib.parse(null === (r = this._peerConnection.remoteDescription) || void 0 === r ? void 0 : r.sdp), u = {};
    l.media.forEach((e2) => {
      void 0 !== e2.mid && (u[e2.mid] = e2);
    }), l.media = c2.media.map((e2) => "inactive" === e2.direction ? e2 : u[e2.mid]), c2.groups && l.groups && (c2.groups[0].mids = a.join(" "), l.groups[0].mids = a.join(" ")), await this.setLocalDescription(d), await this.setRemoteDescription(lib.write(l));
  }
  async setCurrentDescription() {
    await this.peer.createOfferSdp(), this._peerConnection.localDescription && this._peerConnection.remoteDescription && (await this._peerConnection.setLocalDescription(this._peerConnection.localDescription), await this._peerConnection.setRemoteDescription(this._peerConnection.remoteDescription));
  }
  createAVMlineOfferTpl(e) {
    lib.parse(e).media.forEach((e2) => {
      "audio" === e2.type && (this._aRecvonlyOfferTpl = e2);
    });
  }
};
var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __decorateClass$8 = (e, t, i, r) => {
  for (var o, n = r > 1 ? void 0 : r ? __getOwnPropDesc$8(t, i) : t, s = e.length - 1; s >= 0; s--) (o = e[s]) && (n = (r ? o(t, i, n) : o(n)) || n);
  return r && n && __defProp$8(t, i, n), n;
};
var BatchProcessor = class {
  constructor(e) {
    _defineProperty(this, "_queue", []), _defineProperty(this, "_runningTask", []), _defineProperty(this, "executor", void 0), _defineProperty(this, "busy", false), this.executor = e;
  }
  add(e) {
    const { promise: t, resolve: i, reject: r } = promiseWithResolves();
    return this._queue.push({ item: e, resolve: i, reject: r }), this.busy || this._emit(), t;
  }
  destroy() {
    [...this._queue, ...this._runningTask].forEach((e) => {
      let { reject: t } = e;
      t(new SDKError(ErrorCode.OPERATION_CANCEL, "queue close"));
    }), this.busy = false, this._queue = [];
  }
  async _emit() {
    const e = this._queue;
    if (this._runningTask = e, this._queue = [], 0 === e.length) return void (this.busy = false);
    const t = e.map((e2) => e2.item), i = e.map((e2) => e2.resolve), r = e.map((e2) => e2.reject);
    try {
      this.busy = true;
      const e2 = await this.executor(t);
      i.forEach((t2) => t2(e2));
    } catch (e2) {
      r.forEach((t2) => t2(e2));
    }
    this._runningTask = [], setTimeout(() => {
      this._emit();
    });
  }
};
function encodedTransformSupported$1() {
  return isLegacyEncodedTransformSupported() || isEncodedTransformSupported();
}
var StandardHandler = class extends BasicHandler {
  constructor(e, t) {
    var i;
    super(e, t), _defineProperty(this, "name", "standard"), _defineProperty(this, "_applyQueue", new BatchProcessor(this.apply.bind(this))), _defineProperty(this, "_createQueue", new BatchProcessor(this.create.bind(this))), _defineProperty(this, "_pqueue", new PriorityQueue()), _defineProperty(this, "_midMap", /* @__PURE__ */ new Map()), _defineProperty(this, "_aRecvonlyOfferTpl", void 0), this.logger = new Logger$1("StandardHandler", 3, e.id), this.logger.warn("ctor", "using standard handler"), null === (i = this._context.monitor) || void 0 === i || i.set({ handler_mode: "standard" });
  }
  async publish(e) {
    var t;
    this.logger.info("publish()", "streamId: ".concat(e.streamId));
    const { videoDescriptions: i, subVideoDescriptions: r, audioTransceiverInit: o, videoTransceiverInit: n } = super.internalPublish(e);
    e.audioTransceiver = this._peerConnection.addTransceiver(o.track, _objectSpread2(_objectSpread2({}, o.init), {}, { direction: "sendonly" })), Array.isArray(n.init.sendEncodings) && 1 === n.init.sendEncodings.length && (n.init.sendEncodings = n.init.sendEncodings.map((e2) => (delete e2.rid, e2))), e.videoTransceiver = this._peerConnection.addTransceiver(n.track, _objectSpread2(_objectSpread2({}, n.init), {}, { direction: "sendonly" }));
    const s = getServerNow();
    this._report("rtc_begin_create_offer", { direction: "up", stream_id: "", stream_user_id: "", pc_session_id: this.peerConnectionId, vendor_mode: 0 });
    const a = await this._createQueue.add();
    this._report("rtc_create_offer", { direction: "up", error_code: 0, stream_id: "", stream_user_id: "", elapse: getServerNow() - s });
    const d = e.audioTransceiver.mid, c2 = e.videoTransceiver.mid;
    DCHECK(d && c2, "Transceiver not return MID after setLocalDescription"), e.audioMid = d, e.videoMid = c2;
    let l = null, u = null;
    const h = lib.parse(a);
    return h.media = null === (t = h.media) || void 0 === t ? void 0 : t.map((e2) => ("".concat(e2.mid) === d ? l = e2 : "".concat(e2.mid) === c2 && (u = e2), e2)), encodedTransformSupported$1() && (e.initVideoEncodedTransform(), e.initAudioEncodedTransform()), { partialSdp: getLocalPartialSdp(h, l, u), audioMid: d, videoMid: c2, type: "incroffer", semantics: "unified-plan", videoDescriptions: i, subVideoDescriptions: r, audioTransceiverInit: o, videoTransceiverInit: n, peerConnectionMode: this.peerConnectionMode };
  }
  async subscribe(e, t) {
    var i, r, o, n, s;
    this.logger.info("subscribe()", "streamId: ".concat(e.streamId));
    let a, d, c2 = false, l = false;
    e.virtual ? c2 = true : (t.multiChatMode || (c2 = true), l = true), c2 && (e.audioTransceiver = this._peerConnection.addTransceiver("audio", { direction: "recvonly" })), l && (e.videoTransceiver = this._peerConnection.addTransceiver("video", { direction: "recvonly" }));
    const u = getServerNow();
    this._report("rtc_begin_create_offer", { direction: "up", stream_id: e.streamId, stream_user_id: e.userId, pc_session_id: this.peerConnectionId, vendor_mode: 0 });
    const h = await this._createQueue.add();
    this._report("rtc_create_offer", { error_code: 0, direction: "up", stream_id: e.streamId, stream_user_id: e.userId, elapse: getServerNow() - u });
    let _ = null !== (i = null === (r = e.audioTransceiver) || void 0 === r ? void 0 : r.mid) && void 0 !== i ? i : void 0;
    const p = null !== (o = null === (n = e.videoTransceiver) || void 0 === n ? void 0 : n.mid) && void 0 !== o ? o : void 0, m = lib.parse(h);
    let S, g;
    if (null === (s = m.media) || void 0 === s || s.forEach((e2) => {
      "".concat(e2.mid) === _ ? a = e2 : "".concat(e2.mid) === p && (d = e2);
    }), _ && a || (_ = "audio_".concat(p), a = _objectSpread2(_objectSpread2({}, this._aRecvonlyOfferTpl), {}, { mid: _ })), e.audioMid = _, e.videoMid = p, !t.multiChatMode && !e.virtual && this._aSendonlyAnswerTpl && this._aSendonlyAnswerTpl) {
      var v3, f, y;
      S = this._generateAllSsrc();
      const t2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this._aSendonlyAnswerTpl), this.peer._answerIce), {}, { mid: _, msid: "".concat(e.streamId).concat(null !== (v3 = this._context) && void 0 !== v3 && v3.avSync ? "" : "-audio", " ").concat(e.streamId, "-audio"), ssrcs: generateSsrc(e.streamId, "audio", S.audio) }), i2 = _objectSpread2(_objectSpread2(_objectSpread2({}, this._vSendonlyAnswerTpl), this.peer._answerIce), {}, { mid: p, msid: "".concat(e.streamId).concat(null !== (f = this._context) && void 0 !== f && f.avSync ? "" : "-video", " ").concat(e.streamId, "-video") }, generateSsrcs(e.streamId, S, { flexfec: this._enableSubFlexfec }));
      g = { sdp: lib.write(_objectSpread2(_objectSpread2({}, this.peer._answerSession), {}, { media: [t2, i2] })), sequenceId: e.sequenceId ? ++e.sequenceId : 0 }, null === (y = S) || void 0 === y || delete y.next;
    }
    return encodedTransformSupported$1() && (e.initVideoEncodedTransform(), e.initAudioEncodedTransform()), { partialSdp: getLocalPartialSdp(m, a, d, false), audioMid: _, videoMid: p || "", type: "incroffer", semantics: "unified-plan", audioTransceiverInit: e.audioTransceiver ? { track: "audio", init: { direction: "recvonly" } } : void 0, videoTransceiverInit: e.videoTransceiver ? { track: "video", init: { direction: "recvonly" } } : void 0, allSsrc: S, peerConnectionMode: this.peerConnectionMode, signalingAck: g };
  }
  async handleAck(e) {
    const { stream: t, action: i } = e;
    if (i === SdpAction.removetrack) return "";
    if (i === SdpAction.unpublish || i === SdpAction.unsubscribe) {
      try {
        await this.close(t), "function" == typeof e.onSuccess && e.onSuccess();
      } catch (t2) {
        "function" == typeof e.onFail && e.onFail(t2);
      }
      return t.streamId || "";
    }
    const { signalingAck: r, videoCodec: o } = e, n = lib.parse(r.sdp);
    try {
      await this._internalSetRemoteDescription(n.media, t, o), "function" == typeof e.onSuccess && e.onSuccess();
    } catch (t2) {
      "function" == typeof e.onFail && e.onFail(t2);
    }
    return "";
  }
  async _internalSetRemoteDescription(e, t, i) {
    e.forEach((e2) => {
      "audio" === (e2 = _objectSpread2(_objectSpread2({}, e2), this.peer._answerIce)).type && (t.audioMid ? (e2.mid = t.audioMid, this._midMap.set(t.audioMid, e2)) : this._midMap.set(e2.mid, e2)), "video" === e2.type && (i && setCodecPreferences(e2, i), t.videoMid ? (e2.mid = t.videoMid, this._midMap.set(t.videoMid, e2)) : this._midMap.set(e2.mid, e2));
    });
    t instanceof LocalStream ? this.handlePublishAction({ stream: t, videoCodec: i }) : this.handleSubscribeAction({ stream: t }), await this._applyQueue.add();
  }
  handlePublishAction(e) {
    var t;
    const { videoCodec: i, stream: r } = e, o = r.audioMid ? this._midMap.get(r.audioMid) : void 0, n = r.videoMid ? this._midMap.get(r.videoMid) : void 0;
    this._context.pcKillSwitch.sld_rtcpfb_rrtr_add && isRRTRSupported && (SDPTools.addRRTR(o), SDPTools.addRRTR(n));
    const s = null !== (t = this._context.serverConfig) && void 0 !== t && t.audioRed ? "RED" : getParameter("AUDIO_CODEC");
    "OPUS" !== s && o && setAudioCodecPreferences(o, s), this._context.pcKillSwitch.sld_fmtp_opus_add && SDPTools.decorateOpusConfig(o, this._context.audioProfileManager), isFirefox && firefoxVersion <= 87 && SDPTools.removeRtxInMLine(n), i && n && setCodecPreferences(n, i), this._context.pcKillSwitch.sld_ext_sdesmid_remove && isFirefox && firefoxVersion >= 138 && SDPTools.removeExtSdesMid(n), this._context.pcKillSwitch.sld_fmtp_bitrate_add && (r.enableSimulcast || isSafari || !n || this.addBitrateLimit(n, r.videoEncodeConfig[0].maxKbps)), isFirefox && SDPTools.selectCC(n, isTransportCCSupport ? "tcc" : "remb"), r.audioMid && o && this._midMap.set(r.audioMid, o), r.videoMid && n && this._midMap.set(r.videoMid, n);
  }
  handleSubscribeAction(e) {
    const { stream: t } = e, i = t.audioMid ? this._midMap.get(t.audioMid) : void 0, r = t.videoMid ? this._midMap.get(t.videoMid) : void 0;
    isFirefox || (SDPTools.removeRtpStreamId(i), SDPTools.removeRtpStreamId(r)), this._context.pcKillSwitch.sld_rtcpfb_rrtr_add && isRRTRSupported && (SDPTools.addRRTR(i), SDPTools.addRRTR(r)), this._context.pcKillSwitch.sld_fmtp_opus_add && SDPTools.decorateOpusConfig(i), getParameter("IOS_SAFARI_ORIENTATION") || !isSafari && !isIOS || SDPTools.removeExtVideoOrientation(r), this._context.pcKillSwitch.sld_fmtp_sps_add && t.isPublic && isChrome && chromeVersion >= 86 && SDPTools.decorateSpsPpsIdrInKeyframe(r), t.audioMid && i && this._midMap.set(t.audioMid, i), t.videoMid && r && this._midMap.set(t.videoMid, r);
  }
  async getDefaultSdp() {
    const e = new RTCPeerConnection();
    e.addTransceiver("audio", { direction: "recvonly" }), e.addTransceiver("video", { direction: "recvonly" });
    const t = await e.createOffer(), i = lib.parse(t.sdp);
    this.createAVMlineOfferTpl(t.sdp);
    const r = [];
    return i.media = i.media.filter((e2) => {
      if ("recvonly" === e2.direction) {
        const t2 = "template_".concat(e2.type);
        return e2.mid = t2, r.push(t2), true;
      }
      return false;
    }), isRRTRSupported && pushRRTR(i), i.groups = [{ mids: r.join(" "), type: "BUNDLE" }], e.close(), { sdp: lib.write(i), semantics: "unified-plan", type: "incroffer" };
  }
  async rollback(e) {
    let { msid: t, stream: i, audioMid: r, videoMid: o } = e;
    return this.logger.warn("rollback()"), this.close(i, r, o);
  }
  async close(e, t, i) {
    this.logger.info("close()");
    const r = e.audioMid || t, o = e.videoMid || i;
    if (e.audioTransceiver && r) try {
      e.audioTransceiver.stop(), delete e.audioTransceiver;
    } catch (e2) {
    }
    if (e.videoTransceiver && o) try {
      e.videoTransceiver.stop(), delete e.videoTransceiver;
    } catch (e2) {
    }
    const n = r ? this._midMap.get(r) : void 0, s = o ? this._midMap.get(o) : void 0;
    n && closeMline(n), s && closeMline(s), r && n && this._midMap.set(r, n), o && s && this._midMap.set(o, s), await this._applyQueue.add();
  }
  async setCurrentDescription() {
    await this._applyQueue.add();
  }
  createAVMlineOfferTpl(e) {
    lib.parse(e).media.forEach((e2) => {
      "audio" === e2.type && (this._aRecvonlyOfferTpl = e2);
    });
  }
  _generateAllSsrc() {
    const e = generateAllSsrc(this._nextSsrc);
    return this._nextSsrc = e.next, e;
  }
  async create() {
    this.logger.info("RTCPeerConnection create");
    const e = await this.peer.createOfferSdp();
    return DCHECK(e, "RTCPeerConnection not return SDP"), await this.peer.setLocalDescription(e), e;
  }
  async apply() {
    this.logger.info("RTCPeerConnection apply");
    let e = await this.peer.createOfferSdp();
    DCHECK(e, "RTCPeerConnection not return SDP");
    const t = lib.parse(e);
    e = this.generateOffer(t, e);
    const i = this.generateAnswer(t);
    await this.setLocalDescription(e), await this.setRemoteDescription(i);
  }
  generateOffer(e, t) {
    let i = false;
    return "v1" === this.peer.getIceVersion() && isFirefox && (e.media = e.media.map((e2) => _objectSpread2(_objectSpread2({}, e2), this.peer._offerIce)), i = true), this._context.pcKillSwitch.sld_fmtp_opus_add && (e.media = e.media.map((e2) => {
      if ("audio" === e2.type) {
        const t2 = "sendonly" === e2.direction;
        SDPTools.decorateOpusConfig(e2, t2 ? this._context.audioProfileManager : void 0);
      }
      return e2;
    }), i = true), this._context.pcKillSwitch.sld_rtcpfb_rrtr_add && (e.media = e.media.map((e2) => (!isRRTRSupported || "audio" !== e2.type && "video" !== e2.type || SDPTools.addRRTR(e2), e2)), i = true), i ? lib.write(e) : t;
  }
  generateAnswer(e) {
    const t = [];
    return e.media.forEach((e2) => {
      if ("application" === e2.type) {
        DCHECK(void 0 !== e2.mid, "should always have mid in mline");
        let i2 = this._midMap.get(e2.mid);
        return i2 || (i2 = this.generateDCAnswer(e2), this._midMap.set(e2.mid, i2)), void t.push(_objectSpread2({}, i2));
      }
      const i = "".concat(e2.mid);
      DCHECK(i, "No MID in offer m-line: ".concat(e2));
      let r = this._midMap.get(i);
      r || (this.logger.info("generateInactiveAnswerMLine", "mid: %o, mLine: %o", e2.mid, e2), r = this.generateInactiveAnswerMLine(e2)), t.push(r);
    }), this.peer.createAnswerSdp(t, e.groups);
  }
  generateInactiveAnswerMLine(e) {
    return _objectSpread2(_objectSpread2(_objectSpread2({}, e), this.peer._answerIce), {}, { direction: "inactive" });
  }
  generateDCAnswer(e) {
    const t = _objectSpread2(_objectSpread2(_objectSpread2({}, e), this.peer._answerIce), {}, { sctpmap: { sctpmapNumber: 5e3, app: "webrtc-datachannel", maxMessageSize: 262144 } });
    return isFirefox && (delete t.bundleOnly, t.port = 9), t;
  }
  destroy() {
    super.destroy(), this._pqueue.destroy(), this._applyQueue.destroy(), this._createQueue.destroy();
  }
};
function highPLock(e, t, i) {
  const r = i.value;
  return i.value = async function() {
    const e2 = this.logger;
    e2.info("SDP Lock", "pending task %o", t);
    const i2 = await this._pqueue.enqueue(0);
    e2.info("SDP Lock", "running task %o", t);
    try {
      for (var o = arguments.length, n = new Array(o), s = 0; s < o; s++) n[s] = arguments[s];
      return await (null == r ? void 0 : r.apply(this, n));
    } finally {
      e2.info("SDP Lock", "unlocking by task %o", t), i2();
    }
  }, i;
}
function lowPLock(e, t, i) {
  const r = i.value;
  return i.value = async function() {
    const e2 = this.logger;
    e2.info("SDP Lock", "pending task %o", t);
    const i2 = await this._pqueue.enqueue(1);
    e2.info("SDP Lock", "running task %o", t);
    try {
      for (var o = arguments.length, n = new Array(o), s = 0; s < o; s++) n[s] = arguments[s];
      return await (null == r ? void 0 : r.apply(this, n));
    } finally {
      e2.info("SDP Lock", "unlocking by task %o", t), i2();
    }
  }, i;
}
__decorateClass$8([highPLock], StandardHandler.prototype, "create", 1), __decorateClass$8([lowPLock], StandardHandler.prototype, "apply", 1);
var SDPTools = { decorateOpusConfig(e, t) {
  if (!e) return;
  const i = null == e ? void 0 : e.rtp.find((e2) => "opus" === e2.codec);
  if (!i || !e.fmtp) return;
  const r = e.fmtp.find((e2) => e2.payload === i.payload);
  r && (t && (r.config = t.getOpusConfigStr(r.config)), r.config = addStereo(r.config));
}, removeRtxInMLine(e) {
  var t;
  if (!e) return;
  const i = [];
  e.rtp = e.rtp.filter((e2) => ("rtx" === e2.codec && i.push(e2.payload), "rtx" !== e2.codec)), e.fmtp = e.fmtp.filter((e2) => i.includes(e2.payload)), e.payloads = null === (t = e.payloads) || void 0 === t ? void 0 : t.split(" ").filter((e2) => !i.includes(parseInt(e2))).join(" ");
}, removeExtSdesMid(e) {
  var t;
  e && (e.ext = null === (t = e.ext) || void 0 === t ? void 0 : t.filter((e2) => !e2.uri.includes("sdes:mid")));
}, selectCC(e, t) {
  var i, r;
  if (e) {
    if ("tcc" === t) e.ext = null === (i = e.ext) || void 0 === i ? void 0 : i.filter((e2) => -1 === e2.uri.indexOf("abs-send-time")), e.rtcpFb = null === (r = e.rtcpFb) || void 0 === r ? void 0 : r.filter((e2) => "goog-remb" !== e2.type);
    else if ("remb" === t) {
      var o, n;
      e.rtcpFb = null === (o = e.rtcpFb) || void 0 === o ? void 0 : o.filter((e2) => "transport-cc" !== e2.type), e.ext = null === (n = e.ext) || void 0 === n ? void 0 : n.filter((e2) => -1 === e2.uri.indexOf("transport"));
    }
  }
}, addRRTR(e) {
  e && e.rtp.forEach((t) => {
    e.rtcpFb || (e.rtcpFb = []), e.rtcpFb.find((e2) => e2.payload === t.payload && "rrtr" === e2.type) || e.rtcpFb.push({ payload: t.payload, type: "rrtr" });
  });
}, removeRtpStreamId(e) {
  e && Array.isArray(e.ext) && (e.ext = e.ext.filter((e2) => "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id" !== e2.uri));
}, decorateSpsPpsIdrInKeyframe(e) {
  if (!e) return;
  const t = e.rtp.filter((e2) => "H264" === e2.codec);
  t.length && e.fmtp && e.fmtp.forEach((e2) => {
    t.find((t2) => t2.payload === e2.payload) && (e2.config += ";sps-pps-idr-in-keyframe=1");
  });
}, removeExtVideoOrientation(e) {
  e && Array.isArray(e.ext) && (e.ext = e.ext.filter((e2) => !e2.uri.includes("video-orientation")));
}, removeExtFramemarking(e) {
  e && Array.isArray(e.ext) && (e.ext = e.ext.filter((e2) => !e2.uri.includes("framemarking")));
} };
var PriorityQueue = class {
  constructor() {
    _defineProperty(this, "queue", []), _defineProperty(this, "processing", false);
  }
  async enqueue() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    const { promise: t, resolve: i } = promiseWithResolves(), r = { priority: e, resolve: i }, o = this.queue.findIndex((t2) => t2.priority > e);
    return -1 === o ? this.queue.push(r) : this.queue.splice(o, 0, r), this.tryProcess(), await t, this.processing = true, () => {
      this.processing = false, this.tryProcess();
    };
  }
  destroy() {
    this.queue.forEach((e) => {
      let { resolve: t } = e;
      t();
    }), this.queue = [], this.processing = false;
  }
  tryProcess() {
    if (this.processing) return;
    const e = this.queue.shift();
    e && e.resolve();
  }
};
function promiseWithResolves() {
  let e, t;
  const i = new Promise((i2, r) => {
    e = i2, t = r;
  });
  if (!e || !t) throw Error("Broken Implement of Promise");
  return { promise: i, resolve: e, reject: t };
}
var addStereo = (e) => {
  const t = {};
  return e.split(";").forEach((e2) => {
    const [i, r] = e2.split("=");
    i && r && (t[i] = r);
  }), t["sprop-stereo"] = 1, t.stereo = 1, Object.keys(t).map((e2) => "".concat(e2, "=").concat(t[e2])).join(";");
};
var createHandler = (e, t) => e.enableFallbackHandler ? new FallbackHandler(e, t) : e.enableStandardHandler ? new StandardHandler(e, t) : isFirefox ? new FirefoxHandler(e, t) : new ChromeHandler(e, t);
var ReconnectReasonMap = { [InternalReconnectReason.ICE_FAILED]: ReconnectReason.ICE_FAILED, [InternalReconnectReason.DC_ERROR]: ReconnectReason.ICE_FAILED, [InternalReconnectReason.DC_CLOSE]: ReconnectReason.ICE_FAILED, [InternalReconnectReason.NODE_CHANGE]: ReconnectReason.NODE_CHANGE, [InternalReconnectReason.NOTIFY_RECONNECT]: ReconnectReason.NOTIFY_RECONNECT, [InternalReconnectReason.JOIN_TIMEOUT]: ReconnectReason.JOIN_TIMEOUT };
var SignalingManager = class extends EnhancedEventEmitter {
  constructor(e) {
    super(), _defineProperty(this, "_connectionManager", void 0), _defineProperty(this, "_dataChannelSignal", void 0), _defineProperty(this, "_state", void 0), _defineProperty(this, "_connectionLostTimer", void 0), _defineProperty(this, "_isReconnecting", false), _defineProperty(this, "logger", void 0), this._ctx = e, this.logger = new Logger$1("SignalingManager", 1, e.id), this.logger.info("constructor", "invoke"), this._connectionManager = new ConnectionManager(e), this._addConnectorHandler();
  }
  connect() {
    return this.isConnected() ? Promise.resolve() : new Promise((e, t) => {
      this._connectionManager.once("connected", () => e()), this._connectionManager.once("disconnected", t), this._connectionManager.startup();
    });
  }
  reconnect(e, t) {
    this._connectionManager.reconnect(e, t);
  }
  sendSignaling(e, t, i, r) {
    if (!this._dataChannelSignal) throw new SDKError(ErrorCode.NOT_CONNECTED_YET, "signaling channel is not connected");
    return this._dataChannelSignal.sendSignaling(e, t, i, r);
  }
  sendP2PMessage(e, t) {
    if (!this._dataChannelSignal) throw new SDKError(ErrorCode.NOT_CONNECTED_YET, "signaling channel is not connected");
    return this._dataChannelSignal.sendP2PMessage(e, t);
  }
  destroy() {
    var e, t;
    this.logger.info("destroy()"), this._clearConnectionLostTimer(), this._connectionManager.shotdown(), null === (e = this._ctx.handler) || void 0 === e || e.destroy(), this._ctx.handler = void 0, null === (t = this._dataChannelSignal) || void 0 === t || t.destroy(), this._state && this._setState(ConnectionState.CONNECTION_STATE_DISCONNECTED), this.removeAllListeners();
  }
  isConnected() {
    return this._state === ConnectionState.CONNECTION_STATE_CONNECTED || this._state === ConnectionState.CONNECTION_STATE_RECONNECTED;
  }
  isReconnecting() {
    return this._state === ConnectionState.CONNECTION_STATE_CONNECTING || this._state === ConnectionState.CONNECTION_STATE_RECONNECTING;
  }
  _setState(e, t) {
    if (this._state === e) return;
    this._state = e;
    const i = { state: e };
    t && (i.reason = ReconnectReasonMap[t] || ReconnectReason.ICE_FAILED), this.safeEmit(StateEvent.ON_CONNECTION_STATE_CHANGE, i);
  }
  _addConnectorHandler() {
    var e = this;
    this._connectionManager.on("connected", (e2) => {
      var t;
      this.logger.info("connectStateChange", "connected"), this._clearConnectionLostTimer(), null === (t = this._dataChannelSignal) || void 0 === t || t.destroy(), this._ctx.peerConnection = e2.pc, this._ctx.handler = createHandler(this._ctx, e2.pc), this._dataChannelSignal = e2.signaling, this._addSignalEventHandler(), this._setState(this._isReconnecting ? ConnectionState.CONNECTION_STATE_RECONNECTED : ConnectionState.CONNECTION_STATE_CONNECTED);
    }), this._connectionManager.on("disconnected", (e2) => {
      this._clearConnectionLostTimer(), this._setState(ConnectionState.CONNECTION_STATE_DISCONNECTED), this.logger.error("connectStateChange", "disconnected. %o", e2.message), this._isReconnecting && this.safeEmit(StateEvent.ON_RECONNECT_FAILED);
    }), this._connectionManager.on("connecting", () => {
      this._isReconnecting = false, this._ctx.handler = void 0, this._setState(ConnectionState.CONNECTION_STATE_CONNECTING), this.logger.info("connectStateChange", "connecting");
    }), this._connectionManager.on("reconnecting", (e2) => {
      this._setState(ConnectionState.CONNECTION_STATE_DISCONNECTED, e2), this._connectionLostTimer || (this._connectionLostTimer = setTimeout(() => {
        this.safeEmit(StateEvent.ON_CONNECTION_STATE_CHANGE, { state: ConnectionState.CONNECTION_STATE_LOST });
      }, 1e4)), this._isReconnecting = true, this._ctx.handler = void 0, this._setState(ConnectionState.CONNECTION_STATE_RECONNECTING, e2), this.logger.warn("connectStateChange", "reconnecting");
    }), this._connectionManager.on("connectWidthTcp", () => {
      this.safeEmit(StateEvent.CONNECT_WITH_TCP);
    }), ["__onGetIceConfigHook", "__onIceConnectSuccessHook", "__onConnectSuccessHook"].forEach((t) => {
      this._connectionManager.on(t, function() {
        for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++) r[o] = arguments[o];
        return e.emit(t, ...r);
      });
    });
  }
  _clearConnectionLostTimer() {
    this._connectionLostTimer && (clearTimeout(this._connectionLostTimer), delete this._connectionLostTimer);
  }
  _addSignalEventHandler() {
    var e, t;
    [SignalEvent.ON_ADD_STREAM, SignalEvent.ON_ADD_STREAM_LIST, SignalEvent.ON_REMOVE_STREAM, SignalEvent.ON_REMOVE_STREAM_LIST, SignalEvent.USER_CONNECTION, SignalEvent.USER_CONNECTION_LIST, SignalEvent.USER_DISCONNECTION, SignalEvent.USER_DISCONNECTION_LIST, SignalEvent.ON_UPDATE_STREAM_ATTRIBUTES, SignalEvent.ON_UPDATE_ROOM_ATTRIBUTES, SignalEvent.ON_PUSH_TRACK, SignalEvent.ON_REMOVE_TRACK, SignalEvent.ON_CUSTOM_MESSAGE, SignalEvent.USER_MESSAGE_RECEIVED_OUTSIDE_ROOM, SignalEvent.USER_BINARY_MESSAGE_RECEIVED_OUTSIDE_ROOM, SignalEvent.USER_MESSAGE_RECEIVED, SignalEvent.USER_BINARY_MESSAGE_RECEIVED, SignalEvent.POST_PROCESSING_MESSAGE, SignalEvent.ON_USER_TOKEN_WILL_EXPIRE, SignalEvent.ON_TOKEN_PUBLISH_PRIVILEGE_WILL_EXPIRE, SignalEvent.ON_TOKEN_PUBLISH_PRIVILEGE_DID_EXPIRED, SignalEvent.ON_TOKEN_SUBSCRIBE_PRIVILEGE_WILL_EXPIRE, SignalEvent.ON_TOKEN_SUBSCRIBE_PRIVILEGE_DID_EXPIRED, SignalEvent.STREAM_CONTROL_MESSAGE, SignalEvent.ENGINE_CONTROL_MESSAGE, SignalEvent.ON_UPDATE_USER_ATTRIBUTES, SignalEvent.ON_SPEAKER_CHANGE, SignalEvent.ON_STREAM_FAILED, SignalEvent.ON_FORWARD_DST_ROOM_USER_KICK, SignalEvent.ON_STREAM_PULL_STATE_CHANGED, SignalEvent.ON_STREAM_PUSHED_BY_OTHER, MediaServerSignalEvent.RSCP, MediaServerSignalEvent.RTT, MediaServerSignalEvent.SSC].forEach((e2) => {
      var t2;
      null === (t2 = this._dataChannelSignal) || void 0 === t2 || t2.on(e2, (t3) => {
        this.safeEmit(e2, t3);
      });
    }), null === (e = this._dataChannelSignal) || void 0 === e || e.on(SignalEvent.NODE_CHANGE, (e2) => {
      this._connectionManager.reconnectByNodeChange(e2);
    }), null === (t = this._dataChannelSignal) || void 0 === t || t.on(SignalEvent.ON_NOTIFY_RECONNECT, () => {
      this._connectionManager.reconnect(InternalReconnectReason.NOTIFY_RECONNECT);
    });
  }
};
var UserRole = ((e) => (e.NORMAL_USER = "normalUser", e.SILENT_USER = "silentUser", e))(UserRole || {});
var _excluded$3 = ["preferCodecName"];
var EngineVideoProfile = class {
  constructor(e) {
    _defineProperty(this, "_captureDeviceId", void 0), _defineProperty(this, "_contentHint", void 0), _defineProperty(this, "_videoCaptureConf", _objectSpread2({}, defaultVideoEncoderConfig)), _defineProperty(this, "_mainPreferCodec", void 0), _defineProperty(this, "_screenPreferCodec", void 0), _defineProperty(this, "_remoteVideoConfig", /* @__PURE__ */ new Map()), _defineProperty(this, "_remoteSimulcastStreamType", /* @__PURE__ */ new Map()), _defineProperty(this, "_simulcastMode", VideoSimulcastMode.VIDEO_ONLY_ONE), _defineProperty(this, "_highVideoEncodeConf", videoCaptureConf2EncodeConf(defaultVideoEncoderConfig)), _defineProperty(this, "_midVideoEncodeConf", void 0), _defineProperty(this, "_lowVideoEncodeConf", void 0), _defineProperty(this, "_screenEncodeConfig", defaultScreenEncoderConfig), _defineProperty(this, "_invalidVideoEncodeConf", void 0), _defineProperty(this, "activeSimStreams", []), _defineProperty(this, "_logger", void 0), _defineProperty(this, "_apiVersion", void 0), this._ctx = e, this._logger = new Logger$1("EngineVideoProfile", 1, e.id);
  }
  setCaptureDeviceId(e) {
    this._captureDeviceId = e;
  }
  setCaptureConfig(e) {
    this._videoCaptureConf = _objectSpread2(_objectSpread2({}, this._videoCaptureConf), e);
  }
  getCaptureConfig(e) {
    e = e || this._captureDeviceId;
    const t = _objectSpread2({}, this._videoCaptureConf);
    return "user" === e || "environment" === e || "left" === e || "right" === e ? (delete t.deviceId, t.facingMode = e) : e && (!isDingTalk || isIOS ? t.deviceId = { exact: e } : delete t.deviceId), t;
  }
  getContentHint() {
    return this._contentHint;
  }
  getPreferCodec(e) {
    return e ? this._screenPreferCodec : this._mainPreferCodec;
  }
  setRemoteUserVideoConfig(e, t) {
    "object" == typeof t ? this._remoteVideoConfig.set(e, t) : this._remoteSimulcastStreamType.set(e, t);
  }
  getSubLayer(e, t) {
    const i = this._remoteSimulcastStreamType.get(e.userId), r = this._remoteVideoConfig.get(e.userId);
    if (i) {
      var o, n, s, a, d, c2;
      const { videoDescriptions: t2, subVideoDescriptions: r2 } = e.attributes || {}, l = Array.isArray(r2) ? r2 : t2;
      let u;
      return 1 === l.length ? u = 0 : 2 === l.length ? u = i === SimulcastStreamType.VIDEO_STREAM_HIGH ? 0 : 1 : l.length >= 3 && (u = { [SimulcastStreamType.VIDEO_STREAM_HIGH]: 0, [SimulcastStreamType.VIDEO_STREAM_MID]: 1, [SimulcastStreamType.VIDEO_STREAM_LOW]: 2 }[i]), { spatialLayer: null !== (o = null !== (n = u && (null === (s = l[u]) || void 0 === s ? void 0 : s.video_index)) && void 0 !== n ? n : u) && void 0 !== o ? o : 0, spatialSubLayer: null !== (a = null !== (d = u && (null === (c2 = l[u]) || void 0 === c2 ? void 0 : c2.sub_index)) && void 0 !== d ? d : u) && void 0 !== a ? a : -1 };
    }
    return r ? getSubLayerByVideoConfig(r, e) : t ? getSubLayerByVideoConfig(t, e) : void 0;
  }
  getSimulcastMode() {
    return this._simulcastMode;
  }
  async setSimulcastMode(e, t) {
    if (!isSimulcastSupported()) throw new SDKError(ErrorCode.NOT_SUPPORTED, "Simulcast is not supported");
    if (this._simulcastMode !== e) {
      if (null != t && t.hasPublished) {
        var i, r;
        if (null !== (i = t.localStream) && void 0 !== i && i.videoHasPublish || null !== (r = t.localStream) && void 0 !== r && r.audioHasPublish) throw new SDKError(ErrorCode.SET_SIMULCAST_FAILED, "Cannot change simulcast mode after publishing the video streams");
        this._logger.print("setSimulcastMode()", "change simulcast mode and unpublish."), await t.unpublish();
      }
      this._simulcastMode = e, e !== VideoSimulcastMode.VIDEO_ONLY_ONE && this._autoGenerateSubVideoEncodeConfig();
    }
  }
  closeSimulcast() {
    this._simulcastMode = VideoSimulcastMode.VIDEO_ONLY_ONE;
  }
  async setVideoEncodeConfigPolyfill(e) {
    if (Array.isArray(e)) {
      checkVideoEncoderConfig(e);
      const [t, ...i] = e;
      this.setVideoEncodeConfig(t), await this.setSubVideoEncodeConfig(_reverseInstanceProperty(i).call(i));
    } else this.setVideoEncodeConfig(e);
  }
  setVideoEncodeConfig(e) {
    checkVideoEncoderConfig([e]);
    const t = this._midVideoEncodeConf || this._lowVideoEncodeConf;
    t && getResolution(t) >= getResolution(e) ? (this._logger.warn("setVideoEncodeConfig", "smaller then substream"), this._invalidVideoEncodeConf = videoCaptureConf2EncodeConf(e), e = t) : delete this._invalidVideoEncodeConf;
    const i = _objectSpread2({}, e), { preferCodecName: r } = i, o = _objectWithoutProperties(i, _excluded$3);
    checkSupportedConstraints(o), this._logger.print("setVideoEncodeConfig", "update encode config", e), this._highVideoEncodeConf = videoCaptureConf2EncodeConf(e), this._contentHint = e.contentHint, this._mainPreferCodec = r, this._logger.print("setVideoEncodeConfig", "update capture config", o), this._videoCaptureConf = o;
  }
  async setSubVideoEncodeConfig(e, t, i) {
    if (this._logger.print("setSubVideoEncodeConfig", "%o, published=%s", e, null == t ? void 0 : t.hasPublished), e && e.length > 0) {
      checkVideoEncoderConfig(e), _sortInstanceProperty(e).call(e, (e2, t2) => getResolution(e2) - getResolution(t2));
      const n = this._invalidVideoEncodeConf || this._highVideoEncodeConf, s = e[e.length - 1];
      if (getResolution(s) >= getResolution(n)) throw new SDKError(ErrorCode.SET_SIMULCAST_FAILED, "The resolution cannot exceed the mainstream");
      if (null != t && t.hasPublished && e.length !== this._getSubLayers().length) {
        var r, o;
        if (null !== (r = t.localStream) && void 0 !== r && r.videoHasPublish || null !== (o = t.localStream) && void 0 !== o && o.audioHasPublish) throw new SDKError(ErrorCode.SET_SIMULCAST_FAILED, "Cannot change the number of substreams after publishing the video streams");
        await t.unpublish();
      }
      e.length > 2 && (reportRtcInvokeStatus(this._ctx.id, "simulcast_over_limit", "setLocalSimulcastMode: You can set parameters for up to 2 streams"), warnDevelopers("setLocalSimulcastMode: You can set parameters for up to 2 streams"));
      const [a, d] = e;
      a && (checkVideoConfigQuotient(n, a), this._lowVideoEncodeConf = videoCaptureConf2EncodeConf(a)), d && (checkVideoConfigQuotient(n, d), this._midVideoEncodeConf = videoCaptureConf2EncodeConf(d)), this._invalidVideoEncodeConf && (this.setVideoEncodeConfig(this._invalidVideoEncodeConf), await (null == i ? void 0 : i.updateVideoCaptureConfig(this._ctx.videoProfile.getCaptureConfig())));
    } else this._autoGenerateSubVideoEncodeConfig();
  }
  genVideoDescriptions(e) {
    var t, i;
    const r = [];
    let o = [];
    const n = [], s = [];
    let { width: a, height: d, frameRate: c2, maxKbps: l } = e.videoEncodeConfig[0];
    a = constraints2number(a), d = constraints2number(d);
    const u = null === (t = e.videoTrack) || void 0 === t ? void 0 : t.preprocessingTrack, { width: h, height: _, frameRate: p } = null !== (i = null == u ? void 0 : u.getSettings()) && void 0 !== i ? i : {};
    h && (a = Math.floor(h)), _ && (d = Math.floor(_)), p && (c2 = Math.floor(p)), ("number" != typeof c2 || Number.isNaN(c2)) && (c2 = 30), r.push({ width: a, height: d, framerate: c2, maxkbps: l, rid: "0" }), n.unshift({ maxBitrate: 1e3 * l, rid: "0", maxFramerate: c2 });
    const { serverConfig: m } = this._ctx;
    if (!(e.isScreen || this._simulcastMode === VideoSimulcastMode.VIDEO_ONLY_ONE || isFirefox && "VP8" !== (null == m ? void 0 : m.videoCodec))) {
      const e2 = getSimulcastLayers(a, d);
      if (e2 > 1) {
        const t2 = this._getSubVideoEncodeConfig(e2, { width: a, height: d });
        this._logger.info("simulcast() ", "simulcastLayers: %o", t2), s.push(true), t2.forEach((e3, t3) => {
          const i2 = { maxBitrate: 1e3 * e3.maxkbps, scaleResolutionDownBy: e3.scaleResolutionDownBy, rid: "".concat(t3 + 1), maxFramerate: e3.frameRate };
          n.unshift(i2), r.push({ width: e3.width, height: e3.height, framerate: e3.frameRate, maxkbps: e3.maxkbps, rid: "".concat(t3 + 1) }), s.push(true);
        }), null != m && m.simulcastOnDemand && (o = r.map((e3, t3) => _objectSpread2(_objectSpread2({}, e3), {}, { video_index: t3, sub_index: t3 })));
      }
    }
    return null != m && m.e2eFeedback && (o = r.map((e2, t2) => _objectSpread2(_objectSpread2({}, e2), {}, { video_index: t2, sub_index: t2 }))), { videoDescriptions: r, subVideoDescriptions: o, sendEncodings: n, activeSimulcastStreams: s };
  }
  getVideoEncodeConfig() {
    return [this._highVideoEncodeConf, this._midVideoEncodeConf, this._lowVideoEncodeConf].filter((e) => e);
  }
  setScreenEncodeConfig(e) {
    this._screenEncodeConfig = e;
  }
  getScreenEncodeConfig() {
    return this._screenEncodeConfig;
  }
  checkSimulcastApiVersion(e) {
    if (this._apiVersion) {
      if (this._apiVersion !== e) {
        const e2 = "mixing old and new apis, please use ".concat("new" === this._apiVersion ? "setLocalSimulcastMode/setRemoteSimulcastStreamType" : "enableSimulcastMode/setRemoteVideoConfig", " instead.");
        throw reportRtcInvokeStatus(this._ctx.id, "mixingOldAndNewApis", e2), new SDKError(ErrorCode.MIXING_OLD_AND_NEW_APIS, e2);
      }
    } else this._apiVersion = e;
  }
  destroy() {
    this._videoCaptureConf = defaultVideoEncoderConfig, this._highVideoEncodeConf = videoCaptureConf2EncodeConf(defaultVideoEncoderConfig), delete this._invalidVideoEncodeConf, this._remoteVideoConfig.clear(), this._remoteSimulcastStreamType.clear();
  }
  _autoGenerateSubVideoEncodeConfig() {
    this._logger.print("_autoGenerateSubVideoEncodeConfig()", "generate low stream.");
    const e = this._highVideoEncodeConf, t = constraints2number(e.width), i = constraints2number(e.height), r = Math.min(t, i) / 90;
    this._lowVideoEncodeConf = { width: Math.floor(t / r), height: Math.floor(i / r), maxKbps: 100, frameRate: 10 };
  }
  _getSubLayers() {
    const e = [];
    return this._midVideoEncodeConf && e.push(this._midVideoEncodeConf), this._lowVideoEncodeConf && e.push(this._lowVideoEncodeConf), e;
  }
  _getSubVideoEncodeConfig(e, t) {
    return this._getSubLayers().slice(1 - e).map((e2) => {
      if (e2.width > e2.height && t.width < t.height || e2.width < e2.height && t.width > t.height) {
        const t2 = e2.width;
        e2.width = e2.height, e2.height = t2;
      }
      const i = constraints2number(e2.width), r = constraints2number(e2.height), o = Math.max(t.width / i, t.height / r);
      return { width: Math.floor(t.width / o), height: Math.floor(t.height / o), scaleResolutionDownBy: o, frameRate: constraints2number(e2.frameRate) || 15, maxkbps: e2.maxKbps || 600 };
    });
  }
  __autoResetVideoEncoderConfig(e) {
    const t = autoResetVideoEncoderConfig(this.getVideoEncodeConfig(), e);
    t && (this.setVideoEncodeConfigPolyfill(t), this._logger.print("autoResetVideoEncoderConfig() result", JSON.stringify(t)), reportRtcInvokeStatus(this._ctx.id, "autoResetVideoEncoderConfig", JSON.stringify(t)));
  }
};
var RTSMessageLimiter = class {
  constructor(e) {
    _defineProperty(this, "_sendTimes", []), _defineProperty(this, "_bufferSizeLimit", void 0), _defineProperty(this, "_totalSizeLimitPerSecond", void 0), _defineProperty(this, "_limitModeInterval", void 0), _defineProperty(this, "_limitModeQPS", void 0), _defineProperty(this, "_interval", void 0), _defineProperty(this, "_qps", void 0), this.setLimitMode(e);
  }
  setLimitMode(e) {
    e === RTS_MODE.LIMIT_MODE ? (this._bufferSizeLimit = 1, this._totalSizeLimitPerSecond = 30720, this._limitModeInterval = 1e3, this._limitModeQPS = 60) : (this._bufferSizeLimit = 64, delete this._totalSizeLimitPerSecond, delete this._limitModeInterval, delete this._limitModeQPS);
  }
  setQPS(e, t) {
    this._interval = e, this._qps = t;
  }
  check(e) {
    var t, i;
    const r = Date.now(), o = checkBufferSize(e, this._bufferSizeLimit);
    if ("number" == typeof this._totalSizeLimitPerSecond) {
      if (this._sendTimes.reduce((e2, t2) => r - t2.ts < 1e3 ? e2 + t2.size : e2, 0) + o > this._totalSizeLimitPerSecond) throw new SDKError(ErrorCode.USER_MESSAGE_EXCEED_QPS, "user message exceed total size(".concat(this._totalSizeLimitPerSecond, ")"));
    }
    const n = null !== (t = this._limitModeInterval) && void 0 !== t ? t : this._interval, s = null !== (i = this._limitModeQPS) && void 0 !== i ? i : this._qps;
    if ("number" == typeof n && "number" == typeof s) if (this._sendTimes.length < s) this._sendTimes.push({ ts: r, size: o });
    else {
      if (r - this._sendTimes[0].ts < n) throw new SDKError(ErrorCode.USER_MESSAGE_EXCEED_QPS, "user message exceed qps(".concat(s, ")"));
      this._sendTimes.splice(0, 1), this._sendTimes.push({ ts: r, size: o });
    }
  }
};
var encodedJs = "IWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NvbnN0IHQ9e2dldE5BTFVuaXRzKGUpe2xldCByPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV07aWYoZS5sZW5ndGgtZS5wb3NpdGlvbjw0KXJldHVybltdO2NvbnN0e3Bvc2l0aW9uOm59PWU7cmV0dXJuIDE9PT1lLmdldEludDMyKG4pfHwwPT09ZS5nZXRJbnQxNihuKSYmMT09PWUuZ2V0SW50OChuKzIpP3QuZ2V0QW5uZXhiTmFscyhlLHIpOnQuZ2V0QXZjY05hbHMoZSxyKX0sZ2V0QW5uZXhiTmFscyhlLHIpe2NvbnN0IG49W107bGV0IG89dC5nZXRIZWFkZXJQb3NpdGlvbkFubmV4QihlKSxpPW8ucG9zLGE9aTtmb3IoO2k8ZS5sZW5ndGgtNDspe2NvbnN0IHU9bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIuc2xpY2UoaSxpK28uaGVhZGVyTGVuZ3RoKSk7by5wb3M9PT1lLnBvc2l0aW9uJiZlLnNraXAoby5oZWFkZXJMZW5ndGgpLG89dC5nZXRIZWFkZXJQb3NpdGlvbkFubmV4QihlKSxhPW8ucG9zO2NvbnN0IGM9e2hlYWRlcjp1LGJvZHk6bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIuc2xpY2UoaSt1LmJ5dGVMZW5ndGgsYSkpLHR5cGU6LTF9O3I/dC5hbmFseXNlSDI2NU5hbChjKTp0LmFuYWx5c2VOYWwoYyksKGMudHlwZTw9OXx8ciYmYy50eXBlPD00MCkmJjAhPT1jLnR5cGUmJm4ucHVzaChjKSxlLnNraXAoYS1lLnBvc2l0aW9uKSxpPWF9cmV0dXJuIG59LGdldEF2Y2NOYWxzKGUscil7Y29uc3Qgbj1bXTtmb3IoO2UucG9zaXRpb248ZS5sZW5ndGgtNDspe2NvbnN0IG89ZS5nZXRJbnQzMihlLnBvc2l0aW9uKTtpZighKGUubGVuZ3RoLWUucG9zaXRpb24+PW8pKWJyZWFrO3tjb25zdCBpPW5ldyBVaW50OEFycmF5KGUuYnVmZmVyLnNsaWNlKGUucG9zaXRpb24sZS5wb3NpdGlvbis0KSk7ZS5za2lwKDQpO2NvbnN0IGE9bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIuc2xpY2UoZS5wb3NpdGlvbixlLnBvc2l0aW9uK28pKTtlLnNraXAobyk7Y29uc3QgdT17aGVhZGVyOmksYm9keTphLHR5cGU6LTF9O3I/dC5hbmFseXNlSDI2NU5hbCh1KTp0LmFuYWx5c2VOYWwodSksdS50eXBlPD05JiYwIT09dS50eXBlJiZuLnB1c2godSl9fXJldHVybiBufSxhbmFseXNlTmFsKHQpe2NvbnN0IGU9MzEmdC5ib2R5WzBdO3N3aXRjaCh0LnR5cGU9ZSxlKXtjYXNlIDE6dC5uZHI9ITA7YnJlYWs7Y2FzZSA1OnQuaWRyPSEwO2JyZWFrO2Nhc2UgNjp0LnNlaT0hMDticmVhaztjYXNlIDc6dC5zcHM9ITA7YnJlYWs7Y2FzZSA4OnQucHBzPSEwfX0sYW5hbHlzZUgyNjVOYWwodCl7Y29uc3QgZT0oMTI2JnQuYm9keVswXSk+PjE7c3dpdGNoKHQudHlwZT1lLGUpe2Nhc2UgMzk6Y2FzZSA0MDp0LnNlaT0hMH19LGdldEhlYWRlclBvc2l0aW9uQW5uZXhCKHQpe2xldCBlPXQucG9zaXRpb24scj0wO2NvbnN0IG49dC5sZW5ndGg7Zm9yKDszIT09ciYmNCE9PXImJmU8bi00OykwPT09dC5nZXRJbnQxNihlKT8xPT09dC5nZXRJbnQxNihlKzIpP3I9NDoxPT09dC5nZXRJbnQ4KGUrMik/cj0zOmUrKzplKys7cmV0dXJuIGU9PT1uLTQmJigwPT09dC5nZXRJbnQxNihlKT8xPT09dC5nZXRJbnQxNihlKzIpP3I9NDplPW46KGUrKywwPT09dC5nZXRJbnQxNihlKSYmMT09PXQuZ2V0SW50OChlKT9yPTM6ZT1uKSkse3BvczplLGhlYWRlckxlbmd0aDpyfX0saXNIMjY1VmlkZW9GcmFtZSh0KXt2YXIgZTtyZXR1cm4oKG51bGw9PT0oZT10LmdldE1ldGFkYXRhKXx8dm9pZCAwPT09ZXx8bnVsbD09PShlPWUuY2FsbCh0KSl8fHZvaWQgMD09PWU/dm9pZCAwOmUubWltZVR5cGUpfHwiIikudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygiaDI2NSIpfX07dmFyIGU9InVuZGVmaW5lZCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6InVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OiJ1bmRlZmluZWQiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDoidW5kZWZpbmVkIiE9dHlwZW9mIHNlbGY/c2VsZjp7fTtmdW5jdGlvbiByKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCJkZWZhdWx0Iik/dC5kZWZhdWx0OnR9dmFyIG49e2V4cG9ydHM6e319LG89ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuTWF0aD09PU1hdGgmJnR9LGk9bygib2JqZWN0Ij09dHlwZW9mIGdsb2JhbFRoaXMmJmdsb2JhbFRoaXMpfHxvKCJvYmplY3QiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cpfHxvKCJvYmplY3QiPT10eXBlb2Ygc2VsZiYmc2VsZil8fG8oIm9iamVjdCI9PXR5cGVvZiBlJiZlKXx8bygib2JqZWN0Ij09dHlwZW9mIGUmJmUpfHxmdW5jdGlvbigpe3JldHVybiB0aGlzfSgpfHxGdW5jdGlvbigicmV0dXJuIHRoaXMiKSgpLGE9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhdCgpfWNhdGNoKGUpe3JldHVybiEwfX0sdT0hYSgoZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbigpe30uYmluZCgpO3JldHVybiJmdW5jdGlvbiIhPXR5cGVvZiB0fHx0Lmhhc093blByb3BlcnR5KCJwcm90b3R5cGUiKX0pKSxjPXUscz1GdW5jdGlvbi5wcm90b3R5cGUsZj1zLmFwcGx5LGw9cy5jYWxsLHA9Im9iamVjdCI9PXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0LmFwcGx5fHwoYz9sLmJpbmQoZik6ZnVuY3Rpb24oKXtyZXR1cm4gbC5hcHBseShmLGFyZ3VtZW50cyl9KSx5PXUsZD1GdW5jdGlvbi5wcm90b3R5cGUsZz1kLmNhbGwsaD15JiZkLmJpbmQuYmluZChnLGcpLGI9eT9oOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBnLmFwcGx5KHQsYXJndW1lbnRzKX19LHY9YixtPXYoe30udG9TdHJpbmcpLHc9digiIi5zbGljZSksUz1mdW5jdGlvbih0KXtyZXR1cm4gdyhtKHQpLDgsLTEpfSxPPVMsaj1iLEE9ZnVuY3Rpb24odCl7aWYoIkZ1bmN0aW9uIj09PU8odCkpcmV0dXJuIGoodCl9LEw9Im9iamVjdCI9PXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuYWxsLFA9dm9pZCAwPT09TCYmdm9pZCAwIT09TD9mdW5jdGlvbih0KXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgdHx8dD09PUx9OmZ1bmN0aW9uKHQpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiB0fSxJPXt9LGs9IWEoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sMSx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSlbMV19KSksVD11LEU9RnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsVT1UP0UuYmluZChFKTpmdW5jdGlvbigpe3JldHVybiBFLmFwcGx5KEUsYXJndW1lbnRzKX0sRj17fSx4PXt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLE49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixNPU4mJiF4LmNhbGwoezE6Mn0sMSk7Ri5mPU0/ZnVuY3Rpb24odCl7dmFyIGU9Tih0aGlzLHQpO3JldHVybiEhZSYmZS5lbnVtZXJhYmxlfTp4O3ZhciBfLFIsQj1mdW5jdGlvbih0LGUpe3JldHVybntlbnVtZXJhYmxlOiEoMSZ0KSxjb25maWd1cmFibGU6ISgyJnQpLHdyaXRhYmxlOiEoNCZ0KSx2YWx1ZTplfX0sQz1hLEQ9UyxHPU9iamVjdCxIPWIoIiIuc3BsaXQpLFY9QygoZnVuY3Rpb24oKXtyZXR1cm4hRygieiIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApfSkpP2Z1bmN0aW9uKHQpe3JldHVybiJTdHJpbmciPT09RCh0KT9IKHQsIiIpOkcodCl9OkcsVz1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dH0sej1XLEs9VHlwZUVycm9yLEo9ZnVuY3Rpb24odCl7aWYoeih0KSl0aHJvdyBuZXcgSygiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIit0KTtyZXR1cm4gdH0scT1WLFk9SixYPWZ1bmN0aW9uKHQpe3JldHVybiBxKFkodCkpfSwkPVAsUT1mdW5jdGlvbih0KXtyZXR1cm4ib2JqZWN0Ij09dHlwZW9mIHQ/bnVsbCE9PXQ6JCh0KX0sWj17fSx0dD1aLGV0PWkscnQ9UCxudD1mdW5jdGlvbih0KXtyZXR1cm4gcnQodCk/dDp2b2lkIDB9LG90PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg8Mj9udCh0dFt0XSl8fG50KGV0W3RdKTp0dFt0XSYmdHRbdF1bZV18fGV0W3RdJiZldFt0XVtlXX0saXQ9Yih7fS5pc1Byb3RvdHlwZU9mKSxhdD1pLm5hdmlnYXRvcix1dD1hdCYmYXQudXNlckFnZW50LGN0PWksc3Q9dXQ/U3RyaW5nKHV0KToiIixmdD1jdC5wcm9jZXNzLGx0PWN0LkRlbm8scHQ9ZnQmJmZ0LnZlcnNpb25zfHxsdCYmbHQudmVyc2lvbix5dD1wdCYmcHQudjg7eXQmJihSPShfPXl0LnNwbGl0KCIuIikpWzBdPjAmJl9bMF08ND8xOisoX1swXStfWzFdKSksIVImJnN0JiYoIShfPXN0Lm1hdGNoKC9FZGdlXC8oXGQrKS8pKXx8X1sxXT49NzQpJiYoXz1zdC5tYXRjaCgvQ2hyb21lXC8oXGQrKS8pKSYmKFI9K19bMV0pO3ZhciBkdD1SLGd0PWR0LGh0PWEsYnQ9aS5TdHJpbmcsdnQ9ISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzJiYhaHQoKGZ1bmN0aW9uKCl7dmFyIHQ9U3ltYm9sKCJzeW1ib2wgZGV0ZWN0aW9uIik7cmV0dXJuIWJ0KHQpfHwhKE9iamVjdCh0KWluc3RhbmNlb2YgU3ltYm9sKXx8IVN5bWJvbC5zaGFtJiZndCYmZ3Q8NDF9KSksbXQ9dnQmJiFTeW1ib2wuc2hhbSYmInN5bWJvbCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3Isd3Q9b3QsU3Q9UCxPdD1pdCxqdD1PYmplY3QsQXQ9bXQ/ZnVuY3Rpb24odCl7cmV0dXJuInN5bWJvbCI9PXR5cGVvZiB0fTpmdW5jdGlvbih0KXt2YXIgZT13dCgiU3ltYm9sIik7cmV0dXJuIFN0KGUpJiZPdChlLnByb3RvdHlwZSxqdCh0KSl9LEx0PVN0cmluZyxQdD1mdW5jdGlvbih0KXt0cnl7cmV0dXJuIEx0KHQpfWNhdGNoKGUpe3JldHVybiJPYmplY3QifX0sSXQ9UCxrdD1QdCxUdD1UeXBlRXJyb3IsRXQ9ZnVuY3Rpb24odCl7aWYoSXQodCkpcmV0dXJuIHQ7dGhyb3cgbmV3IFR0KGt0KHQpKyIgaXMgbm90IGEgZnVuY3Rpb24iKX0sVXQ9RXQsRnQ9Vyx4dD1VLE50PVAsTXQ9USxfdD1UeXBlRXJyb3IsUnQ9e2V4cG9ydHM6e319LEJ0PWksQ3Q9T2JqZWN0LmRlZmluZVByb3BlcnR5LER0PWksR3Q9ZnVuY3Rpb24odCxlKXt0cnl7Q3QoQnQsdCx7dmFsdWU6ZSxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KX1jYXRjaChyKXtCdFt0XT1lfXJldHVybiBlfSxIdD0iX19jb3JlLWpzX3NoYXJlZF9fIixWdD1SdC5leHBvcnRzPUR0W0h0XXx8R3QoSHQse30pOyhWdC52ZXJzaW9uc3x8KFZ0LnZlcnNpb25zPVtdKSkucHVzaCh7dmVyc2lvbjoiMy4zOS4wIixtb2RlOiJwdXJlIixjb3B5cmlnaHQ6IsKpIDIwMTQtMjAyNCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSIsbGljZW5zZToiaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4zOS4wL0xJQ0VOU0UiLHNvdXJjZToiaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMifSk7dmFyIFd0PVJ0LmV4cG9ydHMsenQ9V3QsS3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4genRbdF18fCh6dFt0XT1lfHx7fSl9LEp0PUoscXQ9T2JqZWN0LFl0PWZ1bmN0aW9uKHQpe3JldHVybiBxdChKdCh0KSl9LFh0PVl0LCR0PWIoe30uaGFzT3duUHJvcGVydHkpLFF0PU9iamVjdC5oYXNPd258fGZ1bmN0aW9uKHQsZSl7cmV0dXJuICR0KFh0KHQpLGUpfSxadD1iLHRlPTAsZWU9TWF0aC5yYW5kb20oKSxyZT1adCgxLi50b1N0cmluZyksbmU9ZnVuY3Rpb24odCl7cmV0dXJuIlN5bWJvbCgiKyh2b2lkIDA9PT10PyIiOnQpKyIpXyIrcmUoKyt0ZStlZSwzNil9LG9lPUt0LGllPVF0LGFlPW5lLHVlPXZ0LGNlPW10LHNlPWkuU3ltYm9sLGZlPW9lKCJ3a3MiKSxsZT1jZT9zZS5mb3J8fHNlOnNlJiZzZS53aXRob3V0U2V0dGVyfHxhZSxwZT1mdW5jdGlvbih0KXtyZXR1cm4gaWUoZmUsdCl8fChmZVt0XT11ZSYmaWUoc2UsdCk/c2VbdF06bGUoIlN5bWJvbC4iK3QpKSxmZVt0XX0seWU9VSxkZT1RLGdlPUF0LGhlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dFtlXTtyZXR1cm4gRnQocik/dm9pZCAwOlV0KHIpfSxiZT1mdW5jdGlvbih0LGUpe3ZhciByLG47aWYoInN0cmluZyI9PT1lJiZOdChyPXQudG9TdHJpbmcpJiYhTXQobj14dChyLHQpKSlyZXR1cm4gbjtpZihOdChyPXQudmFsdWVPZikmJiFNdChuPXh0KHIsdCkpKXJldHVybiBuO2lmKCJzdHJpbmciIT09ZSYmTnQocj10LnRvU3RyaW5nKSYmIU10KG49eHQocix0KSkpcmV0dXJuIG47dGhyb3cgbmV3IF90KCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWUiKX0sdmU9VHlwZUVycm9yLG1lPXBlKCJ0b1ByaW1pdGl2ZSIpLHdlPWZ1bmN0aW9uKHQsZSl7aWYoIWRlKHQpfHxnZSh0KSlyZXR1cm4gdDt2YXIgcixuPWhlKHQsbWUpO2lmKG4pe2lmKHZvaWQgMD09PWUmJihlPSJkZWZhdWx0Iikscj15ZShuLHQsZSksIWRlKHIpfHxnZShyKSlyZXR1cm4gcjt0aHJvdyBuZXcgdmUoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpfXJldHVybiB2b2lkIDA9PT1lJiYoZT0ibnVtYmVyIiksYmUodCxlKX0sU2U9QXQsT2U9ZnVuY3Rpb24odCl7dmFyIGU9d2UodCwic3RyaW5nIik7cmV0dXJuIFNlKGUpP2U6ZSsiIn0samU9USxBZT1pLmRvY3VtZW50LExlPWplKEFlKSYmamUoQWUuY3JlYXRlRWxlbWVudCksUGU9ZnVuY3Rpb24odCl7cmV0dXJuIExlP0FlLmNyZWF0ZUVsZW1lbnQodCk6e319LEllPVBlLGtlPSFrJiYhYSgoZnVuY3Rpb24oKXtyZXR1cm4gNyE9PU9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZSgiZGl2IiksImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSkpLFRlPWssRWU9VSxVZT1GLEZlPUIseGU9WCxOZT1PZSxNZT1RdCxfZT1rZSxSZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO0kuZj1UZT9SZTpmdW5jdGlvbih0LGUpe2lmKHQ9eGUodCksZT1OZShlKSxfZSl0cnl7cmV0dXJuIFJlKHQsZSl9Y2F0Y2gocil7fWlmKE1lKHQsZSkpcmV0dXJuIEZlKCFFZShVZS5mLHQsZSksdFtlXSl9O3ZhciBCZT1hLENlPVAsRGU9LyN8XC5wcm90b3R5cGVcLi8sR2U9ZnVuY3Rpb24odCxlKXt2YXIgcj1WZVtIZSh0KV07cmV0dXJuIHI9PT16ZXx8ciE9PVdlJiYoQ2UoZSk/QmUoZSk6ISFlKX0sSGU9R2Uubm9ybWFsaXplPWZ1bmN0aW9uKHQpe3JldHVybiBTdHJpbmcodCkucmVwbGFjZShEZSwiLiIpLnRvTG93ZXJDYXNlKCl9LFZlPUdlLmRhdGE9e30sV2U9R2UuTkFUSVZFPSJOIix6ZT1HZS5QT0xZRklMTD0iUCIsS2U9R2UsSmU9RXQscWU9dSxZZT1BKEEuYmluZCksWGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gSmUodCksdm9pZCAwPT09ZT90OnFlP1llKHQsZSk6ZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShlLGFyZ3VtZW50cyl9fSwkZT17fSxRZT1rJiZhKChmdW5jdGlvbigpe3JldHVybiA0MiE9PU9iamVjdC5kZWZpbmVQcm9wZXJ0eSgoZnVuY3Rpb24oKXt9KSwicHJvdG90eXBlIix7dmFsdWU6NDIsd3JpdGFibGU6ITF9KS5wcm90b3R5cGV9KSksWmU9USx0cj1TdHJpbmcsZXI9VHlwZUVycm9yLHJyPWZ1bmN0aW9uKHQpe2lmKFplKHQpKXJldHVybiB0O3Rocm93IG5ldyBlcih0cih0KSsiIGlzIG5vdCBhbiBvYmplY3QiKX0sbnI9ayxvcj1rZSxpcj1RZSxhcj1ycix1cj1PZSxjcj1UeXBlRXJyb3Isc3I9T2JqZWN0LmRlZmluZVByb3BlcnR5LGZyPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsbHI9ImVudW1lcmFibGUiLHByPSJjb25maWd1cmFibGUiLHlyPSJ3cml0YWJsZSI7JGUuZj1ucj9pcj9mdW5jdGlvbih0LGUscil7aWYoYXIodCksZT11cihlKSxhcihyKSwiZnVuY3Rpb24iPT10eXBlb2YgdCYmInByb3RvdHlwZSI9PT1lJiYidmFsdWUiaW4gciYmeXIgaW4gciYmIXJbeXJdKXt2YXIgbj1mcih0LGUpO24mJm5beXJdJiYodFtlXT1yLnZhbHVlLHI9e2NvbmZpZ3VyYWJsZTpwciBpbiByP3JbcHJdOm5bcHJdLGVudW1lcmFibGU6bHIgaW4gcj9yW2xyXTpuW2xyXSx3cml0YWJsZTohMX0pfXJldHVybiBzcih0LGUscil9OnNyOmZ1bmN0aW9uKHQsZSxyKXtpZihhcih0KSxlPXVyKGUpLGFyKHIpLG9yKXRyeXtyZXR1cm4gc3IodCxlLHIpfWNhdGNoKG4pe31pZigiZ2V0ImluIHJ8fCJzZXQiaW4gcil0aHJvdyBuZXcgY3IoIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIik7cmV0dXJuInZhbHVlImluIHImJih0W2VdPXIudmFsdWUpLHR9O3ZhciBkcj0kZSxncj1CLGhyPWs/ZnVuY3Rpb24odCxlLHIpe3JldHVybiBkci5mKHQsZSxncigxLHIpKX06ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0W2VdPXIsdH0sYnI9aSx2cj1wLG1yPUEsd3I9UCxTcj1JLmYsT3I9S2UsanI9WixBcj1YZSxMcj1ocixQcj1RdCxJcj1mdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbihyLG4sbyl7aWYodGhpcyBpbnN0YW5jZW9mIGUpe3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG5ldyB0O2Nhc2UgMTpyZXR1cm4gbmV3IHQocik7Y2FzZSAyOnJldHVybiBuZXcgdChyLG4pfXJldHVybiBuZXcgdChyLG4sbyl9cmV0dXJuIHZyKHQsdGhpcyxhcmd1bWVudHMpfTtyZXR1cm4gZS5wcm90b3R5cGU9dC5wcm90b3R5cGUsZX0sa3I9ZnVuY3Rpb24odCxlKXt2YXIgcixuLG8saSxhLHUsYyxzLGYsbD10LnRhcmdldCxwPXQuZ2xvYmFsLHk9dC5zdGF0LGQ9dC5wcm90byxnPXA/YnI6eT9icltsXTpicltsXSYmYnJbbF0ucHJvdG90eXBlLGg9cD9qcjpqcltsXXx8THIoanIsbCx7fSlbbF0sYj1oLnByb3RvdHlwZTtmb3IoaSBpbiBlKW49IShyPU9yKHA/aTpsKyh5PyIuIjoiIyIpK2ksdC5mb3JjZWQpKSYmZyYmUHIoZyxpKSx1PWhbaV0sbiYmKGM9dC5kb250Q2FsbEdldFNldD8oZj1TcihnLGkpKSYmZi52YWx1ZTpnW2ldKSxhPW4mJmM/YzplW2ldLChyfHxkfHx0eXBlb2YgdSE9dHlwZW9mIGEpJiYocz10LmJpbmQmJm4/QXIoYSxicik6dC53cmFwJiZuP0lyKGEpOmQmJndyKGEpP21yKGEpOmEsKHQuc2hhbXx8YSYmYS5zaGFtfHx1JiZ1LnNoYW0pJiZMcihzLCJzaGFtIiwhMCksTHIoaCxpLHMpLGQmJihQcihqcixvPWwrIlByb3RvdHlwZSIpfHxMcihqcixvLHt9KSxMcihqcltvXSxpLGEpLHQucmVhbCYmYiYmKHJ8fCFiW2ldKSYmTHIoYixpLGEpKSl9LFRyPWtyLEVyPWssVXI9JGUuZjtUcih7dGFyZ2V0OiJPYmplY3QiLHN0YXQ6ITAsZm9yY2VkOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSE9PVVyLHNoYW06IUVyfSx7ZGVmaW5lUHJvcGVydHk6VXJ9KTt2YXIgRnI9Wi5PYmplY3QseHI9bi5leHBvcnRzPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gRnIuZGVmaW5lUHJvcGVydHkodCxlLHIpfTtGci5kZWZpbmVQcm9wZXJ0eS5zaGFtJiYoeHIuc2hhbT0hMCk7dmFyIE5yPXIobi5leHBvcnRzKSxNcj1TLF9yPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHQpe3JldHVybiJBcnJheSI9PT1Ncih0KX0sUnI9TWF0aC5jZWlsLEJyPU1hdGguZmxvb3IsQ3I9TWF0aC50cnVuY3x8ZnVuY3Rpb24odCl7dmFyIGU9K3Q7cmV0dXJuKGU+MD9CcjpScikoZSl9LERyPWZ1bmN0aW9uKHQpe3ZhciBlPSt0O3JldHVybiBlIT1lfHwwPT09ZT8wOkNyKGUpfSxHcj1EcixIcj1NYXRoLm1pbixWcj1mdW5jdGlvbih0KXt2YXIgZT1Hcih0KTtyZXR1cm4gZT4wP0hyKGUsOTAwNzE5OTI1NDc0MDk5MSk6MH0sV3I9ZnVuY3Rpb24odCl7cmV0dXJuIFZyKHQubGVuZ3RoKX0senI9VHlwZUVycm9yLEtyPWssSnI9JGUscXI9QixZcj17fTtZcltwZSgidG9TdHJpbmdUYWciKV09InoiO3ZhciBYcj0iW29iamVjdCB6XSI9PT1TdHJpbmcoWXIpLCRyPVhyLFFyPVAsWnI9Uyx0bj1wZSgidG9TdHJpbmdUYWciKSxlbj1PYmplY3Qscm49IkFyZ3VtZW50cyI9PT1acihmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpLG5uPSRyP1pyOmZ1bmN0aW9uKHQpe3ZhciBlLHIsbjtyZXR1cm4gdm9pZCAwPT09dD8iVW5kZWZpbmVkIjpudWxsPT09dD8iTnVsbCI6InN0cmluZyI9PXR5cGVvZihyPWZ1bmN0aW9uKHQsZSl7dHJ5e3JldHVybiB0W2VdfWNhdGNoKHIpe319KGU9ZW4odCksdG4pKT9yOnJuP1pyKGUpOiJPYmplY3QiPT09KG49WnIoZSkpJiZRcihlLmNhbGxlZSk/IkFyZ3VtZW50cyI6bn0sb249UCxhbj1XdCx1bj1iKEZ1bmN0aW9uLnRvU3RyaW5nKTtvbihhbi5pbnNwZWN0U291cmNlKXx8KGFuLmluc3BlY3RTb3VyY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHVuKHQpfSk7dmFyIGNuPWFuLmluc3BlY3RTb3VyY2Usc249Yixmbj1hLGxuPVAscG49bm4seW49Y24sZG49ZnVuY3Rpb24oKXt9LGduPW90KCJSZWZsZWN0IiwiY29uc3RydWN0IiksaG49L15ccyooPzpjbGFzc3xmdW5jdGlvbilcYi8sYm49c24oaG4uZXhlYyksdm49IWhuLnRlc3QoZG4pLG1uPWZ1bmN0aW9uKHQpe2lmKCFsbih0KSlyZXR1cm4hMTt0cnl7cmV0dXJuIGduKGRuLFtdLHQpLCEwfWNhdGNoKGUpe3JldHVybiExfX0sd249ZnVuY3Rpb24odCl7aWYoIWxuKHQpKXJldHVybiExO3N3aXRjaChwbih0KSl7Y2FzZSJBc3luY0Z1bmN0aW9uIjpjYXNlIkdlbmVyYXRvckZ1bmN0aW9uIjpjYXNlIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb24iOnJldHVybiExfXRyeXtyZXR1cm4gdm58fCEhYm4oaG4seW4odCkpfWNhdGNoKGUpe3JldHVybiEwfX07d24uc2hhbT0hMDt2YXIgU249IWdufHxmbigoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbW4obW4uY2FsbCl8fCFtbihPYmplY3QpfHwhbW4oKGZ1bmN0aW9uKCl7dD0hMH0pKXx8dH0pKT93bjptbixPbj1fcixqbj1TbixBbj1RLExuPXBlKCJzcGVjaWVzIiksUG49QXJyYXksSW49ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIE9uKHQpJiYoZT10LmNvbnN0cnVjdG9yLChqbihlKSYmKGU9PT1Qbnx8T24oZS5wcm90b3R5cGUpKXx8QW4oZSkmJm51bGw9PT0oZT1lW0xuXSkpJiYoZT12b2lkIDApKSx2b2lkIDA9PT1lP1BuOmV9LGtuPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyhJbih0KSkoMD09PWU/MDplKX0sVG49YSxFbj1kdCxVbj1wZSgic3BlY2llcyIpLEZuPWtyLHhuPWEsTm49X3IsTW49USxfbj1ZdCxSbj1XcixCbj1mdW5jdGlvbih0KXtpZih0PjkwMDcxOTkyNTQ3NDA5OTEpdGhyb3cgenIoIk1heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCIpO3JldHVybiB0fSxDbj1mdW5jdGlvbih0LGUscil7S3I/SnIuZih0LGUscXIoMCxyKSk6dFtlXT1yfSxEbj1rbixHbj1mdW5jdGlvbih0KXtyZXR1cm4gRW4+PTUxfHwhVG4oKGZ1bmN0aW9uKCl7dmFyIGU9W107cmV0dXJuKGUuY29uc3RydWN0b3I9e30pW1VuXT1mdW5jdGlvbigpe3JldHVybntmb286MX19LDEhPT1lW3RdKEJvb2xlYW4pLmZvb30pKX0sSG49ZHQsVm49cGUoImlzQ29uY2F0U3ByZWFkYWJsZSIpLFduPUhuPj01MXx8IXhuKChmdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0W1ZuXT0hMSx0LmNvbmNhdCgpWzBdIT09dH0pKSx6bj1mdW5jdGlvbih0KXtpZighTW4odCkpcmV0dXJuITE7dmFyIGU9dFtWbl07cmV0dXJuIHZvaWQgMCE9PWU/ISFlOk5uKHQpfTtGbih7dGFyZ2V0OiJBcnJheSIscHJvdG86ITAsYXJpdHk6MSxmb3JjZWQ6IVdufHwhR24oImNvbmNhdCIpfSx7Y29uY2F0OmZ1bmN0aW9uKHQpe3ZhciBlLHIsbixvLGksYT1fbih0aGlzKSx1PURuKGEsMCksYz0wO2ZvcihlPS0xLG49YXJndW1lbnRzLmxlbmd0aDtlPG47ZSsrKWlmKHpuKGk9LTE9PT1lP2E6YXJndW1lbnRzW2VdKSlmb3Iobz1SbihpKSxCbihjK28pLHI9MDtyPG87cisrLGMrKylyIGluIGkmJkNuKHUsYyxpW3JdKTtlbHNlIEJuKGMrMSksQ24odSxjKyssaSk7cmV0dXJuIHUubGVuZ3RoPWMsdX19KTt2YXIgS249bm4sSm49U3RyaW5nLHFuPWZ1bmN0aW9uKHQpe2lmKCJTeW1ib2wiPT09S24odCkpdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmciKTtyZXR1cm4gSm4odCl9LFluPXt9LFhuPURyLCRuPU1hdGgubWF4LFFuPU1hdGgubWluLFpuPVgsdG89ZnVuY3Rpb24odCxlKXt2YXIgcj1Ybih0KTtyZXR1cm4gcjwwPyRuKHIrZSwwKTpRbihyLGUpfSxlbz1Xcixybz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxyLG4pe3ZhciBvPVpuKGUpLGk9ZW8obyk7aWYoMD09PWkpcmV0dXJuIXQmJi0xO3ZhciBhLHU9dG8obixpKTtpZih0JiZyIT1yKXtmb3IoO2k+dTspaWYoKGE9b1t1KytdKSE9YSlyZXR1cm4hMH1lbHNlIGZvcig7aT51O3UrKylpZigodHx8dSBpbiBvKSYmb1t1XT09PXIpcmV0dXJuIHR8fHV8fDA7cmV0dXJuIXQmJi0xfX0sbm89e2luY2x1ZGVzOnJvKCEwKSxpbmRleE9mOnJvKCExKX0sb289e30saW89UXQsYW89WCx1bz1uby5pbmRleE9mLGNvPW9vLHNvPWIoW10ucHVzaCksZm89ZnVuY3Rpb24odCxlKXt2YXIgcixuPWFvKHQpLG89MCxpPVtdO2ZvcihyIGluIG4pIWlvKGNvLHIpJiZpbyhuLHIpJiZzbyhpLHIpO2Zvcig7ZS5sZW5ndGg+bzspaW8obixyPWVbbysrXSkmJih+dW8oaSxyKXx8c28oaSxyKSk7cmV0dXJuIGl9LGxvPVsiY29uc3RydWN0b3IiLCJoYXNPd25Qcm9wZXJ0eSIsImlzUHJvdG90eXBlT2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvTG9jYWxlU3RyaW5nIiwidG9TdHJpbmciLCJ2YWx1ZU9mIl0scG89Zm8seW89bG8sZ289T2JqZWN0LmtleXN8fGZ1bmN0aW9uKHQpe3JldHVybiBwbyh0LHlvKX0saG89ayxibz1RZSx2bz0kZSxtbz1ycix3bz1YLFNvPWdvO1luLmY9aG8mJiFibz9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbih0LGUpe21vKHQpO2Zvcih2YXIgcixuPXdvKGUpLG89U28oZSksaT1vLmxlbmd0aCxhPTA7aT5hOyl2by5mKHQscj1vW2ErK10sbltyXSk7cmV0dXJuIHR9O3ZhciBPbyxqbz1vdCgiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiKSxBbz1uZSxMbz1LdCgia2V5cyIpLFBvPWZ1bmN0aW9uKHQpe3JldHVybiBMb1t0XXx8KExvW3RdPUFvKHQpKX0sSW89cnIsa289WW4sVG89bG8sRW89b28sVW89am8sRm89UGUseG89InByb3RvdHlwZSIsTm89InNjcmlwdCIsTW89UG8oIklFX1BST1RPIiksX289ZnVuY3Rpb24oKXt9LFJvPWZ1bmN0aW9uKHQpe3JldHVybiI8IitObysiPiIrdCsiPC8iK05vKyI+In0sQm89ZnVuY3Rpb24odCl7dC53cml0ZShSbygiIikpLHQuY2xvc2UoKTt2YXIgZT10LnBhcmVudFdpbmRvdy5PYmplY3Q7cmV0dXJuIHQ9bnVsbCxlfSxDbz1mdW5jdGlvbigpe3RyeXtPbz1uZXcgQWN0aXZlWE9iamVjdCgiaHRtbGZpbGUiKX1jYXRjaChvKXt9dmFyIHQsZSxyO0NvPSJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQ/ZG9jdW1lbnQuZG9tYWluJiZPbz9CbyhPbyk6KGU9Rm8oImlmcmFtZSIpLHI9ImphdmEiK05vKyI6IixlLnN0eWxlLmRpc3BsYXk9Im5vbmUiLFVvLmFwcGVuZENoaWxkKGUpLGUuc3JjPVN0cmluZyhyKSwodD1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQpLm9wZW4oKSx0LndyaXRlKFJvKCJkb2N1bWVudC5GPU9iamVjdCIpKSx0LmNsb3NlKCksdC5GKTpCbyhPbyk7Zm9yKHZhciBuPVRvLmxlbmd0aDtuLS07KWRlbGV0ZSBDb1t4b11bVG9bbl1dO3JldHVybiBDbygpfTtFb1tNb109ITA7dmFyIERvPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKHQsZSl7dmFyIHI7cmV0dXJuIG51bGwhPT10Pyhfb1t4b109SW8odCkscj1uZXcgX28sX29beG9dPW51bGwscltNb109dCk6cj1DbygpLHZvaWQgMD09PWU/cjprby5mKHIsZSl9LEdvPXt9LEhvPWZvLFZvPWxvLmNvbmNhdCgibGVuZ3RoIiwicHJvdG90eXBlIik7R28uZj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc3x8ZnVuY3Rpb24odCl7cmV0dXJuIEhvKHQsVm8pfTt2YXIgV289e30sem89YihbXS5zbGljZSksS289UyxKbz1YLHFvPUdvLmYsWW89em8sWG89Im9iamVjdCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXTtXby5mPWZ1bmN0aW9uKHQpe3JldHVybiBYbyYmIldpbmRvdyI9PT1Lbyh0KT9mdW5jdGlvbih0KXt0cnl7cmV0dXJuIHFvKHQpfWNhdGNoKGUpe3JldHVybiBZbyhYbyl9fSh0KTpxbyhKbyh0KSl9O3ZhciAkbz17fTskby5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7dmFyIFFvPWhyLFpvPWZ1bmN0aW9uKHQsZSxyLG4pe3JldHVybiBuJiZuLmVudW1lcmFibGU/dFtlXT1yOlFvKHQsZSxyKSx0fSx0aT0kZSxlaT17fSxyaT1wZTtlaS5mPXJpO3ZhciBuaSxvaSxpaSxhaT1aLHVpPVF0LGNpPWVpLHNpPSRlLmYsZmk9ZnVuY3Rpb24odCl7dmFyIGU9YWkuU3ltYm9sfHwoYWkuU3ltYm9sPXt9KTt1aShlLHQpfHxzaShlLHQse3ZhbHVlOmNpLmYodCl9KX0sbGk9VSxwaT1vdCx5aT1wZSxkaT1abyxnaT1mdW5jdGlvbigpe3ZhciB0PXBpKCJTeW1ib2wiKSxlPXQmJnQucHJvdG90eXBlLHI9ZSYmZS52YWx1ZU9mLG49eWkoInRvUHJpbWl0aXZlIik7ZSYmIWVbbl0mJmRpKGUsbiwoZnVuY3Rpb24odCl7cmV0dXJuIGxpKHIsdGhpcyl9KSx7YXJpdHk6MX0pfSxoaT1ubixiaT1Ycj97fS50b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiJbb2JqZWN0ICIraGkodGhpcykrIl0ifSx2aT1YcixtaT0kZS5mLHdpPWhyLFNpPVF0LE9pPWJpLGppPXBlKCJ0b1N0cmluZ1RhZyIpLEFpPWZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBvPXI/dDp0JiZ0LnByb3RvdHlwZTtvJiYoU2kobyxqaSl8fG1pKG8samkse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTplfSksbiYmIXZpJiZ3aShvLCJ0b1N0cmluZyIsT2kpKX0sTGk9UCxQaT1pLldlYWtNYXAsSWk9TGkoUGkpJiYvbmF0aXZlIGNvZGUvLnRlc3QoU3RyaW5nKFBpKSksa2k9aSxUaT1RLEVpPWhyLFVpPVF0LEZpPVd0LHhpPVBvLE5pPW9vLE1pPSJPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCIsX2k9a2kuVHlwZUVycm9yLFJpPWtpLldlYWtNYXA7aWYoSWl8fEZpLnN0YXRlKXt2YXIgQmk9Rmkuc3RhdGV8fChGaS5zdGF0ZT1uZXcgUmkpO0JpLmdldD1CaS5nZXQsQmkuaGFzPUJpLmhhcyxCaS5zZXQ9Qmkuc2V0LG5pPWZ1bmN0aW9uKHQsZSl7aWYoQmkuaGFzKHQpKXRocm93IG5ldyBfaShNaSk7cmV0dXJuIGUuZmFjYWRlPXQsQmkuc2V0KHQsZSksZX0sb2k9ZnVuY3Rpb24odCl7cmV0dXJuIEJpLmdldCh0KXx8e319LGlpPWZ1bmN0aW9uKHQpe3JldHVybiBCaS5oYXModCl9fWVsc2V7dmFyIENpPXhpKCJzdGF0ZSIpO05pW0NpXT0hMCxuaT1mdW5jdGlvbih0LGUpe2lmKFVpKHQsQ2kpKXRocm93IG5ldyBfaShNaSk7cmV0dXJuIGUuZmFjYWRlPXQsRWkodCxDaSxlKSxlfSxvaT1mdW5jdGlvbih0KXtyZXR1cm4gVWkodCxDaSk/dFtDaV06e319LGlpPWZ1bmN0aW9uKHQpe3JldHVybiBVaSh0LENpKX19dmFyIERpPXtzZXQ6bmksZ2V0Om9pLGhhczppaSxlbmZvcmNlOmZ1bmN0aW9uKHQpe3JldHVybiBpaSh0KT9vaSh0KTpuaSh0LHt9KX0sZ2V0dGVyRm9yOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgcjtpZighVGkoZSl8fChyPW9pKGUpKS50eXBlIT09dCl0aHJvdyBuZXcgX2koIkluY29tcGF0aWJsZSByZWNlaXZlciwgIit0KyIgcmVxdWlyZWQiKTtyZXR1cm4gcn19fSxHaT1YZSxIaT1WLFZpPVl0LFdpPVdyLHppPWtuLEtpPWIoW10ucHVzaCksSmk9ZnVuY3Rpb24odCl7dmFyIGU9MT09PXQscj0yPT09dCxuPTM9PT10LG89ND09PXQsaT02PT09dCxhPTc9PT10LHU9NT09PXR8fGk7cmV0dXJuIGZ1bmN0aW9uKGMscyxmLGwpe2Zvcih2YXIgcCx5LGQ9VmkoYyksZz1IaShkKSxoPVdpKGcpLGI9R2kocyxmKSx2PTAsbT1sfHx6aSx3PWU/bShjLGgpOnJ8fGE/bShjLDApOnZvaWQgMDtoPnY7disrKWlmKCh1fHx2IGluIGcpJiYoeT1iKHA9Z1t2XSx2LGQpLHQpKWlmKGUpd1t2XT15O2Vsc2UgaWYoeSlzd2l0Y2godCl7Y2FzZSAzOnJldHVybiEwO2Nhc2UgNTpyZXR1cm4gcDtjYXNlIDY6cmV0dXJuIHY7Y2FzZSAyOktpKHcscCl9ZWxzZSBzd2l0Y2godCl7Y2FzZSA0OnJldHVybiExO2Nhc2UgNzpLaSh3LHApfXJldHVybiBpPy0xOm58fG8/bzp3fX0scWk9e2ZvckVhY2g6SmkoMCksbWFwOkppKDEpLGZpbHRlcjpKaSgyKSxzb21lOkppKDMpLGV2ZXJ5OkppKDQpLGZpbmQ6SmkoNSksZmluZEluZGV4OkppKDYpLGZpbHRlclJlamVjdDpKaSg3KX0sWWk9a3IsWGk9aSwkaT1VLFFpPWIsWmk9ayx0YT12dCxlYT1hLHJhPVF0LG5hPWl0LG9hPXJyLGlhPVgsYWE9T2UsdWE9cW4sY2E9QixzYT1EbyxmYT1nbyxsYT1HbyxwYT1Xbyx5YT0kbyxkYT1JLGdhPSRlLGhhPVluLGJhPUYsdmE9Wm8sbWE9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0aS5mKHQsZSxyKX0sd2E9S3QsU2E9b28sT2E9bmUsamE9cGUsQWE9ZWksTGE9ZmksUGE9Z2ksSWE9QWksa2E9RGksVGE9cWkuZm9yRWFjaCxFYT1QbygiaGlkZGVuIiksVWE9IlN5bWJvbCIsRmE9InByb3RvdHlwZSIseGE9a2Euc2V0LE5hPWthLmdldHRlckZvcihVYSksTWE9T2JqZWN0W0ZhXSxfYT1YaS5TeW1ib2wsUmE9X2EmJl9hW0ZhXSxCYT1YaS5SYW5nZUVycm9yLENhPVhpLlR5cGVFcnJvcixEYT1YaS5RT2JqZWN0LEdhPWRhLmYsSGE9Z2EuZixWYT1wYS5mLFdhPWJhLmYsemE9UWkoW10ucHVzaCksS2E9d2EoInN5bWJvbHMiKSxKYT13YSgib3Atc3ltYm9scyIpLHFhPXdhKCJ3a3MiKSxZYT0hRGF8fCFEYVtGYV18fCFEYVtGYV0uZmluZENoaWxkLFhhPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1HYShNYSxlKTtuJiZkZWxldGUgTWFbZV0sSGEodCxlLHIpLG4mJnQhPT1NYSYmSGEoTWEsZSxuKX0sJGE9WmkmJmVhKChmdW5jdGlvbigpe3JldHVybiA3IT09c2EoSGEoe30sImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gSGEodGhpcywiYSIse3ZhbHVlOjd9KS5hfX0pKS5hfSkpP1hhOkhhLFFhPWZ1bmN0aW9uKHQsZSl7dmFyIHI9S2FbdF09c2EoUmEpO3JldHVybiB4YShyLHt0eXBlOlVhLHRhZzp0LGRlc2NyaXB0aW9uOmV9KSxaaXx8KHIuZGVzY3JpcHRpb249ZSkscn0sWmE9ZnVuY3Rpb24odCxlLHIpe3Q9PT1NYSYmWmEoSmEsZSxyKSxvYSh0KTt2YXIgbj1hYShlKTtyZXR1cm4gb2EocikscmEoS2Esbik/KHIuZW51bWVyYWJsZT8ocmEodCxFYSkmJnRbRWFdW25dJiYodFtFYV1bbl09ITEpLHI9c2Eocix7ZW51bWVyYWJsZTpjYSgwLCExKX0pKToocmEodCxFYSl8fEhhKHQsRWEsY2EoMSxzYShudWxsKSkpLHRbRWFdW25dPSEwKSwkYSh0LG4scikpOkhhKHQsbixyKX0sdHU9ZnVuY3Rpb24odCxlKXtvYSh0KTt2YXIgcj1pYShlKSxuPWZhKHIpLmNvbmNhdChvdShyKSk7cmV0dXJuIFRhKG4sKGZ1bmN0aW9uKGUpe1ppJiYhJGkoZXUscixlKXx8WmEodCxlLHJbZV0pfSkpLHR9LGV1PWZ1bmN0aW9uKHQpe3ZhciBlPWFhKHQpLHI9JGkoV2EsdGhpcyxlKTtyZXR1cm4hKHRoaXM9PT1NYSYmcmEoS2EsZSkmJiFyYShKYSxlKSkmJighKHJ8fCFyYSh0aGlzLGUpfHwhcmEoS2EsZSl8fHJhKHRoaXMsRWEpJiZ0aGlzW0VhXVtlXSl8fHIpfSxydT1mdW5jdGlvbih0LGUpe3ZhciByPWlhKHQpLG49YWEoZSk7aWYociE9PU1hfHwhcmEoS2Esbil8fHJhKEphLG4pKXt2YXIgbz1HYShyLG4pO3JldHVybiFvfHwhcmEoS2Esbil8fHJhKHIsRWEpJiZyW0VhXVtuXXx8KG8uZW51bWVyYWJsZT0hMCksb319LG51PWZ1bmN0aW9uKHQpe3ZhciBlPVZhKGlhKHQpKSxyPVtdO3JldHVybiBUYShlLChmdW5jdGlvbih0KXtyYShLYSx0KXx8cmEoU2EsdCl8fHphKHIsdCl9KSkscn0sb3U9ZnVuY3Rpb24odCl7dmFyIGU9dD09PU1hLHI9VmEoZT9KYTppYSh0KSksbj1bXTtyZXR1cm4gVGEociwoZnVuY3Rpb24odCl7IXJhKEthLHQpfHxlJiYhcmEoTWEsdCl8fHphKG4sS2FbdF0pfSkpLG59O3RhfHwoX2E9ZnVuY3Rpb24oKXtpZihuYShSYSx0aGlzKSl0aHJvdyBuZXcgQ2EoIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciIpO3ZhciB0PWFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT91YShhcmd1bWVudHNbMF0pOnZvaWQgMCxlPU9hKHQpLHI9ZnVuY3Rpb24odCl7dmFyIG49dm9pZCAwPT09dGhpcz9YaTp0aGlzO249PT1NYSYmJGkocixKYSx0KSxyYShuLEVhKSYmcmEobltFYV0sZSkmJihuW0VhXVtlXT0hMSk7dmFyIG89Y2EoMSx0KTt0cnl7JGEobixlLG8pfWNhdGNoKGkpe2lmKCEoaSBpbnN0YW5jZW9mIEJhKSl0aHJvdyBpO1hhKG4sZSxvKX19O3JldHVybiBaaSYmWWEmJiRhKE1hLGUse2NvbmZpZ3VyYWJsZTohMCxzZXQ6cn0pLFFhKGUsdCl9LHZhKFJhPV9hW0ZhXSwidG9TdHJpbmciLChmdW5jdGlvbigpe3JldHVybiBOYSh0aGlzKS50YWd9KSksdmEoX2EsIndpdGhvdXRTZXR0ZXIiLChmdW5jdGlvbih0KXtyZXR1cm4gUWEoT2EodCksdCl9KSksYmEuZj1ldSxnYS5mPVphLGhhLmY9dHUsZGEuZj1ydSxsYS5mPXBhLmY9bnUseWEuZj1vdSxBYS5mPWZ1bmN0aW9uKHQpe3JldHVybiBRYShqYSh0KSx0KX0sWmkmJm1hKFJhLCJkZXNjcmlwdGlvbiIse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTmEodGhpcykuZGVzY3JpcHRpb259fSkpLFlpKHtnbG9iYWw6ITAsY29uc3RydWN0b3I6ITAsd3JhcDohMCxmb3JjZWQ6IXRhLHNoYW06IXRhfSx7U3ltYm9sOl9hfSksVGEoZmEocWEpLChmdW5jdGlvbih0KXtMYSh0KX0pKSxZaSh7dGFyZ2V0OlVhLHN0YXQ6ITAsZm9yY2VkOiF0YX0se3VzZVNldHRlcjpmdW5jdGlvbigpe1lhPSEwfSx1c2VTaW1wbGU6ZnVuY3Rpb24oKXtZYT0hMX19KSxZaSh7dGFyZ2V0OiJPYmplY3QiLHN0YXQ6ITAsZm9yY2VkOiF0YSxzaGFtOiFaaX0se2NyZWF0ZTpmdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT1lP3NhKHQpOnR1KHNhKHQpLGUpfSxkZWZpbmVQcm9wZXJ0eTpaYSxkZWZpbmVQcm9wZXJ0aWVzOnR1LGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpydX0pLFlpKHt0YXJnZXQ6Ik9iamVjdCIsc3RhdDohMCxmb3JjZWQ6IXRhfSx7Z2V0T3duUHJvcGVydHlOYW1lczpudX0pLFBhKCksSWEoX2EsVWEpLFNhW0VhXT0hMDt2YXIgaXU9dnQmJiEhU3ltYm9sLmZvciYmISFTeW1ib2wua2V5Rm9yLGF1PWtyLHV1PW90LGN1PVF0LHN1PXFuLGZ1PUt0LGx1PWl1LHB1PWZ1KCJzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5IikseXU9ZnUoInN5bWJvbC10by1zdHJpbmctcmVnaXN0cnkiKTthdSh7dGFyZ2V0OiJTeW1ib2wiLHN0YXQ6ITAsZm9yY2VkOiFsdX0se2ZvcjpmdW5jdGlvbih0KXt2YXIgZT1zdSh0KTtpZihjdShwdSxlKSlyZXR1cm4gcHVbZV07dmFyIHI9dXUoIlN5bWJvbCIpKGUpO3JldHVybiBwdVtlXT1yLHl1W3JdPWUscn19KTt2YXIgZHU9a3IsZ3U9UXQsaHU9QXQsYnU9UHQsdnU9aXUsbXU9S3QoInN5bWJvbC10by1zdHJpbmctcmVnaXN0cnkiKTtkdSh7dGFyZ2V0OiJTeW1ib2wiLHN0YXQ6ITAsZm9yY2VkOiF2dX0se2tleUZvcjpmdW5jdGlvbih0KXtpZighaHUodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihidSh0KSsiIGlzIG5vdCBhIHN5bWJvbCIpO2lmKGd1KG11LHQpKXJldHVybiBtdVt0XX19KTt2YXIgd3U9X3IsU3U9UCxPdT1TLGp1PXFuLEF1PWIoW10ucHVzaCksTHU9a3IsUHU9b3QsSXU9cCxrdT1VLFR1PWIsRXU9YSxVdT1QLEZ1PUF0LHh1PXpvLE51PWZ1bmN0aW9uKHQpe2lmKFN1KHQpKXJldHVybiB0O2lmKHd1KHQpKXtmb3IodmFyIGU9dC5sZW5ndGgscj1bXSxuPTA7bjxlO24rKyl7dmFyIG89dFtuXTsic3RyaW5nIj09dHlwZW9mIG8/QXUocixvKToibnVtYmVyIiE9dHlwZW9mIG8mJiJOdW1iZXIiIT09T3UobykmJiJTdHJpbmciIT09T3Uobyl8fEF1KHIsanUobykpfXZhciBpPXIubGVuZ3RoLGE9ITA7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoYSlyZXR1cm4gYT0hMSxlO2lmKHd1KHRoaXMpKXJldHVybiBlO2Zvcih2YXIgbj0wO248aTtuKyspaWYocltuXT09PXQpcmV0dXJuIGV9fX0sTXU9dnQsX3U9U3RyaW5nLFJ1PVB1KCJKU09OIiwic3RyaW5naWZ5IiksQnU9VHUoLy4vLmV4ZWMpLEN1PVR1KCIiLmNoYXJBdCksRHU9VHUoIiIuY2hhckNvZGVBdCksR3U9VHUoIiIucmVwbGFjZSksSHU9VHUoMS4udG9TdHJpbmcpLFZ1PS9bXHVEODAwLVx1REZGRl0vZyxXdT0vXltcdUQ4MDAtXHVEQkZGXSQvLHp1PS9eW1x1REMwMC1cdURGRkZdJC8sS3U9IU11fHxFdSgoZnVuY3Rpb24oKXt2YXIgdD1QdSgiU3ltYm9sIikoInN0cmluZ2lmeSBkZXRlY3Rpb24iKTtyZXR1cm4iW251bGxdIiE9PVJ1KFt0XSl8fCJ7fSIhPT1SdSh7YTp0fSl8fCJ7fSIhPT1SdShPYmplY3QodCkpfSkpLEp1PUV1KChmdW5jdGlvbigpe3JldHVybiciXFx1ZGYwNlxcdWQ4MzQiJyE9PVJ1KCJcdWRmMDZcdWQ4MzQiKXx8JyJcXHVkZWFkIichPT1SdSgiXHVkZWFkIil9KSkscXU9ZnVuY3Rpb24odCxlKXt2YXIgcj14dShhcmd1bWVudHMpLG49TnUoZSk7aWYoVXUobil8fHZvaWQgMCE9PXQmJiFGdSh0KSlyZXR1cm4gclsxXT1mdW5jdGlvbih0LGUpe2lmKFV1KG4pJiYoZT1rdShuLHRoaXMsX3UodCksZSkpLCFGdShlKSlyZXR1cm4gZX0sSXUoUnUsbnVsbCxyKX0sWXU9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPUN1KHIsZS0xKSxvPUN1KHIsZSsxKTtyZXR1cm4gQnUoV3UsdCkmJiFCdSh6dSxvKXx8QnUoenUsdCkmJiFCdShXdSxuKT8iXFx1IitIdShEdSh0LDApLDE2KTp0fTtSdSYmTHUoe3RhcmdldDoiSlNPTiIsc3RhdDohMCxhcml0eTozLGZvcmNlZDpLdXx8SnV9LHtzdHJpbmdpZnk6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXh1KGFyZ3VtZW50cyksbz1JdShLdT9xdTpSdSxudWxsLG4pO3JldHVybiBKdSYmInN0cmluZyI9PXR5cGVvZiBvP0d1KG8sVnUsWXUpOm99fSk7dmFyIFh1PSRvLCR1PVl0O2tyKHt0YXJnZXQ6Ik9iamVjdCIsc3RhdDohMCxmb3JjZWQ6IXZ0fHxhKChmdW5jdGlvbigpe1h1LmYoMSl9KSl9LHtnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ZnVuY3Rpb24odCl7dmFyIGU9WHUuZjtyZXR1cm4gZT9lKCR1KHQpKTpbXX19KSxmaSgiYXN5bmNJdGVyYXRvciIpLGZpKCJoYXNJbnN0YW5jZSIpLGZpKCJpc0NvbmNhdFNwcmVhZGFibGUiKSxmaSgiaXRlcmF0b3IiKSxmaSgibWF0Y2giKSxmaSgibWF0Y2hBbGwiKSxmaSgicmVwbGFjZSIpLGZpKCJzZWFyY2giKSxmaSgic3BlY2llcyIpLGZpKCJzcGxpdCIpO3ZhciBRdT1naTtmaSgidG9QcmltaXRpdmUiKSxRdSgpO3ZhciBadT1vdCx0Yz1BaTtmaSgidG9TdHJpbmdUYWciKSx0YyhadSgiU3ltYm9sIiksIlN5bWJvbCIpLGZpKCJ1bnNjb3BhYmxlcyIpLEFpKGkuSlNPTiwiSlNPTiIsITApO3ZhciBlYyxyYyxuYyxvYz1aLlN5bWJvbCxpYz17fSxhYz1rLHVjPVF0LGNjPUZ1bmN0aW9uLnByb3RvdHlwZSxzYz1hYyYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixmYz11YyhjYywibmFtZSIpLGxjPXtFWElTVFM6ZmMsUFJPUEVSOmZjJiYic29tZXRoaW5nIj09PWZ1bmN0aW9uKCl7fS5uYW1lLENPTkZJR1VSQUJMRTpmYyYmKCFhY3x8YWMmJnNjKGNjLCJuYW1lIikuY29uZmlndXJhYmxlKX0scGM9IWEoKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuY29uc3RydWN0b3I9bnVsbCxPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IHQpIT09dC5wcm90b3R5cGV9KSkseWM9UXQsZGM9UCxnYz1ZdCxoYz1wYyxiYz1QbygiSUVfUFJPVE8iKSx2Yz1PYmplY3QsbWM9dmMucHJvdG90eXBlLHdjPWhjP3ZjLmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3ZhciBlPWdjKHQpO2lmKHljKGUsYmMpKXJldHVybiBlW2JjXTt2YXIgcj1lLmNvbnN0cnVjdG9yO3JldHVybiBkYyhyKSYmZSBpbnN0YW5jZW9mIHI/ci5wcm90b3R5cGU6ZSBpbnN0YW5jZW9mIHZjP21jOm51bGx9LFNjPWEsT2M9UCxqYz1RLEFjPURvLExjPXdjLFBjPVpvLEljPXBlKCJpdGVyYXRvciIpLGtjPSExO1tdLmtleXMmJigibmV4dCJpbihuYz1bXS5rZXlzKCkpPyhyYz1MYyhMYyhuYykpKSE9PU9iamVjdC5wcm90b3R5cGUmJihlYz1yYyk6a2M9ITApO3ZhciBUYz0hamMoZWMpfHxTYygoZnVuY3Rpb24oKXt2YXIgdD17fTtyZXR1cm4gZWNbSWNdLmNhbGwodCkhPT10fSkpO09jKChlYz1UYz97fTpBYyhlYykpW0ljXSl8fFBjKGVjLEljLChmdW5jdGlvbigpe3JldHVybiB0aGlzfSkpO3ZhciBFYz17SXRlcmF0b3JQcm90b3R5cGU6ZWMsQlVHR1lfU0FGQVJJX0lURVJBVE9SUzprY30sVWM9RWMuSXRlcmF0b3JQcm90b3R5cGUsRmM9RG8seGM9QixOYz1BaSxNYz1pYyxfYz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxSYz1rcixCYz1VLENjPWxjLERjPWZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBvPWUrIiBJdGVyYXRvciI7cmV0dXJuIHQucHJvdG90eXBlPUZjKFVjLHtuZXh0OnhjKCshbixyKX0pLE5jKHQsbywhMSwhMCksTWNbb109X2MsdH0sR2M9d2MsSGM9QWksVmM9Wm8sV2M9aWMsemM9RWMsS2M9Q2MuUFJPUEVSLEpjPXpjLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMscWM9cGUoIml0ZXJhdG9yIiksWWM9ImtleXMiLFhjPSJ2YWx1ZXMiLCRjPSJlbnRyaWVzIixRYz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxaYz1mdW5jdGlvbih0LGUscixuLG8saSxhKXtEYyhyLGUsbik7dmFyIHUsYyxzLGY9ZnVuY3Rpb24odCl7aWYodD09PW8mJmcpcmV0dXJuIGc7aWYoIUpjJiZ0JiZ0IGluIHkpcmV0dXJuIHlbdF07c3dpdGNoKHQpe2Nhc2UgWWM6Y2FzZSBYYzpjYXNlICRjOnJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgcih0aGlzLHQpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHIodGhpcyl9fSxsPWUrIiBJdGVyYXRvciIscD0hMSx5PXQucHJvdG90eXBlLGQ9eVtxY118fHlbIkBAaXRlcmF0b3IiXXx8byYmeVtvXSxnPSFKYyYmZHx8ZihvKSxoPSJBcnJheSI9PT1lJiZ5LmVudHJpZXN8fGQ7aWYoaCYmKHU9R2MoaC5jYWxsKG5ldyB0KSkpIT09T2JqZWN0LnByb3RvdHlwZSYmdS5uZXh0JiYoSGModSxsLCEwLCEwKSxXY1tsXT1RYyksS2MmJm89PT1YYyYmZCYmZC5uYW1lIT09WGMmJihwPSEwLGc9ZnVuY3Rpb24oKXtyZXR1cm4gQmMoZCx0aGlzKX0pLG8paWYoYz17dmFsdWVzOmYoWGMpLGtleXM6aT9nOmYoWWMpLGVudHJpZXM6ZigkYyl9LGEpZm9yKHMgaW4gYykoSmN8fHB8fCEocyBpbiB5KSkmJlZjKHkscyxjW3NdKTtlbHNlIFJjKHt0YXJnZXQ6ZSxwcm90bzohMCxmb3JjZWQ6SmN8fHB9LGMpO3JldHVybiBhJiZ5W3FjXSE9PWcmJlZjKHkscWMsZyx7bmFtZTpvfSksV2NbZV09ZyxjfSx0cz1mdW5jdGlvbih0LGUpe3JldHVybnt2YWx1ZTp0LGRvbmU6ZX19LGVzPVgscnM9aWMsbnM9RGk7JGUuZjt2YXIgb3M9WmMsaXM9dHMsYXM9IkFycmF5IEl0ZXJhdG9yIix1cz1ucy5zZXQsY3M9bnMuZ2V0dGVyRm9yKGFzKTtvcyhBcnJheSwiQXJyYXkiLChmdW5jdGlvbih0LGUpe3VzKHRoaXMse3R5cGU6YXMsdGFyZ2V0OmVzKHQpLGluZGV4OjAsa2luZDplfSl9KSwoZnVuY3Rpb24oKXt2YXIgdD1jcyh0aGlzKSxlPXQudGFyZ2V0LHI9dC5pbmRleCsrO2lmKCFlfHxyPj1lLmxlbmd0aClyZXR1cm4gdC50YXJnZXQ9bnVsbCxpcyh2b2lkIDAsITApO3N3aXRjaCh0LmtpbmQpe2Nhc2Uia2V5cyI6cmV0dXJuIGlzKHIsITEpO2Nhc2UidmFsdWVzIjpyZXR1cm4gaXMoZVtyXSwhMSl9cmV0dXJuIGlzKFtyLGVbcl1dLCExKX0pLCJ2YWx1ZXMiKSxycy5Bcmd1bWVudHM9cnMuQXJyYXk7dmFyIHNzPXtDU1NSdWxlTGlzdDowLENTU1N0eWxlRGVjbGFyYXRpb246MCxDU1NWYWx1ZUxpc3Q6MCxDbGllbnRSZWN0TGlzdDowLERPTVJlY3RMaXN0OjAsRE9NU3RyaW5nTGlzdDowLERPTVRva2VuTGlzdDoxLERhdGFUcmFuc2Zlckl0ZW1MaXN0OjAsRmlsZUxpc3Q6MCxIVE1MQWxsQ29sbGVjdGlvbjowLEhUTUxDb2xsZWN0aW9uOjAsSFRNTEZvcm1FbGVtZW50OjAsSFRNTFNlbGVjdEVsZW1lbnQ6MCxNZWRpYUxpc3Q6MCxNaW1lVHlwZUFycmF5OjAsTmFtZWROb2RlTWFwOjAsTm9kZUxpc3Q6MSxQYWludFJlcXVlc3RMaXN0OjAsUGx1Z2luOjAsUGx1Z2luQXJyYXk6MCxTVkdMZW5ndGhMaXN0OjAsU1ZHTnVtYmVyTGlzdDowLFNWR1BhdGhTZWdMaXN0OjAsU1ZHUG9pbnRMaXN0OjAsU1ZHU3RyaW5nTGlzdDowLFNWR1RyYW5zZm9ybUxpc3Q6MCxTb3VyY2VCdWZmZXJMaXN0OjAsU3R5bGVTaGVldExpc3Q6MCxUZXh0VHJhY2tDdWVMaXN0OjAsVGV4dFRyYWNrTGlzdDowLFRvdWNoTGlzdDowfSxmcz1pLGxzPUFpLHBzPWljO2Zvcih2YXIgeXMgaW4gc3MpbHMoZnNbeXNdLHlzKSxwc1t5c109cHMuQXJyYXk7dmFyIGRzPW9jLGdzPXBlLGhzPSRlLmYsYnM9Z3MoIm1ldGFkYXRhIiksdnM9RnVuY3Rpb24ucHJvdG90eXBlO3ZvaWQgMD09PXZzW2JzXSYmaHModnMsYnMse3ZhbHVlOm51bGx9KSxmaSgiYXN5bmNEaXNwb3NlIiksZmkoImRpc3Bvc2UiKSxmaSgibWV0YWRhdGEiKTt2YXIgbXM9ZHMsd3M9YixTcz1vdCgiU3ltYm9sIiksT3M9U3Mua2V5Rm9yLGpzPXdzKFNzLnByb3RvdHlwZS52YWx1ZU9mKSxBcz1Tcy5pc1JlZ2lzdGVyZWRTeW1ib2x8fGZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gdm9pZCAwIT09T3MoanModCkpfWNhdGNoKGUpe3JldHVybiExfX07a3Ioe3RhcmdldDoiU3ltYm9sIixzdGF0OiEwfSx7aXNSZWdpc3RlcmVkU3ltYm9sOkFzfSk7Zm9yKHZhciBMcz1LdCxQcz1vdCxJcz1iLGtzPUF0LFRzPXBlLEVzPVBzKCJTeW1ib2wiKSxVcz1Fcy5pc1dlbGxLbm93blN5bWJvbCxGcz1QcygiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIpLHhzPUlzKEVzLnByb3RvdHlwZS52YWx1ZU9mKSxOcz1Mcygid2tzIiksTXM9MCxfcz1GcyhFcyksUnM9X3MubGVuZ3RoO01zPFJzO01zKyspdHJ5e3ZhciBCcz1fc1tNc107a3MoRXNbQnNdKSYmVHMoQnMpfWNhdGNoKHZmKXt9dmFyIENzPWZ1bmN0aW9uKHQpe2lmKFVzJiZVcyh0KSlyZXR1cm4hMDt0cnl7Zm9yKHZhciBlPXhzKHQpLHI9MCxuPUZzKE5zKSxvPW4ubGVuZ3RoO3I8bztyKyspaWYoTnNbbltyXV09PWUpcmV0dXJuITB9Y2F0Y2godmYpe31yZXR1cm4hMX07a3Ioe3RhcmdldDoiU3ltYm9sIixzdGF0OiEwLGZvcmNlZDohMH0se2lzV2VsbEtub3duU3ltYm9sOkNzfSksZmkoImN1c3RvbU1hdGNoZXIiKSxmaSgib2JzZXJ2YWJsZSIpLGtyKHt0YXJnZXQ6IlN5bWJvbCIsc3RhdDohMCxuYW1lOiJpc1JlZ2lzdGVyZWRTeW1ib2wifSx7aXNSZWdpc3RlcmVkOkFzfSksa3Ioe3RhcmdldDoiU3ltYm9sIixzdGF0OiEwLG5hbWU6ImlzV2VsbEtub3duU3ltYm9sIixmb3JjZWQ6ITB9LHtpc1dlbGxLbm93bjpDc30pLGZpKCJtYXRjaGVyIiksZmkoIm1ldGFkYXRhS2V5IiksZmkoInBhdHRlcm5NYXRjaCIpLGZpKCJyZXBsYWNlQWxsIik7dmFyIERzPXIobXMpLEdzPWIsSHM9RHIsVnM9cW4sV3M9Six6cz1HcygiIi5jaGFyQXQpLEtzPUdzKCIiLmNoYXJDb2RlQXQpLEpzPUdzKCIiLnNsaWNlKSxxcz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxyKXt2YXIgbixvLGk9VnMoV3MoZSkpLGE9SHMociksdT1pLmxlbmd0aDtyZXR1cm4gYTwwfHxhPj11P3Q/IiI6dm9pZCAwOihuPUtzKGksYSkpPDU1Mjk2fHxuPjU2MzE5fHxhKzE9PT11fHwobz1LcyhpLGErMSkpPDU2MzIwfHxvPjU3MzQzP3Q/enMoaSxhKTpuOnQ/SnMoaSxhLGErMik6by01NjMyMCsobi01NTI5Njw8MTApKzY1NTM2fX0sWXM9e2NvZGVBdDpxcyghMSksY2hhckF0OnFzKCEwKX0uY2hhckF0LFhzPXFuLCRzPURpLFFzPVpjLFpzPXRzLHRmPSJTdHJpbmcgSXRlcmF0b3IiLGVmPSRzLnNldCxyZj0kcy5nZXR0ZXJGb3IodGYpO1FzKFN0cmluZywiU3RyaW5nIiwoZnVuY3Rpb24odCl7ZWYodGhpcyx7dHlwZTp0ZixzdHJpbmc6WHModCksaW5kZXg6MH0pfSksKGZ1bmN0aW9uKCl7dmFyIHQsZT1yZih0aGlzKSxyPWUuc3RyaW5nLG49ZS5pbmRleDtyZXR1cm4gbj49ci5sZW5ndGg/WnModm9pZCAwLCEwKToodD1ZcyhyLG4pLGUuaW5kZXgrPXQubGVuZ3RoLFpzKHQsITEpKX0pKTt2YXIgbmY9cihlaS5mKCJpdGVyYXRvciIpKTtmdW5jdGlvbiBvZih0KXtyZXR1cm4ob2Y9ImZ1bmN0aW9uIj09dHlwZW9mIERzJiYic3ltYm9sIj09dHlwZW9mIG5mP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJiJmdW5jdGlvbiI9PXR5cGVvZiBEcyYmdC5jb25zdHJ1Y3Rvcj09PURzJiZ0IT09RHMucHJvdG90eXBlPyJzeW1ib2wiOnR5cGVvZiB0fSkodCl9dmFyIGFmPXIoZWkuZigidG9QcmltaXRpdmUiKSk7ZnVuY3Rpb24gdWYodCl7dmFyIGU9ZnVuY3Rpb24odCxlKXtpZigib2JqZWN0IiE9b2YodCl8fCF0KXJldHVybiB0O3ZhciByPXRbYWZdO2lmKHZvaWQgMCE9PXIpe3ZhciBuPXIuY2FsbCh0LGV8fCJkZWZhdWx0Iik7aWYoIm9iamVjdCIhPW9mKG4pKXJldHVybiBuO3Rocm93IG5ldyBUeXBlRXJyb3IoIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuIil9cmV0dXJuKCJzdHJpbmciPT09ZT9TdHJpbmc6TnVtYmVyKSh0KX0odCwic3RyaW5nIik7cmV0dXJuInN5bWJvbCI9PW9mKGUpP2U6ZSsiIn1mdW5jdGlvbiBjZih0LGUscil7cmV0dXJuKGU9dWYoZSkpaW4gdD9Ocih0LGUse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTp0W2VdPXIsdH1jbGFzcyBzZntjb25zdHJ1Y3Rvcih0KXtjZih0aGlzLCJfcG9zaXRpb24iLDApLGNmKHRoaXMsIl9kYXRhdmlldyIsdm9pZCAwKSx0aGlzLl9kYXRhdmlldz1uZXcgRGF0YVZpZXcodCl9Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RofWdldCBidWZmZXIoKXtyZXR1cm4gdGhpcy5fZGF0YXZpZXcuYnVmZmVyfXNldCBwb3NpdGlvbih0KXt0aGlzLl9wb3NpdGlvbj10fWdldCBwb3NpdGlvbigpe3JldHVybiB0aGlzLl9wb3NpdGlvbn1iYWNrKHQpe3RoaXMucG9zaXRpb24tPXR9Z2V0VWludDgodCl7cmV0dXJuIHRoaXMuX2RhdGF2aWV3LmdldFVpbnQ4KHQpfWdldEludDgodCl7cmV0dXJuIHRoaXMuX2RhdGF2aWV3LmdldEludDgodCl9Z2V0SW50MTYodCl7cmV0dXJuIHRoaXMuX2RhdGF2aWV3LmdldEludDE2KHQpfWdldFVpbnQxNih0KXtyZXR1cm4gdGhpcy5fZGF0YXZpZXcuZ2V0VWludDE2KHQpfWdldFVpbnQzMih0KXtyZXR1cm4gdGhpcy5fZGF0YXZpZXcuZ2V0VWludDMyKHQpfWdldEludDMyKHQpe3JldHVybiB0aGlzLl9kYXRhdmlldy5nZXRJbnQzMih0KX1za2lwKHQpe2NvbnN0IGU9TWF0aC5mbG9vcih0LzQpLHI9dCU0O2ZvcihsZXQgbj0wO248ZTtuKyspc2YucmVhZEJ5dGUodGhpcyw0KTtyPjAmJnNmLnJlYWRCeXRlKHRoaXMscil9c3RhdGljIHJlYWRCeXRlKHQsZSxyKXtsZXQgbjtzd2l0Y2goZSl7Y2FzZSAxOm49cj90LmdldEludDgodC5wb3NpdGlvbik6dC5nZXRVaW50OCh0LnBvc2l0aW9uKTticmVhaztjYXNlIDI6bj1yP3QuZ2V0SW50MTYodC5wb3NpdGlvbik6dC5nZXRVaW50MTYodC5wb3NpdGlvbik7YnJlYWs7Y2FzZSAzOmlmKHIpdGhyb3cgbmV3IEVycm9yKCJub3Qgc3VwcG9ydGVkIGZvciByZWFkQnl0ZSAzIik7bj10LmdldFVpbnQ4KHQucG9zaXRpb24pPDwxNixufD10LmdldFVpbnQ4KHQucG9zaXRpb24rMSk8PDgsbnw9dC5nZXRVaW50OCh0LnBvc2l0aW9uKzIpO2JyZWFrO2Nhc2UgNDpuPXI/dC5nZXRJbnQzMih0LnBvc2l0aW9uKTp0LmdldFVpbnQzMih0LnBvc2l0aW9uKTticmVhaztjYXNlIDg6aWYocil0aHJvdyBuZXcgRXJyb3IoIm5vdCBzdXBwb3J0ZWQgZm9yIHJlYWRCb2R5IDgiKTtuPXQuZ2V0VWludDMyKHQucG9zaXRpb24pPDwzMixufD10LmdldFVpbnQzMih0LnBvc2l0aW9uKzQpO2JyZWFrO2RlZmF1bHQ6bj0iIn1yZXR1cm4gdC5wb3NpdGlvbis9ZSxufXJlYWRVaW50OCgpe3JldHVybiBzZi5yZWFkQnl0ZSh0aGlzLDEpfXJlYWRVaW50MTYoKXtyZXR1cm4gc2YucmVhZEJ5dGUodGhpcywyKX1yZWFkVWludDI0KCl7cmV0dXJuIHNmLnJlYWRCeXRlKHRoaXMsMyl9cmVhZFVpbnQzMigpe3JldHVybiBzZi5yZWFkQnl0ZSh0aGlzLDQpfXJlYWRVaW50NjQoKXtyZXR1cm4gc2YucmVhZEJ5dGUodGhpcyw4KX1yZWFkSW50OCgpe3JldHVybiBzZi5yZWFkQnl0ZSh0aGlzLDEsITApfXJlYWRJbnQxNigpe3JldHVybiBzZi5yZWFkQnl0ZSh0aGlzLDIsITApfXJlYWRJbnQzMigpe3JldHVybiBzZi5yZWFkQnl0ZSh0aGlzLDQsITApfXdyaXRlVWludDMyKHQpe3JldHVybiBuZXcgVWludDhBcnJheShbdD4+PjI0JjI1NSx0Pj4+MTYmMjU1LHQ+Pj44JjI1NSwyNTUmdF0pfX12YXIgZmY9KHQ9Pih0W3QuaW50ZXJuYWw9MF09ImludGVybmFsIix0W3QuZXh0ZXJuYWw9MV09ImV4dGVybmFsIix0W3QuYnlwYXNzPTJdPSJieXBhc3MiLHQpKShmZnx8e30pO2NvbnN0IGxmPW5ldyBVaW50OEFycmF5KFsxMDksMTY3LDUzLDE5MCwxMDMsOTAsNzIsMSwxNzAsODksNjMsMTY0LDE5NCwxOTksMTksODVdKSxwZj1uZXcgVWludDhBcnJheShbMTA5LDE2Nyw1MywxOTAsMTAzLDkwLDcyLDEsMTcwLDg5LDYzLDE2NCwxOTQsMTk5LDE5LDg0XSkseWY9bmV3IFVpbnQ4QXJyYXkoWzMxLDIzOSwzLDUwLDI0MiwxMjAsNzYsODUsMTY5LDQyLDE2MSw5MSw3NSwxODYsMjJdKTtmdW5jdGlvbiBkZih0KXtjb25zdCBlPVtdO2Zvcig7dD49MjU1Oyl0LT0yNTUsZS5wdXNoKDI1NSk7cmV0dXJuIGUucHVzaCh0KSxuZXcgVWludDhBcnJheShlKX1mdW5jdGlvbiBnZih0KXtsZXQgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MCxyPTA7Zm9yKDsyNTU9PT10W2VdJiZlPHQuYnl0ZUxlbmd0aDspZSsrLHIrPTI1NTtyZXR1cm4gZTx0LmJ5dGVMZW5ndGgmJihyKz10W2UrK10pLFtyLGVdfWNvbnN0IGhmPW5ldyBVaW50OEFycmF5KFs4MCwxXSk7Y2xhc3MgYmZ7c3RhdGljIGdlbmVyYXRlU0VJKHQsZSl7bGV0IHI9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtjb25zdCBuPW5ldyBVaW50OEFycmF5KFswLDAsMCwxXSksbz1lP2hmOm5ldyBVaW50OEFycmF5KFs2XSksaT1uZXcgVWludDhBcnJheShbNV0pLGE9YmYuX191dWlkfHwocj9sZjpwZiksdT1kZih0LmJ5dGVMZW5ndGgrYS5ieXRlTGVuZ3RoKSxjPSh0PT57Y29uc3QgZT1bXTtsZXQgcj0wO2Zvcihjb25zdCBuIG9mIHQpcj49MiYmbjw9MyYmKGUucHVzaCgzKSxyPTApLDA9PT1uP3IrKzpyPTAsZS5wdXNoKG4pO3JldHVybiBuZXcgVWludDhBcnJheShlKX0pKHQpO3JldHVybiBuZXcgVWludDhBcnJheShbLi4ubiwuLi5vLC4uLmksLi4udSwuLi5hLC4uLmMsMTI4XSl9c3RhdGljIGRlY29kZVNFSUJvZHkodCxlKXtjb25zdCByPSh0PT57Y29uc3QgZT1bXTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl0W3JdPD0zJiYwPT09dFtyLTFdJiYwPT09dFtyLTJdfHxlLnB1c2godFtyXSk7cmV0dXJuIG5ldyBVaW50OEFycmF5KGUpfSkodD10LnNsaWNlKDAsdC5sZW5ndGgtMSkpO2lmKHIuYnl0ZUxlbmd0aDwyKXJldHVybjtsZXQgbj0wO2NvbnN0IG89ZT8yOjE7aWYoNSE9PXJbb10mJjEwMCE9PXJbb10pcmV0dXJuO24rPTErbztjb25zdFtpLGFdPWdmKHIsbik7bj1hO2xldCB1PTI7Y29uc3QgYz1uK2k7ci5ieXRlTGVuZ3RoPj1wZi5ieXRlTGVuZ3RoJiZpPj1wZi5ieXRlTGVuZ3RoJiYoci5zbGljZShuLG4rcGYuYnl0ZUxlbmd0aCkudG9TdHJpbmcoKT09PXBmLnRvU3RyaW5nKCl8fHIuc2xpY2UobixuK3lmLmJ5dGVMZW5ndGgpLnRvU3RyaW5nKCk9PT15Zi50b1N0cmluZygpKT8obis9cGYuYnl0ZUxlbmd0aCx1PTEpOnIuYnl0ZUxlbmd0aD49cGYuYnl0ZUxlbmd0aCYmaT49cGYuYnl0ZUxlbmd0aCYmci5zbGljZShuLG4rbGYuYnl0ZUxlbmd0aCkudG9TdHJpbmcoKT09PWxmLnRvU3RyaW5nKCkmJihuKz1sZi5ieXRlTGVuZ3RoLHU9MCk7cmV0dXJue3R5cGU6dSxwYXlsb2FkOnIuc2xpY2UobixjKX19c3RhdGljIHBhcnNlSW50ZXJuYWxTRUkodCl7Y29uc3QgZT1uZXcgTWFwO2xldCByPTA7aWYoMD09PXQudHlwZSl7Zm9yKDt0LnBheWxvYWQuYnl0ZUxlbmd0aC1yPj0yOyl7Y29uc3RbbixvXT1nZih0LnBheWxvYWQscik7cj1vO2NvbnN0W2ksYV09Z2YodC5wYXlsb2FkLHIpO2lmKHI9YSxlLmdldChuKXx8IShpPD10LnBheWxvYWQuYnl0ZUxlbmd0aC1yKSlicmVhaztlLnNldChuLHQucGF5bG9hZC5zbGljZShyLHIraSkpLHIrPWl9cmV0dXJuIGV9fXN0YXRpYyBtYWtlSW50ZXJuYWxTZWkodCl7Y29uc3QgZT1bXTtmb3IoY29uc3RbbyxpXW9mIHQpe2NvbnN0IHQ9ZGYobykscj1kZihpLmJ5dGVMZW5ndGgpO2UucHVzaCh0LHIsaSl9Y29uc3Qgcj1lLnJlZHVjZSgoKHQsZSk9PnQrZS5ieXRlTGVuZ3RoKSwwKSxuPW5ldyBVaW50OEFycmF5KHIpO3JldHVybiBlLnJlZHVjZSgoKHQsZSk9PihuLnNldChlLHQpLHQrZS5ieXRlTGVuZ3RoKSksMCksbn19Y2YoYmYsIl9fdXVpZCIsdm9pZCAwKSwidW5kZWZpbmVkIiE9dHlwZW9mIHNlbGYmJiJEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZSI9PT1zZWxmLmNvbnN0cnVjdG9yLm5hbWUmJnNlbGYuYWRkRXZlbnRMaXN0ZW5lcigicnRjdHJhbnNmb3JtIiwoZT0+e2NvbnN0e3RyYW5zZm9ybWVyOnJ9PWUse3N0cmVhbUlkOm4sc2tpcEZpbHRlcjpvfT1yLm9wdGlvbnMsaT1mdW5jdGlvbihlKXtsZXR7cG9zdE1lc3NhZ2U6cixza2lwRmlsdGVyOm59PWU7cmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe3RyYW5zZm9ybShlLG8pe2NvbnN0IGk9dC5pc0gyNjVWaWRlb0ZyYW1lKGUpO3QuZ2V0TkFMVW5pdHMobmV3IHNmKGUuZGF0YSksaSkuZm9yRWFjaCgodD0+e2lmKHQuc2VpKXtjb25zdCBlPWJmLmRlY29kZVNFSUJvZHkodC5ib2R5LGkpO2UmJihufHxlLnR5cGU9PT1mZi5leHRlcm5hbCkmJnIoZSl9fSkpLG8uZW5xdWV1ZShlKX19KX0oe3Bvc3RNZXNzYWdlOnQ9PntzZWxmLnBvc3RNZXNzYWdlKHtzdHJlYW1JZDpuLG1zZzp0fSxbdC5wYXlsb2FkLmJ1ZmZlcl0pfSxza2lwRmlsdGVyOm99KTtyLnJlYWRhYmxlLnBpcGVUaHJvdWdoKGkpLnBpcGVUbyhlLnRyYW5zZm9ybWVyLndyaXRhYmxlKX0pKX0oKTsK";
var blob = "undefined" != typeof window && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper() {
  let e;
  try {
    if (e = blob && (_URL || window.webkitURL).createObjectURL(blob), !e) throw "";
    return new Worker(e);
  } catch (e2) {
    return new Worker("data:application/javascript;base64," + encodedJs);
  } finally {
    e && (_URL || window.webkitURL).revokeObjectURL(e);
  }
}
var ResetPubSubLockReason = ((e) => (e.RECONNECT = "ice-reconnect", e.LEAVE = "leave_room", e))(ResetPubSubLockReason || {});
var DEFAULT_RTS_MODE = RTS_MODE.NORMAL_MODE;
var RTCContext = class {
  constructor(e, t, i) {
    _defineProperty(this, "engineDestroyed", false), _defineProperty(this, "avSync", true), _defineProperty(this, "callId", void 0), _defineProperty(this, "streamRTT", {}), _defineProperty(this, "useCloudProxy", false), _defineProperty(this, "videoProfile", void 0), _defineProperty(this, "audioProfileManager", void 0), _defineProperty(this, "extensionManager", void 0), _defineProperty(this, "userPriority", /* @__PURE__ */ new Map()), _defineProperty(this, "expectedIDC", void 0), _defineProperty(this, "autoPlayPolicy", void 0), _defineProperty(this, "joinRoomConfig", void 0), _defineProperty(this, "signalingManager", void 0), _defineProperty(this, "peerConnection", void 0), _defineProperty(this, "pubSubLock", new PromiseLock2("pubSubLock")), _defineProperty(this, "pcKillSwitch", _objectSpread2({ ctor_sdpsemantics_add: true, ctor_encodedinsetablestream_add: true, sld_rtcpfb_rrtr_add: true, sld_ext_sdesmid_remove: true, sld_fmtp_sps_add: true, sld_fmtp_bitrate_add: true, sld_fmtp_opus_add: true, sld_iceoption_renomination: true }, getParameter("PC_KILLSWITCH"))), _defineProperty(this, "visibility", true), _defineProperty(this, "rtsLimiter", { e2e: new RTSMessageLimiter(DEFAULT_RTS_MODE), e2s: new RTSMessageLimiter(DEFAULT_RTS_MODE), boradcast: new RTSMessageLimiter(DEFAULT_RTS_MODE), conf: void 0, rtsMode: DEFAULT_RTS_MODE }), _defineProperty(this, "serverConfig", void 0), _defineProperty(this, "mediaParams", void 0), _defineProperty(this, "subscribeFallbackOption", void 0), _defineProperty(this, "joinRoomParams", void 0), _defineProperty(this, "isPreConnection", false), _defineProperty(this, "_handler", void 0), _defineProperty(this, "monitor", void 0), _defineProperty(this, "enableFallbackHandler", !!getParameter("ENABLE_FALLBACK_HANDLER")), _defineProperty(this, "enableStandardHandler", !!getParameter("ENABLE_STANDARD_HANDLER")), _defineProperty(this, "_businessId", void 0), _defineProperty(this, "_userStreamConfig", /* @__PURE__ */ new Map()), _defineProperty(this, "_localAudioTrackDumpConfig", { [StreamIndex$1.STREAM_INDEX_MAIN]: { callback: void 0, frameSize: void 0 }, [StreamIndex$1.STREAM_INDEX_SCREEN]: { callback: void 0, frameSize: void 0 } }), _defineProperty(this, "_remoteAudioTrackDumpConfig", { [StreamIndex$1.STREAM_INDEX_MAIN]: /* @__PURE__ */ new Map(), [StreamIndex$1.STREAM_INDEX_SCREEN]: /* @__PURE__ */ new Map() }), _defineProperty(this, "_targetCodec", void 0), _defineProperty(this, "_targetScreenCodec", void 0), _defineProperty(this, "earMonitorSettings", { [StreamIndex$1.STREAM_INDEX_MAIN]: { position: EarMonitorPosition.NONE, volume: 100 }, [StreamIndex$1.STREAM_INDEX_SCREEN]: { position: EarMonitorPosition.NONE, volume: 100 } }), _defineProperty(this, "localVideoTrack", void 0), _defineProperty(this, "localAudioTrack", void 0), _defineProperty(this, "publicAudioVolume", /* @__PURE__ */ new Map()), _defineProperty(this, "_receiveSEIWorker", void 0), this.id = e, this.appId = t, this.monitor = getMonitor(e), this.expectedIDC = null == i ? void 0 : i.expectedIDC, this.autoPlayPolicy = null == i ? void 0 : i.autoPlayPolicy, this.audioProfileManager = new AudioProfileManager(t), this.extensionManager = new ExtensionManager(e), this.joinRoomConfig = new JoinRoomConfig(e), this.signalingManager = new SignalingManager(this), this.videoProfile = new EngineVideoProfile(this);
  }
  set businessId(e) {
    var t;
    this._businessId = e, null === (t = this.monitor) || void 0 === t || t.set({ rtc_business_id: e });
  }
  get businessId() {
    return this._businessId;
  }
  set handler(e) {
    var t;
    e && this.resetPubSubLock("ice-reconnect"), null === (t = this._handler) || void 0 === t || t.destroy(), this._handler = e;
  }
  get handler() {
    return this._handler;
  }
  get role() {
    return this.visibility ? UserRole.NORMAL_USER : UserRole.SILENT_USER;
  }
  set targetCodec(e) {
    e && [VideoCodecName.H264, VideoCodecName.VP8, VideoCodecName.ByteVC1].forEach((t) => {
      e.toLowerCase() === t.toLowerCase() && (this._targetCodec = t);
    });
  }
  set targetScreenCodec(e) {
    e && [VideoCodecName.H264, VideoCodecName.VP8, VideoCodecName.ByteVC1].forEach((t) => {
      e.toLowerCase() === t.toLowerCase() && (this._targetScreenCodec = t);
    });
  }
  get targetCodec() {
    return this._targetCodec;
  }
  get targetScreenCodec() {
    return this._targetScreenCodec;
  }
  resetPubSubLock(e) {
    this.pubSubLock.closeReason = e, this.pubSubLock = new PromiseLock2("pubSubLock");
  }
  setUserStreamConf(e, t, i) {
    const r = this._userStreamConfig.get(e) || {}, o = r[t] || {};
    r[t] = _objectSpread2(_objectSpread2({}, o), i), this._userStreamConfig.set(e, r);
  }
  getRemoteMirrorType(e, t) {
    var i;
    return !(null === (i = this._userStreamConfig.get(e)) || void 0 === i || null === (i = i[t]) || void 0 === i || !i.mirrorType);
  }
  get rtsMode() {
    return this.rtsLimiter.rtsMode;
  }
  setRTSMode(e) {
    this.rtsLimiter.e2e.setLimitMode(e), this.rtsLimiter.boradcast.setLimitMode(e), this.rtsLimiter.e2s.setLimitMode(e), this.rtsLimiter.rtsMode = e;
  }
  setRtsQpsConf(e) {
    this.rtsLimiter.e2e.setQPS(null == e ? void 0 : e.rts_qps_interval, null == e ? void 0 : e.rts_e2e_qps_value), this.rtsLimiter.boradcast.setQPS(null == e ? void 0 : e.rts_qps_interval, null == e ? void 0 : e.rts_broadcast_qps_value), this.rtsLimiter.e2s.setQPS(null == e ? void 0 : e.rts_qps_interval, null == e ? void 0 : e.rts_e2s_qps_value), this.rtsLimiter.conf = e;
  }
  get receiveSEIWorker() {
    return this._receiveSEIWorker || (this._receiveSEIWorker = new WorkerWrapper()), this._receiveSEIWorker;
  }
  updatePCKillSwitch(e) {
    this.pcKillSwitch = _objectSpread2(_objectSpread2({}, this.pcKillSwitch), e);
  }
  destroy() {
    this.engineDestroyed = true, this.signalingManager.destroy(), this.userPriority.clear(), this.avSync = true, this._localAudioTrackDumpConfig = { [StreamIndex$1.STREAM_INDEX_MAIN]: { callback: void 0, frameSize: void 0 }, [StreamIndex$1.STREAM_INDEX_SCREEN]: { callback: void 0, frameSize: void 0 } }, this._remoteAudioTrackDumpConfig[StreamIndex$1.STREAM_INDEX_MAIN].clear(), this._remoteAudioTrackDumpConfig[StreamIndex$1.STREAM_INDEX_SCREEN].clear(), this.extensionManager.destroy(), this.earMonitorSettings = { [StreamIndex$1.STREAM_INDEX_MAIN]: { position: EarMonitorPosition.NONE, volume: 100 }, [StreamIndex$1.STREAM_INDEX_SCREEN]: { position: EarMonitorPosition.NONE, volume: 100 } }, this.publicAudioVolume.clear();
  }
};
function pubSubLock(e, t, i) {
  const r = i.value;
  return i.value = async function() {
    var e2, t2;
    const i2 = await this._ctx.pubSubLock.lock();
    "chrome" !== (null === (e2 = this._ctx.handler) || void 0 === e2 ? void 0 : e2.name) && "standard" !== (null === (t2 = this._ctx.handler) || void 0 === t2 ? void 0 : t2.name) || i2();
    try {
      const { closeReason: e3 } = this._ctx.pubSubLock;
      if (e3) throw new SDKError(ErrorCode.UNEXPECTED_ERROR, e3);
      for (var o = arguments.length, n = new Array(o), s = 0; s < o; s++) n[s] = arguments[s];
      return await r.apply(this, n);
    } finally {
      var a, d;
      "chrome" !== (null === (a = this._ctx.handler) || void 0 === a ? void 0 : a.name) && "standard" !== (null === (d = this._ctx.handler) || void 0 === d ? void 0 : d.name) && i2();
    }
  }, i;
}
function checkNotInRTSRoom(e, t, i) {
  const r = i.value;
  return i.value = async function() {
    var e2;
    if (null !== (e2 = this._room) && void 0 !== e2 && e2.config.isRTSOnlyRoom()) throw new SDKError(ErrorCode.NOT_ALLOWED_IN_RTS_ROOM, "Engine.".concat(t, "() is not allowed in RTS room"));
    for (var i2 = arguments.length, o = new Array(i2), n = 0; n < i2; n++) o[n] = arguments[n];
    return await r.apply(this, o);
  }, i;
}
var encodedTransformSupported = isLegacyEncodedTransformSupported() || isEncodedTransformSupported();
var VendorHandler = class extends BasicHandler {
  constructor(e, t) {
    super(e, t), _defineProperty(this, "_peerConnectionId", genUuid()), _defineProperty(this, "peerConnectionMode", 1), _defineProperty(this, "name", "vendor"), _defineProperty(this, "direction", "up"), _defineProperty(this, "stream", void 0), t.on("ice_state", (e2) => {
      this._report("rtc_ice_state", { pc_session_id: this.peerConnectionId, direction: this.direction, error_code: 0, ice_state: e2.toUpperCase(), message: "", peer_connection_id: this.peerConnectionId, stream_id: "", stream_user_id: "" });
    }), t.on("disconnect", () => {
      this.emit("disconnect");
    });
  }
  async publish(e) {
    this._context.videoProfile.closeSimulcast(), this.stream = e;
    const { videoDescriptions: t, subVideoDescriptions: i, audioTransceiverInit: r, videoTransceiverInit: o } = super.internalPublish(e);
    e.audioTransceiver = this._peerConnection.addTransceiver(r.track, r.init), e.videoTransceiver = this._peerConnection.addTransceiver(o.track, o.init), encodedTransformSupported && (e.initAudioEncodedTransform(), e.initVideoEncodedTransform()), this._report("rtc_begin_create_offer", { direction: "up", stream_id: "", stream_user_id: "", pc_session_id: this.peerConnectionId, vendor_mode: (null == e ? void 0 : e.vendorCode) || 0 });
    const n = await this.peer.createOfferSdp(), s = getServerNow(), a = lib.parse(n);
    Array.isArray(a.media) && (a.media = a.media.map((e2) => {
      if ("video" === e2.type) (isSafari || isIOS) && Array.isArray(e2.ext) && (e2.ext = e2.ext.filter((e3) => {
        var t3;
        return !(null != e3 && null !== (t3 = e3.uri) && void 0 !== t3 && t3.includes("video-orientation"));
      })), isSafari || this.addBitrateLimit(e2, this._context.videoProfile.getVideoEncodeConfig()[0].maxKbps);
      else if ("audio" === e2.type) {
        const i2 = null == e2 ? void 0 : e2.rtp.find((e3) => "opus" === e3.codec);
        if (i2 && e2.fmtp) {
          var t2;
          const r2 = e2.fmtp.find((e3) => e3.payload === i2.payload);
          r2 && null !== (t2 = this._context) && void 0 !== t2 && t2.audioProfileManager && (r2.config = this._context.audioProfileManager.getOpusConfigStr(r2.config));
        }
      }
      return e2;
    }));
    const d = { type: "offer", sdp: lib.write(a) };
    try {
      await this._peerConnection.setLocalDescription(d), this._report("rtc_set_description", { error_code: 0, message: d.sdp || "", is_local: "1", direction: "up", stream_id: "", stream_user_id: "", elapse: getServerNow() - s }, { type: "offer" });
    } catch (e2) {
      throw this._report("rtc_set_description", { error_code: -1, message: e2.message + d.sdp, is_local: "1", direction: "up", stream_id: "", stream_user_id: "", elapse: getServerNow() - s }, { type: "offer" }), e2;
    }
    return { partialSdp: d.sdp || "", audioMid: "0", videoMid: "1", type: "offer", semantics: "unified-plan", videoDescriptions: t, subVideoDescriptions: i, audioTransceiverInit: r, videoTransceiverInit: o, peerConnectionMode: this.peerConnectionMode, peerConnectionId: this.peerConnectionId };
  }
  async subscribe(e) {
    this.stream = e, this.direction = "down", e.audioTransceiver = this._peerConnection.addTransceiver("audio", { direction: "recvonly" }), e.videoTransceiver = this._peerConnection.addTransceiver("video", { direction: "recvonly" }), encodedTransformSupported && (e.initAudioEncodedTransform(), e.initVideoEncodedTransform()), this._report("rtc_begin_create_offer", { direction: "down", stream_id: e.streamId, stream_user_id: e.userId, pc_session_id: this.peerConnectionId, vendor_mode: e.vendorCode || 0 });
    const t = await this.peer.createOfferSdp(), i = getServerNow(), r = lib.parse(t);
    Array.isArray(r.media) && (r.media = r.media.map((e2) => {
      if ("audio" === e2.type) {
        const t2 = null == e2 ? void 0 : e2.rtp.find((e3) => "opus" === e3.codec);
        if (t2 && null != e2 && e2.fmtp) {
          const i2 = null == e2 ? void 0 : e2.fmtp.find((e3) => e3.payload === t2.payload);
          i2 && this._context && (i2.config += ";stereo=1;sprop-stereo=1");
        }
      }
      return e2;
    }));
    const o = { type: "offer", sdp: lib.write(r) };
    try {
      await this._peerConnection.setLocalDescription(o), this._report("rtc_set_description", { error_code: 0, message: o.sdp || "", is_local: "1", direction: "down", stream_id: e.streamId, stream_user_id: e.userId, elapse: getServerNow() - i }, { type: "offer" });
    } catch (t2) {
      throw this._report("rtc_set_description", { error_code: -1, message: t2.message + o.sdp, is_local: "1", direction: "down", stream_id: e.streamId, stream_user_id: e.userId, elapse: getServerNow() - i }, { type: "offer" }), t2;
    }
    return { partialSdp: o.sdp || "", audioMid: "0", videoMid: "1", type: "offer", semantics: "unified-plan", peerConnectionMode: this.peerConnectionMode, peerConnectionId: this.peerConnectionId };
  }
  async handleAck(e) {
    if (e.action === SdpAction.publish || e.action === SdpAction.subscribe) {
      const { signalingAck: n, videoMid: s, videoCodec: a } = e, { sdp: d } = n, c2 = lib.parse(d);
      c2.media = c2.media.map((e2) => (e2.mid === s && a && setCodecPreferences(e2, a), e2));
      const l = { sdp: lib.write(c2), type: "answer" }, u = getServerNow();
      try {
        var t, i;
        await this._peerConnection.setRemoteDescription(l), this._report("rtc_set_description", { error_code: 0, message: l.sdp || "", is_local: "1", direction: "down", stream_id: (null === (t = e.stream) || void 0 === t ? void 0 : t.streamId) || "", stream_user_id: null === (i = e.stream) || void 0 === i ? void 0 : i.userId, elapse: getServerNow() - u }, { type: "answer" });
      } catch (t2) {
        var r, o;
        throw this._report("rtc_set_description", { error_code: -1, message: t2.message + l.sdp, is_local: "1", direction: "down", stream_id: (null === (r = e.stream) || void 0 === r ? void 0 : r.streamId) || "", stream_user_id: null === (o = e.stream) || void 0 === o ? void 0 : o.userId, elapse: getServerNow() - u }, { type: "offer" }), t2;
      }
      "function" == typeof e.onSuccess && e.onSuccess();
    } else e.action !== SdpAction.unpublish && e.action !== SdpAction.unsubscribe || this.destroy();
    return "";
  }
  destroy() {
    this.peer.destroy(), super.destroy();
  }
  async getDefaultSdp() {
    return { sdp: "", type: "offer", semantics: "" };
  }
  connect() {
    throw new Error("Method not implemented.");
  }
  async rollback() {
    try {
      this._peerConnection.close();
    } catch (e) {
    }
  }
  get peerConnectionId() {
    return this._peerConnectionId;
  }
  set peerConnectionId(e) {
    this._peerConnectionId = e;
  }
};
var __defProp$7 = Object.defineProperty;
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __decorateClass$7 = (e, t, i, r) => {
  for (var o, n = r > 1 ? void 0 : r ? __getOwnPropDesc$7(t, i) : t, s = e.length - 1; s >= 0; s--) (o = e[s]) && (n = (r ? o(t, i, n) : o(n)) || n);
  return r && n && __defProp$7(t, i, n), n;
};
var RoomPublisher = class extends EnhancedEventEmitter {
  constructor(e, t) {
    super(), _defineProperty(this, "_logger", void 0), _defineProperty(this, "_pubBackOff", /* @__PURE__ */ new Map()), this._ctx = e, this._roomConf = t, this._logger = new Logger$1("RoomPublisher", 2, e.id);
  }
  async hasPublished(e) {
    return !!e.audioMid && !!e.videoMid;
  }
  async publish(e) {
    return this._publish(e);
  }
  async _publish(e) {
    var t, i, r, o, n, s, a, d, c2, l;
    this._logger.info("publish()", "localStream: %o", e);
    const { videoTrack: u } = e, { audioTrack: h } = e, _ = getServerNow();
    let p, { handler: m } = this._ctx;
    this._roomConf.vendorConfig.enableMultiVendor ? [m, p] = await this._getVendorPubSdpInfo(e) : p = await this._ctx.handler.publish(e), this.emit("_test_pub_sdpInfo_", p);
    const { audioMid: S, videoMid: g } = p;
    e.pubAttributes = { localaudio: !!h, localvideo: !!u, videostream: e.pubVideo, audiostream: e.pubAudio, extvideo: (null == u ? void 0 : u.sourceType) === SourceType.EXTERNAL, extaudio: (null == h ? void 0 : h.sourceType) === SourceType.EXTERNAL, videoDescriptions: p.videoDescriptions, videoType: VideoType.NORMAL };
    const v3 = { attributes: _objectSpread2({}, e.pubAttributes), audio: true, video: true, screen: e.isScreen, audioMid: S, videoMid: g, sdpInfo: { msid: e.stream.id, type: p.type, sdp: p.partialSdp, semantics: p.semantics }, peerConnectionMode: null === (t = p) || void 0 === t ? void 0 : t.peerConnectionMode, supportMultiVendor: true }, f = !this._roomConf.vendorConfig.enableMultiVendor && e.enableSimulcast && (null === (i = this._ctx.serverConfig) || void 0 === i ? void 0 : i.simulcastOnDemand) && (null === (r = p.subVideoDescriptions) || void 0 === r ? void 0 : r.length);
    let y;
    (f || null !== (o = this._ctx.serverConfig) && void 0 !== o && o.e2eFeedback) && (v3.attributes.subVideoDescriptions = p.subVideoDescriptions), null !== (n = p) && void 0 !== n && n.peerConnectionId && (v3.peerConnectionId = p.peerConnectionId);
    try {
      this.emit("_test_pub_body_", v3), y = await this._ctx.signalingManager.sendSignaling("publish", v3);
    } catch (t2) {
      var E, T;
      if (this._logger.error("_publish", getErrorString(t2)), null === (E = this._ctx.monitor) || void 0 === E || E.report("rtc_error", { message: "[publisher._publish] ".concat(getErrorString(t2)), error_code: -1 }), t2 instanceof Error ? this._roomConf.report("rtc_publish_stat", { result: "fail", is_screen: "0", start: _, message: "".concat(t2.name, ": ").concat(t2.message) }) : t2 instanceof SDKError && this._roomConf.report("rtc_publish_stat", { result: "fail", is_screen: "0", start: _, message: "".concat(t2.code, ": ").concat(t2.message) }), await (null === (T = m) || void 0 === T ? void 0 : T.rollback({ msid: e.stream.id, stream: e, audioMid: S, videoMid: g })), t2.code >= 500 && t2.code < 600) {
        this.emit("_test_pub_5xx_");
        const t3 = this._getPubBackOff(e.id);
        if (t3.retryDuration < 6e4) return this._logger.info("pubRetry", e.id, t3.retryDuration), await new Promise((e2) => setTimeout(e2, t3.interval)), t3.retryDuration += t3.interval, t3.interval = t3.interval > 4e3 ? 8e3 : 2 * t3.interval, e.resetStream(), this.emit(RoomEvent.PUB_RETRY, { screen: e.isScreen }), this._publish(e);
        this._logger.info("pubRetry", "end"), this._pubBackOff.delete(e.id);
      } else if (403 === t2.code) throw new SDKError(ErrorCode.TOKEN_NO_PUBLISH_PERMISSION, t2.message || "token no publish permission");
      throw t2;
    }
    var b, I;
    (this._roomConf.report("rtc_recv_answer", { error_code: 0, answer_type: null === (s = y) || void 0 === s ? void 0 : s.relayMessage.type, sequence_id: (null === (a = y) || void 0 === a || null === (a = a.relayMessage) || void 0 === a ? void 0 : a.sequenceId) || 0, message: null === (d = y) || void 0 === d || null === (d = d.relayMessage) || void 0 === d ? void 0 : d.sdp, direction: "up", stream_id: "", stream_user_id: "", pc_session_id: (null === (c2 = m) || void 0 === c2 ? void 0 : c2.peerConnectionId) || "" }), e.isScreen) ? e.setVideoCaps(null === (b = y.relayMessage.content) || void 0 === b ? void 0 : b.screenCaps) : e.setVideoCaps(null === (I = y.relayMessage.content) || void 0 === I ? void 0 : I.videoCaps);
    e.streamId = y.streamId;
    const R = await e.getSelectedCodec();
    e.currentVideoCodec = R;
    const C = new Promise((t2, i2) => {
      var r2, o2, n2, s2, a2;
      null === (r2 = m) || void 0 === r2 || r2.handleAck({ action: SdpAction.publish, streamId: y.streamId, audioMid: S, videoMid: g, audioTransceiverInit: null === (o2 = p) || void 0 === o2 ? void 0 : o2.audioTransceiverInit, videoTransceiverInit: null === (n2 = p) || void 0 === n2 ? void 0 : n2.videoTransceiverInit, signalingAck: { sdp: null === (s2 = y) || void 0 === s2 || null === (s2 = s2.relayMessage) || void 0 === s2 ? void 0 : s2.sdp, sequenceId: null === (a2 = y) || void 0 === a2 || null === (a2 = a2.relayMessage) || void 0 === a2 ? void 0 : a2.sequenceId }, stream: e, videoCodec: R, onSuccess: () => {
        this._logger.info("publish()", "publish success"), t2(0);
      }, onFail: (e2) => {
        this._logger.info("publish()", "publish fail"), i2(e2);
      } });
    });
    !isFirefox && await C, this.emit("___afterHandleAckInPub"), (f && this._ctx.videoProfile.getSimulcastMode() === VideoSimulcastMode.VIDEO_ON_DEMAND || null !== (l = this._ctx.serverConfig) && void 0 !== l && l.e2eFeedback) && this.emit(MediaServerSignalEvent.RSCP, [{ StreamIds: [e.stream.id], Metadata: { VideoIndex: 0 } }], true), e.videoMid = g, e.audioMid = S, e.subVideoDescriptions = p.subVideoDescriptions, e.remoteSdp = y.relayMessage.sdp, this._roomConf.report("rtc_publish_stat", { result: "success", is_screen: "0", start: _, message: "unknown" });
  }
  async updatePubTrack(e) {
    this._logger.info("updatePubTrack()", "localStream: %o", e);
    const { videoTrack: t, audioTrack: i, pubAudio: r, pubVideo: o } = e, n = e.vendorHandler || this._ctx.handler;
    let s = null == i ? void 0 : i.preprocessingTrack;
    const a = null == t ? void 0 : t.preprocessingTrack;
    var d, c2;
    o && a ? (e.stopBlackFrame(), await (null === (d = e.videoTransceiver) || void 0 === d ? void 0 : d.sender.replaceTrack(a)), this._updateVideoDescriptions(e)) : await (null === (c2 = e.videoTransceiver) || void 0 === c2 ? void 0 : c2.sender.replaceTrack(null));
    if (r && s) {
      var l;
      const { mixType: t2, mixedAudioTrack: r2 } = i;
      r2 && t2 !== AudioMixingType.PLAYOUT && s.enabled && (s = r2), await (null === (l = e.audioTransceiver) || void 0 === l ? void 0 : l.sender.replaceTrack(s));
    } else {
      var u;
      await (null === (u = e.audioTransceiver) || void 0 === u ? void 0 : u.sender.replaceTrack(null)), reportRtcInvokeStatus(this._ctx.id, "MediaClient.updatePubTrack(audio)", "null");
    }
    await this._updatePublishCodec(e), this.emit("___onAfterReplaceTrack");
    try {
      reportRtcInvokeStatus(this._ctx.id, "MediaClient.updatePubTrack", JSON.stringify({ audioStreamTrack: mediaTrackStringify(s), videoStreamTrack: mediaTrackStringify(a) }));
    } catch (e2) {
    }
    const h = { localaudio: !!i, localvideo: !!t, videostream: o, audiostream: r, extvideo: (null == t ? void 0 : t.sourceType) === SourceType.EXTERNAL, extaudio: (null == i ? void 0 : i.sourceType) === SourceType.EXTERNAL, videoType: t ? VideoType.NORMAL : e.pubAttributes.videoType }, _ = {};
    for (const [t2, i2] of Object.entries(h)) i2 !== Reflect.get(e.pubAttributes, t2) && Reflect.set(_, t2, i2);
    if (!Object.keys(_).length) return;
    if (e.observer) {
      const { observer: t2 } = e, { audiostream: i2, videostream: r2, localaudio: o2, localvideo: n2, extaudio: s2, extvideo: a2 } = _;
      void 0 !== n2 ? void 0 !== a2 ? t2.setPushVideo(a2) : t2.setEnableVideo(n2) : void 0 !== r2 && t2.setUnmuteVideo(r2), void 0 !== o2 ? void 0 !== s2 ? t2.setPushAudio(s2) : t2.setEnableAudio(o2) : void 0 !== i2 && t2.setUnmuteAudio(i2);
    }
    e.pubAttributes = _objectSpread2(_objectSpread2({}, e.pubAttributes), h), e.pubAttributes.videostream || e.stopBlackFrame();
    const p = { roomId: this._roomConf.roomId, streamId: e.streamId, attributes: _ };
    await this._ctx.signalingManager.sendSignaling("updateStreamAttributes", p), this.emit("___onAfterUpdateSignaling"), isFirefox && await (null == n ? void 0 : n.setCurrentDescription());
  }
  async _updatePublishCodec(e) {
    this._logger.info("updatePublishCodec()", "localStream: %o", e);
    const { audioMid: t, videoMid: i, remoteSdp: r, streamId: o, currentVideoCodec: n } = e, s = await e.getSelectedCodec();
    if (this._logger.info("updatePublishCodec()", "selectedCodec: %o", s), s !== n) {
      if (e.currentVideoCodec = s, t && i && o && r) {
        var a;
        if (this._ctx.handler instanceof FirefoxHandler || this._ctx.handler instanceof FallbackHandler) await (null === (a = this._ctx.handler) || void 0 === a ? void 0 : a._internalChangePubCodec());
        return new Promise((n2, a2) => {
          var d;
          null === (d = this._ctx.handler) || void 0 === d || d.handleAck({ action: SdpAction.publish, streamId: o, audioMid: t, videoMid: i, signalingAck: { sdp: r, sequenceId: -1 }, videoCodec: s, onSuccess: n2, onFail: a2, stream: e });
        });
      }
      {
        const t2 = ["audioMid", "videoMid", "streamId", "remoteSdp"].filter((t3) => !Reflect.get(e, t3));
        this._logger.warn("updatePublishCodec()", "fast return, because params: %o", t2);
      }
    } else this._logger.warn("updatePublishCodec()", "selectedCodec is equal to currentVideoCodec");
  }
  async unpublish(e) {
    this._logger.info("unpublish()", "localStream: %o", e);
    const t = { roomId: this._roomConf.roomId, initStreamId: e.initStreamId, streamId: e.streamId };
    this._ctx.signalingManager.sendSignaling("unpublish", t).catch(() => {
    });
    const i = e.vendorHandler || this._ctx.handler;
    e.stopBlackFrame(), await (null == i ? void 0 : i.handleAck({ action: SdpAction.unpublish, audioMid: e.audioMid, videoMid: e.videoMid, stream: e, streamId: e.streamId }));
  }
  async updatePubBlackFrame(e) {
    var t;
    const i = e.genBlackFrame();
    i && (null === (t = e.videoTransceiver) || void 0 === t || null === (t = t.sender) || void 0 === t || t.replaceTrack(i), e.pubAttributes.videoType = VideoType.BLACK, this._ctx.signalingManager.sendSignaling("updateStreamAttributes", { roomId: this._roomConf.roomId, streamId: e.streamId, attributes: { videoType: VideoType.BLACK } }), e.on("black-frame-ended", () => {
      var t2;
      null === (t2 = e.videoTransceiver) || void 0 === t2 || null === (t2 = t2.sender) || void 0 === t2 || t2.replaceTrack(null), e.pubAttributes.videoType = VideoType.NORMAL, this._ctx.signalingManager.sendSignaling("updateStreamAttributes", { roomId: this._roomConf.roomId, streamId: e.streamId, attributes: { videoType: VideoType.NORMAL } });
    }));
  }
  async cleanStream(e) {
    return this._logger.info("cleanStream()", "localStream: %o", e), null == e ? void 0 : e.clean();
  }
  async destroyStream(e) {
    return this._logger.info("destroyStream()", "localStream: %o", e), null == e ? void 0 : e.destroy();
  }
  destroy(e) {
    e.forEach((e2) => {
      e2 && (this.unpublish(e2).catch(() => {
      }), this.destroyStream(e2).catch(() => {
      }));
    }), this._pubBackOff.clear(), super.removeAllListeners();
  }
  async _updateVideoDescriptions(e) {
    var t;
    const i = this._ctx.videoProfile.genVideoDescriptions(e), r = e.pubAttributes.videoDescriptions;
    if (r.length !== i.videoDescriptions.length) return;
    const o = {};
    if (r.find((e2, t2) => {
      if (e2.framerate !== i.videoDescriptions[t2].framerate || e2.maxkbps !== i.videoDescriptions[t2].maxkbps || e2.width !== i.videoDescriptions[t2].width || e2.height !== i.videoDescriptions[t2].height) return o.videoDescriptions = i.videoDescriptions, true;
    }), null === (t = e.subVideoDescriptions) || void 0 === t || t.find((e2, t2) => {
      if (e2.framerate !== i.subVideoDescriptions[t2].framerate || e2.maxkbps !== i.subVideoDescriptions[t2].maxkbps || e2.width !== i.subVideoDescriptions[t2].width || e2.height !== i.subVideoDescriptions[t2].height) return o.subVideoDescriptions = i.subVideoDescriptions, true;
    }), Object.keys(o).length > 0) {
      var n;
      this._ctx.signalingManager.sendSignaling("updateStreamAttributes", { roomId: this._roomConf.roomId, streamId: e.streamId, attributes: o });
      const t2 = null === (n = e.videoTransceiver) || void 0 === n || null === (n = n.sender) || void 0 === n ? void 0 : n.getParameters();
      var s;
      if (reportRtcInvokeStatus(this._ctx.id, "sender.getParameters", JSON.stringify(t2), 0, e.streamId), t2 && Array.isArray(null == t2 ? void 0 : t2.encodings)) t2.encodings = t2.encodings.map((e2, r2) => {
        var o2;
        return (null !== (o2 = e2.rid) && void 0 !== o2 ? o2 : 1 === t2.encodings.length ? "0" : void 0) === i.sendEncodings[r2].rid && (e2.maxBitrate = i.sendEncodings[r2].maxBitrate, e2.maxFramerate = i.sendEncodings[r2].maxFramerate, e2.scaleResolutionDownBy = i.sendEncodings[r2].scaleResolutionDownBy), e2;
      }), this._logger.info("sender.setParameters()", JSON.stringify(t2.encodings)), reportRtcInvokeStatus(this._ctx.id, "sender.setParameters", JSON.stringify(t2), 0, e.streamId), null === (s = e.videoTransceiver) || void 0 === s || s.sender.setParameters(t2), reportRtcInvokeStatus(this._ctx.id, "Handler.updateScaleResolutionDownBy", JSON.stringify(t2.encodings));
    }
  }
  async _getVendorPubSdpInfo(e) {
    const t = new PeerConnection(this._ctx, "");
    e.vendorHandler = new VendorHandler(this._ctx, t), e.pcSessionId && (e.vendorHandler.peerConnectionId = e.pcSessionId);
    const i = await e.vendorHandler.publish(e), r = e.vendorHandler;
    return r.on("ice_state", (e2) => {
      this.emit(StateEvent.ON_VENDOR_CONNECTION_STATE_CHANGE, { state: { checking: ConnectionState.CONNECTION_STATE_CONNECTING, connected: ConnectionState.CONNECTION_STATE_CONNECTED, disconnected: ConnectionState.CONNECTION_STATE_RECONNECTING }[e2], userId: this._roomConf.userId });
    }), r.once("disconnect", async () => {
      var t2;
      r.removeAllListeners(), "connected" === (null === (t2 = this._ctx.peerConnection) || void 0 === t2 ? void 0 : t2.getIceConnectionState()) ? (await this.unpublish(e), await this.publish(e), e.vendorHandler && e.statsReport.setVar(e.vendorHandler)) : this._logger.info("vendor ice failed", e.streamId);
    }), [r, i];
  }
  _getPubBackOff(e) {
    return this._pubBackOff.has(e) || this._pubBackOff.set(e, { interval: 1e3, retryDuration: 0 }), this._pubBackOff.get(e);
  }
};
__decorateClass$7([streamQueue], RoomPublisher.prototype, "hasPublished", 1), __decorateClass$7([streamQueue, pubSubLock, checkRoomState], RoomPublisher.prototype, "publish", 1), __decorateClass$7([streamQueue, pubSubLock, checkRoomState], RoomPublisher.prototype, "updatePubTrack", 1), __decorateClass$7([streamQueue, pubSubLock, checkRoomState], RoomPublisher.prototype, "unpublish", 1), __decorateClass$7([streamQueue, checkRoomState], RoomPublisher.prototype, "updatePubBlackFrame", 1), __decorateClass$7([streamQueue], RoomPublisher.prototype, "cleanStream", 1), __decorateClass$7([streamQueue], RoomPublisher.prototype, "destroyStream", 1), __decorateClass$7([checkRoomState], RoomPublisher.prototype, "_updateVideoDescriptions", 1);
var __defProp$6 = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorateClass$6 = (e, t, i, r) => {
  for (var o, n = r > 1 ? void 0 : r ? __getOwnPropDesc$6(t, i) : t, s = e.length - 1; s >= 0; s--) (o = e[s]) && (n = (r ? o(t, i, n) : o(n)) || n);
  return r && n && __defProp$6(t, i, n), n;
};
var RoomSubscriber = class extends EnhancedEventEmitter {
  constructor(e, t) {
    super(), _defineProperty(this, "_logger", void 0), _defineProperty(this, "_subBackOff", /* @__PURE__ */ new Map()), _defineProperty(this, "_subResolves", {}), _defineProperty(this, "_ontrackCallbackMap", /* @__PURE__ */ new Map()), this._ctx = e, this._roomConf = t, this._logger = new Logger$1("RoomSubscriber", 2, e.id);
  }
  async hasSubscribed(e) {
    return e.streamState === StreamState.SUB_ED;
  }
  async subscribe(e, t, i) {
    if (e.streamState !== StreamState.SUB_ED) return this._subscribe(e, t, i);
    this._logger.warn("subscribe()", "remoteStream ".concat(e.streamId, " has been subscribed, silently return"));
  }
  async _subscribe(e, t, i) {
    var r, o, n, s, a, d, c2, l, u, h, _, p, m, S;
    this._logger.info("subscribe()", "mediaType: %o", t), logRemoteStream("subscribe()", e, this._logger), e.streamState = StreamState.SUB_ING;
    let g = false, v3 = false;
    if (audioInMediaType(t) && (v3 = true), videoInMediaType(t) && (g = true), !g && this._roomConf.isMultiChatMode()) return void (e.streamState = StreamState.INIT);
    const f = getServerNow(), y = e.subVideo, E = [];
    this._subResolves[e.streamId] || (this._subResolves[e.streamId] = []), E.push(new Promise((t2, i2) => {
      this._subResolves[e.streamId].push(t2);
      const r2 = setTimeout(() => i2(new SDKError(ErrorCode.TIME_OUT, "wait video timeout for userId: ".concat(e.userId))), 6e4), o2 = (i3) => {
        "video" === i3.mediaType && (this._logger.info("remoteStream ".concat(e.userId, " received video track")), e.off("ontrack", o2), clearTimeout(r2), t2(0));
      };
      e.on("ontrack", o2);
    })), this._roomConf.isMultiChatMode() || E.push(new Promise((t2, i2) => {
      this._subResolves[e.streamId].push(t2);
      const r2 = setTimeout(() => i2(new SDKError(ErrorCode.TIME_OUT, "wait audio timeout for userId: ".concat(e.userId))), 6e4), o2 = (i3) => {
        "audio" === i3.mediaType && (this._logger.info("remoteStream ".concat(e.userId, " received audio track")), e.off("ontrack", o2), clearTimeout(r2), t2(0));
      };
      e.on("ontrack", o2);
    }));
    const T = (t2) => {
      e.ontrack(t2);
    };
    null === (r = this._ctx.handler) || void 0 === r || r.on("ontrack", T), this._ontrackCallbackMap.set(e, T);
    let b, { handler: I } = this._ctx;
    null !== (o = this._ctx.serverConfig) && void 0 !== o && o.forceUniHandler || !e.enableVendorMode ? b = await this._ctx.handler.subscribe(e, { multiChatMode: this._roomConf.isMultiChatMode() }) : [I, b] = await this._getVendorSubSdpInfo(e, T);
    const { audioMid: R, videoMid: C } = b;
    e.subVideo = g;
    const P = { spatialLayer: (null == i ? void 0 : i.spatialLayer) || 0, temporalLayer: 0, spatialSubLayer: (null == i ? void 0 : i.spatialSubLayer) || -1 }, A = { audio: !this._roomConf.isMultiChatMode(), video: true, data: true, screen: e.isScreen, browser: "chrome-stable", videoMid: C, audioMid: R, sdpInfo: { sdp: null === (n = b) || void 0 === n ? void 0 : n.partialSdp, semantics: null === (s = b) || void 0 === s ? void 0 : s.semantics, type: null === (a = b) || void 0 === a ? void 0 : a.type }, streamUserId: e.userId, streamId: e.streamId, config: { enableMediaType: { audio: !!this._roomConf.isMultiChatMode() || v3, video: g }, qualityLayer: P }, extra: { enableSendRTT: true }, peerConnectionMode: null === (d = b) || void 0 === d ? void 0 : d.peerConnectionMode, supportMultiVendor: true };
    null !== (c2 = b) && void 0 !== c2 && c2.peerConnectionId && (A.peerConnectionId = b.peerConnectionId);
    const { subscribeFallbackOption: O, userPriority: k } = this._ctx;
    "number" == typeof O && (A.config.fallbackOption = O), k.has(e.userId) && (A.config.priority = k.get(e.userId)), null !== (l = b) && void 0 !== l && l.allSsrc && (A.extra.subscribeSSRC = b.allSsrc), this.emit("_test_before_ack_");
    const { signalingAck: N, audioTransceiverInit: w, videoTransceiverInit: M } = b;
    let D;
    N && (e.videoMid = C, e.audioMid = R, await new Promise((t2, i2) => {
      var r2;
      null === (r2 = I) || void 0 === r2 || r2.handleAck({ action: SdpAction.subscribe, streamId: e.streamId, audioMid: R, videoMid: C, audioTransceiverInit: w, videoTransceiverInit: M, signalingAck: N, stream: e, onSuccess: () => {
        this._logger.info("ssrc", "success"), t2(0);
      }, onFail: (e2) => {
        this._logger.info("ssrc", "fail", e2), i2(e2);
      } });
    }));
    try {
      this.emit("_test_sub_body_", A);
      const e2 = this._ctx.signalingManager.sendSignaling("subscribe", A);
      this.emit("_test_during_signaling_", A), D = await e2;
    } catch (r2) {
      var L, $2;
      if (null === (L = this._ctx.monitor) || void 0 === L || L.report("rtc_error", { message: "[subscriber._subscribe] ".concat(getErrorString(r2)), error_code: -1 }), e.streamState = StreamState.INIT, r2 instanceof Error && this._roomConf.report("rtc_subscribe_stat", { result: "fail", start: f, message: r2.message, stream_user_id: e.userId }), r2.code >= 500 && r2.code < 600) {
        this.emit("_test_sub_5xx_");
        const r3 = this._getSubBackOff(e.streamId);
        var x;
        if (r3.retryDuration < 6e4) return this._logger.info("subRetry", e.streamId, r3.retryDuration), await new Promise((e2) => setTimeout(e2, r3.interval)), r3.retryDuration += r3.interval, r3.interval = r3.interval > 4e3 ? 8e3 : 2 * r3.interval, this.emit(RoomEvent.SUB_RETRY, { screen: e.isScreen, userId: e.userId }), await (null === (x = I) || void 0 === x ? void 0 : x.handleAck({ action: SdpAction.unsubscribe, streamId: e.streamId, audioMid: R, videoMid: C, stream: e })), e.resetStream(), this._subscribe(e, t, i);
        this._logger.info("subRetry", "end", e.streamId), this._subBackOff.delete(e.streamId);
      }
      e.subVideo = y, await (null === ($2 = I) || void 0 === $2 ? void 0 : $2.rollback({ msid: e.streamId, stream: e }));
      const o2 = { roomId: this._roomConf.roomId, streamId: e.streamId, userId: e.userId };
      if (await this._ctx.signalingManager.sendSignaling("unsubscribe", o2).catch(() => {
      }), e.streamState = StreamState.INIT, 403 === r2.code) throw new SDKError(ErrorCode.TOKEN_NO_SUBSCRIBE_PERMISSION, r2.message || "token no subscribe permission");
      throw r2;
    }
    if (!D.relayMessage) throw this._roomConf.report("rtc_error", { error_code: -1009, message: "relayMessage is null" }), new SDKError(ErrorCode.UNEXPECTED_ERROR, "unable to subscribe");
    const { audioMid: V, videoMid: U } = null !== (u = null === (h = D) || void 0 === h ? void 0 : h.relayMessage) && void 0 !== u ? u : {}, W = { [R]: V, [C]: U };
    this._logger.info("sub midmap", e.userId, W), e.videoMid = C, e.audioMid = R, e.subMediaType = t, e.streamState = StreamState.SUB_ED, e.subLayer = P, this._roomConf.report("rtc_recv_answer", { error_code: 0, answer_type: null === (_ = D) || void 0 === _ || null === (_ = _.relayMessage) || void 0 === _ ? void 0 : _.type, sequence_id: (null === (p = D) || void 0 === p || null === (p = p.relayMessage) || void 0 === p ? void 0 : p.sequenceId) || 0, message: null === (m = D) || void 0 === m || null === (m = m.relayMessage) || void 0 === m ? void 0 : m.sdp, direction: "down", stream_id: e.streamId, stream_user_id: e.userId, pc_session_id: (null === (S = I) || void 0 === S ? void 0 : S.peerConnectionId) || "" });
    try {
      var F;
      null !== (F = b) && void 0 !== F && F.signalingAck || await new Promise((t2, i2) => {
        var r2, o2, n2, s2, a2;
        null === (r2 = I) || void 0 === r2 || r2.handleAck({ action: SdpAction.subscribe, streamId: e.streamId, audioMid: R, videoMid: C, audioTransceiverInit: null === (o2 = b) || void 0 === o2 ? void 0 : o2.audioTransceiverInit, videoTransceiverInit: null === (n2 = b) || void 0 === n2 ? void 0 : n2.videoTransceiverInit, signalingAck: { sdp: null === (s2 = D) || void 0 === s2 || null === (s2 = s2.relayMessage) || void 0 === s2 ? void 0 : s2.sdp, sequenceId: null === (a2 = D) || void 0 === a2 || null === (a2 = a2.relayMessage) || void 0 === a2 ? void 0 : a2.sequenceId }, stream: e, onSuccess: () => {
          this._logger.info("sub ack", "success"), t2(0);
        }, onFail: (e2) => {
          this._logger.info("sub ack", "fail", e2), i2(e2);
        } });
      }), await Promise.all(E);
    } catch (t2) {
      var Z, G;
      null === (Z = this._ctx.monitor) || void 0 === Z || Z.report("rtc_error", { message: "[subscriber._subscribe] ".concat(getErrorString(t2)), error_code: -1 }), t2 instanceof Error && this._roomConf.report("rtc_subscribe_stat", { result: "fail", start: f, message: t2.message, stream_user_id: e.userId });
      const i2 = { roomId: this._roomConf.roomId, streamId: e.streamId, userId: e.userId };
      throw await this._ctx.signalingManager.sendSignaling("unsubscribe", i2).catch(() => {
      }), await (null === (G = I) || void 0 === G ? void 0 : G.handleAck({ action: SdpAction.unsubscribe, streamId: e.streamId, audioMid: R, videoMid: C, stream: e })), e.streamState = StreamState.INIT, e.resetStream(), t2;
    }
    this._roomConf.isMultiChatMode() || (e.subAudio = v3), this._roomConf.report("rtc_subscribe_stat", { result: "success", start: f, message: "unknown", stream_user_id: e.userId }), e.startReport((e2) => this.emit("onRemoteStreamStats", e2), I);
  }
  async unsubscribe(e) {
    return this._unsubscribe(e);
  }
  async _unsubscribe(e) {
    var t, i;
    logRemoteStream("unsubscribe()", e, this._logger);
    const r = { roomId: this._roomConf.roomId, streamId: e.streamId, userId: e.userId }, o = e.vendorHandler || this._ctx.handler;
    this._ctx.signalingManager.sendSignaling("unsubscribe", r).catch(() => {
    }), e.streamState = StreamState.INIT, e.subVideo = false, null === (t = e.observer) || void 0 === t || t.setSubscribeVideo(false), !this._roomConf.isMultiChatMode() && (null === (i = e.observer) || void 0 === i || i.setSubscribeAudio(false));
    const n = await (null == o ? void 0 : o.handleAck({ action: SdpAction.unsubscribe, streamId: e.streamId, audioMid: e.audioMid, videoMid: e.videoMid, stream: e }));
    this._subResolves[n] && this._subResolves[n].forEach((e2) => e2(0)), this._logger.info("unsubscribe", "clean unsub ".concat(e.userId)), e.clean(), e.subMediaType = ExtendMediaType.NONE, this._removeOnTrackListener(e), e.statsReport.unsubscribe();
  }
  async unsubscribe4removeTrack(e, t, i) {
    var r, o, n, s;
    if (logRemoteStream("unsubscribe4removeTrack()", e, this._logger), this._logger.info("unsubscribe4removeTrack()", "sequenceId: ", t.sequenceId, "trackType: ", i), t.sequenceId < e.sequenceId) return void this._logger.warn("unsubscribe4removeTrack()", "sequenceId return");
    const a = i + 1, d = !!(a & MediaType$1.AUDIO), c2 = !!(a & MediaType$1.VIDEO);
    await (null === (r = this._ctx.handler) || void 0 === r ? void 0 : r.handleAck({ action: SdpAction.removetrack, streamId: e.streamId, audioMid: e.audioMid, videoMid: e.videoMid, stream: e })), null === (o = e.observer) || void 0 === o || o.setPushTrack(false), null === (n = e.observer) || void 0 === n || n.setUnmuteAudio(!d), e.subAudio = !d, null === (s = e.observer) || void 0 === s || s.setUnmuteVideo(!c2), e.subVideo = !c2, e.subMediaType = e.subMediaType - (e.subMediaType & a), e.virtual && (e.clean(), e.resetHasSubscribed(), e.statsReport.unsubscribe());
  }
  async handleStreamFailed(e) {
    const t = e.subMediaType, i = e.subLayer;
    await this._unsubscribe(e), await this._subscribe(e, t, i);
  }
  async handleRemoveStream(e) {
    logRemoteStream("handleRemoveStream()", e, this._logger), e.subVideo = false, e.streamState !== StreamState.INIT && (await this._unsubscribe(e), await this._cleanStream(e), this._destroyStream(e));
  }
  _removeOnTrackListener(e) {
    const t = this._ontrackCallbackMap.get(e);
    if (t) {
      const i = e.vendorHandler || this._ctx.handler;
      null == i || i.off("ontrack", t), this._ontrackCallbackMap.delete(e);
    }
  }
  async _getVendorSubSdpInfo(e, t) {
    const i = new PeerConnection(this._ctx, "");
    e.vendorHandler = new VendorHandler(this._ctx, i), e.pcSessionId && (e.vendorHandler.peerConnectionId = e.pcSessionId);
    const r = e.vendorHandler;
    r.on("ontrack", t);
    const o = await e.vendorHandler.subscribe(e);
    return r.on("ice_state", (t2) => {
      this.emit(StateEvent.ON_VENDOR_CONNECTION_STATE_CHANGE, { state: { checking: ConnectionState.CONNECTION_STATE_CONNECTING, connected: ConnectionState.CONNECTION_STATE_CONNECTED, disconnected: ConnectionState.CONNECTION_STATE_RECONNECTING }[t2], userId: e.userId });
    }), r.once("disconnect", async () => {
      var t2;
      if (null == r || r.removeAllListeners(), "connected" !== (null === (t2 = this._ctx.peerConnection) || void 0 === t2 ? void 0 : t2.getIceConnectionState())) return void this._logger.info("vendor ice failed", e.streamId);
      const i2 = e.subMediaType;
      await this.unsubscribe(e), await this.subscribe(e, i2), e.vendorHandler && e.statsReport.setVar(e.vendorHandler), this.emit(RoomEvent.RESUBSCRIBE, { stream: e });
    }), [r, o];
  }
  async subscribe4pushTrack(e, t) {
    var i, r, o;
    this._logger.info("subscribe4pushTrack()", "streamInfo: %o", t), logRemoteStream("subscribe4pushTrack()", e, this._logger), e.subAudio = true;
    const n = await (null === (i = this._ctx.handler) || void 0 === i ? void 0 : i.subscribe(e, { multiChatMode: this._roomConf.isMultiChatMode() }));
    if (!n) throw new SDKError(ErrorCode.ADD_TRANSCEIVER_FAILED, "add transceiver failed");
    const { audioMid: s } = n, { videoMid: a } = n, d = [];
    d.push(new Promise((t2, i2) => {
      const r2 = setTimeout(() => i2(new SDKError(ErrorCode.TIME_OUT, "wait audio timeout for userId: ".concat(e.userId))), 6e4), o2 = (i3) => {
        "audio" === i3.mediaType && (this._logger.success("remoteStream ".concat(e.userId, " received audio track")), e.off("ontrack", o2), clearTimeout(r2), t2(0));
      };
      e.on("ontrack", o2);
    }));
    const c2 = (t2) => {
      e.ontrack(t2);
    };
    null === (r = this._ctx.handler) || void 0 === r || r.on("ontrack", c2), this._ontrackCallbackMap.set(e, c2), await (null === (o = this._ctx.handler) || void 0 === o ? void 0 : o.handleAck({ action: SdpAction.pushtrack, streamId: e.streamId, audioMid: s, videoMid: a, stream: e, audioTransceiverInit: null == n ? void 0 : n.audioTransceiverInit, videoTransceiverInit: null == n ? void 0 : n.videoTransceiverInit, signalingAck: null == t ? void 0 : t.message })), await Promise.all(d), e.videoMid = a, e.audioMid = s, e.startReport((e2) => this.emit("onRemoteStreamStats", e2), this._ctx.handler);
  }
  async updateUserAttributes(e) {
    this._logger.info("updateUserAttributes()", "attributes: %o", e), await this._ctx.signalingManager.sendSignaling("updateUserAttributes", { roomId: this._roomConf.roomId, sessionId: this._roomConf.sessionId, attributes: e });
  }
  async updateSubTrackLayer(e, t) {
    if (this._logger.info("updateSubTrack()", "subLayer: %o", t), e.subLayer.spatialLayer === t.spatialLayer && e.subLayer.spatialSubLayer === t.spatialSubLayer) return void this._logger.warn("updateSubTrack()", "subLayer no change");
    const i = { roomId: this._roomConf.roomId, streamList: [e.streamId], streamId: e.streamId, streamUserId: e.userId, config: { qualityLayer: t } };
    return await this._ctx.signalingManager.sendSignaling("updateSubscribe", i), this.emit("___afterUpdateSubscribeSend"), e.subLayer = t, e;
  }
  async updateSubPriority(e, t) {
    if (this._logger.info("updateSubPriority()", "priority: %o", t), e.priority === t) return this._logger.warn("updateSubPriority()", "priority no change"), e;
    const i = { roomId: this._roomConf.roomId, streamList: [e.streamId], streamId: e.streamId, streamUserId: e.userId, config: { priority: t } };
    return await this._ctx.signalingManager.sendSignaling("updateSubscribe", i), e.priority = t, e;
  }
  async updateSubMediaType(e, t) {
    var i;
    let r = false, o = false;
    audioInMediaType(t) && (o = true), videoInMediaType(t) && (r = true);
    const n = { roomId: this._roomConf.roomId, streamList: [e.streamId], config: { enableMediaType: { video: r, audio: !!this._roomConf.isMultiChatMode() || o } } };
    var s;
    (await this._ctx.signalingManager.sendSignaling("updateSubscribe", n), this._roomConf.isMultiChatMode()) || (null === (s = e.observer) || void 0 === s || s.setUnmuteAudio(o), e.subAudio = o);
    return null === (i = e.observer) || void 0 === i || i.setUnmuteVideo(r), e.subVideo = r, e.subMediaType = t, e;
  }
  async cleanStream(e) {
    return this._cleanStream(e);
  }
  async _cleanStream(e) {
    this._logger.info("cleanStream()", "stream: %o", e), null == e || e.clean();
  }
  destroyStream(e) {
    return this._destroyStream(e);
  }
  _destroyStream(e) {
    this._logger.info("destroyStream()", "stream: %o", e), null == e || e.destroy();
  }
  destroy(e) {
    var t;
    this._logger.info("destroy()", "remoteStream: %o", e), e.forEach((e2) => {
      this.unsubscribe(e2).catch(() => {
      }), this.destroyStream(e2);
    }), this._subBackOff.clear(), this._ontrackCallbackMap.forEach((e2, t2) => {
      this._removeOnTrackListener(t2), this._ontrackCallbackMap.delete(t2);
    }), this._subResolves = {}, null === (t = this._ctx.handler) || void 0 === t || t.removeAllListeners("ontrack"), super.removeAllListeners();
  }
  _getSubBackOff(e) {
    return this._subBackOff.has(e) || this._subBackOff.set(e, { interval: 1e3, retryDuration: 0 }), this._subBackOff.get(e);
  }
};
__decorateClass$6([streamQueue], RoomSubscriber.prototype, "hasSubscribed", 1), __decorateClass$6([streamQueue, pubSubLock, checkRoomState], RoomSubscriber.prototype, "subscribe", 1), __decorateClass$6([streamQueue, pubSubLock, checkRoomState], RoomSubscriber.prototype, "unsubscribe", 1), __decorateClass$6([streamQueue, pubSubLock, checkRoomState], RoomSubscriber.prototype, "unsubscribe4removeTrack", 1), __decorateClass$6([streamQueue], RoomSubscriber.prototype, "handleStreamFailed", 1), __decorateClass$6([streamQueue, checkRoomState], RoomSubscriber.prototype, "handleRemoveStream", 1), __decorateClass$6([streamQueue, pubSubLock, checkRoomState], RoomSubscriber.prototype, "subscribe4pushTrack", 1), __decorateClass$6([streamQueue, checkRoomState], RoomSubscriber.prototype, "updateUserAttributes", 1), __decorateClass$6([streamQueue, checkRoomState], RoomSubscriber.prototype, "updateSubTrackLayer", 1), __decorateClass$6([streamQueue, checkRoomState], RoomSubscriber.prototype, "updateSubPriority", 1), __decorateClass$6([streamQueue], RoomSubscriber.prototype, "updateSubMediaType", 1), __decorateClass$6([streamQueue], RoomSubscriber.prototype, "cleanStream", 1), __decorateClass$6([streamQueue], RoomSubscriber.prototype, "destroyStream", 1);
var RoomProfileMap = { [RoomProfileType.communication]: [0], [RoomProfileType.chat]: [0], [RoomProfileType.chatRoom]: [1, "IES_chatroom"], [RoomProfileType.coHost]: [1, "IES_PK"], [RoomProfileType.meeting]: [16], [RoomProfileType.classRoom]: [0] };
var RoomJoin = class _RoomJoin extends EnhancedEventEmitter {
  constructor(e, t) {
    super(), _defineProperty(this, "_logger", void 0), _defineProperty(this, "_authorization", void 0), _defineProperty(this, "_joinRoom5xxTimer", void 0), _defineProperty(this, "_joinTask", void 0), _defineProperty(this, "_sdpInfo", void 0), this._ctx = e, this._roomConf = t, this._logger = new Logger$1("RoomJoin", 2, e.id), this._logger.info("constructor", "invoke");
  }
  join() {
    let e, t, i = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    this._logger.info("join()");
    const r = new Promise((r2, o) => {
      e = r2, t = o, this._callJoinRoom(i).catch((e2) => {
        const t2 = Array.isArray(e2) && e2.length > 0 ? e2[0] : e2;
        this._joinRoomFailed(t2.message);
      });
    });
    return this._joinTask && i ? this._joinTask.startTime = getServerNow() : (this._joinTask = { startTime: getServerNow(), success: e, fail: t }, this._roomConf.joinPromise = r), this._reportJoinRoomStart(), r;
  }
  async updateToken(e) {
    if (this._logger.info("updateToken()", "newToken: %o", e), !this._ctx.appId || !this._roomConf.userId || !this._roomConf.roomId) return;
    const t = { roomId: this._roomConf.roomId, userId: this._roomConf.userId, appId: this._ctx.appId, token: "Bearer ".concat(e) };
    try {
      await this._ctx.signalingManager.sendSignaling("updateToken", t);
    } catch (e2) {
      throw new SDKError(ErrorCode.UPDATE_TOKEN_WITH_INVALID_TOKEN, "invoke updateToken with an invalid token");
    }
  }
  async leave() {
    this._logger.info("leave()"), this._stopJoinRoom5xxRetry(), this._joinRoomFailed("leave_room");
    const e = { Authorization: this._authorization, roomId: this._roomConf.roomId, sessionId: this._roomConf.sessionId };
    if (await this._ready2join(), !this._ctx.signalingManager.isConnected()) return Promise.reject(new SDKError(ErrorCode.NOT_CONNECTED_YET, "server not connected"));
    await this._ctx.signalingManager.sendSignaling("leaveRoom", e, this._roomConf.rtsOnlySignalHeader);
  }
  destroy() {
    this._logger.info("destroy()"), this._joinRoomFailed("leave_room"), this._authorization = void 0, this._stopJoinRoom5xxRetry(), this.removeAllListeners();
  }
  async _ready2join() {
    var e;
    (await this._ctx.signalingManager.connect(), this._sdpInfo) || (this._sdpInfo = await (null === (e = this._ctx.handler) || void 0 === e ? void 0 : e.getDefaultSdp()));
    return _RoomJoin.supportedCodecs || (_RoomJoin.supportedCodecs = await internalGetSupportedCodecs()), { sdpInfo: this._sdpInfo, supportedCodecs: _RoomJoin.supportedCodecs };
  }
  async _callJoinRoom(e) {
    var t, i;
    this._logger.info("_callJoinRoom", "invoke"), delete this._sdpInfo;
    const { appId: r, role: o, businessId: n, useCloudProxy: s, joinRoomParams: a, mediaParams: d } = this._ctx, { sdpInfo: c2, supportedCodecs: l } = await this._ready2join(), u = { Authorization: Utils.token2auth(r, this._roomConf.roomId, this._roomConf.userId, this._roomConf.token), sessionId: this._roomConf.sessionId, timestamp: Date.now(), controlMessage: this._roomConf.getLiveControlMessage(), userAttributes: { extra_info: this._roomConf.userInfo.extraInfo, role: o }, sdpInfo: c2, params: { supportedCodecs: l, userAgent: window.navigator.userAgent, sdkVersion: Config2.VERSION, deviceId: sdkCache.getDeviceId(), appId: r, roomId: this._roomConf.roomId, userId: this._roomConf.userId, businessId: n, enableCloudProxy: s, channelProfile: RoomProfileMap[this._roomConf.roomProfileType] ? "".concat(RoomProfileMap[this._roomConf.roomProfileType][0]) : "0", SDKCodecNegotiation: getParameter("SDK_CODEC_NEGOTIATION"), sdkType: "rtc", joinRoomMode: this._roomConf.isRTSOnlyRoom() ? 2 : 1, deviceType: "web", platformType: 2, rtsMode: this._ctx.rtsMode, mediaProcessingType: null !== (t = Config2.MEDIA_PROCESSING_TYPE) && void 0 !== t ? t : 0 }, options: { supportCheckTokenPrivilege: true, supportTokenExpireCallBack: true, enableSceneConfigV2: true, enableUnBundleMode: true, enableAudioMux: true, enableBigRoomMode: true, needNegotiateSDP: true, supportMultiVendor: true }, accessParams: JSON.stringify({ requireICEUfragV2: true }) };
    if ("AREA_CODE_US_OPCO" === getParameter("AREA_CODE") && (u.params.mediaArea = JSON.stringify([{ AreaList: ["GEO:US_OPCO"], Attribute: "include" }])), a) for (const [e2, t2] of Object.entries(a)) u.params[e2] = t2;
    d && (u.mediaParams = d);
    getParameter("SIGNAL_CROP_JOINROOM") && null !== (i = u.sdpInfo) && void 0 !== i && i.sdp && (u.sdpInfo.sdp = cropSdpMediaSection(u.sdpInfo.sdp)), Promise.resolve().then(() => this.emit("onSendingJoinMessageHook"));
    try {
      var h, _, p, m, S, g, v3, f;
      const t2 = e ? "reconnected" : "joinRoom", i2 = await this._joinRoomWithRetry(t2, u);
      this._logger.success("join", "send join message success");
      const { _abtest_vid: r2 } = i2.config || {};
      let { engine_WEB: o2 } = i2.config || {};
      var y, E, T;
      if (this._authorization = u.Authorization, sdkCache.setEngineWebConfig(this._ctx.appId, this._roomConf.roomId, o2), o2 = Object.assign({}, getParameter("ENGINE_WEB_CONFIG"), o2), this._ctx.serverConfig = { videoCodec: null === (h = o2) || void 0 === h ? void 0 : h.video_codec, audioRed: !(null === (_ = o2) || void 0 === _ || !_.pub_audio_red), muteReplaceUnsub: !(null === (p = i2.config) || void 0 === p || !p.mute_replace_unsub), simulcastOnDemand: !(false === (null === (m = i2.config) || void 0 === m || null === (m = m.engine_VPM) || void 0 === m || null === (m = m.ondemand) || void 0 === m ? void 0 : m.enable)), forceUniHandler: 1 === (null === (S = i2.config) || void 0 === S || null === (S = S.vendor_param) || void 0 === S ? void 0 : S.vendor_stream_sub_mode), e2eFeedback: null === (g = o2) || void 0 === g ? void 0 : g.e2e_feedback }, getParameter("SDK_CODEC_NEGOTIATION")) this._ctx.targetCodec = null === (y = i2.config) || void 0 === y ? void 0 : y.targetCodec, this._ctx.targetScreenCodec = null === (E = i2.config) || void 0 === E ? void 0 : E.targetScreenCodec;
      if ("boolean" == typeof (null === (v3 = o2) || void 0 === v3 ? void 0 : v3.av_sync) && (this._ctx.avSync = o2.av_sync), this._roomConf.rtcVid = r2, i2.vendorConfig && this._roomConf.setVendorConfig(i2.vendorConfig), AudioStallObserver.setAudioStallConfig(o2), null !== (f = i2.relayMessage) && void 0 !== f && f.sdp) null === (T = this._ctx.handler) || void 0 === T || T.createAVMlineAnswerTpl(i2.relayMessage.sdp);
      this.emit(RoomEvent.JOIN_SUCCESS, { joinRes: i2, reconnect: e }), this._joinRoomSuccess(i2);
    } catch (e2) {
      var b;
      null === (b = this._ctx.monitor) || void 0 === b || b.report("rtc_error", { message: "[join._callJoinRoom] ".concat(getErrorString(e2)), error_code: -1 });
      const t2 = { 461: ErrorCode.ROOM_FORBIDDEN, 462: ErrorCode.USER_FORBIDDEN };
      (null == e2 ? void 0 : e2.code) >= 700 && (null == e2 ? void 0 : e2.code) < 800 ? this._joinRoomFailed("token_error", ErrorCode.INVALID_TOKEN) : t2[null == e2 ? void 0 : e2.code] ? this._joinRoomFailed((null == e2 ? void 0 : e2.message) || t2[null == e2 ? void 0 : e2.code], t2[null == e2 ? void 0 : e2.code]) : (null == e2 ? void 0 : e2.code) === ErrorCode.TIME_OUT && this._ctx.joinRoomConfig.useTcpAfterJoinTimeout ? (this._logger.error("join", InternalReconnectReason.JOIN_TIMEOUT), this.safeEmit(RoomEvent.ON_REJOIN_WITH_TCP), this._ctx.signalingManager.reconnect(InternalReconnectReason.JOIN_TIMEOUT, true)) : e2.code === ErrorCode.OPERATION_CANCEL && this._ctx.signalingManager.isReconnecting() || this._joinRoomFailed((null == e2 ? void 0 : e2.message) || "signaling_error");
    }
  }
  _joinRoomWithRetry(e, t, i) {
    return new Promise((r, o) => {
      this._ctx.signalingManager.sendSignaling(e, t, this._roomConf.rtsOnlySignalHeader, 1e4).then((e2) => {
        this.emit("onJoinRoomAck", e2), r(e2);
      }).catch((n) => {
        if (i = i || new RetryLimiter(), n.code >= 500 && n.code < 600 && getServerNow() - i.initTs < 6e4) {
          const s = i.getRetryDelay();
          return this._logger.warn("_joinRoomWithRetry", "joinRoom failed(code: ".concat(n.code, "), will retry after ").concat(s, "ms")), void (this._joinRoom5xxTimer = setTimeout(() => {
            delete this._joinRoom5xxTimer, this._joinRoomWithRetry(e, t, i).then(r).catch(o);
          }, s));
        }
        o(n);
      });
    });
  }
  _stopJoinRoom5xxRetry() {
    this._joinRoom5xxTimer && (clearTimeout(this._joinRoom5xxTimer), delete this._joinRoom5xxTimer);
  }
  _reportJoinRoomStart() {
    this._joinTask && (this.emit("__joinRoomStartReport"), this._roomConf.report("join_room", { type: "begin", start: this._joinTask.startTime, result: false, reason: "" }, { enable_cloud_proxy: this._ctx.useCloudProxy, expectedIDC: this._ctx.expectedIDC }));
  }
  _joinRoomSuccess(e) {
    this._joinTask && (this._joinTask.success(e), this.emit("__joinRoomSuccessReport"), this._roomConf.report("join_room", { type: "end", start: this._joinTask.startTime, result: true, reason: "" }, { enable_cloud_proxy: this._ctx.useCloudProxy, expectedIDC: this._ctx.expectedIDC }), this._roomConf.report("rtc_join_room", { error_code: 0, deviceModel: "web", deviceManufacturer: "web", elapse: getServerNow() - this._joinTask.startTime }), delete this._joinTask, delete this._roomConf.joinPromise);
  }
  _joinRoomFailed(e, t) {
    this._joinTask && (this._joinTask.fail(new SDKError(t || ErrorCode.JOIN_ROOM_FAILED, e)), this.emit("__joinRoomFailedReport"), this._roomConf.report("join_room", { type: "end", start: this._joinTask.startTime, result: false, reason: e }, { enable_cloud_proxy: this._ctx.useCloudProxy, expectedIDC: this._ctx.expectedIDC }), delete this._joinTask, delete this._roomConf.joinPromise);
  }
};
_defineProperty(RoomJoin, "supportedCodecs", void 0);
var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorateClass$5 = (e, t, i, r) => {
  for (var o, n = r > 1 ? void 0 : r ? __getOwnPropDesc$5(t, i) : t, s = e.length - 1; s >= 0; s--) (o = e[s]) && (n = (r ? o(t, i, n) : o(n)) || n);
  return r && n && __defProp$5(t, i, n), n;
};
var RoomMessage = class {
  constructor(e, t) {
    _defineProperty(this, "_logger", void 0), this._ctx = e, this._roomConf = t, this._logger = new Logger$1("RoomMessage", 2, e.id);
  }
  sendUserMessage(e, t) {
    return this._ctx.signalingManager.sendP2PMessage({ to: e, from: this._roomConf.userId, room: this._roomConf.roomId, app: this._ctx.appId, msg: t });
  }
  async sendRoomMessage(e, t) {
    const i = { clientId: this._roomConf.userId, binary: t, message: "", roomId: this._roomConf.roomId };
    return i.message = t ? await Utils.ab2b64str(e) : e, this._ctx.signalingManager.sendSignaling("customMessage", i, this._roomConf.rtsOnlySignalHeader);
  }
  async controlMessage(e) {
    this._logger.info("controlMessage()", "params: %o", e);
    const t = e;
    "transcode" === e.type && (t.roomId = this._roomConf.roomId), await this._ctx.signalingManager.sendSignaling("controlMessage", t);
  }
};
__decorateClass$5([checkRoomState], RoomMessage.prototype, "sendUserMessage", 1), __decorateClass$5([checkRoomState], RoomMessage.prototype, "sendRoomMessage", 1), __decorateClass$5([checkRoomState], RoomMessage.prototype, "controlMessage", 1);
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorateClass$4 = (e, t, i, r) => {
  for (var o, n = r > 1 ? void 0 : r ? __getOwnPropDesc$4(t, i) : t, s = e.length - 1; s >= 0; s--) (o = e[s]) && (n = (r ? o(t, i, n) : o(n)) || n);
  return r && n && __defProp$4(t, i, n), n;
};
var virtualStreamAttributes = { audiostream: true, extaudio: false, extvideo: false, localaudio: true, localvideo: false, videoDescriptions: [], videostream: false, publishTime: 0 };
var Room = class extends EnhancedEventEmitter {
  constructor(e, t) {
    super(), _defineProperty(this, "_localStream", void 0), _defineProperty(this, "_localScreenStream", void 0), _defineProperty(this, "_remoteUsers", /* @__PURE__ */ new Map()), _defineProperty(this, "_remoteStreams", /* @__PURE__ */ new Map()), _defineProperty(this, "_remoteStreamStreamIdUserIdMap", {}), _defineProperty(this, "_remoteUserMediaBanned", /* @__PURE__ */ new Map()), _defineProperty(this, "_virtualStreams", []), _defineProperty(this, "_serverConfig", void 0), _defineProperty(this, "_userDuplicateLoginTimerMap", /* @__PURE__ */ new Map()), _defineProperty(this, "_networkQualityManager", void 0), _defineProperty(this, "_videoSizeObserver", void 0), _defineProperty(this, "_hasPublished", false), _defineProperty(this, "_subtitleTool", void 0), _defineProperty(this, "_csrcUserIdMap", {}), _defineProperty(this, "_publishOnDemandItem", void 0), _defineProperty(this, "_onceTriggerBySignal", false), _defineProperty(this, "_pubTransceiverReady", false), _defineProperty(this, "_publishOnDemandBusy", false), _defineProperty(this, "logger", void 0), _defineProperty(this, "_forwardStreamManager", void 0), _defineProperty(this, "_publisher", void 0), _defineProperty(this, "_subscriber", void 0), _defineProperty(this, "_roomJoin", void 0), _defineProperty(this, "_roomMessage", void 0), _defineProperty(this, "_clearSignalListeners", void 0), this.config = e, this._ctx = t, this.logger = new Logger$1("Room", 1, t.id), this.logger.info("constructor", "invoke"), this._publisher = new RoomPublisher(t, e), this._addPublisherListeners(), this._subscriber = new RoomSubscriber(t, e), this._addSubscriberListeners(), this._roomJoin = new RoomJoin(t, e), this._addJoinRoomHandler(), this._forwardStreamManager = new ForwardStreamManager(t, e), this._addForwardStreamListeners(), this._roomMessage = new RoomMessage(t, e), this._networkQualityManager = new NetworkQualityManager(t), this._networkQualityManager.reportor = this._reportNetworkQuality.bind(this), this._videoSizeObserver = new VideoSizeObserver(this), this._videoSizeObserver.onchange = this._emitVideoSizeChange.bind(this), this._addSignalListeners();
  }
  get remoteUsers() {
    return this._remoteUsers;
  }
  get remoteStreams() {
    return this._remoteStreams;
  }
  get localStream() {
    return this._localStream;
  }
  get localScreenStream() {
    return this._localScreenStream;
  }
  get virtualStreams() {
    return this._virtualStreams;
  }
  _addSignalListeners() {
    const e = { [SignalEvent.ON_ADD_STREAM]: this._onAddStream.bind(this), [SignalEvent.ON_ADD_STREAM_LIST]: (e2) => {
      e2 && Array.isArray(e2.streamList) && e2.streamList.forEach((e3) => this._onAddStream(e3));
    }, [SignalEvent.ON_REMOVE_STREAM]: this._onRemoveStream.bind(this), [SignalEvent.ON_REMOVE_STREAM_LIST]: (e2) => {
      e2 && Array.isArray(e2.streamList) && e2.streamList.forEach((e3) => this._onRemoveStream(e3));
    }, [SignalEvent.USER_CONNECTION]: this._onUserConnection.bind(this), [SignalEvent.USER_CONNECTION_LIST]: (e2) => {
      e2 && Array.isArray(e2.userList) && e2.userList.forEach((e3) => this._onUserConnection(e3));
    }, [SignalEvent.USER_DISCONNECTION]: this._onUserDisconnection.bind(this), [SignalEvent.USER_DISCONNECTION_LIST]: (e2) => {
      e2 && Array.isArray(e2.userList) && e2.userList.forEach((e3) => this._onUserDisconnection(e3));
    }, [SignalEvent.ON_UPDATE_ROOM_ATTRIBUTES]: this._onUpdateRoomAttributes.bind(this), [SignalEvent.ON_UPDATE_USER_ATTRIBUTES]: this._onUpdateUserAttributes.bind(this), [SignalEvent.ON_UPDATE_STREAM_ATTRIBUTES]: this._onUpdateStreamAttributes.bind(this), [SignalEvent.ON_PUSH_TRACK]: this._onPushTrack.bind(this), [SignalEvent.ON_REMOVE_TRACK]: this._onRemoveTrack.bind(this), [SignalEvent.ON_CUSTOM_MESSAGE]: this._onCustomMessage.bind(this), [SignalEvent.USER_MESSAGE_RECEIVED]: this._onUserMessageReceived.bind(this), [SignalEvent.USER_BINARY_MESSAGE_RECEIVED]: this._onUserBinaryMessageReceived.bind(this), [SignalEvent.POST_PROCESSING_MESSAGE]: this._onPostProcessingMessage.bind(this), [SignalEvent.ON_USER_TOKEN_WILL_EXPIRE]: this._onUserTokenWillExpire.bind(this), [SignalEvent.ON_TOKEN_PUBLISH_PRIVILEGE_WILL_EXPIRE]: this._onUserTokePublishPrivilegeWillExpire.bind(this), [SignalEvent.ON_TOKEN_PUBLISH_PRIVILEGE_DID_EXPIRED]: this._onUserTokenPublishPrivilegeDidExpire.bind(this), [SignalEvent.ON_TOKEN_SUBSCRIBE_PRIVILEGE_WILL_EXPIRE]: this._onUserTokeSubscribePrivilegeWillExpire.bind(this), [SignalEvent.ON_TOKEN_SUBSCRIBE_PRIVILEGE_DID_EXPIRED]: this._onUserTokenSubscribePrivilegeDidExpire.bind(this), [SignalEvent.STREAM_CONTROL_MESSAGE]: this._onStreamControlMessage.bind(this), [SignalEvent.ENGINE_CONTROL_MESSAGE]: this._onEngineControlMessage.bind(this), [SignalEvent.ON_STREAM_FAILED]: this._onStreamFailed.bind(this), [MediaServerSignalEvent.RTT]: this._onRTT.bind(this), [MediaServerSignalEvent.SSC]: this._onSSC.bind(this), [StateEvent.ON_CONNECTION_STATE_CHANGE]: this._onConnectionStateChange.bind(this), [SignalEvent.ON_SPEAKER_CHANGE]: this._onMeetingSpeakerChange.bind(this), [SignalEvent.ON_FORWARD_DST_ROOM_USER_KICK]: this._forwardStreamManager.onForwardDstRoomUserKick.bind(this._forwardStreamManager), [MediaServerSignalEvent.RSCP]: this._onRSCP.bind(this) };
    Object.keys(e).forEach((t) => {
      this._ctx.signalingManager.on(t, e[t]);
    }), this._clearSignalListeners = () => {
      Object.keys(e).forEach((t) => {
        this._ctx.signalingManager.off(t, e[t]);
      });
    };
  }
  _addPublisherListeners() {
    this._publisher.on(RoomEvent.PUB_RETRY, (e) => {
      this.emit(RoomEvent.PUB_RETRY, e);
    }), this._publisher.on(MediaServerSignalEvent.RSCP, this._onRSCP.bind(this)), this._publisher.on(StateEvent.ON_VENDOR_CONNECTION_STATE_CHANGE, (e) => this.emit(StateEvent.ON_VENDOR_CONNECTION_STATE_CHANGE, e));
  }
  _addSubscriberListeners() {
    this._subscriber.on(StateEvent.ON_VENDOR_CONNECTION_STATE_CHANGE, (e) => this.emit(StateEvent.ON_VENDOR_CONNECTION_STATE_CHANGE, e)), this._subscriber.on("onRemoteStreamStats", (e) => {
      this._networkQualityManager.updateDownlinkStats(e, this._findRemoteStreamByScreen(e.userId, e.isScreen)), getParameter("HIDDEN_STATS") || (e = getPublicStats(e)), this.emit(RoomEvent.ON_REMOTE_STREAM_STATS, e);
    }), this._subscriber.on(RoomEvent.RESUBSCRIBE, (e) => {
      this.emit(RoomEvent.RESUBSCRIBE, e);
    }), this._subscriber.on(RoomEvent.SUB_RETRY, (e) => {
      this.emit(RoomEvent.SUB_RETRY, e);
    });
  }
  _addJoinRoomHandler() {
    this._roomJoin.on(RoomEvent.JOIN_SUCCESS, this._onJoinSucc.bind(this)), this._roomJoin.on(RoomEvent.ON_REJOIN_WITH_TCP, () => {
      this.emit(RoomEvent.ON_REJOIN_WITH_TCP);
    });
  }
  _addForwardStreamListeners() {
    this._forwardStreamManager.on(RoomEvent.ON_FORWARD_STREAM_ERROR, (e) => {
      this.safeEmit(RoomEvent.ON_FORWARD_STREAM_ERROR, e);
    });
  }
  _onLocalStreamStats(e) {
    const t = e.isScreen ? this._localScreenStream : this.localStream;
    this._networkQualityManager.updateUplinkStats(e, t), getParameter("HIDDEN_STATS") || (e = getPublicStats(e)), this.emit(RoomEvent.ON_LOCAL_STREAM_STATS, e);
  }
  async join() {
    this.logger.info("join()"), this.config.startJoinTimestamp = getServerNow();
    try {
      var e;
      const t2 = await this._roomJoin.join();
      return this._ctx.callId = t2.callId, null !== (e = t2.roomAttributes) && void 0 !== e && e.multiChatMode && this._handleFFAudioTrack(), this._initSubtitleTool(), { users: t2.clients, streams: t2.streams };
    } catch (e2) {
      var t;
      if (null === (t = this._ctx.monitor) || void 0 === t || t.report("rtc_error", { message: "[room.join] ".concat(getErrorString(e2)), error_code: -1 }), e2.code !== ErrorCode.OPERATION_CANCEL) throw e2;
    }
  }
  async hasScreenPublished() {
    return !!this._localScreenStream && this._publisher.hasPublished(this._localScreenStream);
  }
  async hasPublished() {
    return !!this._localStream && this._publisher.hasPublished(this._localStream);
  }
  async publishScreen(e, t, i, r) {
    this.logger.info("publishScreen()"), this._localScreenStream || (this._localScreenStream = new LocalStream(this._ctx, StreamIndex$1.STREAM_INDEX_SCREEN), this.config.vendorConfig.enableMultiVendor && (this._localScreenStream.pcSessionId = genUuid$1()), this._localScreenStream.isScreen = true, this._localScreenStream.observer = new SendFrameObserver(this._ctx, this._localScreenStream));
    let o = false, n = false, s = false, a = false;
    !this._localScreenStream.videoTrack && e ? (e.sourceType === SourceType.EXTERNAL && (n = true), o = true) : this._localScreenStream.videoTrack && !e && (o = false), !this._localScreenStream.audioTrack && t ? (t.sourceType === SourceType.EXTERNAL && (a = true), s = true) : this._localScreenStream.audioTrack && !t && (s = false), this._localScreenStream.videoTrack = e, this._localScreenStream.audioTrack = t, i && (audioInMediaType(i) && (this._localScreenStream.pubAudio = r === PubState.PUB), videoInMediaType(i) && (this._localScreenStream.pubVideo = r === PubState.PUB), this.logger.info("publishScreen mediaType", "pubAudio: %o, pubVideo: %o", this._localScreenStream.pubAudio, this._localScreenStream.pubVideo));
    const d = await this._publisher.hasPublished(this._localScreenStream);
    if (!this._localScreenStream.pubAudio && !this._localScreenStream.pubVideo) return d ? this.unpublishScreen() : void 0;
    if (d) {
      var c2, l, u, h;
      if (n) null === (c2 = this._localScreenStream.observer) || void 0 === c2 || c2.setPushVideo(o);
      else null === (l = this._localScreenStream.observer) || void 0 === l || l.setEnableVideo(o);
      if (a) null === (u = this._localScreenStream.observer) || void 0 === u || u.setPushAudio(s);
      else null === (h = this._localScreenStream.observer) || void 0 === h || h.setEnableAudio(s);
      await this.updatePubScreenTrack();
    } else {
      var _;
      null === (_ = this._localScreenStream.observer) || void 0 === _ || _.setPublish(true), await this._publisher.publish(this._localScreenStream);
    }
    this._localScreenStream.pubAudio || this._localScreenStream.pubVideo ? this._ctx.handler && this._localScreenStream.startReport(this._onLocalStreamStats.bind(this), this._localScreenStream.vendorHandler || this._ctx.handler) : this._localScreenStream.stopReport("unpublish screen");
  }
  async updatePubScreenTrack() {
    this.logger.info("updatePubScreenTrack", "Invoke updatePubScreenTrack"), this._localScreenStream && await this._publisher.updatePubTrack(this._localScreenStream);
  }
  async unpublishScreen() {
    var e;
    (this.logger.info("unpublish", "Invoke unpublishScreen"), this._localScreenStream) && (null === (e = this._localScreenStream.observer) || void 0 === e || e.setPublish(false), await this._publisher.unpublish(this._localScreenStream), this._localScreenStream.stopReport("unpublish screen"), await this._publisher.cleanStream(this._localScreenStream), this._localScreenStream = void 0);
  }
  async liveControlMessage(e) {
    var t;
    this.logger.info("controlMessage", "Invoke controlMessage"), null === (t = e.transcodeMeta) || void 0 === t || t.layout.regions.forEach((e2) => {
      e2.roomID = this.config.roomId;
    }), this.config.setLiveControlMessage("stopped" === e.action ? void 0 : e);
    try {
      await this._roomMessage.controlMessage(e);
    } catch (t2) {
      if ("stopped" !== e.action) throw t2;
    }
  }
  async publicStreamControlMessage(e) {
    "stopped" === e.action && delete e.publicStreamMeta, await this._roomMessage.controlMessage(e);
  }
  getLocalStreamStats() {
    var e;
    return null === (e = this.localStream) || void 0 === e ? void 0 : e.getLocalStreamStats();
  }
  async updateUserAttributes() {
    this.logger.info("updateUserAttributes", "Invoke updateUserAttributes"), await this._subscriber.updateUserAttributes({ role: this._ctx.role });
  }
  async publish(e, t, i, r) {
    let o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    this.logger.info("publish", "Invoke publish");
    let n = false;
    this._localStream || (this._localStream = new LocalStream(this._ctx), this.config.vendorConfig.enableMultiVendor && (this._localStream.pcSessionId = genUuid$1()), this._localStream.observer = new SendFrameObserver(this._ctx, this._localStream), n = true, this._localStream.vendorCode = this.config.vendorConfig.vendorCode || 0), this._localStream.videoTrack = e, this._localStream.audioTrack = t;
    const { pubAudio: s, pubVideo: a } = this._localStream;
    i && (audioInMediaType(i) && (this._localStream.pubAudio = r === PubState.PUB), videoInMediaType(i) && (this._localStream.pubVideo = r === PubState.PUB), this.logger.info("publish mediaType", "pubAudio: %o, pubVideo: %o", this._localStream.pubAudio, this._localStream.pubVideo));
    if (await this._publisher.hasPublished(this._localStream)) try {
      this.emit("___onMediaServerClientPublish"), await this.updatePubTrack();
    } catch (e2) {
      throw this._localStream.pubAudio = s, this._localStream.pubVideo = a, e2;
    }
    else {
      if (!this._localStream.pubAudio && !this._localStream.pubVideo) return;
      try {
        var d;
        if (o) null === (d = this._localStream.observer) || void 0 === d || d.setLogin(true);
        else if (n) {
          var c2, l;
          const e2 = !!this._localStream.videoTrack, t2 = !!this._localStream.audioTrack, i2 = (null === (c2 = this._localStream.videoTrack) || void 0 === c2 ? void 0 : c2.sourceType) === SourceType.EXTERNAL, r2 = (null === (l = this._localStream.audioTrack) || void 0 === l ? void 0 : l.sourceType) === SourceType.EXTERNAL;
          if (this.config.isAutoPublish && !this._hasPublished) {
            var u, h, _, p;
            if (e2) if (i2) null === (u = this._localStream.observer) || void 0 === u || u.setPushVideo(true);
            else null === (h = this._localStream.observer) || void 0 === h || h.setEnableVideo(true);
            if (t2) if (r2) null === (_ = this._localStream.observer) || void 0 === _ || _.setPushAudio(true);
            else null === (p = this._localStream.observer) || void 0 === p || p.setEnableAudio(true);
          } else {
            var m;
            null === (m = this._localStream.observer) || void 0 === m || m.setPublish(true);
          }
        }
        this.emit("___onMediaServerClientPublish"), await this._publisher.publish(this._localStream), this._hasPublished = true, this.emit(RoomEvent.ON_PUBLISH_RESULT, { isScreen: false, state: PublishState.PUBLISH_SUCC });
      } catch (e2) {
        var S;
        throw null === (S = this._ctx.monitor) || void 0 === S || S.report("rtc_error", { message: "[room.publish] ".concat(getErrorString(e2)), error_code: -1 }), this.emit(RoomEvent.ON_PUBLISH_RESULT, { isScreen: false, state: PublishState.PUBLISH_FAIL, errorCode: e2.code }), delete this._localStream, e2;
      }
    }
    this._localStream.pubAudio || this._localStream.pubVideo ? this._ctx.handler && this._localStream.startReport(this._onLocalStreamStats.bind(this), this._localStream.vendorHandler || this._ctx.handler) : this._localStream.stopReport("unpublish");
  }
  async updatePubTrack() {
    if (this.logger.info("updatePubTrack", "Invoke updatePubTrack"), this._localStream) try {
      await this._publisher.updatePubTrack(this._localStream);
    } catch (t) {
      var e;
      throw null === (e = this._ctx.monitor) || void 0 === e || e.report("rtc_error", { message: "[room.updatePubTrack] ".concat(getErrorString(t)), error_code: -1 }), t;
    }
  }
  async unpublish() {
    if (this.logger.info("unpublish", "Invoke unpublish"), this._localStream) try {
      await this._publisher.unpublish(this._localStream), this._localStream.stopReport("unpublish"), await this._publisher.cleanStream(this._localStream), this._localStream = void 0;
    } catch (t) {
      var e;
      throw null === (e = this._ctx.monitor) || void 0 === e || e.report("rtc_error", { message: "[room.unpublish] ".concat(getErrorString(t)), error_code: -1 }), t;
    }
  }
  async subscribe(e, t) {
    this.logger.info("subscribe", "remoteStream %o", e);
    if (await this._subscriber.hasSubscribed(e)) {
      const i2 = e.subMediaType | t;
      return i2 !== e.subMediaType ? await this._subscriber.updateSubMediaType(e, i2) : void 0;
    }
    const i = this._ctx.videoProfile.getSubLayer(e, this.config.remoteVideoConfig);
    try {
      await this._subscriber.subscribe(e, t, i);
    } catch (e2) {
      var r;
      throw null === (r = this._ctx.monitor) || void 0 === r || r.report("rtc_error", { message: "[room.subscribe] ".concat(getErrorString(e2)), error_code: -1 }), e2;
    }
  }
  async updateSubVideoConfig(e) {
    var t;
    const i = this._findRemoteStreamByScreen(e, false);
    if (this.logger.info("updateSubVideoConfig", "userId %s", e), !i) return;
    if (!await this._subscriber.hasSubscribed(i) || (null === (t = i.attributes) || void 0 === t || null === (t = t.videoDescriptions) || void 0 === t ? void 0 : t.length) <= 1) return;
    const r = this._ctx.videoProfile.getSubLayer(i);
    return r ? (i.originalStreamIndex = r.spatialLayer, this._subscriber.updateSubTrackLayer(i, r)) : void 0;
  }
  async unsubscribe(e, t) {
    this.logger.info("unsubscribe", "Invoke unsubscribe");
    try {
      var i;
      if (!await this._subscriber.hasSubscribed(e)) return;
      const r2 = e.subMediaType - (e.subMediaType & t);
      if ((null === (i = this._ctx.serverConfig) || void 0 === i || !i.muteReplaceUnsub) && (r2 === ExtendMediaType.NONE || this.config.isMultiChatMode() && r2 === MediaType$1.AUDIO)) return await this._subscriber.unsubscribe(e);
      await this._subscriber.updateSubMediaType(e, r2);
    } catch (e2) {
      var r;
      throw null === (r = this._ctx.monitor) || void 0 === r || r.report("rtc_error", { message: "[room.unsubscribe] ".concat(getErrorString(e2)), error_code: -1 }), e2;
    }
  }
  async startSubtitle(e) {
    if (!this._subtitleTool) throw new SDKError(ErrorCode.INVOKED_BEFORE_JOIN_ROOM, "join first");
    await this._subtitleTool.start(e);
  }
  async updateSubtitleConfig(e) {
    if (!this._subtitleTool) throw new SDKError(ErrorCode.INVOKED_BEFORE_JOIN_ROOM, "join first");
    await this._subtitleTool.update(e);
  }
  async stopSubtitle() {
    var e;
    null === (e = this._subtitleTool) || void 0 === e || e.stop();
  }
  async startForwardStream2Rooms(e) {
    return this._forwardStreamManager.startForwardStream2Rooms(e);
  }
  async updateForwardStream2Rooms(e) {
    return this._forwardStreamManager.updateForwardStream2Rooms(e);
  }
  async stopForwardStream2Rooms() {
    return this._forwardStreamManager.stopForwardStream2Rooms();
  }
  async pauseForwardStream2AllRooms() {
    return this._forwardStreamManager.pauseForwardStream2AllRooms();
  }
  async resumeForwardStream2AllRooms() {
    return this._forwardStreamManager.resumeForwardStream2AllRooms();
  }
  async updateMediaParams(e) {
    return this._ctx.signalingManager.sendSignaling("updateMediaParams", { roomId: this.config.roomId, mediaParams: e });
  }
  async leave() {
    var e;
    let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    this.logger.info("leave", "Invoke leave"), null === (e = this._subtitleTool) || void 0 === e || e.destroy(), delete this._subtitleTool;
    try {
      for (const e2 of this._remoteStreams.values()) Array.isArray(e2) && e2.forEach((e3) => {
        var t2;
        null === (t2 = e3.observer) || void 0 === t2 || t2.setLogin(false);
      });
      var i;
      if (this._localStream) null === (i = this._localStream.observer) || void 0 === i || i.setLogin(false);
      await this._roomJoin.leave().catch(() => {
      }), this.destroy(), this.config.report("rtc_leave_room", { error_code: 0, message: "", elapse: this.config.getStayRoomDuration() });
    } catch (e2) {
      var r;
      if (null === (r = this._ctx.monitor) || void 0 === r || r.report("rtc_error", { message: "[room.leave] ".concat(getErrorString(e2)), error_code: -1 }), e2 instanceof Error && this.config.report("rtc_leave_room", { error_code: -1, message: e2.message, elapse: this.config.getStayRoomDuration() }), t) throw e2;
      this.destroy();
    }
  }
  updateRemoteUserPriority(e) {
    var t;
    null === (t = this.remoteStreams.get(e)) || void 0 === t || t.forEach((t2) => {
      const { userPriority: i } = this._ctx;
      t2.hasSubscribed && i.has(e) && this._subscriber.updateSubPriority(t2, i.get(e));
    });
  }
  destroy() {
    var e, t, i;
    this.logger.info("destroy", "Invoke destroy"), reportRtcInvokeStatus(this._ctx.id, "room_destroy", "".concat(new Error().stack)), null === (e = this._subtitleTool) || void 0 === e || e.destroy(), delete this._subtitleTool;
    const r = _flatInstanceProperty(t = Array.from(this._remoteStreams.values())).call(t);
    this._subscriber.destroy(r), this._subscriber.destroy(this._virtualStreams), this._publisher.destroy([this.localStream, this.localScreenStream]), this._roomJoin.destroy(), null === (i = this._clearSignalListeners) || void 0 === i || i.call(this), this._remoteUsers = /* @__PURE__ */ new Map(), this._remoteStreams = /* @__PURE__ */ new Map(), this._localStream && (this._localStream = void 0), this._localScreenStream && (this._localScreenStream = void 0), this._userDuplicateLoginTimerMap.forEach((e2) => {
      clearTimeout(e2);
    }), this._userDuplicateLoginTimerMap.clear(), this._networkQualityManager.destroy(), this._videoSizeObserver.destroy(), this._csrcUserIdMap = {}, this._virtualStreams = [], this._remoteStreamStreamIdUserIdMap = {}, this._forwardStreamManager.destoy(), this._remoteUserMediaBanned.clear();
  }
  async updateToken(e) {
    if (this.logger.info("updateToken", "Invoke updateToken"), this.config.token = e, !this.config.isRTSOnlyRoom()) try {
      await this._roomJoin.updateToken(e);
    } catch (e2) {
      throw this.safeEmit(RoomEvent.ON_ROOM_ERROR, { errorCode: ErrorCode.UPDATE_TOKEN_WITH_INVALID_TOKEN }), e2;
    }
  }
  sendUserMessage(e, t) {
    return this._ctx.rtsLimiter.e2e.check(t), this._roomMessage.sendUserMessage(e, t);
  }
  sendRoomMessage(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return this._ctx.rtsLimiter.boradcast.check(e), this._roomMessage.sendRoomMessage(e, t);
  }
  async maybeFillBackFrame2Stream(e) {
    var t;
    e.refreshBlackFrameLifetime(), null !== (t = e.videoTransceiver) && void 0 !== t && t.sender.track || this._publisher.updatePubBlackFrame(e);
  }
  _onJoinSucc(e) {
    var t, i;
    let { joinRes: r, reconnect: o } = e;
    this.logger.info("_onJoinSucc()", "invoke. ".concat(o ? "[reconnect]" : "")), this.emit(RoomEvent.JOIN_SUCCESS, o), this._serverConfig = r.config, this.config.updateRoomAttributes(r.roomAttributes);
    const n = [], s = [], a = [], d = [], c2 = [];
    this.config.isRTSOnlyRoom() && Array.isArray(r.userInfos) && (r.clientsDetail = r.userInfos.map((e2) => ({ clientId: e2.userId, clientJoinTime: e2.userJoinTime }))), null === (t = r.clientsDetail) || void 0 === t || t.forEach((e2) => {
      if (this._checkClientBanned(e2), e2.clientId === r.clientId) return;
      const t2 = this._remoteUsers.get(e2.clientId);
      t2 ? t2._stillExist = true : n.push(e2);
    });
    for (const e2 of this._remoteUsers.values()) e2._stillExist || s.push({ clientId: e2.userId }), delete e2._stillExist;
    null === (i = r.streams) || void 0 === i || i.forEach((e2) => {
      const t2 = this._findRemoteStreamByScreen(e2.clientId, e2.screen);
      this.config.updateUserPubInfo(e2), t2 ? (t2.stillExist = true, t2.streamId = e2.streamId, c2.push(e2)) : d.push(e2);
    });
    for (const e2 of this._remoteStreams.values()) Array.isArray(e2) && e2.forEach((e3) => {
      e3.stillExist ? delete e3.stillExist : a.push({ clientId: e3.userId, streamId: e3.streamId, message: RemoveStreamMessage.clientDisconnected });
    });
    s.forEach((e2) => this._onUserDisconnection(e2)), n.forEach((e2) => this._onUserConnection(e2)), a.forEach((e2) => this._onRemoveStream(e2)), d.forEach((e2) => this._onAddStream(e2, { fromSignal: false })), c2.forEach((e2) => this._onUpdateStreamAttributes(e2)), this.config.resetUserPubInfo(), o && this._handleSendOrRecvStreamAfterReconnect(), this.emit("__joinSuccess");
  }
  _handleSendOrRecvStreamAfterReconnect() {
    var e;
    this._localStream && (this._publisher.cleanStream(this._localStream).then(() => {
      var e2;
      this._localStream && (this._localStream.vendorCode = this.config.vendorConfig.vendorCode || 0, null === (e2 = this._localStream.observer) || void 0 === e2 || e2.setLogin(true));
    }), this._publisher.publish(this._localStream).then(() => {
      var e2;
      this._ctx.handler && (null === (e2 = this._localStream) || void 0 === e2 || e2.startReport(this._onLocalStreamStats.bind(this), this._localStream.vendorHandler || this._ctx.handler)), this.emit(RoomEvent.ON_PUBLISH_RESULT, { isScreen: false, state: PublishState.PUBLISH_SUCC, retry: true });
    }).catch((e2) => {
      this.logger.error("failed repub error:".concat(e2)), this.emit(RoomEvent.ON_PUBLISH_RESULT, { isScreen: false, state: PublishState.PUBLISH_FAIL, errorCode: e2.code, retry: true });
    })), this._localScreenStream && (this._publisher.cleanStream(this._localScreenStream).then(() => {
      var e2;
      this._localScreenStream && (null === (e2 = this._localScreenStream.observer) || void 0 === e2 || e2.setLogin(true));
    }), this._publisher.publish(this._localScreenStream).then(() => {
      var e2;
      this._ctx.handler && (null === (e2 = this._localScreenStream) || void 0 === e2 || e2.startReport(this._onLocalStreamStats.bind(this), this._localScreenStream.vendorHandler || this._ctx.handler)), this.emit(RoomEvent.ON_PUBLISH_RESULT, { isScreen: true, state: PublishState.PUBLISH_SUCC, retry: true });
    }).catch((e2) => {
      this.logger.error("failed repub screen stream error:".concat(e2)), this.emit(RoomEvent.ON_PUBLISH_RESULT, { isScreen: true, state: PublishState.PUBLISH_FAIL, errorCode: e2.code, retry: true });
    }));
    for (const e2 of this._remoteStreams.values()) Array.isArray(e2) && e2.forEach(async (e3) => {
      if (e3.hasSubscribed) {
        e3.resetHasSubscribed();
        try {
          var t, i;
          this.logger.info("start resubscribe ".concat(e3.userId, " with ").concat(e3.subMediaType)), videoInMediaType(e3.subMediaType) && (null === (t = e3.observer) || void 0 === t || t.setSubscribeVideo(true)), audioInMediaType(e3.subMediaType) && (null === (i = e3.observer) || void 0 === i || i.setSubscribeAudio(true)), await this._subscriber.subscribe(e3, e3.subMediaType), this.logger.info("success resubscribe ".concat(e3.userId, " with ").concat(e3.subMediaType)), this.safeEmit(RoomEvent.RESUBSCRIBE, { stream: e3 }), this.emit(RoomEvent.ON_SUBSCRIBE_RESULT, { state: SubscribeState.SUBSCRIBE_SUCC, userId: e3.userId, isScreen: e3.isScreen, retry: true });
        } catch (t2) {
          if (this.emit(RoomEvent.ON_SUBSCRIBE_RESULT, { state: SubscribeState.SUBSCRIBE_FAIL, userId: e3.userId, isScreen: e3.isScreen, errorCode: t2.code, retry: true }), this.logger.error("failed resubscribe ".concat(e3.userId, " with ").concat(e3.subMediaType, ", error:").concat(t2)), t2.code === ErrorCode.NOT_CONNECTED_YET) return void (e3.streamState = StreamState.SUB_ED);
          await this._subscriber.cleanStream(e3), e3.resetHasSubscribed();
        }
      }
    });
    null === (e = this._subtitleTool) || void 0 === e || e.reconnect(), this._forwardStreamManager.resumeFromReconnect();
  }
  _handleFFAudioTrack() {
    var e, t;
    const i = null === (e = this._ctx.handler) || void 0 === e ? void 0 : e.audioTrack4ff, r = null === (t = this._ctx.handler) || void 0 === t ? void 0 : t.getTransceivers();
    if (i && Array.isArray(r)) {
      const e2 = r.find((e3) => {
        var t2;
        return (null == e3 || null === (t2 = e3.receiver) || void 0 === t2 ? void 0 : t2.track) === i;
      });
      if (e2) {
        const t2 = new RemoteStream(this._ctx, "ff-stream", "ff-stream", false, false, virtualStreamAttributes);
        t2.virtual = true, t2.audioTransceiver = e2, t2.audioMid = "0", t2.audioTrack = createRemoteAudioTrack(this._ctx, i, { streamIndex: ExtendStreamIndex.VIRTUAL }), this._virtualStreams.push(t2), this.safeEmit(RoomEvent.SUBSCRIBE_PUSH_TRACK, { stream: t2 });
      }
    }
  }
  _findRemoteStream(e, t) {
    const i = this._remoteStreams.get(e);
    return Array.isArray(i) ? i.find((e2) => e2.streamId === t) : null;
  }
  _findRemoteStreamByScreen(e, t) {
    const i = this._remoteStreams.get(e);
    return Array.isArray(i) ? i.find((e2) => e2.isScreen === t) : null;
  }
  _onAddStream(e) {
    let { needEmit: t = true, fromSignal: i = true, virtual: r = false } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (e.clientId === this.config.userId) return;
    const { isAutoSubscribeAudio: o, isAutoSubscribeVideo: n } = this.config, s = this._findRemoteStreamByScreen(e.clientId, e.screen);
    if (s && s.streamId !== e.streamId) {
      var a;
      const t2 = null === (a = this._remoteStreams.get(e.clientId)) || void 0 === a ? void 0 : a.filter((e2) => e2.streamId !== s.streamId);
      this._subscriber.cleanStream(s), this._remoteStreams.set(e.clientId, t2 || []);
    }
    let d = this._findRemoteStream(e.clientId, e.streamId);
    if (this._remoteStreamStreamIdUserIdMap[e.streamId] = e.clientId, d) d.attributes = e.attributes;
    else if (d = new RemoteStream(this._ctx, e.clientId, e.streamId, e.screen, false, e.attributes), d.virtual = r, this._initStreamListeners(d), !r) {
      const t2 = this._remoteStreams.get(e.clientId);
      t2 ? t2.push(d) : this._remoteStreams.set(e.clientId, [d]);
    }
    if (d.remoteSessionId = e.remoteSessionId || "", d.observer = new RecvFrameObserver(this._ctx, d), !d.isScreen && n && !this._getRemoteUserMediaBanned(e.clientId, MediaType$1.VIDEO) && (i && d.hasVideo && (d.attributes.extvideo ? (d.observer.setExternalVideoSource(true), d.observer.setPushVideo(true)) : (d.observer.setExternalVideoSource(false), d.observer.setPublishVideo(true))), i && d.hasAudio && o && !this.config.isMultiChatMode() && !this._getRemoteUserMediaBanned(e.clientId, MediaType$1.AUDIO) && (d.attributes.extaudio ? (d.observer.setExternalAudioSource(true), d.observer.setPushAudio(true)) : (d.observer.setExternalAudioSource(false), d.observer.setPublishAudio(true))), t && !i)) {
      const { isAutoSubscribeAudio: e2, isAutoSubscribeVideo: t2 } = this.config;
      d.observer.setLogin(true, { audio: !!e2 && !this.config.isMultiChatMode(), video: !!t2 });
    }
    return t && this.safeEmit(SignalEvent.ON_ADD_STREAM, { stream: d }), d;
  }
  _onUserConnection(e) {
    var t;
    if (e.clientId === this.config.userId) return;
    const i = this._userDuplicateLoginTimerMap.get(e.clientId);
    if ("number" == typeof i) return this._userDuplicateLoginTimerMap.delete(e.clientId), void self.clearTimeout(i);
    const r = { userId: e.clientId, extraInfo: null === (t = e.attributes) || void 0 === t ? void 0 : t.extra_info };
    this._remoteUsers.set(e.clientId, _objectSpread2({}, r)), this.safeEmit(SignalEvent.USER_CONNECTION, { userInfo: r, publishState: this.config.getUserPubInfo(r.userId) }), this._checkClientBanned(e);
  }
  _onUserDisconnection(e) {
    let { clientId: t, tag: i, code: r, forbiddenTime: o } = e;
    if (t) if (t === this.config.userInfo.userId) {
      let e2 = null;
      i === UserDisconnectionTag.kickedByAdmin ? e2 = ErrorCode.KICKED_OUT : i === UserDisconnectionTag.onUserTokenDidExpire ? e2 = ErrorCode.TOKEN_EXPIRED : i === UserDisconnectionTag.userDuplicateLogin && (e2 = ErrorCode.DUPLICATE_LOGIN), r === UserDisconnectionCode.roomDismissByAdmin && (e2 = ErrorCode.ROOM_DISMISS), e2 && this.safeEmit(RoomEvent.ON_ROOM_ERROR, { errorCode: e2, forbiddenTime: o });
    } else {
      let e2 = UserOfflineReason.DROPPED;
      i === UserDisconnectionTag.userLeave ? e2 = UserOfflineReason.QUIT : i === UserDisconnectionTag.kickedByAdmin ? e2 = UserOfflineReason.KICKED_BY_ADMIN : i === UserDisconnectionTag.roleChanged && (e2 = UserOfflineReason.SWITCH_TO_INVISIBLE);
      const r2 = () => {
        var r3;
        this._remoteUsers.delete(t);
        const o2 = [];
        null === (r3 = this._remoteStreams.get(t)) || void 0 === r3 || r3.forEach((e3) => {
          o2.push(this._onRemoveStream({ clientId: e3.userId, streamId: e3.streamId, message: RemoveStreamMessage.clientDisconnected }));
        }), this._remoteStreams.delete(t), Promise.all(o2).finally(() => {
          this.safeEmit(RoomEvent.ON_USER_LEAVE, { userInfo: { userId: t }, reason: e2, tag: i });
        });
      };
      if (i === UserDisconnectionTag.userDuplicateLogin) {
        const e3 = this._userDuplicateLoginTimerMap.get(t);
        e3 && self.clearTimeout(e3);
        const i2 = self.setTimeout(r2, 5e3);
        this._userDuplicateLoginTimerMap.set(t, i2);
      } else r2();
    }
  }
  async _onRemoveStream(e) {
    if (e.clientId === this.config.userId) return;
    const t = this._remoteStreams.get(e.clientId);
    if (!t) return;
    const i = t.find((t2) => t2.streamId === e.streamId);
    if (!i) return;
    var r, o;
    i.hasVideo && (null === (r = i.observer) || void 0 === r || r.setPublishVideo(false));
    i.hasAudio && !this.config.isMultiChatMode() && (null === (o = i.observer) || void 0 === o || o.setPublishAudio(false));
    const n = t.filter((t2) => t2.streamId !== e.streamId);
    this._remoteStreams.set(e.clientId, n);
    const s = { isScreen: i.isScreen, userId: i.userId, streamId: i.streamId, attributes: { audiostream: i.attributes.audiostream, videostream: i.attributes.videostream } };
    try {
      await this._subscriber.handleRemoveStream(i);
    } catch (e2) {
      console.error(e2);
    }
    this.safeEmit(SignalEvent.ON_REMOVE_STREAM, { stream: s, reason: e.message });
  }
  _onUpdateUserAttributes(e) {
    this._checkClientBanned(e);
  }
  _onUpdateRoomAttributes(e) {
    var t;
    e.roomAttributes && (this.config.updateRoomAttributes(e.roomAttributes), this._ctx && (this._ctx.callId = e.roomAttributes.callId)), null !== (t = e.roomAttributes) && void 0 !== t && t.multiChatMode && this._handleFFAudioTrack();
  }
  _onUpdateStreamAttributes(e) {
    const { isAutoSubscribeAudio: t, isAutoSubscribeVideo: i } = this.config, { clientId: r, streamId: o, attributes: n } = e, s = this._findRemoteStream(r, o);
    if (!s) return;
    const a = s.attributes, d = _objectSpread2(_objectSpread2({}, a), n);
    let c2 = false;
    const l = d.localaudio !== a.localaudio;
    let u = false, h = false;
    const _ = d.localvideo !== a.localvideo;
    let p = false, m = ExtendMediaType.NONE, S = ExtendMediaType.NONE;
    if (d.audiostream !== a.audiostream && (c2 = d.localaudio, u = !!d.audiostream, d.audiostream ? m |= MediaType$1.AUDIO : S |= MediaType$1.AUDIO), d.videostream !== a.videostream && (h = d.localvideo, p = !!d.videostream, d.videostream ? m |= MediaType$1.VIDEO : S |= MediaType$1.VIDEO), m && this.safeEmit(RoomEvent.ON_USER_PUBLISH_STATE_CHANGE, { userId: r, mediaType: m, isScreen: s.isScreen, pubState: PubState.PUB, remoteStream: s }), S && this.safeEmit(RoomEvent.ON_USER_PUBLISH_STATE_CHANGE, { userId: r, mediaType: S, isScreen: s.isScreen, pubState: PubState.UNPUB, remoteStream: s }), s.remoteSessionId = e.remoteSessionId || "", s.attributes = d, d.localaudio !== a.localaudio) if (d.localaudio) {
      var g, v3, f, y;
      if ((t || s.subAudio) && d.audiostream) if (d.extaudio) null === (g = s.observer) || void 0 === g || g.setExternalAudioSource(true), null === (v3 = s.observer) || void 0 === v3 || v3.setPushAudio(true);
      else null === (f = s.observer) || void 0 === f || f.setExternalAudioSource(false), null === (y = s.observer) || void 0 === y || y.setEnableAudio(true);
      this.safeEmit(RoomEvent.ON_USER_START_AUDIO_CAPTURE, { userId: r }, s);
    } else {
      var E, T, b, I;
      if (d.extaudio) null === (E = s.observer) || void 0 === E || E.setExternalAudioSource(true), null === (T = s.observer) || void 0 === T || T.setPushAudio(false);
      else null === (b = s.observer) || void 0 === b || b.setExternalAudioSource(false), null === (I = s.observer) || void 0 === I || I.setEnableAudio(false);
      !s.isScreen && this.safeEmit(RoomEvent.ON_USER_STOP_AUDIO_CAPTURE, { userId: r });
    }
    if (d.localvideo !== a.localvideo) if (d.localvideo) {
      var R, C, P, A;
      if ((i || s.subVideo) && d.videostream) if (d.extvideo) null === (R = s.observer) || void 0 === R || R.setExternalVideoSource(true), null === (C = s.observer) || void 0 === C || C.setPushVideo(true);
      else null === (P = s.observer) || void 0 === P || P.setExternalVideoSource(false), null === (A = s.observer) || void 0 === A || A.setEnableVideo(true);
      this.safeEmit(RoomEvent.ON_USER_START_VIDEO_CAPTURE, { userId: r });
    } else {
      var O, k, N, w;
      if (d.extvideo) null === (O = s.observer) || void 0 === O || O.setExternalVideoSource(true), null === (k = s.observer) || void 0 === k || k.setPushVideo(false);
      else null === (N = s.observer) || void 0 === N || N.setExternalVideoSource(false), null === (w = s.observer) || void 0 === w || w.setEnableVideo(false);
      !s.isScreen && this.safeEmit(RoomEvent.ON_USER_STOP_VIDEO_CAPTURE, { userId: r });
    }
    var M, D;
    c2 && !l && t && (null === (M = s.observer) || void 0 === M || M.setRemoteUnmuteAudio(u));
    h && !_ && i && (null === (D = s.observer) || void 0 === D || D.setRemoteUnmuteVideo(p));
    "number" == typeof d.videoType && d.videoType !== a.videoType && this.safeEmit(RoomEvent.VIDEO_TYPE_CHANGE, { userId: s.userId, isScreen: s.isScreen, type: d.videoType === VideoType.BLACK ? SEIStreamEventType.BLACK : SEIStreamEventType.NORMAL });
  }
  _onPushTrack(e) {
    var t;
    if (null === (t = e.streamId) || void 0 === t || !t.startsWith("audio_mux")) return void this.config.report("rtc_error", { message: "onPushTrack, userId: ".concat(e.clientId, ", ").concat(e.streamId), error_code: RtcErrorCode.TRACK_ERROR });
    const i = this._onAddStream(_objectSpread2(_objectSpread2({}, e), {}, { attributes: virtualStreamAttributes }), { needEmit: false, fromSignal: false, virtual: true });
    i && this._subscriber.subscribe4pushTrack(i, e).then(() => {
      this.safeEmit(RoomEvent.SUBSCRIBE_PUSH_TRACK, { stream: i }), this._virtualStreams.push(i);
    }).catch((e2) => {
      this.logger.error("subscribe", "push track failed %o", e2);
    });
  }
  _onRemoveTrack(e) {
    let { clientId: t, streamId: i, message: r, trackType: o } = e;
    this.logger.info("_onRemoveTrack", "remove track: %o", t);
    const n = this._findRemoteStream(t, i);
    n && (n.removeTrack = true, this._subscriber.unsubscribe4removeTrack(n, r, o), this.emit(RoomEvent.REMOVE_PUSH_TRACK, { stream: n, mediaType: o + 1 }));
  }
  _onMeetingSpeakerChange(e) {
    if (Array.isArray(null == e ? void 0 : e.speakerCsrcInfo)) {
      const t = {};
      null == e || e.speakerCsrcInfo.forEach((e2) => {
        let { csrc: i, userId: r, isScreen: o } = e2;
        o || (t[i] = r);
      }), this._csrcUserIdMap = t;
    }
    Array.isArray(e.muxStreamInUse) && this._virtualStreams.forEach((t) => {
      var i;
      null !== (i = e.muxStreamInUse) && void 0 !== i && i.includes(t.streamId) ? t.virtualOccupy = true : t.virtualOccupy = false;
    });
  }
  getActiveSpeakerInMultiChatMode() {
    const e = [];
    return this._virtualStreams.forEach((t) => {
      var i;
      const r = null === (i = t.audioTransceiver) || void 0 === i ? void 0 : i.receiver;
      if (r) {
        const [t2] = r.getContributingSources() || [];
        if (t2) {
          const { audioLevel: i2, source: r2 } = t2;
          this._csrcUserIdMap[r2] && e.push({ userId: this._csrcUserIdMap[r2], audioLevel: i2 });
        }
      }
    }), e.length && _sortInstanceProperty(e).call(e, (e2, t) => e2.audioLevel - t.audioLevel), e;
  }
  _onReconnecting() {
    var e, t;
    for (const e2 of this._remoteStreams.values()) Array.isArray(e2) && e2.forEach((e3) => {
      var t2;
      null === (t2 = e3.observer) || void 0 === t2 || t2.setDisconnect(), this._subscriber.cleanStream(e3);
    });
    this._virtualStreams.forEach((e2) => {
      var t2;
      this.emit(RoomEvent.REMOVE_PUSH_TRACK, { stream: e2, mediaType: MediaType$1.AUDIO }), null === (t2 = e2.observer) || void 0 === t2 || t2.setDisconnect(), this._subscriber.cleanStream(e2);
    }), this._virtualStreams = [], null === (e = this.localStream) || void 0 === e || null === (e = e.observer) || void 0 === e || e.setDisconnect(), this._publisher.cleanStream(this.localStream), null === (t = this.localScreenStream) || void 0 === t || null === (t = t.observer) || void 0 === t || t.setDisconnect(), this._publisher.cleanStream(this.localScreenStream);
  }
  _onConnectionStateChange(e) {
    e.state === ConnectionState.CONNECTION_STATE_RECONNECTING ? this._onReconnecting() : e.state === ConnectionState.CONNECTION_STATE_RECONNECTED && this._roomJoin.join(true);
  }
  _initStreamListeners(e) {
    e.on("ontrack", (e2) => {
      e2.track;
    }), e.on("onSEIMessage", (t) => {
      this.emit(RoomEvent.ON_SEI_MESSAGED_RECEIVED, { sei: t, remoteStreamKey: { userId: e.userId, roomId: this.config.roomId, streamIndex: e.isScreen ? StreamIndex$1.STREAM_INDEX_SCREEN : StreamIndex$1.STREAM_INDEX_MAIN } });
    });
  }
  _onCustomMessage(e) {
    var t;
    null !== (t = this._subtitleTool) && void 0 !== t && t.onMessageRecv(e) || this.safeEmit(SignalEvent.ON_CUSTOM_MESSAGE, e);
  }
  _onUserMessageReceived(e) {
    this.safeEmit(SignalEvent.USER_MESSAGE_RECEIVED, { userId: e.from, message: e.msg });
  }
  _onUserBinaryMessageReceived(e) {
    var t;
    const i = { userId: e.from, message: e.msg };
    null !== (t = this._subtitleTool) && void 0 !== t && t.onMessageRecv(i) || this.safeEmit(SignalEvent.USER_BINARY_MESSAGE_RECEIVED, i);
  }
  _initSubtitleTool() {
    this._subtitleTool = new SubtitleTool(this._ctx, this.config), this._subtitleTool.onEvent = (e) => {
      this.emit(RoomEvent.ON_SUBTITLE_STATE_CHANGED, e);
    }, this._subtitleTool.onMessage = (e) => {
      this.emit(RoomEvent.ON_SUBTITLE_MESSAGE_RECEIVED, e);
    };
  }
  _onPostProcessingMessage(e) {
    if (!e.body) return;
    var t;
    if ("subtitleCallback" === e.type) return void (null === (t = this._subtitleTool) || void 0 === t || t.onResult(e));
    const i = e.body, r = i.error || 0;
    let o = StreamMixingEventType.START;
    const n = ["success", "parameter error", "subscription timeout", "ffmpeg error", "cdn error", "publish error"];
    if ("2.0" === i.protocol) {
      switch (i.eventType) {
        case "TranscodeStarted":
          0 !== i.error && (o = StreamMixingEventType.START_FAILED);
          break;
        case "TranscodeStateChanged":
          o = 0 !== i.error ? StreamMixingEventType.START_FAILED : StreamMixingEventType.START_SUCCESS;
          break;
        case "TranscodeStopped":
          o = 0 !== i.error ? StreamMixingEventType.STOP_FAILED : StreamMixingEventType.STOP_SUCCESS;
          break;
        case "TranscodeUpdated":
          o = 0 !== i.error ? StreamMixingEventType.UPDATE_FAILED : StreamMixingEventType.UPDATE_SUCCESS;
      }
      this.safeEmit(SignalEvent.POST_PROCESSING_MESSAGE, { code: r, protocol: i.protocol, error: i.error, eventType: o, message: n[r] });
    }
    this.safeEmit(SignalEvent.POST_PROCESSING_MESSAGE, { code: r, message: n[r], type: e.type });
  }
  _onUserTokenWillExpire() {
    this.safeEmit(SignalEvent.ON_USER_TOKEN_WILL_EXPIRE, null);
  }
  _onUserTokePublishPrivilegeWillExpire() {
    this.safeEmit(SignalEvent.ON_TOKEN_PUBLISH_PRIVILEGE_WILL_EXPIRE, null);
  }
  _onUserTokenPublishPrivilegeDidExpire() {
    this.safeEmit(SignalEvent.ON_TOKEN_PUBLISH_PRIVILEGE_DID_EXPIRED, null);
  }
  _onUserTokeSubscribePrivilegeWillExpire() {
    this.safeEmit(SignalEvent.ON_TOKEN_SUBSCRIBE_PRIVILEGE_WILL_EXPIRE, null);
  }
  _onUserTokenSubscribePrivilegeDidExpire() {
    this.safeEmit(SignalEvent.ON_TOKEN_SUBSCRIBE_PRIVILEGE_DID_EXPIRED, null);
  }
  async _onStreamFailed(e) {
    if ("publish" === e.type) {
      var t, i;
      let r;
      if ((null === (t = this.localStream) || void 0 === t ? void 0 : t.streamId) === e.streamId ? r = this.localStream : (null === (i = this.localScreenStream) || void 0 === i ? void 0 : i.streamId) === e.streamId && (r = this.localScreenStream), !r) return;
      await this._publisher.unpublish(r).catch(() => {
      }), await this._publisher.cleanStream(r), await this._publisher.publish(r).catch(() => {
      });
    } else if ("subscribe" === e.type) {
      const t2 = this._remoteStreamStreamIdUserIdMap[e.streamId], i2 = this._findRemoteStream(t2, e.streamId);
      i2 && (await this._subscriber.handleStreamFailed(i2), this.safeEmit(RoomEvent.RESUBSCRIBE, { stream: i2 }));
    }
  }
  _onStreamControlMessage(e) {
    var t, i;
    e.type === StreamControlType.PushLimitWarn && (null !== (t = this._localStream) && void 0 !== t && t.pubAudio || null !== (i = this._localStream) && void 0 !== i && i.pubVideo || this.unpublish());
  }
  async _onPublishOnDemand() {
    var e, t, i;
    if (this._publishOnDemandItem && !this._publishOnDemandBusy && false !== (null === (e = this._serverConfig) || void 0 === e || null === (e = e.engine_VPM) || void 0 === e || null === (e = e.ondemand) || void 0 === e ? void 0 : e.enable)) {
      if (null !== (t = this._localStream) && void 0 !== t && t.videoTransceiver) {
        this._publishOnDemandBusy = true;
        const e2 = this._publishOnDemandItem;
        this._publishOnDemandItem = void 0;
        const t2 = [], i2 = this._localStream.stream.id, { sender: r } = this._localStream.videoTransceiver, o = r.getParameters();
        if (reportRtcInvokeStatus(this._ctx.id, "sender.getParameters", JSON.stringify(o), 0, i2), Array.isArray(o.encodings) && Array.isArray(e2)) {
          const r2 = {};
          this.logger.info("_onPublishOnDemand exec", "usedDescriptions: %o", e2), e2.forEach((e3) => {
            var t3;
            if (null !== (t3 = e3.StreamIds) && void 0 !== t3 && t3.includes(i2)) {
              var o2, n2, s;
              const t4 = null !== (o2 = null === (n2 = e3.Metadata) || void 0 === n2 ? void 0 : n2.VideoIndex) && void 0 !== o2 ? o2 : 0;
              let i3 = 0;
              var a, d;
              if (null !== (s = this._ctx.serverConfig) && void 0 !== s && s.e2eFeedback) i3 = Math.max(...Object.keys(null !== (a = null === (d = e3.Metadata) || void 0 === d ? void 0 : d.VideoKbpsHist) && void 0 !== a ? a : {}).map((e4) => Number(e4)), 0);
              r2[t4] = { kbps: i3 };
            }
          });
          const n = [...this._localStream.pubAttributes.videoDescriptions];
          o.encodings = o.encodings.map((e3) => {
            if (e3.rid) {
              if (r2[e3.rid]) {
                var i3;
                e3.active = true;
                const t3 = null === (i3 = r2[e3.rid]) || void 0 === i3 ? void 0 : i3.kbps;
                t3 && (e3.maxBitrate = 1e3 * calculateKbps(e3.rid, t3, n));
              } else e3.active = false;
              const o3 = Number(e3.rid);
              t2[o3] = e3.active;
            } else {
              var o2;
              const t3 = null === (o2 = r2[0]) || void 0 === o2 ? void 0 : o2.kbps;
              t3 && (e3.maxBitrate = 1e3 * calculateKbps(void 0, t3, n));
            }
            return e3;
          }), this.config.report("rtc_invoke_status", { sdk_api_name: "onPublishOnDemand", message: JSON.stringify(o.encodings), error_code: 0, stream_id: i2, elapse: 0 }), this._ctx.videoProfile.activeSimStreams = t2;
        }
        this.logger.info("sender.setParameters()", JSON.stringify(o.encodings)), reportRtcInvokeStatus(this._ctx.id, "sender.setParameters", JSON.stringify(o), 0, i2), await r.setParameters(o), this._publishOnDemandBusy = false;
      } else if (null === (i = this._localStream) || void 0 === i || !i.videoTransceiver) return;
      this._onPublishOnDemand();
    }
  }
  _onRTT(e) {
    const { StreamIds: t, Metadata: i } = e;
    if (null != t && t.length && i) {
      const e2 = t[0];
      this._ctx.streamRTT[e2] = { audio: i.audio_rtt, video: i.video_rtt };
    }
  }
  _onRSCP(e, t) {
    !!e.find((e2) => {
      var t2, i;
      return null == e2 || null === (t2 = e2.StreamIds) || void 0 === t2 ? void 0 : t2.includes(null === (i = this._localStream) || void 0 === i || null === (i = i.stream) || void 0 === i ? void 0 : i.id);
    }) && (t ? this._pubTransceiverReady = true : this._onceTriggerBySignal = true, t && this._onceTriggerBySignal || (this._publishOnDemandItem = e), this._pubTransceiverReady && this._onPublishOnDemand());
  }
  _onSSC(e) {
    const { StreamIds: t, Metadata: i } = e, r = t[0], o = this._remoteStreamStreamIdUserIdMap[r], n = this._findRemoteStream(o, r), s = { userId: o, isScreen: !!n && n.isScreen, beforeVideoIndex: i.ssc_items[0].prev_layer_id, afterVideoIndex: i.ssc_items[0].cur_layer_id, beforeEnable: 0 !== i.ssc_items[0].prev_video_open, afterEnable: 0 !== i.ssc_items[0].cur_video_open, reason: i.ssc_items[0].change_reason };
    this.emit(RoomEvent.ON_SIMULCAST_SUBSCRIBE_FALLBACK, s);
  }
  _reportNetworkQuality(e, t) {
    this.emit(RoomEvent.ON_NETWORK_QUALITY, e, t);
  }
  _emitVideoSizeChange(e, t, i, r) {
    this.emit(RoomEvent.ON_REMOTE_VIDEO_SIZE_CHANGED, { roomId: this.config.roomId, userId: e, streamIndex: t ? StreamIndex$1.STREAM_INDEX_SCREEN : StreamIndex$1.STREAM_INDEX_MAIN }, { width: i, height: r });
  }
  async setAudioEncodeMaxBitrate(e, t) {
    const i = e === StreamIndex$1.STREAM_INDEX_MAIN ? this.localStream : this.localScreenStream;
    if (null != i && i.pubAudio) {
      var r;
      const e2 = null === (r = i.audioTransceiver) || void 0 === r ? void 0 : r.sender.getParameters();
      var o;
      if (reportRtcInvokeStatus(this._ctx.id, "sender.getParameters", JSON.stringify(e2), 0, i.streamId), null != e2 && e2.encodings.length) e2.encodings[0].maxBitrate = 1e3 * t, reportRtcInvokeStatus(this._ctx.id, "sender.setParameters", JSON.stringify(e2), 0, i.streamId), await (null === (o = i.audioTransceiver) || void 0 === o ? void 0 : o.sender.setParameters(e2));
    }
  }
  _onEngineControlMessage(e) {
    let { type: t, body: i } = e;
    if (t === EngineControlType.CHANGE_CODEC) {
      if (!getParameter("SDK_CODEC_NEGOTIATION")) return void this.logger.info("_onEngineControlMessage", "SDK_CODEC_NEGOTIATION is false, ignore");
      const { codec: e2, media: t2, streamId: s } = i;
      if (!t2 || "audio" === t2) return;
      const a = e2.split(",").map((e3) => _trimInstanceProperty(e3).call(e3).toUpperCase());
      let d;
      var r, o, n;
      if (this.logger.info("_onEngineControlMessage", "changeCodec to %s", e2), s) (null === (r = this.localStream) || void 0 === r ? void 0 : r.streamId) === s ? d = this.localStream : (null === (o = this.localScreenStream) || void 0 === o ? void 0 : o.streamId) === s && (d = this.localScreenStream), null === (n = d) || void 0 === n || n.setChangeCodecs(a);
      else "video" === t2 ? (d = this.localStream, this._ctx.targetCodec = a[0]) : "screen" === t2 && (d = this.localScreenStream, this._ctx.targetScreenCodec = a[0]);
      d && this.emit(RoomEvent.UPDATE_PUBLISH, { streamIndex: d.isScreen ? StreamIndex$1.STREAM_INDEX_SCREEN : StreamIndex$1.STREAM_INDEX_MAIN });
    }
  }
  _checkClientBanned(e) {
    let { clientId: t, attributes: i } = e;
    if (!i || !t) return;
    const { serverMuteAudio: r, serverMuteVideo: o } = i;
    if (o) {
      const e2 = 1 === o;
      this.safeEmit(RoomEvent.ON_VIDEO_STREAM_BANNED, { uid: t, banned: e2 }), this._setRemoteUserMediaBanned(t, MediaType$1.VIDEO, e2), this._maybeStartReceiveFirstFrameForServerMute(t, MediaType$1.VIDEO, e2);
    }
    if (r) {
      const e2 = 1 === r;
      this.safeEmit(RoomEvent.ON_AUDIO_STREAM_BANNED, { uid: t, banned: e2 }), this._setRemoteUserMediaBanned(t, MediaType$1.AUDIO, e2), this._maybeStartReceiveFirstFrameForServerMute(t, MediaType$1.AUDIO, e2);
    }
  }
  _setRemoteUserMediaBanned(e, t, i) {
    var r;
    let o = null !== (r = this._remoteUserMediaBanned.get(e)) && void 0 !== r ? r : 0;
    i ? o |= t : o &= ~t, this._remoteUserMediaBanned.set(e, o);
  }
  _getRemoteUserMediaBanned(e, t) {
    var i;
    return t & (null !== (i = this._remoteUserMediaBanned.get(e)) && void 0 !== i ? i : 0);
  }
  _maybeStartReceiveFirstFrameForServerMute(e, t, i) {
    var r;
    if (i) return;
    const o = null !== (r = this._remoteStreams.get(e)) && void 0 !== r ? r : [];
    for (const e2 of o) {
      var n, s;
      e2.isScreen || e2.attributes.localvideo && e2.subVideo && (null === (n = e2.observer) || void 0 === n || n.setExternalVideoSource(e2.attributes.extvideo), null === (s = e2.observer) || void 0 === s || s.setUnmuteVideo(true));
    }
  }
};
__decorateClass$4([checkRoomState], Room.prototype, "publishScreen", 1), __decorateClass$4([checkRoomState], Room.prototype, "updatePubScreenTrack", 1), __decorateClass$4([checkRoomState], Room.prototype, "unpublishScreen", 1), __decorateClass$4([checkRoomState], Room.prototype, "liveControlMessage", 1), __decorateClass$4([checkRoomState], Room.prototype, "publicStreamControlMessage", 1), __decorateClass$4([checkRoomState], Room.prototype, "updateUserAttributes", 1), __decorateClass$4([checkRoomState], Room.prototype, "publish", 1), __decorateClass$4([checkRoomState], Room.prototype, "updatePubTrack", 1), __decorateClass$4([checkRoomState], Room.prototype, "unpublish", 1), __decorateClass$4([checkRoomState], Room.prototype, "subscribe", 1), __decorateClass$4([checkRoomState], Room.prototype, "updateSubVideoConfig", 1), __decorateClass$4([checkRoomState], Room.prototype, "unsubscribe", 1), __decorateClass$4([checkRoomState], Room.prototype, "startSubtitle", 1), __decorateClass$4([checkRoomState], Room.prototype, "stopSubtitle", 1), __decorateClass$4([checkRoomState], Room.prototype, "startForwardStream2Rooms", 1), __decorateClass$4([checkRoomState], Room.prototype, "updateForwardStream2Rooms", 1), __decorateClass$4([checkRoomState], Room.prototype, "stopForwardStream2Rooms", 1), __decorateClass$4([checkRoomState], Room.prototype, "pauseForwardStream2AllRooms", 1), __decorateClass$4([checkRoomState], Room.prototype, "resumeForwardStream2AllRooms", 1), __decorateClass$4([checkRoomState], Room.prototype, "updateMediaParams", 1), __decorateClass$4([checkRoomState], Room.prototype, "updateRemoteUserPriority", 1), __decorateClass$4([checkRoomState], Room.prototype, "updateToken", 1), __decorateClass$4([checkRoomState], Room.prototype, "sendUserMessage", 1), __decorateClass$4([checkRoomState], Room.prototype, "sendRoomMessage", 1), __decorateClass$4([checkRoomState], Room.prototype, "maybeFillBackFrame2Stream", 1);
var isValidAudioFile = async (e, t) => {
  const i = new Audio(_URL.createObjectURL(new Blob([e], t)));
  try {
    return i.muted = true, await i.play(), i.pause(), true;
  } catch (e2) {
    return false;
  }
};
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorateClass$3 = (e, t, i, r) => {
  for (var o, n = r > 1 ? void 0 : r ? __getOwnPropDesc$3(t, i) : t, s = e.length - 1; s >= 0; s--) (o = e[s]) && (n = (r ? o(t, i, n) : o(n)) || n);
  return r && n && __defProp$3(t, i, n), n;
};
var AudioMixingManager = class {
  constructor(e, t) {
    _defineProperty(this, "_sharedAudioContext", new AudioContext()), _defineProperty(this, "_workletReady", void 0), _defineProperty(this, "_audioDestination", this._sharedAudioContext.createMediaStreamDestination()), _defineProperty(this, "_localGainNode", this._sharedAudioContext.createGain()), _defineProperty(this, "_bufferGainNode", this._sharedAudioContext.createGain()), _defineProperty(this, "_audioBufferSource", void 0), _defineProperty(this, "_localSource", void 0), _defineProperty(this, "_context", void 0), _defineProperty(this, "_failedAudioList", []), _defineProperty(this, "_startingIds", /* @__PURE__ */ new Map()), _defineProperty(this, "_revokeURLs", /* @__PURE__ */ new Set()), _defineProperty(this, "_audioFetchMap", /* @__PURE__ */ new Map()), _defineProperty(this, "_audioFetchConfig", /* @__PURE__ */ new Map()), _defineProperty(this, "mixingMap", /* @__PURE__ */ new Map()), _defineProperty(this, "resourcesCache", /* @__PURE__ */ new Map()), _defineProperty(this, "volumeConfig", /* @__PURE__ */ new Map()), _defineProperty(this, "cachedBuffer", []), _defineProperty(this, "id", "AudioMixingManager"), this.engineId = t, this._context = e;
    try {
      var i, r;
      this._workletReady = null === (i = this._sharedAudioContext.audioWorklet) || void 0 === i || null === (r = i.addModule) || void 0 === r ? void 0 : r.call(i, dumpAudioDataWorklet), this._workletReady.catch(() => {
        this._workletReady = null;
      });
    } catch (e2) {
      this._workletReady = null;
    }
    this._localGainNode.gain.value = 1;
  }
  mixMediaStream(e) {
    this._localSource && this._localSource.disconnect(this._localGainNode), this._localSource = this._sharedAudioContext.createMediaStreamSource(e), this._localSource.connect(this._localGainNode).connect(this._audioDestination);
  }
  async startAudioMixing(e, t, i) {
    if (void 0 !== this._startingIds.get(e)) return void console.warn("AudioMixing task id: ".concat(e, " is starting"));
    this._startingIds.set(e, e);
    const { playCount: r, type: o } = i;
    checkEnum(o, "mixingType", values2(AudioMixingType));
    const n = this._context.getLocalAudioTrack();
    if (!n) return;
    const s = n.preprocessingTrack;
    s && this.mixMediaStream(new MediaStream([s])), n.once("needReplaceTrack", () => {
      this.mixMediaStream(new MediaStream([n.preprocessingTrack]));
    });
    const a = this.mixingMap.get(e);
    if (null != a && a.audioNode) {
      a.audioNode.pause(), this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_STOPPED, error: AudioMixingError.AUDIO_MIXING_ERROR_OK });
      try {
        a.gainNode.disconnect(this._audioDestination), a.audioSource.disconnect(a.gainNode);
      } catch (e2) {
      }
    }
    let d;
    const c2 = this.resourcesCache.get(e);
    if (c2 && c2.filePath === t) d = c2.getAudioNode();
    else {
      const i2 = await fetch(t, { mode: "cors" }).then((t2) => {
        if (t2.ok) return t2.arrayBuffer();
        throw this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_FAILED, error: AudioMixingError.AUDIO_MIXING_ERROR_START_FAILED }), this._startingIds.delete(e), this.mixingMap.delete(e), new SDKError(ErrorCode.LOAD_RESOURCES_FAILED, t2.statusText);
      });
      let r2;
      t.endsWith("mp3") ? r2 = { type: "audio/mpeg" } : t.endsWith("aac") && (r2 = { type: "audio/aac" });
      if (!await isValidAudioFile(i2, r2)) throw this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_FAILED, error: AudioMixingError.AUDIO_MIXING_ERROR_START_FAILED }), this._startingIds.delete(e), this.mixingMap.delete(e), new SDKError(ErrorCode.LOAD_RESOURCES_FAILED, "invalid audio resource");
      d = new Audio(), d.crossOrigin = "anonymous", d.src = _URL.createObjectURL(new Blob([i2], r2));
    }
    if (r <= 0) d.loop = true;
    else if (r > 0) {
      let t2 = r;
      d.onended = () => {
        --t2 > 0 ? d.play() : (this.mixingMap.delete(e), this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_FINISHED, error: AudioMixingError.AUDIO_MIXING_ERROR_OK }));
      };
    }
    try {
      await d.play();
    } catch (e2) {
      console.error(e2), this._failedAudioList.push(d), this._context.onAutoPlayFailed({ userId: this.id, kind: "audio", streamIndex: StreamIndex$1.STREAM_INDEX_MAIN, mediaType: MediaType$1.AUDIO });
    }
    this._startingIds.delete(e);
    const l = this._sharedAudioContext.createMediaElementSource(d), u = this._sharedAudioContext.createGain(), h = this.volumeConfig.get(e);
    if (u.gain.value = h ? h / 100 : 1, l.connect(u).connect(this._audioDestination), this.mixingMap.set(e, { audioSource: l, audioNode: d, gainNode: u, type: "file" }), o === AudioMixingType.PUBLISH) try {
      u.disconnect(this._sharedAudioContext.destination);
    } catch (e2) {
    }
    else u.connect(this._sharedAudioContext.destination);
    this._context.updateLocalAudioTrack(this._audioDestination.stream.getAudioTracks()[0], i.type), this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_PLAYING, error: AudioMixingError.AUDIO_MIXING_ERROR_OK }), this.updateFetcher(e);
  }
  stopAudioMixing(e) {
    const t = this.mixingMap.get(e);
    t && "file" === t.type && (this.mixingMap.delete(e), t.audioNode.pause(), t.audioSource.disconnect(t.gainNode), t.gainNode.disconnect(this._audioDestination), this.updateFetcher(e), this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_STOPPED, error: AudioMixingError.AUDIO_MIXING_ERROR_OK }));
  }
  pauseAudioMixing(e) {
    const t = this.mixingMap.get(e);
    t && (this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_PAUSED, error: AudioMixingError.AUDIO_MIXING_ERROR_OK }), t.audioNode.pause());
  }
  resumeAudioMixing(e) {
    const t = this.mixingMap.get(e);
    t && (this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_PLAYING, error: AudioMixingError.AUDIO_MIXING_ERROR_OK }), t.audioNode.play());
  }
  async preloadAudioMixing(e, t) {
    this.stopAudioMixing(e);
    const i = await fetch(t, { mode: "cors" }).then((e2) => {
      if (e2.ok) return e2.arrayBuffer();
      throw new SDKError(ErrorCode.LOAD_RESOURCES_FAILED, e2.statusText);
    }).catch((t2) => {
      if (this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_FAILED, error: AudioMixingError.AUDIO_MIXING_ERROR_PRELOAD_FAILED }), t2 instanceof SDKError) throw t2;
      throw new SDKError(ErrorCode.LOAD_RESOURCES_FAILED, "Load resources failed", t2);
    });
    let r;
    t.endsWith("mp3") ? r = { type: "audio/mpeg" } : t.endsWith("aac") && (r = { type: "audio/aac" });
    if (!await isValidAudioFile(i, r)) throw this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_FAILED, error: AudioMixingError.AUDIO_MIXING_ERROR_PRELOAD_FAILED }), new SDKError(ErrorCode.LOAD_RESOURCES_FAILED, "Load resources failed");
    this._context.emitMessage({ mixId: e, state: AudioMixingState.AUDIO_MIXING_STATE_PRELOADED, error: AudioMixingError.AUDIO_MIXING_ERROR_OK }), this.resourcesCache.set(e, { getAudioNode: () => {
      const e2 = _URL.createObjectURL(new Blob([i], r));
      return this._revokeURLs.add(e2), new Audio(e2);
    }, filePath: t, duration: 0 }), await new Promise((t2) => {
      const o = _URL.createObjectURL(new Blob([i], r)), n = new Audio(o);
      n.addEventListener("durationchange", () => {
        const i2 = this.resourcesCache.get(e);
        i2 && (i2.duration = n.duration, this.resourcesCache.set(e, i2)), _URL.revokeObjectURL(o), t2(null);
      });
    });
  }
  unloadAudioMixing(e) {
    this.resourcesCache.has(e) && this.resourcesCache.delete(e);
  }
  getAudioMixingVolume(e) {
    const t = this.mixingMap.get(e);
    return t ? 100 * t.gainNode.gain.value : 0;
  }
  setAudioMixingVolume(e, t) {
    t < 0 ? t = 0 : t > 400 && (t = 400), this.volumeConfig.set(e, t);
    const i = this.mixingMap.get(e);
    i && (i.gainNode.gain.value = Number(t) / 100);
  }
  getAudioMixingDuration(e) {
    const t = this.mixingMap.get(e), i = this.resourcesCache.get(e);
    return t || i ? t ? 1e3 * t.audioNode.duration : i ? 1e3 * i.duration : 0 : 0;
  }
  getAudioMixingCurrentPosition(e) {
    const t = this.mixingMap.get(e);
    return t ? 1e3 * t.audioNode.currentTime : 0;
  }
  setAudioMixingPosition(e, t) {
    const i = this.mixingMap.get(e);
    i && (i.audioNode.currentTime = t / 1e3, i.audioNode.play());
  }
  setAudioFrameCallback(e, t) {
    var i;
    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4096;
    if (checkEnum(r, "frameSize", [256, 512, 1024, 2048, 4096, 8192, 16384]), r = null !== (i = r) && void 0 !== i ? i : 4096, null === this._workletReady) throw new SDKError(ErrorCode.NOT_SUPPORTED, "Not support AudioWorklet");
    t ? this._audioFetchConfig.set(e, { callback: t, frameSize: r }) : this._audioFetchConfig.delete(e), this.updateFetcher(e);
  }
  updateFetcher(e) {
    var t, i;
    const { callback: r, frameSize: o } = null !== (t = this._audioFetchConfig.get(e)) && void 0 !== t ? t : {}, n = null === (i = this.mixingMap.get(e)) || void 0 === i ? void 0 : i.gainNode;
    if (n && r && o) {
      let t2 = this._audioFetchMap.get(e);
      t2 ? t2.setFrameSize(o) : t2 = new AudioDataFetcher(n, o, this._sharedAudioContext, this._workletReady), t2.on("data", r), this._audioFetchMap.set(e, t2);
    } else {
      const t2 = this._audioFetchMap.get(e);
      null == t2 || t2.removeAllListeners("data"), null == t2 || t2.destroy(), this._audioFetchMap.delete(e);
    }
  }
  enableAudioMixingBuffer(e) {
    checkEnum(e, "type", values2(AudioMixingType));
    const t = this._context.getLocalAudioTrack();
    if (!t) return;
    const i = t.preprocessingTrack;
    if (i && this.mixMediaStream(new MediaStream([i])), e === AudioMixingType.PUBLISH) try {
      this._bufferGainNode.disconnect(this._sharedAudioContext.destination);
    } catch (e2) {
    }
    else this._bufferGainNode.connect(this._sharedAudioContext.destination);
    this._context.updateLocalAudioTrack(this._audioDestination.stream.getAudioTracks()[0], e), this._bufferGainNode.connect(this._audioDestination), this._context.emitMessage({ mixId: -1, state: AudioMixingState.AUDIO_MIXING_STATE_PCM_ENABLED, error: AudioMixingError.AUDIO_MIXING_ERROR_OK });
  }
  disableAudioMixingBuffer() {
    if (this.cachedBuffer = [], this._audioBufferSource) {
      try {
        this._audioBufferSource.onended = null, this._audioBufferSource.disconnect(this._bufferGainNode), this._bufferGainNode.disconnect(this._audioDestination), this._bufferGainNode.disconnect(this._sharedAudioContext.destination);
      } catch (e) {
      } finally {
        this._audioBufferSource = void 0;
      }
      this._context.updateLocalAudioTrack(), this._context.emitMessage({ mixId: -1, state: AudioMixingState.AUDIO_MIXING_STATE_PCM_DISABLED, error: AudioMixingError.AUDIO_MIXING_ERROR_OK });
    }
  }
  pushAudioMixingBuffer(e) {
    if (!(this._audioBufferSource && (this.cachedBuffer.push(e), this.cachedBuffer.length > 0))) {
      this._audioBufferSource = this._sharedAudioContext.createBufferSource(), this._audioBufferSource.buffer = e, this._audioBufferSource.connect(this._bufferGainNode);
      try {
        this._audioBufferSource.start();
      } catch (e2) {
        this._failedAudioList.push(this._audioBufferSource);
      }
      this._audioBufferSource.onended = () => {
        var e2;
        if (null === (e2 = this._audioBufferSource) || void 0 === e2 || e2.disconnect(this._bufferGainNode), this._audioBufferSource = void 0, this.cachedBuffer.length) {
          const e3 = this.cachedBuffer.shift();
          e3 && this.pushAudioMixingBuffer(e3);
        }
      };
    }
  }
  stopAll() {
    if (this._localSource) try {
      this._localSource.disconnect(this._localGainNode), delete this._localSource;
    } catch (e) {
    }
    this.mixingMap.forEach((e, t) => {
      this.stopAudioMixing(t);
    });
  }
  get mixTrack() {
    return this._audioDestination.stream.getAudioTracks()[0];
  }
  get sharedAudioContext() {
    return this._sharedAudioContext;
  }
  async resumeLocalPlay() {
    const e = [];
    for (const t of this._failedAudioList) try {
      t instanceof HTMLAudioElement ? (t.muted = false, await t.play()) : t.start();
    } catch (i) {
      e.push(t), console.error(i), this._context.onAutoPlayFailed({ userId: this.id, kind: "audio", streamIndex: StreamIndex$1.STREAM_INDEX_MAIN, mediaType: MediaType$1.AUDIO });
      break;
    }
    this._failedAudioList = e;
  }
  destroy() {
    const { _sharedAudioContext: e } = this;
    "closed" !== e.state && "function" == typeof e.close && e.close(), this.cachedBuffer = [], this.mixingMap.clear(), this.resourcesCache.clear(), this.volumeConfig.clear(), this._startingIds = /* @__PURE__ */ new Map(), this._revokeURLs.forEach((e2) => {
      _URL.revokeObjectURL(e2);
    });
  }
};
__decorateClass$3([reportRtcSdkApi(["id", "filePath", "options"])], AudioMixingManager.prototype, "startAudioMixing", 1), __decorateClass$3([reportRtcSdkApi(["id"])], AudioMixingManager.prototype, "stopAudioMixing", 1), __decorateClass$3([reportRtcSdkApi(["id"])], AudioMixingManager.prototype, "pauseAudioMixing", 1), __decorateClass$3([reportRtcSdkApi(["id"])], AudioMixingManager.prototype, "resumeAudioMixing", 1), __decorateClass$3([reportRtcSdkApi(["id"])], AudioMixingManager.prototype, "preloadAudioMixing", 1), __decorateClass$3([reportRtcSdkApi(["id"])], AudioMixingManager.prototype, "unloadAudioMixing", 1), __decorateClass$3([reportRtcSdkApi(["id"])], AudioMixingManager.prototype, "getAudioMixingVolume", 1), __decorateClass$3([reportRtcSdkApi(["id", "volume"])], AudioMixingManager.prototype, "setAudioMixingVolume", 1), __decorateClass$3([reportRtcSdkApi(["id"])], AudioMixingManager.prototype, "getAudioMixingDuration", 1), __decorateClass$3([reportRtcSdkApi(["id"])], AudioMixingManager.prototype, "getAudioMixingCurrentPosition", 1), __decorateClass$3([reportRtcSdkApi(["id", "position"])], AudioMixingManager.prototype, "setAudioMixingPosition", 1), __decorateClass$3([reportRtcSdkApi(["id", "callback", "frameSize"])], AudioMixingManager.prototype, "setAudioFrameCallback", 1), __decorateClass$3([reportRtcSdkApi(["type"])], AudioMixingManager.prototype, "enableAudioMixingBuffer", 1), __decorateClass$3([reportRtcSdkApi()], AudioMixingManager.prototype, "disableAudioMixingBuffer", 1), __decorateClass$3([reportRtcSdkApi(["buffer"])], AudioMixingManager.prototype, "pushAudioMixingBuffer", 1);
var RTSClient = class extends eventemitter3Exports.EventEmitter {
  constructor(e) {
    super(), _defineProperty(this, "_loginSessionId", null), _defineProperty(this, "_userId", null), _defineProperty(this, "_token", null), _defineProperty(this, "_loginResolveCallback", void 0), _defineProperty(this, "_loginRejectCallback", void 0), _defineProperty(this, "_waitLoginToken", false), _defineProperty(this, "_serverParamsCache", void 0), _defineProperty(this, "id", void 0), _defineProperty(this, "logger", void 0), _defineProperty(this, "_clearListeners", void 0), this._ctx = e, this.id = e.id, this.logger = new Logger$1("RTSClient", 1, e.id);
  }
  login(e, t) {
    return new Promise((i, r) => {
      var o;
      if (this.logger.info("login", "invoke login, token: %o, userId: %o", e, t), this._loginSessionId) throw new SDKError(ErrorCode.ALREADY_LOGIN, "Already logined");
      if (this._loginResolveCallback) throw new SDKError(ErrorCode.LOGIN_FAILED, "Is logging in, please try again later.");
      this._userId = t, this._token = e, null === (o = getMonitor(this.id)) || void 0 === o || o.set({ rtm_user_id: t }), this._loginResolveCallback = i, this._loginRejectCallback = r, this._ctx.signalingManager.connect().then(() => {
        this._addSignalEventHandler(), this._login();
      });
    });
  }
  async logout() {
    if (!this._loginSessionId || !this._userId) throw new SDKError(ErrorCode.NOT_LOGIN, "login first");
    this._checkNotInLimitMode("logout"), await this._ctx.signalingManager.sendSignaling("logout", { loginSessionId: this._loginSessionId, userId: this._userId, appId: this._ctx.appId }, { functionType: SIGNALING_FUNCTION_TYPE.C2RTM }).catch(() => {
    }), this._clearState();
  }
  async updateLoginToken(e) {
    return this._checkNotInLimitMode("updateLoginToken"), this._token = e, new Promise((e2, t) => {
      this._waitLoginToken ? (this._loginResolveCallback = e2, this._loginRejectCallback = t, this._login()) : e2();
    });
  }
  async getPeerOnlineStatus(e) {
    if (!this._loginSessionId || !this._userId) throw new SDKError(ErrorCode.NOT_LOGIN, "login first");
    this._checkNotInLimitMode("getPeerOnlineStatus");
    const t = await this._ctx.signalingManager.sendSignaling("getPeerOnlineStatus", { loginSessionId: this._loginSessionId, userId: this._userId, appId: this._ctx.appId, peerUserId: e }, { functionType: SIGNALING_FUNCTION_TYPE.C2RTM });
    return null == t ? void 0 : t.status;
  }
  async sendUserMessageOutsideRoom(e, t) {
    if (!this._loginSessionId || !this._userId) throw new SDKError(ErrorCode.NOT_LOGIN, "login first");
    return this._checkNotInLimitMode("sendUserMessageOutsideRoom"), this._ctx.rtsLimiter.e2e.check(t), this._ctx.signalingManager.sendP2PMessage({ from: this._userId, app: this._ctx.appId, to: e, room: "", msg: t });
  }
  async setRTSMessageLimit(e) {
    e && this._ctx.signalingManager.sendSignaling("RTSMessageLimit", { appId: this._ctx.appId, interval: e.rts_qps_interval, broadcast: e.rts_broadcast_qps_value, one2one: e.rts_e2e_qps_value, e2bs: e.rts_e2s_qps_value }, { functionType: SIGNALING_FUNCTION_TYPE.C2RTM }).catch(() => {
    });
  }
  async setServerParams(e, t) {
    try {
      if (checkString(e, "signature"), checkString(t, "url"), !this._loginSessionId || !this._userId) throw new SDKError(ErrorCode.NOT_LOGIN, "login first");
      await this._ctx.signalingManager.sendSignaling("setServerParams", { loginSessionId: this._loginSessionId, userId: this._userId, appId: this._ctx.appId, signature: e, url: t }, { functionType: SIGNALING_FUNCTION_TYPE.C2RTM }).catch((e2) => {
        throw new SDKError(ErrorCode.UNEXPECTED_ERROR, e2.msg);
      }), RTSMsgReportor.setServerUrl(this.id, t), this._serverParamsCache = { signature: e, url: t }, this.emit("onServerParamsSetResult");
    } catch (e2) {
      throw this.emit("onServerParamsSetResult", e2), e2;
    }
  }
  async sendServerMessage(e) {
    if (!this._loginSessionId || !this._userId) throw new SDKError(ErrorCode.NOT_LOGIN, "login first");
    return this._checkNotInLimitMode("sendServerMessage"), this._ctx.rtsLimiter.e2s.check(e), this._ctx.signalingManager.sendP2PMessage({ from: this._userId, app: this._ctx.appId, to: "", room: "", type: DC_MESSAGE_FUNCTION_TYPE.BUSINESS_SERVER, msg: e });
  }
  destroy() {
    this.logger.info("destroy", "invoke."), super.removeAllListeners(), this._loginResolveCallback && this._loginRejectCallback && (this._loginRejectCallback(new SDKError(ErrorCode.LOGIN_FAILED, "logout")), delete this._loginResolveCallback, delete this._loginRejectCallback), this._clearState(), delete this._serverParamsCache;
  }
  _login() {
    var e;
    if (!this._userId) return;
    const t = genUuid();
    try {
      this._checkNotInLimitMode("login");
    } catch (e2) {
      var i;
      null === (i = this._loginRejectCallback) || void 0 === i || i.call(this, e2);
    }
    this._ctx.signalingManager.sendSignaling("login", { Token: Utils.token2auth(this._ctx.appId, null, this._userId, this._token), timestamp: Date.now(), loginSessionId: t, params: { userAgent: window.navigator.userAgent, sdkVersion: Config2.VERSION, deviceId: sdkCache.getDeviceId(), appId: this._ctx.appId, userId: this._userId, deviceType: "web", platformType: 2, rtsMode: this._ctx.rtsMode, mediaProcessingType: null !== (e = Config2.MEDIA_PROCESSING_TYPE) && void 0 !== e ? e : 0 }, accessParams: JSON.stringify({ requireICEUfragV2: true }) }, { functionType: SIGNALING_FUNCTION_TYPE.C2RTM }).then(() => {
      "function" == typeof this._loginResolveCallback && this._loginResolveCallback(), this._loginSessionId = t, RTSMsgReportor.setRtsSessionId(this.id, t), this._waitLoginToken = false, this._serverParamsCache && this.setServerParams(this._serverParamsCache.signature, this._serverParamsCache.url);
    }).catch((e2) => {
      const { code: t2, message: i2 } = e2 || {};
      let r, o;
      this._waitLoginToken = false, t2 >= 700 && t2 < 800 ? 708 === t2 ? (r = ErrorCode.INVALID_PARAMS, o = "Invalid userId") : (r = ErrorCode.INVALID_TOKEN, o = "Invalid token", this._waitLoginToken = true, this._loginRejectCallback || this.emit("onRTMTokenError")) : (r = ErrorCode.LOGIN_FAILED, o = "login failed"), "function" == typeof this._loginRejectCallback && this._loginRejectCallback(new SDKError(r, i2 || o));
    }).finally(() => {
      delete this._loginResolveCallback, delete this._loginRejectCallback;
    });
  }
  _addSignalEventHandler() {
    const e = (e2) => {
      e2.state === ConnectionState.CONNECTION_STATE_RECONNECTED && this._login();
    }, t = () => this._clearState(), i = (e2) => {
      this.emit("onUserMessageReceivedOutsideRoom", { userId: e2.from, message: e2.msg });
    }, r = (e2) => {
      this.emit("onUserBinaryMessageReceivedOutsideRoom", { userId: e2.from, message: e2.msg });
    }, o = (e2) => {
      e2.clientId !== this._userId || e2.roomId || (this.emit("onUserDisconnection"), this._clearState());
    };
    this._ctx.signalingManager.on(StateEvent.ON_CONNECTION_STATE_CHANGE, e), this._ctx.signalingManager.on(StateEvent.ON_RECONNECT_FAILED, t), this._ctx.signalingManager.on(SignalEvent.USER_MESSAGE_RECEIVED_OUTSIDE_ROOM, i), this._ctx.signalingManager.on(SignalEvent.USER_BINARY_MESSAGE_RECEIVED_OUTSIDE_ROOM, r), this._ctx.signalingManager.on(SignalEvent.USER_DISCONNECTION, o), this._clearListeners = () => {
      this._ctx.signalingManager.off(StateEvent.ON_CONNECTION_STATE_CHANGE, e), this._ctx.signalingManager.off(StateEvent.ON_RECONNECT_FAILED, t), this._ctx.signalingManager.off(SignalEvent.USER_MESSAGE_RECEIVED_OUTSIDE_ROOM, i), this._ctx.signalingManager.off(SignalEvent.USER_BINARY_MESSAGE_RECEIVED_OUTSIDE_ROOM, r), this._ctx.signalingManager.off(SignalEvent.USER_DISCONNECTION, o);
    };
  }
  _clearState() {
    var e;
    null === (e = this._clearListeners) || void 0 === e || e.call(this), this._userId = null, this._token = null, this._loginSessionId = null, RTSMsgReportor.setRtsSessionId(this.id, "");
  }
  _checkNotInLimitMode(e) {
    if (this._ctx.rtsMode === RTS_MODE.LIMIT_MODE) throw new SDKError(ErrorCode.NOT_ALLOWED_IN_RESTRICTED_MODE, "not allow to call ".concat(e, " in rts restricted mode"));
  }
};
var WTNStreamEventsTypes = ((e) => (e.onWTNPushStateChanged = "onWTNPushStateChanged", e.onWTNPlayStateChanged = "onWTNPlayStateChanged", e.onWTNRemoteAudioStateChanged = "onWTNRemoteAudioStateChanged", e.onWTNRemoteVideoStateChanged = "onWTNRemoteVideoStateChanged", e.onWTNRemoteVideoStats = "onWTNRemoteVideoStats", e.onWTNRemoteAudioStats = "onWTNRemoteAudioStats", e.onWTNFirstRemoteVideoFrameDecoded = "onWTNFirstRemoteVideoFrameDecoded", e.onWTNSEIMessageReceived = "onWTNSEIMessageReceived", e))(WTNStreamEventsTypes || {});
var WTNPushState = ((e) => (e[e.INIT = 0] = "INIT", e[e.START = 1] = "START", e[e.SUCCESS = 2] = "SUCCESS", e[e.STOP = 3] = "STOP", e[e.FAIL = 4] = "FAIL", e))(WTNPushState || {});
var WTNPushStateChangedReason = ((e) => (e[e.PUSH_SUCCESS = 0] = "PUSH_SUCCESS", e[e.START_PUSH = 1] = "START_PUSH", e[e.STOP_PUSH = 2] = "STOP_PUSH", e[e.IN_RETRY = 3] = "IN_RETRY", e[e.RETRY_FAIL = 4] = "RETRY_FAIL", e[e.NO_PUSH_PERMISSION = 5] = "NO_PUSH_PERMISSION", e[e.STREAM_PUSH_BY_OTHER = 6] = "STREAM_PUSH_BY_OTHER", e))(WTNPushStateChangedReason || {});
var WTNPlayState = ((e) => (e[e.INIT = 0] = "INIT", e[e.START = 1] = "START", e[e.SUCCESS = 2] = "SUCCESS", e[e.STOP = 3] = "STOP", e[e.FAIL = 4] = "FAIL", e))(WTNPlayState || {});
var WTNPlayStateChangedReason = ((e) => (e[e.PLAY_SUCCESS = 0] = "PLAY_SUCCESS", e[e.START_PLAY = 1] = "START_PLAY", e[e.STOP_PLAY = 2] = "STOP_PLAY", e[e.REMOTE_STOP = 3] = "REMOTE_STOP", e[e.REMOTE_FAILURE = 4] = "REMOTE_FAILURE", e[e.STREAM_BANNED = 5] = "STREAM_BANNED", e[e.NO_PLAY_PERMISSION = 6] = "NO_PLAY_PERMISSION", e[e.STREAM_NOT_EXIST = 7] = "STREAM_NOT_EXIST", e[e.IN_RETRY = 8] = "IN_RETRY", e[e.RETRY_FAIL = 9] = "RETRY_FAIL", e[e.INTERNAL = 10] = "INTERNAL", e[e.OVER_CLIENT_SUBSCRIBE_STREAM_LIMIT = 1310] = "OVER_CLIENT_SUBSCRIBE_STREAM_LIMIT", e[e.OVER_STREAM_SUBSCRIBE_USER_LIMIT = 1311] = "OVER_STREAM_SUBSCRIBE_USER_LIMIT", e[e.OVER_STREAM_SUBSCRIBE_REQUES_TLIMIT = 1312] = "OVER_STREAM_SUBSCRIBE_REQUES_TLIMIT", e))(WTNPlayStateChangedReason || {});
var WTNRemoteAudioState = ((e) => (e[e.STOPED = 0] = "STOPED", e[e.STARTING = 1] = "STARTING", e[e.DECODING = 2] = "DECODING", e[e.FROZEN = 3] = "FROZEN", e[e.FAILED = 4] = "FAILED", e))(WTNRemoteAudioState || {});
var WTNRemoteAudioStateChangeReason = ((e) => (e[e.INTERNAL = 0] = "INTERNAL", e[e.NETWORK_CONGESTION = 1] = "NETWORK_CONGESTION", e[e.NETWORK_RECOVERY = 2] = "NETWORK_RECOVERY", e[e.UNMUTE = 3] = "UNMUTE", e[e.MUTE = 4] = "MUTE", e[e.REMOTE_START = 5] = "REMOTE_START", e[e.REMOTE_STOP = 6] = "REMOTE_STOP", e))(WTNRemoteAudioStateChangeReason || {});
var WTNRemoteVideoState = ((e) => (e[e.STOPED = 0] = "STOPED", e[e.STARTING = 1] = "STARTING", e[e.DECODING = 2] = "DECODING", e[e.FROZEN = 3] = "FROZEN", e[e.FAILED = 4] = "FAILED", e))(WTNRemoteVideoState || {});
var WTNRemoteVideoStateChangeReason = ((e) => (e[e.INTERNAL = 0] = "INTERNAL", e[e.NETWORK_CONGESTION = 1] = "NETWORK_CONGESTION", e[e.NETWORK_RECOVERY = 2] = "NETWORK_RECOVERY", e[e.UNMUTE = 3] = "UNMUTE", e[e.MUTE = 4] = "MUTE", e[e.REMOTE_START = 5] = "REMOTE_START", e[e.REMOTE_STOP = 6] = "REMOTE_STOP", e))(WTNRemoteVideoStateChangeReason || {});
var BACK_OFF_INIT_STATE = { interval: 1e3, retryDuration: 0 };
var WTNLocalStream = class extends LocalStream {
  constructor(e, t, i) {
    let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    super(i, StreamIndex.STREAM_INDEX_MAIN), _defineProperty(this, "_state", WTNPushState.INIT), _defineProperty(this, "_stateChangeTs", getServerNow()), _defineProperty(this, "streamId", void 0), _defineProperty(this, "Authorization", void 0), _defineProperty(this, "_backOff", BACK_OFF_INIT_STATE), this.token = t, this.streamId = e, this.logName = "WTNLocalStream-".concat(e), this.observer = new SendFrameObserver(this._ctx, this), this.Authorization = Utils.token2auth(i.appId, "", e, t), this._state = r ? WTNPushState.FAIL : WTNPushState.INIT, this.isPublicStream = true;
  }
  setState(e, t) {
    const i = this._state;
    if (i === e) return;
    this.logger.print("setState", e, t), this._state = e;
    const r = getServerNow();
    this.safeEmit(WTNStreamEventsTypes.onWTNPushStateChanged, { streamId: this.streamId, oldState: i, newState: e, reason: t, elapse: r - this._stateChangeTs }), this._stateChangeTs = r;
  }
  getPushBackOff() {
    return this._backOff;
  }
  updatePushBackOff() {
    this._backOff.retryDuration += this._backOff.interval, this._backOff.interval = this._backOff.interval > 4e3 ? 8e3 : 2 * this._backOff.interval;
  }
  resetPushBackOff() {
    this._backOff = BACK_OFF_INIT_STATE;
  }
};
var WTNRemoteStream = class extends RemoteStream {
  constructor(e, t, i) {
    let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    super(i, e, e, false, true, { audiostream: true, localaudio: true, videostream: true, localvideo: true, extaudio: false, extvideo: false, videoDescriptions: [] }), _defineProperty(this, "_state", WTNPlayState.INIT), _defineProperty(this, "Authorization", void 0), _defineProperty(this, "_stateChangeTs", getServerNow()), _defineProperty(this, "streamId", void 0), _defineProperty(this, "_backOff", BACK_OFF_INIT_STATE), _defineProperty(this, "_audioState", WTNRemoteAudioState.STOPED), _defineProperty(this, "_videoState", WTNRemoteVideoState.STOPED), this.token = t, this.streamId = e, this.logName = "WTNRemoteStream-".concat(e), this.observer = new RecvFrameObserver(this._ctx, this), this._initObserverEvent(r), this.Authorization = Utils.token2auth(i.appId, "", e, t), this._state = r ? WTNPlayState.FAIL : WTNPlayState.INIT, this.isPublicStream = true;
  }
  setState(e, t) {
    const i = this._state;
    if (i === e) return;
    this.logger.print("setState", e, t), this._state = e;
    const r = getServerNow();
    this.safeEmit(WTNStreamEventsTypes.onWTNPlayStateChanged, { streamId: this.streamId, oldState: i, newState: e, reason: t, elapse: r - this._stateChangeTs }), this._stateChangeTs = r;
  }
  get state() {
    return this._state;
  }
  getPushBackOff() {
    return this._backOff;
  }
  updatePushBackOff() {
    this._backOff.retryDuration += this._backOff.interval, this._backOff.interval = this._backOff.interval > 4e3 ? 8e3 : 2 * this._backOff.interval;
  }
  resetPushBackOff() {
    this._backOff = BACK_OFF_INIT_STATE;
  }
  setVideoState(e, t) {
    this._videoState !== e && (e === WTNRemoteVideoState.DECODING && this.setVideoState(WTNRemoteVideoState.STARTING, t), this.logger.print("setVideoState", e, t), this._videoState = e, this.safeEmit(WTNStreamEventsTypes.onWTNRemoteVideoStateChanged, { streamId: this.streamId, state: e, reason: t }));
  }
  setAudioState(e, t) {
    this._audioState !== e && (e === WTNRemoteAudioState.DECODING && this.setAudioState(WTNRemoteAudioState.STARTING, t), this.logger.print("setAudioState", e, t), this._audioState = e, this.safeEmit(WTNStreamEventsTypes.onWTNRemoteAudioStateChanged, { streamId: this.streamId, state: e, reason: t }));
  }
  muteToSubMediaType(e, t) {
    let i = false;
    const r = audioInMediaType(this.subMediaType), o = videoInMediaType(this.subMediaType);
    return "boolean" == typeof e && r === e && (this.subMediaType += e ? -MediaType$1.AUDIO : MediaType$1.AUDIO, i = true), "boolean" == typeof t && o === t && (this.subMediaType += t ? -MediaType$1.VIDEO : MediaType$1.VIDEO, i = true), i;
  }
  getEnableMediaType() {
    return { audio: audioInMediaType(this.subMediaType), video: videoInMediaType(this.subMediaType) };
  }
  _initObserverEvent(e) {
    var t, i;
    null === (t = this.observer) || void 0 === t || t.once("recvAudioFirstFrame", () => {
      this.setAudioState(WTNRemoteAudioState.DECODING, e ? WTNRemoteAudioStateChangeReason.NETWORK_RECOVERY : WTNRemoteAudioStateChangeReason.REMOTE_START);
    }), null === (i = this.observer) || void 0 === i || i.once("recvVideoFirstFrame", () => {
      this.setVideoState(WTNRemoteVideoState.DECODING, e ? WTNRemoteVideoStateChangeReason.NETWORK_RECOVERY : WTNRemoteVideoStateChangeReason.REMOTE_START);
    });
  }
};
var _excluded$2 = ["rid"];
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (e, t, i, r) => {
  for (var o, n = r > 1 ? void 0 : r ? __getOwnPropDesc$2(t, i) : t, s = e.length - 1; s >= 0; s--) (o = e[s]) && (n = (r ? o(t, i, n) : o(n)) || n);
  return r && n && __defProp$2(t, i, n), n;
};
var WTNStream = class extends EnhancedEventEmitter {
  constructor(e) {
    super(), _defineProperty(this, "_reportName", "WTNStream"), _defineProperty(this, "_localStreams", /* @__PURE__ */ new Map()), _defineProperty(this, "_remoteStreams", /* @__PURE__ */ new Map()), _defineProperty(this, "_logger", void 0), _defineProperty(this, "_monitor", void 0), _defineProperty(this, "_ontrackCallbackMap", /* @__PURE__ */ new Map()), _defineProperty(this, "_pushTaskMap", /* @__PURE__ */ new Map()), _defineProperty(this, "_playTaskMap", /* @__PURE__ */ new Map()), _defineProperty(this, "engineId", void 0), _defineProperty(this, "_publicVideoPlayerConfig", /* @__PURE__ */ new Map()), _defineProperty(this, "__onSEIMessageReceived", void 0), _defineProperty(this, "__onRemoteStreamStats", void 0), _defineProperty(this, "__onResubscribe", void 0), _defineProperty(this, "__onPlayerEvents", void 0), _defineProperty(this, "_clearSignalListeners", void 0), this._ctx = e, this._monitor = getMonitor(e.id), this._logger = new Logger$1("WTNStream", 1, e.id), this.engineId = e.id, this._addSignalListeners();
  }
  async startPushWTN(e, t, i, r) {
    var o;
    let n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    if (i = !!i, r = !!r, this._logger.print("startPushWTN", e, t, i, r), checkPublicStreamId(t), !isEmpty(e) && checkString(e, "token"), this._localStreams.get(t)) return;
    const s = new WTNLocalStream(t, e, this._ctx, n);
    this._addLocalStreamEventHandler(s), s.setState(WTNPushState.START, WTNPushStateChangedReason.START_PUSH), this._localStreams.set(t, s), await this._ctx.signalingManager.connect(), s.videoTrack = this._ctx.localVideoTrack, s.audioTrack = this._ctx.localAudioTrack, s.pubAudio = !r, s.pubVideo = !i, null === (o = s.observer) || void 0 === o || o.setLogin(true), await new Promise((e2, i2) => {
      n || this._pushTaskMap.set(t, { resolve: () => {
        e2(), s.startReport(() => {
        }, this._ctx.handler);
      }, reject: i2 }), this._sendStartPushStreamSignal(s).catch((e3) => i2(e3));
    });
  }
  async stopPushWTN(e) {
    var t;
    this._logger.print("stopPushWTN", e);
    const i = this._localStreams.get(e);
    i && (null === (t = i.observer) || void 0 === t || t.setLogin(false), i.setState(WTNPushState.STOP, WTNPushStateChangedReason.STOP_PUSH), this._ctx.signalingManager.sendSignaling("stopPushStream", { appId: this._ctx.appId, streamId: e }).catch(() => {
    }), await this._stopLocalStream(i));
  }
  async muteWTNLocalAudio(e, t) {
    var i;
    this._logger.print("muteWTNLocalAudio", e, t);
    const r = this._localStreams.get(e);
    if (!r) throw new SDKError(ErrorCode.INVALID_PARAMS, "streamId not found");
    this._assertNotConnect(), r.pubAudio = !t, null === (i = r.observer) || void 0 === i || i.setUnmuteAudio(!t), await this._updatePushStream(r);
  }
  async muteWTNLocalVideo(e, t) {
    var i;
    this._logger.print("muteWTNLocalVideo", e, t);
    const r = this._localStreams.get(e);
    if (!r) throw new SDKError(ErrorCode.INVALID_PARAMS, "streamId not found");
    this._assertNotConnect(), null === (i = r.observer) || void 0 === i || i.setUnmuteVideo(!t), r.pubVideo = !t, await this._updatePushStream(r);
  }
  sendWTNSEIMessage(e, t, i) {
    this._logger.info("sendWTNSEIMessage()", "streamId: %o, sei: %o, repeatCount: %o", e, t, i);
    const r = this._localStreams.get(e);
    if (!r || !r.pubVideo && !r.pubAudio) return;
    if (!isLegacyEncodedTransformSupported() && !isEncodedTransformSupported()) return warnDevelopers("Your browser does not support sending SEI"), false;
    checkNumber(i, "repeatCount", 0, 30);
    const o = "string" == typeof t ? new Uint8Array(Utils.str2ab(t)) : t;
    if (!t.length) return this._logger.warn("sei message must not be empty"), false;
    if (o.byteLength > 4096) return void this._logger.warn("sei size must not bigger than 4KB");
    isAndroid || this._maybeFillBackFrame2Stream(r);
    const n = genUuid();
    r.sendSEIMessage({ content: o, uuid: n, repeatCount: i + 1 }), setTimeout(async () => {
      if (!r) return;
      var e2;
      await r.revokeSEIMessage(n) && (console.error("[RTC WebSDK] sei timeout for message: %o", t), null === (e2 = this._monitor) || void 0 === e2 || e2.report("rtc_sdk_callback", { sdk_callback_name: "sendSEIMessage", message: "timeout for message: ".concat(t), error_code: 400 }));
    }, getParameter("SEI_TIME_OUT"));
  }
  async startPlayWTN(e, t, i, r) {
    var o;
    let n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    i = !!i, r = !!r, this._logger.print("startPlayWTN", e, t, i, r), checkPublicStreamId(t), !isEmpty(e) && checkString(e, "token");
    let s = this._remoteStreams.get(t);
    if (s) {
      if (s.state === WTNPlayState.START || s.state === WTNPlayState.SUCCESS) throw new SDKError(ErrorCode.REPEAT_PLAY, "repeat play public media stream");
      await this.stopPlayWTN(s.streamId);
    }
    s = new WTNRemoteStream(t, e, this._ctx, n), this._addRemoteStreamEventHandler(s), s.setState(WTNPlayState.START, WTNPlayStateChangedReason.START_PLAY), s.muteToSubMediaType(r, i), this._remoteStreams.set(t, s), null === (o = s.observer) || void 0 === o || o.setLogin(true, s.getEnableMediaType());
    try {
      await this._ctx.signalingManager.connect(), await new Promise((e2, i2) => {
        n || this._playTaskMap.set(t, { resolve: e2, reject: i2 }), this._sendStartPullStreamSignal(s).catch((e3) => i2(e3));
      });
    } catch (e2) {
      throw this._remoteStreams.delete(t), e2;
    }
  }
  async stopPlayWTN(e) {
    var t, i;
    this._logger.print("stopPlayWTN", e);
    const r = this._remoteStreams.get(e);
    if (r) return r.setState(WTNPlayState.STOP, WTNPlayStateChangedReason.STOP_PLAY), r.setAudioState(WTNRemoteAudioState.STOPED, WTNRemoteAudioStateChangeReason.MUTE), r.setVideoState(WTNRemoteVideoState.STOPED, WTNRemoteVideoStateChangeReason.MUTE), null === (t = r.observer) || void 0 === t || t.setLogin(false), null == r || null === (i = r.audioTrack) || void 0 === i || i.stop(), this._remoteStreams.delete(e), await this._ctx.signalingManager.connect(), this._unsubscribePublicStream(r);
  }
  async muteWTNRemoteAudio(e, t) {
    this._logger.print("muteWTNRemoteAudio", e, t), this._assertNotConnect();
    const i = this._remoteStreams.get(e);
    if (!i) throw new SDKError(ErrorCode.INVALID_PARAMS, "streamId not found");
    var r;
    i.muteToSubMediaType(t, null) && (null === (r = i.observer) || void 0 === r || r.setUnmuteAudio(!t), await this._updatePullStream(e, i), i.setAudioState(t ? WTNRemoteAudioState.STOPED : WTNRemoteAudioState.DECODING, t ? WTNRemoteAudioStateChangeReason.MUTE : WTNRemoteAudioStateChangeReason.UNMUTE));
  }
  async muteWTNRemoteVideo(e, t) {
    this._logger.print("muteWTNRemoteVideo", e, t), this._assertNotConnect();
    const i = this._remoteStreams.get(e);
    if (!i) throw new SDKError(ErrorCode.INVALID_PARAMS, "streamId not found");
    var r;
    i.muteToSubMediaType(null, t) && (null === (r = i.observer) || void 0 === r || r.setUnmuteVideo(!t), await this._updatePullStream(e, i), i.setVideoState(t ? WTNRemoteVideoState.STOPED : WTNRemoteVideoState.DECODING, t ? WTNRemoteVideoStateChangeReason.MUTE : WTNRemoteVideoStateChangeReason.UNMUTE));
  }
  setWTNRemoteVideoPlayer(e, t) {
    var i;
    if (this._logger.print("setWTNRemoteVideoPlayer()", "streamId: %o, videoPlayerOption: %o", e, t), null === (i = this._publicVideoPlayerConfig.get(e)) || void 0 === i || null === (i = i.player) || void 0 === i || i.destroy(), !t.renderDom) return void this._publicVideoPlayerConfig.delete(e);
    const r = new VideoPlayer(this._ctx.id, DEFAULT_PLAYER_ID, _objectSpread2(_objectSpread2({}, t), {}, { isLocal: false, userId: e })), o = _objectSpread2(_objectSpread2({}, t), {}, { player: r });
    return this._publicVideoPlayerConfig.set(e, o), this._updateVideoPlayerState(e), r.domElement;
  }
  setWTNRemoteAudioPlaybackVolume(e, t) {
    var i;
    checkString(e, "publicStreamId"), t = numberRangeGuide(t, "volume", 0, 400), this._ctx.publicAudioVolume.set(e, t), null === (i = this._remoteStreams.get(e)) || void 0 === i || null === (i = i.audioTrack) || void 0 === i || i.setVolume(t);
  }
  __getRemoteStreams() {
    return this._remoteStreams;
  }
  __getPublicStreamTrack(e, t) {
    const i = this._remoteStreams.get(e);
    if (i) return "video" === t ? i.videoTrack : i.audioTrack;
  }
  async _updatePushTrack() {
    0 !== this._localStreams.size && (this._logger.info("_updatePushTrack()"), await this._ctx.signalingManager.connect(), this._localStreams.forEach(async (e) => {
      var t;
      e.videoTrack = this._ctx.localVideoTrack, e.audioTrack = this._ctx.localAudioTrack, null === (t = e.observer) || void 0 === t || t.setEnableVideo(true), await this._updatePushStream(e);
    }));
  }
  destroy() {
    var e;
    this._remoteStreams.forEach((e2) => {
      e2.destroy();
    }), this._remoteStreams = /* @__PURE__ */ new Map(), this.removeAllListeners(), this._ontrackCallbackMap.clear(), this._publicVideoPlayerConfig.forEach((e2) => {
      e2.player.destroy();
    }), this._publicVideoPlayerConfig.clear(), null === (e = this._clearSignalListeners) || void 0 === e || e.call(this);
  }
  async _sendStartPushStreamSignal(e) {
    var t, i, r, o;
    this._logger.print("_sendStartPushStreamSignal()", "streamId: %s", e.streamId);
    const { streamId: n, Authorization: s, pubAudio: a, pubVideo: d } = e, { handler: c2 } = this._ctx;
    await (null == c2 ? void 0 : c2.getDefaultSdp());
    const l = await c2.publish(e), u = await internalGetSupportedCodecs(), { appId: h, businessId: _, useCloudProxy: p } = this._ctx, m = { appId: h, streamId: n, Authorization: s, sdpInfo: { msid: e.stream.id, type: l.type, sdp: l.partialSdp, semantics: l.semantics }, timestamp: Date.now(), params: { appId: h, businessId: _, userAgent: window.navigator.userAgent, sdkVersion: Config2.VERSION, deviceId: sdkCache.getDeviceId(), enableCloudProxy: p, channelProfile: "0", SDKCodecNegotiation: true, supportedCodecs: u, sdkType: "rtc", joinRoomMode: 1, deviceType: "web", platformType: 2, rtsMode: this._ctx.rtsMode, mediaProcessingType: null !== (t = Config2.MEDIA_PROCESSING_TYPE) && void 0 !== t ? t : 0 }, options: { supportCheckTokenPrivilege: true, supportTokenExpireCallBack: true, enableSceneConfigV2: true, enableUnBundleMode: true, enableAudioMux: true, enableBigRoomMode: true, needNegotiateSDP: true, supportMultiVendor: true, enableStreamStatusCallback: true }, attributes: { localaudio: !!e.audioTrack, localvideo: !!e.videoTrack, videostream: d, audiostream: a, extvideo: (null === (i = e.videoTrack) || void 0 === i ? void 0 : i.sourceType) === SourceType.EXTERNAL, extaudio: (null === (r = e.audioTrack) || void 0 === r ? void 0 : r.sourceType) === SourceType.EXTERNAL, videoDescriptions: l.videoDescriptions.map((e2) => _objectWithoutProperties(e2, _excluded$2)), videoType: VideoType.NORMAL }, video: d, audio: a, screen: e.isScreen, accessParams: JSON.stringify({ requireICEUfragV2: true }) };
    let S;
    try {
      this.emit("__onSendingPushStreamMessageHook"), S = await this._ctx.signalingManager.sendSignaling("startPushStream", m);
    } catch (t2) {
      if (await (null == c2 ? void 0 : c2.rollback({ msid: e.stream.id, stream: e, audioMid: l.audioMid, videoMid: l.videoMid })), t2.code >= 500 && t2.code < 600) {
        const i2 = e.getPushBackOff();
        if (i2.retryDuration < 6e4) return this._logger.info("pushRetry", "start msid: %s, retryDuration: %s", e.id, i2.retryDuration), await new Promise((e2) => setTimeout(e2, i2.interval)), e.updatePushBackOff(), e.resetStream(), e.setState(WTNPushState.START, WTNPushStateChangedReason.IN_RETRY), this._sendStartPushStreamSignal(e);
        throw this._logger.info("pushRetry", "end"), e.setState(WTNPushState.FAIL, WTNPushStateChangedReason.RETRY_FAIL), await this._stopLocalStream(e), e.resetPushBackOff(), new SDKError(ErrorCode.WTN_PUSH_FAILED, t2.message || "server error");
      }
      if (401 === t2.code) throw e.setState(WTNPushState.FAIL, WTNPushStateChangedReason.NO_PUSH_PERMISSION), await this._stopLocalStream(e), new SDKError(ErrorCode.WTN_PUSH_FAILED, t2.message || "token error");
      if (t2.code === ErrorCode.OPERATION_CANCEL && this._ctx.signalingManager.isReconnecting()) return;
      throw new SDKError(ErrorCode.WTN_PUSH_FAILED, t2.message || "push error");
    }
    e.pubAttributes = m.attributes;
    const g = await e.getSelectedCodec();
    e.currentVideoCodec = g;
    const v3 = new Promise((t2, i2) => {
      var r2, o2;
      null == c2 || c2.handleAck({ action: SdpAction.publish, streamId: n, audioMid: l.audioMid, videoMid: l.videoMid, audioTransceiverInit: null == l ? void 0 : l.audioTransceiverInit, videoTransceiverInit: null == l ? void 0 : l.videoTransceiverInit, signalingAck: { sdp: null === (r2 = S) || void 0 === r2 || null === (r2 = r2.relayMessage) || void 0 === r2 ? void 0 : r2.sdp, sequenceId: null === (o2 = S) || void 0 === o2 || null === (o2 = o2.relayMessage) || void 0 === o2 ? void 0 : o2.sequenceId }, stream: e, videoCodec: g, onSuccess: () => {
        this._logger.info("pushStream()", "pushStream success"), e.setState(WTNPushState.SUCCESS, WTNPushStateChangedReason.PUSH_SUCCESS), t2(0);
      }, onFail: (e2) => {
        this._logger.info("pushStream()", "pushStream fail"), i2(e2);
      } });
    });
    !isFirefox && await v3, null === (o = this._pushTaskMap.get(n)) || void 0 === o || o.resolve(), this._pushTaskMap.delete(n);
  }
  async _stopLocalStream(e) {
    var t;
    e.stopBlackFrame(), await (null === (t = this._ctx.handler) || void 0 === t ? void 0 : t.handleAck({ action: SdpAction.unpublish, audioMid: e.audioMid, videoMid: e.videoMid, stream: e, streamId: e.streamId })), e.destroy(), this._localStreams.delete(e.streamId);
  }
  async _updatePushStream(e) {
    var t, i, r, o;
    const { videoTrack: n, audioTrack: s, pubAudio: a, pubVideo: d } = e;
    let c2 = null === (t = e.audioTrack) || void 0 === t ? void 0 : t.preprocessingTrack;
    const l = null === (i = e.videoTrack) || void 0 === i ? void 0 : i.preprocessingTrack;
    var u, h;
    d && l ? (e.stopBlackFrame(), await (null === (u = e.videoTransceiver) || void 0 === u ? void 0 : u.sender.replaceTrack(l))) : await (null === (h = e.videoTransceiver) || void 0 === h ? void 0 : h.sender.replaceTrack(null));
    if (a && c2) {
      var _;
      const { mixType: t2, mixedAudioTrack: i2 } = e.audioTrack;
      i2 && t2 !== AudioMixingType.PLAYOUT && c2.enabled && (c2 = i2), await (null === (_ = e.audioTransceiver) || void 0 === _ ? void 0 : _.sender.replaceTrack(c2));
    } else {
      var p;
      await (null === (p = e.audioTransceiver) || void 0 === p ? void 0 : p.sender.replaceTrack(null));
    }
    const m = { localaudio: !!s, localvideo: !!n, videostream: d, audiostream: a, extvideo: (null == n ? void 0 : n.sourceType) === SourceType.EXTERNAL, extaudio: (null == s ? void 0 : s.sourceType) === SourceType.EXTERNAL, videoType: n ? VideoType.NORMAL : e.pubAttributes.videoType }, S = {};
    for (const [t2, i2] of Object.entries(m)) i2 !== Reflect.get(e.pubAttributes, t2) && Reflect.set(S, t2, i2);
    var g;
    Object.keys(S).length && (e.pubAudio = null !== (r = m.audiostream) && void 0 !== r ? r : e.pubAudio, e.pubVideo = null !== (o = m.videostream) && void 0 !== o ? o : e.pubVideo, e.pubAttributes = _objectSpread2(_objectSpread2({}, e.pubAttributes), m), e.pubAttributes.videostream || e.stopBlackFrame(), await this._ctx.signalingManager.sendSignaling("updatePushStream", { appId: this._ctx.appId, streamId: e.streamId, attributes: m }), isFirefox && await (null === (g = this._ctx.handler) || void 0 === g ? void 0 : g.setCurrentDescription()));
  }
  async _sendStartPullStreamSignal(e) {
    var t, i, r, o, n;
    this._logger.print("startPullStream()", "streamId:", e.streamId);
    const { streamId: s, Authorization: a } = e, { handler: d } = this._ctx, c2 = await (null == d ? void 0 : d.subscribe(e, { multiChatMode: false }));
    if (!c2) throw new SDKError(ErrorCode.ADD_TRANSCEIVER_FAILED, "add transceiver failed");
    const l = getServerNow(), { audioMid: u, videoMid: h } = c2, { appId: _, businessId: p, useCloudProxy: m } = this._ctx, S = await internalGetSupportedCodecs(), g = { appId: _, streamId: s, Authorization: a, audio: true, video: true, screen: false, timestamp: Date.now(), sdpInfo: { sdp: c2.partialSdp, semantics: c2.semantics, type: c2.type }, params: { appId: _, businessId: p, userAgent: window.navigator.userAgent, sdkVersion: Config2.VERSION, deviceId: sdkCache.getDeviceId(), enableCloudProxy: m, channelProfile: "0", SDKCodecNegotiation: true, supportedCodecs: S, sdkType: "rtc", joinRoomMode: 1, deviceType: "web", platformType: 2, rtsMode: this._ctx.rtsMode, mediaProcessingType: null !== (t = Config2.MEDIA_PROCESSING_TYPE) && void 0 !== t ? t : 0 }, options: { supportCheckTokenPrivilege: true, supportTokenExpireCallBack: true, enableSceneConfigV2: true, enableUnBundleMode: true, enableAudioMux: true, enableBigRoomMode: true, needNegotiateSDP: true, supportMultiVendor: true, enableStreamStatusCallback: true }, config: { enableMediaType: e.getEnableMediaType(), qualityLayer: { spatialLayer: 0, temporalLayer: 0 } }, accessParams: JSON.stringify({ requireICEUfragV2: true }), extra: { enableSendRTT: true } };
    let v3;
    try {
      this.emit("__onSendingPullStreamMessageHook"), v3 = await this._ctx.signalingManager.sendSignaling("startPullStream", g);
    } catch (t2) {
      if (await (null == d ? void 0 : d.rollback({ msid: s, stream: e }).catch(() => {
      })), 401 === t2.code) throw e.setState(WTNPlayState.FAIL, WTNPlayStateChangedReason.NO_PLAY_PERMISSION), new SDKError(ErrorCode.WTN_PLAY_FAILED, t2.message || "token error");
      if (433 === t2.code) throw e.setState(WTNPlayState.FAIL, WTNPlayStateChangedReason.OVER_CLIENT_SUBSCRIBE_STREAM_LIMIT), new SDKError(ErrorCode.WTN_PLAY_FAILED, t2.message || "over client subscribe stream limit");
      if (434 === t2.code) throw e.setState(WTNPlayState.FAIL, WTNPlayStateChangedReason.OVER_STREAM_SUBSCRIBE_USER_LIMIT), new SDKError(ErrorCode.WTN_PLAY_FAILED, t2.message || "over stream subscribe user limit");
      if (t2.code === ErrorCode.OPERATION_CANCEL && this._ctx.signalingManager.isReconnecting()) return;
      throw e.setState(WTNPlayState.FAIL, WTNPlayStateChangedReason.INTERNAL), new SDKError(ErrorCode.WTN_PLAY_FAILED, t2.message || "play wtn error");
    }
    const f = [];
    f.push(new Promise((t2, i2) => {
      const r2 = setTimeout(() => i2(new SDKError(ErrorCode.WTN_PLAY_FAILED, "wait video timeout for streamId: ".concat(s))), 6e4), o2 = (i3) => {
        "video" === i3.mediaType && (this._logger.success("remoteStream ".concat(e.userId, " received video track")), e.off("ontrack", o2), clearTimeout(r2), t2(0));
      };
      e.on("ontrack", o2);
    })), f.push(new Promise((t2, i2) => {
      const r2 = setTimeout(() => i2(new SDKError(ErrorCode.WTN_PLAY_FAILED, "wait audio timeout for streamId: ".concat(s))), 6e4), o2 = (i3) => {
        "audio" === i3.mediaType && (this._logger.success("remoteStream ".concat(e.userId, " received audio track")), e.off("ontrack", o2), clearTimeout(r2), t2(0));
      };
      e.on("ontrack", o2);
    }));
    const y = (t2) => {
      e.ontrack(t2);
    };
    null === (i = this._ctx.handler) || void 0 === i || i.on("ontrack", y), this._ontrackCallbackMap.set(e, y);
    const { sequenceId: E, sdp: T } = v3.relayMessage;
    e.videoMid = h, e.audioMid = u, e.sequenceId = E, e.streamState = StreamState.SUB_ED, await (null === (r = this._ctx.handler) || void 0 === r ? void 0 : r.handleAck({ action: SdpAction.subscribe, streamId: s, audioMid: u, videoMid: h, audioTransceiverInit: c2.audioTransceiverInit, videoTransceiverInit: c2.videoTransceiverInit, signalingAck: { sdp: T, sequenceId: E }, stream: e })), await Promise.all(f), null === (o = this._monitor) || void 0 === o || o.report("rtc_subscribe_stat", { result: "success", start: l, message: "unknown", stream_user_id: e.userId }), e.startReport((t2) => {
      var i2;
      t2.publicStreamId = t2.userId, delete t2.userId, delete t2.isScreen;
      const r2 = getPublicStats(t2);
      r2.audioStats && this.safeEmit(WTNStreamEventsTypes.onWTNRemoteAudioStats, { streamId: e.streamId, audioStats: r2.audioStats }), r2.videoStats && this.safeEmit(WTNStreamEventsTypes.onWTNRemoteVideoStats, { streamId: e.streamId, videoStats: r2.videoStats }), null === (i2 = this.__onRemoteStreamStats) || void 0 === i2 || i2.call(this, r2);
    }, this._ctx.handler), this._updateVideoPlayerState(s), this._initAudioPlayer(s), e.subVideo = e.getEnableMediaType().video, e.subAudio = e.getEnableMediaType().audio, null === (n = this._playTaskMap.get(s)) || void 0 === n || n.resolve(), this._playTaskMap.delete(s);
  }
  async _unsubscribePublicStream(e) {
    var t;
    logRemoteStream("_unsubscribePublicStream()", e, this._logger);
    const i = { appId: this._ctx.appId, streamId: e.streamId };
    try {
      await this._ctx.signalingManager.sendSignaling("stopPullStream", i);
    } catch (e2) {
    }
    e.streamState = StreamState.INIT, await (null === (t = this._ctx.handler) || void 0 === t ? void 0 : t.handleAck({ action: SdpAction.unsubscribe, streamId: e.streamId, audioMid: e.audioMid, videoMid: e.videoMid, stream: e })), e.subMediaType = ExtendMediaType.NONE, this._removeOnTrackListener(e), e.statsReport.unsubscribe(), e.destroy();
  }
  async _updatePullStream(e, t) {
    const i = t.getEnableMediaType();
    await this._ctx.signalingManager.sendSignaling("updatePullStream", { appId: this._ctx.appId, streamId: e, config: { enableMediaType: i } }), t.subVideo = i.video, t.subAudio = i.audio;
  }
  _removeOnTrackListener(e) {
    const t = this._ontrackCallbackMap.get(e);
    if (t) {
      const i = e.vendorHandler || this._ctx.handler;
      null == i || i.off("ontrack", t), this._ontrackCallbackMap.delete(e);
    }
  }
  _addSignalListeners() {
    const e = { [StateEvent.ON_CONNECTION_STATE_CHANGE]: (e2) => {
      e2.state === ConnectionState.CONNECTION_STATE_RECONNECTED ? (Array.from(this._remoteStreams.values()).forEach((e3) => {
        const { streamId: t, token: i } = e3, { audio: r, video: o } = e3.getEnableMediaType();
        e3.destroy(), this._remoteStreams.delete(t), this.startPlayWTN(i, t, !o, !r, true).then(() => {
          var t2;
          null === (t2 = this.__onResubscribe) || void 0 === t2 || t2.call(this, { stream: e3 });
        });
      }), Array.from(this._localStreams.values()).forEach((e3) => {
        const { token: t, pubAudio: i, pubVideo: r } = e3;
        e3.destroy(), this._localStreams.delete(e3.streamId), this.startPushWTN(t, e3.streamId, !r, !i, true);
      })) : e2.state === ConnectionState.CONNECTION_STATE_DISCONNECTED && (this._remoteStreams.forEach((e3) => {
        e3.setState(WTNPlayState.FAIL, WTNPlayStateChangedReason.IN_RETRY), e3.setAudioState(WTNRemoteAudioState.FROZEN, WTNRemoteAudioStateChangeReason.NETWORK_CONGESTION), e3.setVideoState(WTNRemoteVideoState.FROZEN, WTNRemoteVideoStateChangeReason.NETWORK_CONGESTION);
      }), this._localStreams.forEach((e3) => {
        e3.setState(WTNPushState.FAIL, WTNPushStateChangedReason.IN_RETRY);
      }));
    }, [SignalEvent.ON_STREAM_PUSHED_BY_OTHER]: (e2) => {
      const t = this._localStreams.get(e2.streamId);
      this._logger.print("_addSignalListeners", "onStreamPushedByOther", e2.streamId), t && (t.setState(WTNPushState.FAIL, WTNPushStateChangedReason.STREAM_PUSH_BY_OTHER), this._stopLocalStream(t));
    }, [SignalEvent.ON_STREAM_PULL_STATE_CHANGED]: async (e2) => {
      const t = this._remoteStreams.get(e2.streamId);
      if (this._logger.print("_addSignalListeners", "onStreamPullStateChanged", e2), t) switch (e2.code) {
        case 0:
          t.setState(WTNPlayState.SUCCESS, WTNPlayStateChangedReason.PLAY_SUCCESS);
          break;
        case 1:
        case 2:
        case 3:
          const r = { 1: WTNPlayStateChangedReason.STREAM_NOT_EXIST, 2: WTNPlayStateChangedReason.REMOTE_STOP, 3: WTNPlayStateChangedReason.REMOTE_FAILURE }[e2.code];
          t.setAudioState(WTNRemoteAudioState.STOPED, WTNRemoteAudioStateChangeReason.REMOTE_STOP), t.setVideoState(WTNRemoteVideoState.STOPED, WTNRemoteVideoStateChangeReason.REMOTE_STOP), t.setState(WTNPlayState.FAIL, r);
          break;
        case 4:
          const o = t.getPushBackOff();
          var i;
          if (o.retryDuration < 6e4) this._logger.info("subRetry", t.streamId, o.retryDuration), t.setState(WTNPlayState.START, WTNPlayStateChangedReason.IN_RETRY), await new Promise((e3) => setTimeout(e3, o.interval)), t.updatePushBackOff(), await (null === (i = this._ctx) || void 0 === i || null === (i = i.handler) || void 0 === i ? void 0 : i.handleAck({ action: SdpAction.unsubscribe, streamId: t.streamId, audioMid: t.audioMid, videoMid: t.videoMid, stream: t })), t.clean(), await this._sendStartPullStreamSignal(t);
          else t.setState(WTNPlayState.FAIL, WTNPlayStateChangedReason.RETRY_FAIL), this._logger.info("subRetry", "end", t.streamId), t.resetPushBackOff();
      }
    }, [MediaServerSignalEvent.RTT]: (e2) => {
      const { StreamIds: t, Metadata: i } = e2;
      if (null != t && t.length && i) {
        const e3 = t[0];
        this._ctx.streamRTT[e3] = { audio: i.audio_rtt, video: i.video_rtt };
      }
    } };
    Object.keys(e).forEach((t) => {
      this._ctx.signalingManager.on(t, e[t]);
    }), this._clearSignalListeners = () => {
      Object.keys(e).forEach((t) => {
        this._ctx.signalingManager.off(t, e[t]);
      });
    };
  }
  _addLocalStreamEventHandler(e) {
    e.on(WTNStreamEventsTypes.onWTNPushStateChanged, (e2) => {
      this.safeEmit(WTNStreamEventsTypes.onWTNPushStateChanged, e2);
    });
  }
  _addRemoteStreamEventHandler(e) {
    e.on(WTNStreamEventsTypes.onWTNPlayStateChanged, (e2) => {
      this.safeEmit(WTNStreamEventsTypes.onWTNPlayStateChanged, e2);
    }), e.on(WTNStreamEventsTypes.onWTNRemoteAudioStateChanged, (e2) => {
      this.safeEmit(WTNStreamEventsTypes.onWTNRemoteAudioStateChanged, e2);
    }), e.on(WTNStreamEventsTypes.onWTNRemoteVideoStateChanged, (e2) => {
      this.safeEmit(WTNStreamEventsTypes.onWTNRemoteVideoStateChanged, e2);
    }), e.on("onSEIMessage", (t) => {
      if (t instanceof Uint8Array) {
        const r = splitPublicStreamSei(t);
        for (let t2 = 0; t2 < r.seiCount; t2++) {
          var i;
          null === (i = this.__onSEIMessageReceived) || void 0 === i || i.call(this, { sei: r.seis[t2], publicStreamId: e.streamId }), this.safeEmit(WTNStreamEventsTypes.onWTNSEIMessageReceived, { streamId: e.streamId, sei: r.seis[t2] });
        }
      }
    });
  }
  _updateVideoPlayerState(e) {
    const t = this._remoteStreams.get(e);
    if (t) {
      const o = this._publicVideoPlayerConfig.get(e);
      var i, r;
      if (o) null === (i = t.videoTrack) || void 0 === i || i.setPlayer(this._ctx.id, o, null === (r = this._ctx) || void 0 === r ? void 0 : r.autoPlayPolicy, this._initPlayerEvents.bind(this));
    }
  }
  _initAudioPlayer(e) {
    const t = this._remoteStreams.get(e);
    if (null != t && t.audioTrack) {
      var i, r;
      const o = new AudioPlayer(this._ctx.id, e, { muted: (null === (i = this._ctx) || void 0 === i ? void 0 : i.autoPlayPolicy) === RTCAutoPlayPolicy.VIDEO_ONLY || (null === (r = this._ctx) || void 0 === r ? void 0 : r.autoPlayPolicy) === RTCAutoPlayPolicy.PLAY_MANUALLY, isScreen: false });
      t.audioTrack.setPlayer(o), t.audioTrack.bindPlayerEvent(this._initPlayerEvents.bind(this)), t.audioTrack.play();
    }
  }
  _initPlayerEvents(e) {
    var t;
    let i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : StreamIndex$1.STREAM_INDEX_MAIN;
    null === (t = this.__onPlayerEvents) || void 0 === t || t.call(this, e, i, r), e.on("playback_event", (t2) => {
      const i2 = this._remoteStreams.get(e.userId);
      if ("loadeddata" === t2.eventName) {
        const e2 = () => {
          i2 && "video" === t2.type && this.safeEmit(WTNStreamEventsTypes.onWTNFirstRemoteVideoFrameDecoded, { streamId: i2.streamId });
        };
        null == i2 || !i2.observer || i2.observer.audioFirstFrameReceived ? e2() : i2.observer.once("recvVideoFirstFrame", e2);
      }
    });
  }
  async _maybeFillBackFrame2Stream(e) {
    var t;
    if (e.refreshBlackFrameLifetime(), null === (t = e.videoTransceiver) || void 0 === t || !t.sender.track) {
      var i;
      const t2 = e.genBlackFrame();
      if (!t2) return;
      null === (i = e.videoTransceiver) || void 0 === i || null === (i = i.sender) || void 0 === i || i.replaceTrack(t2), e.pubAttributes.videoType = VideoType.BLACK, this._ctx.signalingManager.sendSignaling("updatePushStream", { streamId: e.streamId, appId: this._ctx.appId, attributes: { videoType: VideoType.BLACK } }), e.on("black-frame-ended", () => {
        var t3;
        null === (t3 = e.videoTransceiver) || void 0 === t3 || null === (t3 = t3.sender) || void 0 === t3 || t3.replaceTrack(null), e.pubAttributes.videoType = VideoType.NORMAL, this._ctx.signalingManager.sendSignaling("updatePushStream", { streamId: e.streamId, appId: this._ctx.appId, attributes: { videoType: VideoType.NORMAL } });
      });
    }
  }
  safeEmit(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    return reportRtcSdkCallback(this._ctx.id, e, i), super.safeEmit(e, ...i);
  }
  _assertNotConnect() {
    if (!this._ctx.signalingManager.isConnected()) throw new SDKError(ErrorCode.NOT_CONNECTED_YET, "server not connected");
  }
};
__decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "startPushWTN", 1), __decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "stopPushWTN", 1), __decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "muteWTNLocalAudio", 1), __decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "muteWTNLocalVideo", 1), __decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "sendWTNSEIMessage", 1), __decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "startPlayWTN", 1), __decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "stopPlayWTN", 1), __decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "muteWTNRemoteAudio", 1), __decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "muteWTNRemoteVideo", 1), __decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "setWTNRemoteVideoPlayer", 1), __decorateClass$2([reportRtcSdkApi()], WTNStream.prototype, "setWTNRemoteAudioPlaybackVolume", 1), __decorateClass$2([pubSubLock], WTNStream.prototype, "_sendStartPushStreamSignal", 1), __decorateClass$2([pubSubLock], WTNStream.prototype, "_stopLocalStream", 1), __decorateClass$2([pubSubLock], WTNStream.prototype, "_sendStartPullStreamSignal", 1), __decorateClass$2([pubSubLock], WTNStream.prototype, "_unsubscribePublicStream", 1);
var logger$1 = new Logger$1("AudioDeviceManager", 1);
var AudioDeviceManager = class extends eventemitter3Exports.EventEmitter {
  constructor(e) {
    super(), _defineProperty(this, "_audioLevelFetcher", void 0), _defineProperty(this, "_playbackDeviceTestTimer", void 0), _defineProperty(this, "_audioElement", void 0), _defineProperty(this, "_audioTrack", void 0), _defineProperty(this, "_mediaRecorder", void 0), _defineProperty(this, "_recoderTimer", void 0), _defineProperty(this, "_isAudioPlaybackDeviceTesting", false), _defineProperty(this, "_isAudioDeviceRecordTesting", false), _defineProperty(this, "_audioCaptureAndRecoderResolve", void 0), _defineProperty(this, "_onAutoplayFailed", void 0), _defineProperty(this, "_audioPlaybackDeviceId", void 0), this._ctx = e;
  }
  get audioTrack() {
    return this._audioTrack;
  }
  async startAudioPlaybackDeviceTest(e, t) {
    if (this._isAudioPlaybackDeviceTesting || this._isAudioDeviceRecordTesting) throw new SDKError(ErrorCode.REPEAT_DEVICE_TEST, "device test cannot be called repeatedly at the same time.");
    this._isAudioPlaybackDeviceTesting = true, logger$1.info("startAudioPlaybackDeviceTest()", "Invoke");
    try {
      await this._playAudioFile(e, { loop: true });
    } catch (e2) {
      throw logger$1.error("startAudioPlaybackDeviceTest()", "error", e2), this.stopAudioPlaybackDeviceTest(), e2;
    }
    this._startEmitAudioPlaybackDeviceTestVolume(t);
  }
  stopAudioPlaybackDeviceTest() {
    this._isAudioPlaybackDeviceTesting && (logger$1.info("stopAudioPlaybackDeviceTest()", "Invoke"), this._isAudioPlaybackDeviceTesting = false, this._stopEmitAudioPlaybackDeviceTestVolume(), this._destroyAudioElement());
  }
  async startAudioDeviceRecordTest(e, t, i) {
    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 3e4;
    if (!window.MediaRecorder) throw new SDKError(ErrorCode.NOT_SUPPORTED, "Your browser does not support MediaRecorder.");
    if (this._isAudioDeviceRecordTesting || this._isAudioPlaybackDeviceTesting) throw new SDKError(ErrorCode.REPEAT_DEVICE_TEST, "device test cannot be called repeatedly at the same time.");
    this._isAudioDeviceRecordTesting = true, logger$1.info("startAudioDeviceRecordTest()", "Invoke"), this._recoderTimer = setTimeout(() => {
      logger$1.info("startAudioDeviceRecordTest()", "".concat(r, 'ms automatic call method "stopAudioDeviceRecordAndPlayTest"')), this._stopAudioCaptureAndRecoder();
    }, r);
    try {
      this._onAutoplayFailed = t, await this._startAudioCaptureAndRecoder(e, null != i ? i : 100);
    } catch (e2) {
      throw this._isAudioDeviceRecordTesting = false, delete this._onAutoplayFailed, e2;
    }
    delete this._audioCaptureAndRecoderResolve;
  }
  stopAudioDeviceRecordAndPlayTest() {
    logger$1.info("stopAudioDeviceRecordAndPlayTest()", "Invoke"), void 0 !== this._recoderTimer && (clearTimeout(this._recoderTimer), delete this._recoderTimer), this._stopAudioCaptureAndRecoder();
  }
  stopAudioDevicePlayTest() {
    this._isAudioDeviceRecordTesting && (logger$1.info("stopAudioDevicePlayTest()", "Invoke"), this._isAudioDeviceRecordTesting = false, this._mediaRecorder && (this._mediaRecorder.ondataavailable = null), this.stopAudioDeviceRecordAndPlayTest(), this._stopEmitAudioPlaybackDeviceTestVolume(), this._destroyAudioElement()), delete this._onAutoplayFailed;
  }
  getRecordTrack() {
    return this._audioTrack;
  }
  async setSinkId(e) {
    if (logger$1.info("setSinkId()", "Invoke"), void 0 === HTMLAudioElement.prototype.setSinkId) throw new SDKError(ErrorCode.NOT_SUPPORTED, "setSinkId not supported by current browser");
    const t = await dd.getAudioPlaybackDeviceById(e);
    if (!t) throw new SDKError(ErrorCode.INVALID_DEVICE_ID, "audio playback device id ".concat(e, " is invalid"));
    return this._audioPlaybackDeviceId = e, this._setAudioCtxSinkId(), t;
  }
  getSinkId() {
    return this._audioPlaybackDeviceId;
  }
  destroy() {
    logger$1.info("destroy()", "Invoke"), super.removeAllListeners(), this.stopAudioPlaybackDeviceTest(), this.stopAudioDevicePlayTest();
  }
  async _playAudioFile(e, t) {
    return logger$1.info("_playAudioFile()", "Invoke url=".concat(e, "; loop=").concat(t.loop)), new Promise((i, r) => {
      const o = createElement$1("audio", { attributes: { src: e, crossOrigin: "anonymous" } });
      this._audioElement = o, o.loop = t.loop, this._audioLevelFetcher = new AudioLevelFetcher(o), o.onplaying = () => {
        o.onplaying = null, logger$1.info("_playAudioFile()", "onplaying"), i();
      }, o.onerror = async (e2) => {
        var t2;
        logger$1.error("_playAudioFile()", "onerror", e2);
        const i2 = e2.message || (null == o || null === (t2 = o.error) || void 0 === t2 ? void 0 : t2.message);
        r(new SDKError(ErrorCode.LOAD_RESOURCES_FAILED, "Failed to play recorded audio".concat(i2 ? ", reason: ".concat(i2) : ".")));
      }, this._setAudioCtxSinkId().then(() => {
        var e2, t2;
        return null === (e2 = o.play()) || void 0 === e2 || null === (t2 = e2.catch) || void 0 === t2 ? void 0 : t2.call(e2, (e3) => {
          logger$1.warn("_playAudioFile()", "autoplay error", e3);
          const t3 = "Failed to play recorded audio, ".concat(e3.name, ": ").concat(e3.message);
          "NotAllowedError" === e3.name && this._onAutoplayFailed ? this._onAutoplayFailed(() => {
            var e4;
            return Promise.all([null === (e4 = this._audioLevelFetcher) || void 0 === e4 ? void 0 : e4.resume(), o.play()]);
          }) : r(new SDKError(ErrorCode.LOAD_RESOURCES_FAILED, t3));
        });
      });
    });
  }
  _destroyAudioElement() {
    this._audioElement && (logger$1.info("_destroyAudioElement()", "Invoke"), this._audioElement.onplaying = null, this._audioElement.onerror = null, this._audioElement.src = "", delete this._audioElement, "function" == typeof this._audioCaptureAndRecoderResolve && this._audioCaptureAndRecoderResolve());
  }
  _startEmitAudioPlaybackDeviceTestVolume(e) {
    e = Math.max(e, 100), this._audioElement && (logger$1.info("_startEmitAudioPlaybackDeviceTestVolume()", "start timer(".concat(e, "ms)")), this._playbackDeviceTestTimer = self.setInterval(() => {
      this._audioLevelFetcher && this.emit("onAudioPlaybackDeviceTestVolume", this._audioLevelFetcher.getAudioLevel());
    }, e));
  }
  _stopEmitAudioPlaybackDeviceTestVolume() {
    var e;
    void 0 !== this._playbackDeviceTestTimer && (logger$1.info("_stopEmitAudioPlaybackDeviceTestVolume()", "stop timer"), self.clearInterval(this._playbackDeviceTestTimer), delete this._playbackDeviceTestTimer), null === (e = this._audioLevelFetcher) || void 0 === e || e.destroy(), delete this._audioLevelFetcher;
  }
  async _startAudioCaptureAndRecoder(e, t) {
    this._audioTrack = await createMicrophoneAudioTrack(this._ctx, this._ctx.audioProfileManager.getConstraints()), this._audioTrack.setVolume(t + 0.01);
    const i = new MediaStream([this._audioTrack.preprocessingTrack]);
    return logger$1.info("startAudioDeviceRecordTest()", "create microphone track success!"), new Promise((t2, r) => {
      let o;
      "function" == typeof MediaRecorder.isTypeSupported && (o = ["audio/webm", "audio/mp4"].find((e2) => MediaRecorder.isTypeSupported(e2)), logger$1.info("startAudioDeviceRecordTest()", "use mimeType: ".concat(o))), this._mediaRecorder = new MediaRecorder(i, o ? { mimeType: o } : void 0);
      const n = this._mediaRecorder.mimeType;
      this._mediaRecorder.ondataavailable = async (i2) => {
        if (this._isAudioDeviceRecordTesting) {
          var o2;
          logger$1.info("startAudioDeviceRecordTest()", "get recorded file(mimeType: ".concat(n, ")."));
          const s = new Blob([i2.data], { type: n });
          try {
            await this._playAudioFile(_URL.createObjectURL(s), { loop: false });
          } catch (e2) {
            return r(e2);
          }
          this._startEmitAudioPlaybackDeviceTestVolume(e), null === (o2 = this._audioElement) || void 0 === o2 || o2.addEventListener("ended", () => {
            this.stopAudioDevicePlayTest(), t2();
          }), this._audioCaptureAndRecoderResolve = t2;
        } else t2();
      }, this._mediaRecorder.onerror = (e2) => {
        r(new SDKError(ErrorCode.AUDIO_DEVICE_TEST_FAILED, e2.message || "mediaRecorder error"));
      }, this._audioCaptureAndRecoderResolve = t2, this._mediaRecorder.start();
    });
  }
  _stopAudioCaptureAndRecoder() {
    var e;
    this._mediaRecorder && ("recording" === this._mediaRecorder.state && this._mediaRecorder.stop(), delete this._mediaRecorder), null === (e = this._audioTrack) || void 0 === e || e.destroy(), delete this._audioTrack;
  }
  async _setAudioCtxSinkId() {
    let e = this._audioPlaybackDeviceId;
    if (e) {
      "default" === e && (e = "");
      try {
        var t, i;
        null === (t = audioContextManager.getAudioContextInstance()) || void 0 === t || null === (i = t.setSinkId) || void 0 === i || i.call(t, e), logger$1.info("setSinkId", "ctx.sinkId=".concat(e));
      } catch (e2) {
        logger$1.error("setSinkId", "failed, ".concat(e2.name, " - ").concat(e2.message));
      }
    }
  }
};
var getDefaultValue = () => ({ url: "", video: { codec: TRANSCODING_VIDEO_CODEC.H264, width: 640, height: 360, fps: 15, gop: 2, kBitRate: getKBitRate(640, 360, 15) }, audio: { codec: "AAC", kBitRate: 64, sampleRate: 48e3, channels: 2, AACProfile: AAC_PROFILE.LC }, layout: { regions: [], appData: "", backgroundColor: "#000000" } });
function getKBitRate(e, t, i) {
  return e * t <= 288e3 ? i <= 15 ? 800 : 1200 : e * t <= 864e3 ? i <= 15 ? 1200 : 1800 : e * t <= 1152e3 ? i <= 15 ? 1600 : 2400 : e * t <= 2592e3 ? i <= 15 ? 2500 : 3750 : i <= 15 ? 3300 : 5e3;
}
function checkRtmpUrl(e) {
  if ("string" != typeof e || !/^rtmps?:\/\//.test(e)) throw new SDKError(ErrorCode.INVALID_PARAMS, "Invalid rtmp address");
}
function checkTranscodeRegions() {
  let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  if (null == e || !e.length) throw new SDKError(ErrorCode.INVALID_PARAMS, "regions should not be empty.");
  for (const t of e) {
    if ("string" != typeof t.userId) throw new SDKError(ErrorCode.INVALID_PARAMS, "region.userId(".concat(t.userId, ") should be a string."));
    if (checkUserId(t.userId), "boolean" != typeof t.isScreenStream) throw new SDKError(ErrorCode.INVALID_PARAMS, "region.isScreenStream(".concat(t.isScreenStream, ") should be a boolean."));
  }
}
function getTranscodeControlMessage(e, t) {
  var i, r;
  const o = (e2, i2) => {
    const r2 = e2.reduce((e3, t2) => null == e3 ? void 0 : e3[t2], t), o2 = e2.reduce((e3, t2) => null == e3 ? void 0 : e3[t2], getDefaultValue());
    return r2 && i2(r2) ? r2 : o2;
  }, n = (e2) => e2 % 2 == 0 ? e2 : e2 + 1, s = n(o(["video", "width"], (e2) => e2 >= 2 && e2 <= 1920)), a = n(o(["video", "height"], (e2) => e2 >= 2 && e2 <= 1920)), d = o(["video", "fps"], (e2) => e2 >= 1 && e2 <= 60), c2 = (null === (i = t.video) || void 0 === i ? void 0 : i.kBitRate) || 0, l = o(["audio", "sampleRate"], (e2) => !![32e3, 44100, 48e3].find((t2) => t2 === e2 || t2 / 1e3 === e2));
  return { type: "transcode", action: e, transcodeMeta: { transcode: { url: t.url }, control: { protocol: "2.0" }, audio: { codec: o(["audio", "codec"], (e2) => "AAC" === e2), bitRate: 1e3 * o(["audio", "kBitRate"], (e2) => e2 >= 32 && e2 <= 192), sampleRate: l < 100 ? 1e3 * l : l, channels: o(["audio", "channels"], (e2) => [1, 2].includes(e2)), profile: o(["audio", "AACProfile"], (e2) => [AAC_PROFILE.LC, AAC_PROFILE.HEv1, AAC_PROFILE.HEv2].includes(e2)) }, video: { codec: o(["video", "codec"], (e2) => ["H264", "H265"].includes(e2)), fps: d, gop: o(["video", "gop"], (e2) => e2 >= 1 && e2 <= 5) * d, bitRate: 1e3 * (c2 >= 16 && c2 <= 1e4 ? c2 : getKBitRate(s, a, d)), width: s, height: a }, layout: { canvas: { bgnd: o(["layout", "backgroundColor"], (e2) => /^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/.test(e2)) }, regions: (null === (r = t.layout) || void 0 === r || null === (r = r.regions) || void 0 === r ? void 0 : r.map((e2) => ({ alpha: !e2.alpha || Number(e2.alpha) > 1 || Number(e2.alpha) <= 0 ? 1 : Number(e2.alpha), uid: e2.userId, zorder: !e2.zorder || Number(e2.zorder) < 0 || Number(e2.zorder) > 100 ? 0 : Number(e2.zorder), x: !e2.x || Number(e2.x) >= 1 || Number(e2.x) < 0 ? 0 : Number(e2.x), y: !e2.y || Number(e2.y) >= 1 || Number(e2.y) < 0 ? 0 : Number(e2.y), w: !e2.w || Number(e2.w) > 1 || Number(e2.w) <= 0 ? 1 : Number(e2.w), h: !e2.h || Number(e2.h) > 1 || Number(e2.h) <= 0 ? 1 : Number(e2.h), renderMode: e2.renderMode && [1, 2, 3].includes(e2.renderMode) ? e2.renderMode : 1, contentControl: e2.contentControl && [0, 1, 2].includes(e2.contentControl) ? e2.contentControl : 0, screen: !!e2.isScreenStream }))) || [], app_data: o(["layout", "appData"], (e2) => "string" == typeof e2) } } };
}
function checkStartParams(e) {
  var t;
  checkRtmpUrl(e.url), checkTranscodeRegions(null === (t = e.layout) || void 0 === t ? void 0 : t.regions);
}
function checkUpdateParams(e) {
  var t;
  e.url && checkRtmpUrl(e.url), checkTranscodeRegions(null === (t = e.layout) || void 0 === t ? void 0 : t.regions);
}
function getStartParams(e) {
  return getTranscodeControlMessage("started", e);
}
function getUpdateParams(e) {
  return getTranscodeControlMessage("layoutChanged", e);
}
var LiveTranscoding = { getDefaultValue, checkStartParams, checkUpdateParams, getStartParams, getUpdateParams };
var remoteAudioReplayTimer;
var replayRemoteAudioWorkaround = (e) => {
  remoteAudioReplayTimer && clearTimeout(remoteAudioReplayTimer), remoteAudioReplayTimer = setTimeout(() => {
    for (const [t, i] of e) null != t && t.startsWith("mux") && i.forEach((e2) => {
      var t2;
      null === (t2 = e2.audioTrack) || void 0 === t2 || t2.pause();
    });
    for (const [t, i] of e) null != t && t.startsWith("mux") && i.forEach((e2) => {
      var t2;
      null === (t2 = e2.audioTrack) || void 0 === t2 || t2.play();
    });
  }, 2e3);
};
var $ = _export;
var iterate = iterate$6;
var createProperty = createProperty$4;
$({ target: "Object", stat: true }, { fromEntries: function(e) {
  var t = {};
  return iterate(e, function(e2, i) {
    createProperty(t, e2, i);
  }, { AS_ENTRIES: true }), t;
} });
var path = path$e;
var fromEntries$5 = path.Object.fromEntries;
var parent$2 = fromEntries$5;
var fromEntries$4 = parent$2;
var parent$1 = fromEntries$4;
var fromEntries$3 = parent$1;
var parent = fromEntries$3;
var fromEntries$2 = parent;
var fromEntries$1 = fromEntries$2;
var fromEntries2 = fromEntries$1;
var _Object$fromEntries = getDefaultExportFromCjs(fromEntries2);
var _excluded$1 = ["ele", "fakeEle"];
var _excluded2 = ["orgTrack", "mediaTrack", "preprocessingTrack"];
var _excluded3 = ["orgTrack", "mediaTrack", "preprocessingTrack"];
var MEDIA_STATES = ["currentTime", "duration", "ended", "error", "muted", "networkState", "paused", "readyState", "seekable", "sinkId", "src", "volume"];
var AUDIOCONTEXT_STATES = ["currentTime", "sampleRate", "state", "baseLatency", "outputLatency", "sinkId"];
var TRACK_STATES = ["contentHint", "enabled", "id", "kind", "label", "muted", "readyState"];
var TRANSCEIVER_STATES = ["currentDirection", "direction", "mid", "stopped"];
var ac;
async function getStats(e) {
  const t = Date.now();
  let i = [];
  e._ctx.handler && e._ctx.handler._peerConnection && (i = await e._ctx.handler._peerConnection.getStats());
  const r = [];
  return i.forEach((e2) => {
    r.push(e2);
  }), { timestamp: t, stats: r };
}
function formatSrcObject(e) {
  const t = {};
  if (e instanceof MediaStream) {
    t.id = e.id, t.active = e.active;
    const i = e.getTracks();
    t.tracks = i.map((e2) => _Object$fromEntries(TRACK_STATES.map((t2) => [t2, e2[t2]])));
  }
  return t;
}
async function getMediaElementState(e) {
  const t = Date.now(), i = [];
  var r;
  (e._videoPlayer && i.push({ userId: "__local__", mediaType: "video", isScreen: false, isPublic: false, ele: e._videoPlayer._videoDom }), e._screenPlayer && i.push({ userId: "__local__", mediaType: "video", isScreen: true, isPublic: false, ele: e._screenPlayer._videoDom }), e._remoteVideoPlayer && e._remoteVideoPlayer.forEach((e2, t2) => {
    i.push({ userId: t2, mediaType: "video", isScreen: false, isPublic: false, ele: e2 ? e2._videoDom : void 0 });
  }), e._remoteScreenPlayer) && (null === (r = e._remoteScreenPlayer) || void 0 === r || r.forEach((e2, t2) => {
    i.push({ userId: t2, mediaType: "video", isScreen: true, isPublic: false, ele: e2 ? e2._videoDom : void 0 });
  }));
  e._remoteAudioPlayer && e._remoteAudioPlayer.forEach((e2, t2) => {
    i.push({ userId: t2, mediaType: "audio", isScreen: false, isPublic: false, ele: e2 ? e2._audioDom : void 0, fakeEle: e2 ? e2._fakeAudioDom : void 0 });
  }), e._remoteScreenAudioPlayer && e._remoteScreenAudioPlayer.forEach((e2, t2) => {
    i.push({ userId: t2, mediaType: "audio", isScreen: true, isPublic: false, ele: e2 ? e2._audioDom : void 0, fakeEle: e2 ? e2._fakeAudioDom : void 0 });
  }), e._publicStreamVideoPlayer && e._publicStreamVideoPlayer.forEach((e2, t2) => {
    i.push({ userId: t2, mediaType: "video", isScreen: false, isPublic: true, ele: e2 ? e2._videoDom : void 0 });
  }), e._publicStreamAudioPlayer && e._publicStreamAudioPlayer.forEach((e2, t2) => {
    i.push({ userId: t2, mediaType: "audio", isScreen: false, isPublic: true, ele: e2 ? e2._audioDom : void 0, fakeEle: e2 ? e2._fakeAudioDom : void 0 });
  }), e._localVideoTrack && e._localVideoTrack.videoPlayers && e._localVideoTrack.videoPlayers.forEach((e2, t2) => {
    i.push({ playerId: t2.toString(), userId: "__local__", mediaType: "video", isScreen: false, isPublic: false, ele: e2._videoDom });
  }), e._localScreenTrack && e._localScreenTrack.videoPlayers && e._localScreenTrack.videoPlayers.forEach((e2, t2) => {
    i.push({ playerId: t2.toString(), userId: "__local__", mediaType: "video", isScreen: true, isPublic: false, ele: e2._videoDom });
  }), e._room && e._room._remoteStreams && e._room._remoteStreams.forEach((e2, t2) => {
    e2.forEach((e3) => {
      if (e3.audioTrack) {
        const r2 = e3.audioTrack._audioPlayer;
        i.push({ userId: t2, mediaType: "audio", isScreen: e3.isScreen, isPublic: false, ele: r2 ? r2._audioDom : void 0, fakeEle: r2 ? r2._fakeAudioDom : void 0 });
      }
      e3.videoTrack && e3.videoTrack.videoPlayers && e3.videoTrack.videoPlayers.forEach((r2, o2) => {
        i.push({ playerId: o2.toString(), userId: t2, mediaType: "video", isScreen: e3.isScreen, isPublic: false, ele: r2 ? r2._videoDom : void 0 });
      });
    });
  });
  let o = e._publicStreamManager;
  o || (o = e._outsideRoom), o && o.remoteStreams && o.remoteStreams.forEach((e2, t2) => {
    if (e2.audioTrack) {
      const r2 = e2.audioTrack._audioPlayer;
      i.push({ userId: t2, mediaType: "audio", isScreen: false, isPublic: true, ele: r2 ? r2._audioDom : void 0, fakeEle: r2 ? r2._fakeAudioDom : void 0 });
    }
    e2.videoTrack && e2.videoTrack.videoPlayers && e2.videoTrack.videoPlayers.forEach((e3, r2) => {
      i.push({ playerId: r2.toString(), userId: t2, mediaType: "video", isScreen: false, isPublic: true, ele: e3 ? e3._videoDom : void 0 });
    });
  }), e && e._room && e._room._virtualStreams && e._room._virtualStreams.forEach((e2, t2) => {
    if (e2.audioTrack) {
      const r2 = e2.audioTrack._audioPlayer;
      i.push({ userId: "virtualStream-".concat(t2), mediaType: "audio", isScreen: false, isPublic: false, isVirtual: true, ele: r2 ? r2._audioDom : void 0, fakeEle: r2 ? r2._fakeAudioDom : void 0 });
    }
  });
  return { timestamp: t, elementStats: i.map((e2) => {
    let { ele: t2, fakeEle: i2 } = e2, r2 = _objectWithoutProperties(e2, _excluded$1);
    const o2 = _objectSpread2({ ele: _objectSpread2({ srcObject: t2 ? formatSrcObject(t2.srcObject) : void 0 }, _Object$fromEntries(MEDIA_STATES.map((e3) => [e3, t2[e3]]))) }, r2);
    return i2 && (o2.fakeEle = _objectSpread2({ srcObject: formatSrcObject(i2.srcObject) }, _Object$fromEntries(MEDIA_STATES.map((e3) => [e3, i2[e3]])))), o2;
  }) };
}
function findAudioContextInEngine(e) {
  const t = [];
  let i = [];
  e && e._room && e._room._remoteStreams && (i = e._room._remoteStreams.values());
  for (const e2 of i) e2.forEach((e3) => {
    e3.audioTrack && t.push(e3.audioTrack);
  });
  e._localAudioTrack && t.push(e._localAudioTrack), e._localScreenAudioTrack && t.push(e._localScreenAudioTrack);
  for (const e2 of t) {
    if (e2._audioLevelFetcher && e2._audioLevelFetcher._ctx) return e2._audioLevelFetcher._ctx;
    if (e2._ac) return e2._ac;
    if (e2._audioFetchMap && Array.from(e2._audioFetchMap.values()).length) return Array.from(e2._audioFetchMap.values())[0]._ctx;
    if (e2._ap && e2._ap._ac) return e2._ap._ac;
  }
  return null;
}
async function getAudioContextState(e) {
  const t = Date.now(), i = findAudioContextInEngine(e), r = {};
  return i ? (AUDIOCONTEXT_STATES.forEach((e2) => {
    r[e2] = i[e2];
  }), { timestamp: t, acState: r }) : { timestamp: t, acState: void 0 };
}
function getTrack(e) {
  const t = [];
  e._localAudioTrack && t.push({ userId: "__local__", mediaType: "audio", isScreen: false, isPublic: false, isVirtual: false, orgTrack: e._localAudioTrack._originTrack, mediaTrack: e._localAudioTrack._mediaTrack, preprocessingTrack: e._localAudioTrack._preProcessingTrack }), e._localScreenAudioTrack && t.push({ userId: "__local__", mediaType: "audio", isScreen: true, isPublic: false, isVirtual: false, orgTrack: e._localScreenAudioTrack._originTrack, mediaTrack: e._localScreenAudioTrack._mediaTrack, preprocessingTrack: e._localScreenAudioTrack._preProcessingTrack }), e._localVideoTrack && t.push({ userId: "__local__", mediaType: "video", isScreen: false, isPublic: false, isVirtual: false, orgTrack: e._localVideoTrack._originTrack, mediaTrack: e._localVideoTrack._mediaTrack, preprocessingTrack: e._localVideoTrack._preProcessingTrack }), e._localScreenVideoTrack && t.push({ userId: "__local__", mediaType: "video", isScreen: true, isPublic: false, isVirtual: false, orgTrack: e._localScreenVideoTrack._originTrack, mediaTrack: e._localScreenVideoTrack._mediaTrack, preprocessingTrack: e._localScreenVideoTrack._preProcessingTrack }), e._room && e._room._remoteStreams && e._room._remoteStreams.forEach((e2, i2) => {
    e2.forEach((e3) => {
      e3.audioTrack && t.push({ userId: i2, mediaType: "audio", isScreen: e3.isScreen, isPublic: false, isVirtual: false, orgTrack: e3.audioTrack._originTrack, mediaTrack: e3.audioTrack._mediaTrack }), e3.videoTrack && t.push({ userId: i2, mediaType: "video", isScreen: e3.isScreen, isPublic: false, isVirtual: false, orgTrack: e3.videoTrack._originTrack, mediaTrack: e3.videoTrack._mediaTrack });
    });
  });
  let i = e._publicStreamManager;
  return i || (i = e._outsideRoom), i && i.remoteStreams && i.remoteStreams.forEach((e2, i2) => {
    e2.audioTrack && t.push({ userId: i2, mediaType: "audio", isScreen: e2.isScreen, isPublic: true, isVirtual: false, orgTrack: e2.audioTrack._originTrack, mediaTrack: e2.audioTrack._mediaTrack }), e2.videoTrack && t.push({ userId: i2, mediaType: "video", isScreen: e2.isScreen, isPublic: true, isVirtual: false, orgTrack: e2.videoTrack._originTrack, mediaTrack: e2.videoTrack._mediaTrack });
  }), e && e._room && e._room._virtualStreams && e._room._virtualStreams.forEach((e2, i2) => {
    e2.audioTrack && t.push({ userId: "virtualStream-".concat(i2), mediaType: "audio", isScreen: false, isPublic: false, isVirtual: true, orgTrack: e2.audioTrack._originTrack, mediaTrack: e2.audioTrack._mediaTrack }), e2.videoTrack && t.push({ userId: "virtualStream-".concat(i2), mediaType: "video", isScreen: false, isPublic: false, isVirtual: true, orgTrack: e2.videoTrack._originTrack, mediaTrack: e2.videoTrack._mediaTrack });
  }), t;
}
async function getVolumeFromTrack(e, t) {
  if (!e) return;
  const i = new MediaStream();
  i.addTrack(e);
  const r = t.createMediaStreamSource(i), o = t.createAnalyser();
  r.connect(o), "suspended" === t.state && (console.warn(t.state), t.resume());
  const n = new Uint8Array(2048);
  o.getByteTimeDomainData(n), await new Promise((e2) => {
    setTimeout(e2, 50);
  }), o.getByteTimeDomainData(n), await new Promise((e2) => {
    setTimeout(e2, 50);
  });
  let s = 0;
  n.forEach((e2) => s = Math.max(s, Math.abs(e2 - 128)));
  const a = s / 128 * 256, d = a > 2 ? a : 0;
  return r.disconnect(), o.disconnect(), d;
}
async function getVolume(e) {
  const t = Date.now();
  if (ac || (ac = new AudioContext()), "suspended" === ac.state && await new Promise((t2) => {
    const i2 = setTimeout(() => {
      console.warn("[RTC_AMBULANCE] AudioContext resume failed, try to find one in RTCEngine"), ac = findAudioContextInEngine(e), ac && console.warn("[RTC_AMBULANCE] find AudioContext in RTCEngine success"), t2();
    }, 1e3);
    ac.resume().then(() => {
      clearTimeout(i2), t2();
    }, () => {
      clearTimeout(i2), ac = null, t2();
    });
  }), !ac) return void console.error("[RTC_AMBULANCE] get volume is not supported");
  const i = getTrack(e), r = [];
  return await Promise.all(i.filter((e2) => "audio" === e2.mediaType).map(async (e2) => {
    let { orgTrack: t2, mediaTrack: i2, preprocessingTrack: o } = e2;
    const n = _objectSpread2({}, _objectWithoutProperties(e2, _excluded2));
    await Promise.all([getVolumeFromTrack(t2, ac).then((e3) => {
      n.orgTrackVolume = e3;
    }), getVolumeFromTrack(i2, ac).then((e3) => {
      n.mediaTrackVolume = e3;
    }), getVolumeFromTrack(o, ac).then((e3) => {
      n.preprocessingTrackVolume = e3;
    })]), r.push(n);
  })), { timestamp: t, trackVolumes: r };
}
async function getTrackState(e) {
  return { timestamp: Date.now(), trackStates: getTrack(e).map((e2) => {
    let { orgTrack: t, mediaTrack: i, preprocessingTrack: r } = e2, o = _objectWithoutProperties(e2, _excluded3);
    return _objectSpread2({ orgTrack: t ? _Object$fromEntries(TRACK_STATES.map((e3) => [e3, t[e3]])) : void 0, mediaTrack: i ? _Object$fromEntries(TRACK_STATES.map((e3) => [e3, i[e3]])) : void 0, preprocessingTrack: r ? _Object$fromEntries(TRACK_STATES.map((e3) => [e3, r[e3]])) : void 0 }, o);
  }) };
}
function formatSenderOrReceiver(e) {
  if (!e) return;
  const t = { track: e.track ? e.track.id : void 0, transport: { state: e.transport ? e.transport.state : void 0 } };
  return e.transport && e.transport.iceTransport && (t.iceTransport = { state: e.transport.iceTransport.state, role: e.transport.iceTransport.role, gatheringState: e.transport.iceTransport.gatheringState, component: e.transport.iceTransport.component }), t;
}
async function getTranceiverState(e) {
  const t = Date.now();
  let i = [];
  e._ctx._handler && e._ctx._handler._peerConnection && (i = e._ctx._handler._peerConnection.getTransceivers());
  const r = [];
  return i.forEach((e2) => {
    const t2 = _objectSpread2({ sender: formatSenderOrReceiver(e2.sender), receiver: formatSenderOrReceiver(e2.receiver) }, _Object$fromEntries(TRANSCEIVER_STATES.map((t3) => [t3, e2[t3]])));
    r.push(t2);
  }), { timestamp: t, tranceiverStates: r };
}
async function ambulance(e) {
  const t = { stats: [], mediaElementStates: [], audioContextStates: [], volumes: [], trackStates: [], tranceiverStates: [] }, i = [];
  return await new Promise((r) => {
    let o, n = 0;
    const s = () => {
      i.push(getStats(e).then((e2) => {
        t.stats.push(e2);
      }), getMediaElementState(e).then((e2) => {
        t.mediaElementStates.push(e2);
      }), getAudioContextState(e).then((e2) => {
        t.audioContextStates.push(e2);
      }), getVolume(e).then((e2) => {
        t.volumes.push(e2);
      }), getTrackState(e).then((e2) => {
        t.trackStates.push(e2);
      }), getTranceiverState(e).then((e2) => {
        t.tranceiverStates.push(e2);
      })), n++, n >= 10 ? Promise.all(i).then(() => {
        r();
      }) : (clearTimeout(o), o = setTimeout(s, 500));
    };
    o = setTimeout(s, 500);
  }), console.log("RTC_AMBULANCE", t), t;
}
var ContainerCollisionDetector = class {
  constructor() {
    _defineProperty(this, "containers", /* @__PURE__ */ new WeakSet());
  }
  getContainerById(e) {
    return document.getElementById(e);
  }
  registerContainer(e) {
    var t;
    "string" == typeof e && (e = null !== (t = this.getContainerById(e)) && void 0 !== t ? t : void 0);
    return !(!e || this.containers.has(e)) && (this.containers.add(e), true);
  }
  unregisterContainer(e) {
    var t;
    "string" == typeof e && (e = null !== (t = this.getContainerById(e)) && void 0 !== t ? t : void 0);
    return !!e && (this.containers.delete(e), true);
  }
};
var _excluded = ["videoStats", "audioStats"];
var _Class;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (e, t, i, r) => {
  for (var o, n = r > 1 ? void 0 : r ? __getOwnPropDesc$1(t, i) : t, s = e.length - 1; s >= 0; s--) (o = e[s]) && (n = (r ? o(t, i, n) : o(n)) || n);
  return r && n && __defProp$1(t, i, n), n;
};
var _RTCEngine2 = (_Class = class extends EnhancedEventEmitter {
  constructor(e, t, i) {
    var r;
    super(), r = this, _defineProperty(this, "monitor", void 0), _defineProperty(this, "logger", void 0), _defineProperty(this, "_room", void 0), _defineProperty(this, "_wtnStreamManager", void 0), _defineProperty(this, "_appId", void 0), _defineProperty(this, "_localImgVideoTrack", void 0), _defineProperty(this, "_localImgScreenTrack", void 0), _defineProperty(this, "_localScreenVideoTrack", void 0), _defineProperty(this, "_localScreenAudioTrack", void 0), _defineProperty(this, "_tempMixingAudioTrack", void 0), _defineProperty(this, "_localAudioVolume", 100), _defineProperty(this, "_localScreenAudioVolume", 100), _defineProperty(this, "_remoteAudioVolume", /* @__PURE__ */ new Map()), _defineProperty(this, "_remoteScreenAudioVolume", /* @__PURE__ */ new Map()), _defineProperty(this, "_localVideoPlayerConfig", { [StreamIndex$1.STREAM_INDEX_MAIN]: /* @__PURE__ */ new Map(), [StreamIndex$1.STREAM_INDEX_SCREEN]: /* @__PURE__ */ new Map() }), _defineProperty(this, "_remoteVideoPlayerConfig", { [StreamIndex$1.STREAM_INDEX_MAIN]: /* @__PURE__ */ new Map(), [StreamIndex$1.STREAM_INDEX_SCREEN]: /* @__PURE__ */ new Map() }), _defineProperty(this, "_publicStreamIds", /* @__PURE__ */ new Map()), _defineProperty(this, "_dummyMainImage", void 0), _defineProperty(this, "_dummyScreenImage", void 0), _defineProperty(this, "_trackSourceType", void 0), _defineProperty(this, "_liveTranscodeConfig", void 0), _defineProperty(this, "_startCloudProxyTimestamp", void 0), _defineProperty(this, "_pauseAllSubscribeState", { audio: void 0, video: void 0, resumeAudioStreamIds: {}, resumeVideoStreamIds: {} }), _defineProperty(this, "_audioVolumeIndicationTimer", void 0), _defineProperty(this, "_dummyMainTimer", void 0), _defineProperty(this, "_dummyScreenTimer", void 0), _defineProperty(this, "_audioPropertiesReportTimer", null), _defineProperty(this, "_mirrorType", MirrorType.MIRROR_TYPE_RENDER), _defineProperty(this, "_audioMixingManager", void 0), _defineProperty(this, "_pubLock", void 0), _defineProperty(this, "_subLocks", void 0), _defineProperty(this, "_audioCaptureLock", void 0), _defineProperty(this, "_videoCaptureLock", void 0), _defineProperty(this, "_screenCaptureLock", void 0), _defineProperty(this, "_subScreenLocks", void 0), _defineProperty(this, "_rtmClient", void 0), _defineProperty(this, "_messageStatisticsObserver", void 0), _defineProperty(this, "_waitForNewToken", false), _defineProperty(this, "_originIceConfigRequestUrls", void 0), _defineProperty(this, "_originConfigServerUrls", void 0), _defineProperty(this, "_originLogServerUrl", void 0), _defineProperty(this, "_audioDeviceManager", void 0), _defineProperty(this, "_config", void 0), _defineProperty(this, "_needClosePreTrack", false), _defineProperty(this, "_containerCollisionDetector", new ContainerCollisionDetector()), _defineProperty(this, "_ctx", void 0), _defineProperty(this, "_removeDeviceEventHandler", void 0), _defineProperty(this, "_updateMixAudioTrack", async function(e2) {
      var t2;
      let i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : AudioMixingType.PLAYOUT_AND_PUBLISH;
      if (r.logger.info("_updateMixAudioTrack()"), !r._localAudioTrack) return void (e2 && (r._tempMixingAudioTrack = { track: e2, type: i2 }));
      e2 ? (r._localAudioTrack.mixType = i2, r._localAudioTrack.mixedAudioTrack = e2) : (delete r._localAudioTrack.mixType, delete r._localAudioTrack.mixedAudioTrack);
      await (null === (t2 = r._room) || void 0 === t2 ? void 0 : t2.hasPublished()) && await r._updatePublish(), r._wtnStreamManager._updatePushTrack();
    }), _defineProperty(this, "_onVideoDeviceStateChange", (e2) => {
      this.safeEmit(EngineEventsTypes.onVideoDeviceStateChanged, e2);
    }), _defineProperty(this, "_onAudioDeviceStateChange", (e2) => {
      this.safeEmit(EngineEventsTypes.onAudioDeviceStateChanged, e2);
    }), _defineProperty(this, "_onAudioMixingMessage", (e2) => {
      this.safeEmit(EngineEventsTypes.onAudioMixingStateChanged, e2);
    }), _defineProperty(this, "_onAudioMixingAutoplayFailed", (e2) => {
      this.safeEmit(EngineEventsTypes.onAutoplayFailed, e2);
    }), _defineProperty(this, "_revokeAutoplayFailedWorkaround", void 0), this.id = t, this._appId = e, this.monitor = getMonitor(t), this._ctx = new RTCContext(t, e, i), this._pubLock = new PromiseLock2("pubLock"), this._subLocks = /* @__PURE__ */ new Map(), this._subScreenLocks = /* @__PURE__ */ new Map(), this._audioCaptureLock = new PromiseLock2("audioCap"), this._videoCaptureLock = new PromiseLock2("videoCap"), this._screenCaptureLock = new PromiseLock2("screenCap"), this._addDeviceEventHandler(), this._audioDeviceManager = new AudioDeviceManager(this._ctx), this._addSignalingEventHandler(), this._wtnStreamManager = new WTNStream(this._ctx), this._addWTNStreamEventHandler(), isDebuggerMode && (window.__rtc_engine__ = this, window["__rtc_engine__".concat(Math.floor(100 * Math.random() + 1))] = this), this._trackSourceType = { video: VideoSourceType.VIDEO_SOURCE_TYPE_INTERNAL, screenVideo: VideoSourceType.VIDEO_SOURCE_TYPE_INTERNAL, audio: AudioSourceType.AUDIO_SOURCE_TYPE_INTERNAL, screenAudio: AudioSourceType.AUDIO_SOURCE_TYPE_INTERNAL }, this._config = i, this._rtmClient = new RTSClient(this._ctx), this._handleRTMClient(this._rtmClient), this._handleAudioDeviceManager(), this._messageStatisticsObserver = new MessageStatisticsObserver(t), this.logger = new Logger$1("Engine", 0, t), RTSMsgReportor.createRTSMsgReportor(this.id), _RTCEngine2.hasReportNativeDetector || (this.monitor.reportLongString("NativeDetector", JSON.stringify(detectorResults)), _RTCEngine2.hasReportNativeDetector = true), this._initAutoplayFailedWorkaround();
  }
  get appId() {
    return this._appId;
  }
  set appId(e) {
    this._appId = e;
  }
  async updateToken(e) {
    if (this.logger.info("updateToken()", "token: %s", e), checkString(e, "token"), this._room && this._waitForNewToken) return this._waitForNewToken = false, this._room.config.token = e, await this._join(this._room);
    if (!this._room) throw new SDKError(ErrorCode.UPDATE_TOKEN_BEFORE_JOIN, "update token before join room");
    await this._room.updateToken(e);
    const t = [];
    if (this._room.config.tokenPublishPrivilegeExpired && this._room.config.isAutoPublish && this._ctx.visibility && t.push(this._updatePublish({ mediaType: MediaType$1.AUDIO_AND_VIDEO })), this._room.config.tokenSubscribePrivilegeExpired) {
      const { isAutoSubscribeAudio: e2, isAutoSubscribeVideo: i } = this._room.config, r = (e2 ? MediaType$1.AUDIO : 0) | (i ? MediaType$1.VIDEO : 0);
      r && t.push(this._triedResumeAllRemoteStreams(r, true));
    }
    await Promise.allSettled(t);
  }
  async setVideoCaptureDevice(e) {
    if (this.logger.info("setVideoCaptureDevice()", "deviceId: %s", e), checkString(e, "deviceId"), !this._localVideoTrack) return void this._ctx.videoProfile.setCaptureDeviceId(e);
    if (isWeChat && isAndroid) {
      if (this._localVideoTrack.originTrack.getSettings().deviceId === e) return;
    }
    const t = this._ctx.videoProfile.getCaptureConfig(e);
    var i;
    isAndroid && isChrome && chromeVersion >= 85 && chromeVersion <= 91 && (null === (i = this.localVideoTrack) || void 0 === i || i.removePlayerTrack());
    this._needClosePreTrack = this._needClosePreTrack || unsupportedSimultaneousCapture, this._needClosePreTrack && (this._removeLocalTrackEvents(this._localVideoTrack), this._localVideoTrack.destroy(), delete this._localVideoTrack), this.logger.info("setVideoCaptureDevice()", "start createCameraVideoTrack...");
    const r = await createCameraVideoTrack(this._ctx, t).catch((e2) => {
      if (this._localVideoTrack && !this._localVideoTrack.dummy) return this.logger.warn("setVideoCaptureDevice()", "createCameraVideoTrack failed, stop pre VideoTrack."), this._removeLocalTrackEvents(this._localVideoTrack), this._localVideoTrack.destroy(), delete this._localVideoTrack, createCameraVideoTrack(this._ctx, t).then((e3) => (this._needClosePreTrack = true, e3)).catch(async () => {
        this.logger.error("setVideoCaptureDevice()", "createCameraVideoTrack failed, rollback.");
        const t2 = await createCameraVideoTrack(this._ctx);
        throw this._switchTrack(t2), e2;
      });
      throw e2;
    });
    this.logger.success("setVideoCaptureDevice()", "createCameraVideoTrack success."), this._ctx.videoProfile.setCaptureDeviceId(e), this._localVideoTrack && (this._removeLocalTrackEvents(this._localVideoTrack), this._localVideoTrack.destroy());
    const o = this._ctx.videoProfile.getContentHint();
    o && r.setContentHint(o), await this._switchTrack(r);
  }
  async setAudioCaptureDevice(e) {
    var t;
    if (this.logger.info("setAudioCaptureDevice()", "deviceId: %s", e), checkString(e, "deviceId"), this._ctx.audioProfileManager.updateConstraints({ deviceId: { exact: e } }), !this._localAudioTrack) return;
    this._localAudioTrack.destroy(), this._removeLocalTrackEvents(this._localAudioTrack);
    const i = await createMicrophoneAudioTrack(this._ctx, this._ctx.audioProfileManager.getConstraints());
    this._initLocalTrackEvents(i), this._localAudioTrack = i, this._localAudioTrack.setVolume(this._localAudioVolume), this._wtnStreamManager._updatePushTrack(), this._room && null !== (t = this._room.localStream) && void 0 !== t && t.pubAudio && await this._updatePublish();
  }
  _addDeviceEventHandler() {
    dd.on(EngineEventsTypes.onVideoDeviceStateChanged, this._onVideoDeviceStateChange), dd.on(EngineEventsTypes.onAudioDeviceStateChanged, this._onAudioDeviceStateChange), this._removeDeviceEventHandler = () => {
      dd.off(EngineEventsTypes.onVideoDeviceStateChanged, this._onVideoDeviceStateChange), dd.off(EngineEventsTypes.onAudioDeviceStateChanged, this._onAudioDeviceStateChange);
    };
  }
  _addSignalingEventHandler() {
    const e = this._ctx.signalingManager;
    e.on(StateEvent.ON_CONNECTION_STATE_CHANGE, this._onConnectionStateChange.bind(this)), e.on(StateEvent.ON_RECONNECT_FAILED, () => {
      this.safeEmit(EngineEventsTypes.onError, { errorCode: ErrorCode.RECONNECT_FAILED });
    }), e.on(StateEvent.CONNECT_WITH_TCP, () => {
      this.safeEmit(EngineEventsTypes.onIceConnectWithTcp);
    });
  }
  _addWTNStreamEventHandler() {
    this._wtnStreamManager.__onResubscribe = (e) => {
      const t = e.stream;
      t && (t.audioTrack && this._updateAudioPlayerState(t), t.videoTrack && this._updateVideoPlayerState(t));
    }, this._wtnStreamManager.__onRemoteStreamStats = (e) => {
      this.safeEmit(EngineEventsTypes.onPublicStreamStats, e);
    }, this._wtnStreamManager.__onSEIMessageReceived = (e) => {
      this.safeEmit(EngineEventsTypes.onPublicStreamSEIMessageReceived, e);
    }, this._wtnStreamManager.__onPlayerEvents = (e, t, i) => {
      this._initPlayerEvents(e, t, i);
    };
  }
  _addHandlerEventHandler() {
    var e, t, i, r, o, n, s, a, d, c2, l, u, h, _, p, m, S, g, v3, f, y, E, T, b, I, R, C, P, A, O, k, N, w, M, D, L, $2, x, V, U, W, F;
    null === (e = this._room) || void 0 === e || e.on(SignalEvent.ON_ADD_STREAM, this._onAddStream.bind(this)), null === (t = this._room) || void 0 === t || t.on(SignalEvent.ON_REMOVE_STREAM, this._onRemoveStream.bind(this)), null === (i = this._room) || void 0 === i || i.on(SignalEvent.USER_CONNECTION, this._onUserConnection.bind(this)), null === (r = this._room) || void 0 === r || r.on(RoomEvent.ON_USER_LEAVE, this._onUserLeave.bind(this)), null === (o = this._room) || void 0 === o || o.on(RoomEvent.ON_ROOM_ERROR, this._onRoomError.bind(this)), null === (n = this._room) || void 0 === n || n.on(RoomEvent.ON_NETWORK_QUALITY, this._onNetworkQuality.bind(this)), null === (s = this._room) || void 0 === s || s.on(SignalEvent.ON_CUSTOM_MESSAGE, this._onCustomMessage.bind(this)), null === (a = this._room) || void 0 === a || a.on(SignalEvent.USER_MESSAGE_RECEIVED, this._onUserMessageReceived.bind(this)), null === (d = this._room) || void 0 === d || d.on(SignalEvent.USER_BINARY_MESSAGE_RECEIVED, this._onUserBinaryMessageReceived.bind(this)), null === (c2 = this._room) || void 0 === c2 || c2.on(SignalEvent.ON_USER_TOKEN_WILL_EXPIRE, this._onUserTokenWillExpire.bind(this)), null === (l = this._room) || void 0 === l || l.on(SignalEvent.ON_TOKEN_PUBLISH_PRIVILEGE_WILL_EXPIRE, this._onUserTokenPublishPrivilegeWillExpire.bind(this)), null === (u = this._room) || void 0 === u || u.on(SignalEvent.ON_TOKEN_PUBLISH_PRIVILEGE_DID_EXPIRED, this._onUserTokenPublishPrivilegeDidExpired.bind(this)), null === (h = this._room) || void 0 === h || h.on(SignalEvent.ON_TOKEN_SUBSCRIBE_PRIVILEGE_WILL_EXPIRE, this._onUserTokenSubscribePrivilegeWillExpire.bind(this)), null === (_ = this._room) || void 0 === _ || _.on(SignalEvent.ON_TOKEN_SUBSCRIBE_PRIVILEGE_DID_EXPIRED, this._onUserTokenSubscribePrivilegeDidExpired.bind(this)), null === (p = this._room) || void 0 === p || p.on(SignalEvent.POST_PROCESSING_MESSAGE, (e2) => {
      var t2;
      "2.0" === (null == (t2 = e2) ? void 0 : t2.protocol) ? this._onStreamMixingEvent({ error: e2.error, event: e2.eventType, message: e2.message }) : "publicStreamCallback" === e2.type ? this._onPushPublicStreamResult(e2) : "transcodeStatusCallback" === e2.type && this._onLiveTranscodingResult(e2);
    }), null === (m = this._room) || void 0 === m || m.on(StateEvent.ON_VENDOR_CONNECTION_STATE_CHANGE, (e2) => this.safeEmit(EngineEventsTypes.onVendorConnectionStateChanged, e2)), null === (S = this._room) || void 0 === S || S.on(RoomEvent.RESUBSCRIBE, this._onResubscribe.bind(this)), null === (g = this._room) || void 0 === g || g.on(RoomEvent.SUBSCRIBE_PUSH_TRACK, this._onSubscribePushTrack.bind(this)), null === (v3 = this._room) || void 0 === v3 || v3.on(RoomEvent.REMOVE_PUSH_TRACK, this._onRemovePushTrack.bind(this)), null === (f = this._room) || void 0 === f || f.on(RoomEvent.ON_PUBLISH_RESULT, (e2) => {
      var t2, i2, r2;
      e2.state === PublishState.PUBLISH_SUCC && (null === (i2 = this._room) || void 0 === i2 || i2.config.setTokenPublishPrivilegeExpired(false));
      e2.state === PublishState.PUBLISH_FAIL && e2.errorCode === ErrorCode.TOKEN_NO_PUBLISH_PERMISSION && (null === (r2 = this._room) || void 0 === r2 || r2.config.setTokenPublishPrivilegeExpired(true));
      const o2 = !(e2.retry || null === (t2 = this._room) || void 0 === t2 || !t2.config.isAutoPublish);
      o2 && this.safeEmit(EngineEventsTypes.onAutoPublishResult, e2), this.safeEmit(EngineEventsTypes.onPublishResult, { isScreen: e2.isScreen, isAutoPublish: o2, errorCode: e2.errorCode });
    }), null === (y = this._room) || void 0 === y || y.on(RoomEvent.ON_SUBSCRIBE_RESULT, (e2) => {
      var t2;
      e2.state === SubscribeState.SUBSCRIBE_SUCC && (null === (t2 = this._room) || void 0 === t2 || t2.config.setTokenSubscribePrivilegeExpired(false));
      e2.state === SubscribeState.SUBSCRIBE_FAIL && e2.errorCode === ErrorCode.TOKEN_NO_SUBSCRIBE_PERMISSION && this._handleLoseSubscribePrivilege(), this.safeEmit(EngineEventsTypes.onSubscribeResult, { userId: e2.userId, isScreen: e2.isScreen, isAutoSubscribe: false, errorCode: e2.errorCode });
    }), null === (E = this._room) || void 0 === E || E.on(RoomEvent.ON_REMOTE_STREAM_STATS, (e2) => {
      this.safeEmit(EngineEventsTypes.onRemoteStreamStats, e2);
    }), null === (T = this._room) || void 0 === T || T.on(RoomEvent.ON_LOCAL_STREAM_STATS, (e2) => {
      this.safeEmit(EngineEventsTypes.onLocalStreamStats, e2);
    }), null === (b = this._room) || void 0 === b || b.on(RoomEvent.ON_SUBTITLE_STATE_CHANGED, (e2) => {
      this.safeEmit(EngineEventsTypes.onSubtitleStateChanged, e2);
    }), null === (I = this._room) || void 0 === I || I.on(RoomEvent.ON_SUBTITLE_MESSAGE_RECEIVED, (e2) => {
      this.safeEmit(EngineEventsTypes.onSubtitleMessageReceived, e2);
    }), null === (R = this._room) || void 0 === R || R.on(RoomEvent.ON_USER_PUBLISH_STATE_CHANGE, this._onUserPublishStateChange.bind(this)), null === (C = this._room) || void 0 === C || C.on(RoomEvent.ON_USER_START_AUDIO_CAPTURE, (e2, t2) => {
      let { userId: i2 } = e2;
      this._updateAudioPlayerState(t2), this.safeEmit(EngineEventsTypes.onUserStartAudioCapture, { userId: i2 });
    }), null === (P = this._room) || void 0 === P || P.on(RoomEvent.ON_USER_STOP_AUDIO_CAPTURE, (e2) => {
      let { userId: t2 } = e2;
      this.safeEmit(EngineEventsTypes.onUserStopAudioCapture, { userId: t2 });
    }), null === (A = this._room) || void 0 === A || A.on(RoomEvent.ON_USER_START_VIDEO_CAPTURE, (e2) => {
      let { userId: t2 } = e2;
      this.safeEmit(EngineEventsTypes.onUserStartVideoCapture, { userId: t2 });
    }), null === (O = this._room) || void 0 === O || O.on(RoomEvent.ON_USER_STOP_VIDEO_CAPTURE, (e2) => {
      let { userId: t2 } = e2;
      this.safeEmit(EngineEventsTypes.onUserStopVideoCapture, { userId: t2 });
    }), null === (k = this._room) || void 0 === k || k.on(RoomEvent.ON_SEI_MESSAGED_RECEIVED, (e2) => {
      this.safeEmit(EngineEventsTypes.onSEIMessageReceived, e2);
    }), null === (N = this._room) || void 0 === N || N.on(RoomEvent.ON_REMOTE_VIDEO_SIZE_CHANGED, (e2, t2) => {
      this.safeEmit(EngineEventsTypes.onRemoteVideoSizeChanged, e2, t2);
    }), null === (w = this._room) || void 0 === w || w.on(RoomEvent.ON_SIMULCAST_SUBSCRIBE_FALLBACK, (e2) => this.safeEmit(EngineEventsTypes.onSimulcastSubscribeFallback, e2)), null === (M = this._room) || void 0 === M || M.on(RoomEvent.ON_VIDEO_STREAM_BANNED, (e2) => {
      this.safeEmit(EngineEventsTypes.onVideoStreamBanned, { uid: e2.uid, banned: e2.banned });
    }), null === (D = this._room) || void 0 === D || D.on(RoomEvent.ON_AUDIO_STREAM_BANNED, (e2) => {
      this.safeEmit(EngineEventsTypes.onAudioStreamBanned, { uid: e2.uid, banned: e2.banned });
    }), null === (L = this._room) || void 0 === L || L.on(RoomEvent.ON_FORWARD_STREAM_ERROR, (e2) => {
      this.safeEmit(EngineEventsTypes.onForwardStreamError, e2);
    }), null === ($2 = this._room) || void 0 === $2 || $2.on(RoomEvent.ON_REJOIN_WITH_TCP, () => {
      this.safeEmit(EngineEventsTypes.onRejoinWithTcp);
    }), null === (x = this._room) || void 0 === x || x.on(RoomEvent.PUB_RETRY, (e2) => {
      this.safeEmit(EngineEventsTypes.onPublishRetry, e2);
    }), null === (V = this._room) || void 0 === V || V.on(RoomEvent.SUB_RETRY, (e2) => {
      this.safeEmit(EngineEventsTypes.onSubscribeRetry, e2);
    }), null === (U = this._room) || void 0 === U || U.on(RoomEvent.VIDEO_TYPE_CHANGE, (e2) => {
      this.safeEmit(EngineEventsTypes.onSEIStreamUpdate, e2);
    }), null === (W = this._room) || void 0 === W || W.on(RoomEvent.JOIN_SUCCESS, (e2) => {
      this._ctx.isPreConnection || this.safeEmit(EngineEventsTypes.onConnectionStateChanged, { state: e2 ? ConnectionState.CONNECTION_STATE_RECONNECTED : ConnectionState.CONNECTION_STATE_CONNECTED });
    }), null === (F = this._room) || void 0 === F || F.on(RoomEvent.UPDATE_PUBLISH, (e2) => {
      let { streamIndex: t2 } = e2;
      t2 === StreamIndex$1.STREAM_INDEX_MAIN ? this._updatePublish() : t2 === StreamIndex$1.STREAM_INDEX_SCREEN && this._updateScreenPublish();
    });
  }
  safeEmit(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];
    if (isReportCallback(e)) {
      if (e === EngineEventsTypes.onRemoteStreamStats) {
        const e2 = getParameter("UPLOAD_REMOTE_STATS"), t2 = getParameter("FORCE_ENABLED_REPORT_CALLBACKS").includes("onRemoteStreamStats"), r2 = i[0], { videoStats: o, audioStats: n } = r2, s = _objectWithoutProperties(r2, _excluded);
        i[0] = _objectSpread2({}, s), (e2 & MediaType$1.VIDEO || t2) && (i[0].videoStats = o), (e2 & MediaType$1.AUDIO || t2) && (i[0].audioStats = n);
      }
      reportRtcSdkCallback(this.id, e, i);
    }
    return super.safeEmit(e, ...i);
  }
  _removeHandlerEventHandler() {
    var e;
    null === (e = this._room) || void 0 === e || e.removeAllListeners();
  }
  async connect() {
    await this._ctx.signalingManager.connect();
  }
  async joinRoom(e, t, i, r) {
    var o, n, s, a, d;
    if (this.logger.info("joinRoom()", "token: %o roomId: %o, userInfo: %o, roomConfig: %o", e, t, i, r), isEmpty(e) || checkString(e, "token"), this._room) throw new SDKError(ErrorCode.REPEAT_JOIN, "Already joined");
    null === (o = this._ctx.monitor) || void 0 === o || o.report("rtc_sdk_api_call", { sdk_api_name: "host", message: location.host, error_code: 0 }), checkRoomId(t), checkUserInfo(i);
    const c2 = new RoomContext({ token: e, roomId: t, userInfo: i }, this._ctx);
    return checkRoomConfig(c2.updateRoomConfig(r)), c2.setLiveControlMessage(this._liveTranscodeConfig && LiveTranscoding.getStartParams(this._liveTranscodeConfig)), this._room = new Room(c2, this._ctx), this.monitor.set({ rtc_session_id: this._room.config.sessionId }), this._addHandlerEventHandler(), this._ctx.useCloudProxy && (this._startCloudProxyTimestamp = Date.now()), null === (n = this._localVideoTrack) || void 0 === n || n.setUserId(i.userId), null === (s = this._localScreenVideoTrack) || void 0 === s || s.setUserId(i.userId), null === (a = this._localAudioTrack) || void 0 === a || a.setUserId(i.userId), null === (d = this._localScreenAudioTrack) || void 0 === d || d.setUserId(i.userId), checkSourceLanguage(i), await this._join(this._room);
  }
  async _join(e) {
    try {
      var t;
      const i = await e.join();
      return this._waitForNewToken = false, this._ctx.audioProfileManager.setRoomId(e.config.roomId), null !== (t = this._room) && void 0 !== t && t.config.isAutoPublish && (this._ctx.visibility ? this._updatePublish({ invokeByJoinRoom: true, mediaType: MediaType$1.AUDIO_AND_VIDEO }).catch((e2) => {
        this.logger.error("_join", "_updatePublish failed", e2);
      }) : (this.safeEmit(EngineEventsTypes.onAutoPublishResult, { isScreen: false, state: PublishState.PUBLISH_FAIL }), this.safeEmit(EngineEventsTypes.onPublishResult, { isScreen: false, isAutoPublish: true, errorCode: ErrorCode.NO_PUBLISH_PERMISSION }))), this.monitor.set({ rtc_vid: e.config.rtcVid }), RTSMsgReportor.setRoomId(this.id, e.config.roomId), RTSMsgReportor.setUserId(this.id, e.config.userId), i;
    } catch (t2) {
      throw t2.code === ErrorCode.INVALID_TOKEN ? this._waitForNewToken = true : (e.destroy(), this._room === e && delete this._room), t2;
    }
  }
  async leaveRoom() {
    let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    this.logger.info("leaveRoom()");
    const t = this._room;
    delete this._room, this._ctx.resetPubSubLock(ResetPubSubLockReason.LEAVE), this._ctx.callId = void 0, e ? await (null == t ? void 0 : t.leave(e)) : null == t || t.leave(e).catch(), this._removeHandlerEventHandler(), this._subLocks = /* @__PURE__ */ new Map(), this._subScreenLocks = /* @__PURE__ */ new Map(), this._ctx.audioProfileManager.setRoomId(), this._liveTranscodeConfig && this.stopLiveTranscoding(), null == t || t.destroy(), this._remoteVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].forEach((e2) => {
      e2.forEach((e3) => {
        const { player: t2, renderDom: i } = e3;
        null == t2 || t2.destroy(), this._containerCollisionDetector.unregisterContainer(i);
      });
    }), this._remoteVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].clear(), this._remoteVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_SCREEN].forEach((e2) => {
      e2.forEach((e3) => {
        const { player: t2, renderDom: i } = e3;
        null == t2 || t2.destroy(), this._containerCollisionDetector.unregisterContainer(i);
      });
    }), this._remoteVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_SCREEN].clear(), this._publicStreamIds = /* @__PURE__ */ new Map(), RTSMsgReportor.setRoomId(this.id, ""), RTSMsgReportor.setUserId(this.id, ""), this.monitor.set({ rtc_session_id: "", rtc_vid: "" });
  }
  _destroyLocalTrack() {
    this._localAudioTrack && (this._removeLocalTrackEvents(this._localAudioTrack), this._localAudioTrack.destroy(), this._localAudioTrack = void 0), this._localVideoTrack && (this._removeLocalTrackEvents(this._localVideoTrack), this._localVideoTrack.destroy(), this._localVideoTrack = void 0), this._localScreenAudioTrack && (this._removeLocalTrackEvents(this._localScreenAudioTrack), this._localScreenAudioTrack.destroy(), this._localScreenAudioTrack = void 0), this._localScreenVideoTrack && (this._removeLocalTrackEvents(this._localScreenVideoTrack), this._localScreenVideoTrack.destroy(), this._localScreenVideoTrack = void 0), this._localImgVideoTrack && (this._localImgVideoTrack.stop(), this._localImgVideoTrack = void 0), this._localImgScreenTrack && (this._localImgScreenTrack.stop(), this._localImgScreenTrack = void 0);
  }
  destroy() {
    var e, t, i, r;
    this.logger.info("destroy()"), this.removeAllListeners(), this._removeHandlerEventHandler(), null === (e = this._removeDeviceEventHandler) || void 0 === e || e.call(this), null === (t = this._revokeAutoplayFailedWorkaround) || void 0 === t || t.call(this), null === (i = this._room) || void 0 === i || i.destroy(), this._room = void 0, this._subLocks = /* @__PURE__ */ new Map(), this._subScreenLocks = /* @__PURE__ */ new Map(), this._audioCaptureLock = new PromiseLock2("audioCap"), this._videoCaptureLock = new PromiseLock2("videoCap"), this._screenCaptureLock = new PromiseLock2("screenCap"), this._pauseAllSubscribeState = { audio: void 0, video: void 0, resumeVideoStreamIds: {}, resumeAudioStreamIds: {} }, this._messageStatisticsObserver.destroy(), this.monitor.destroy(), RTSMsgReportor.destroyRTSMsgReportor(this.id), clearInterval(this._audioVolumeIndicationTimer), clearInterval(this._dummyMainTimer), clearInterval(this._dummyScreenTimer), this._audioVolumeIndicationTimer = void 0, this._stopAudioPropertiesReport(), this._destroyLocalTrack(), null === (r = this._audioMixingManager) || void 0 === r || r.destroy(), this._rtmClient.destroy(), this._wtnStreamManager.destroy(), this._publicStreamIds = /* @__PURE__ */ new Map(), this._audioDeviceManager.destroy(), this._ctx.destroy(), this._localAudioVolume = 100, this._localScreenAudioVolume = 100, this._remoteAudioVolume.clear(), this._remoteScreenAudioVolume.clear(), this._localVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].forEach((e2) => {
      e2.player.destroy();
    }), this._localVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].clear(), this._localVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_SCREEN].forEach((e2) => {
      e2.player.destroy();
    }), this._localVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_SCREEN].clear(), this._remoteVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].forEach((e2) => {
      e2.forEach((e3) => {
        e3.player.destroy();
      });
    }), this._remoteVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].clear(), this._remoteVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_SCREEN].forEach((e2) => {
      e2.forEach((e3) => {
        e3.player.destroy();
      });
    }), this._remoteVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_SCREEN].clear();
  }
  async publishStream(e) {
    this.logger.info("publishStream()", "mediaType: %o", e), this._checkMediaType(e), this._assertNotInRoom(), videoInMediaType(e) && !this._localVideoTrack && this._localImgVideoTrack && (this._localVideoTrack = await createDummyVideoLocalTrack(this._ctx, this._localImgVideoTrack)), await this._updatePublish({ mediaType: e }, true);
  }
  async unpublishStream(e, t) {
    var i;
    if (this.logger.info("unpublishStream()", "mediaType: %o", e), this._checkMediaType(e), this._assertNotInRoom(), t) return null === (i = this._room) || void 0 === i ? void 0 : i.unpublish();
    await this._updatePublish({ mediaType: e, pubState: PubState.UNPUB }, true);
  }
  async publishScreen(e) {
    this.logger.info("publishScreen()", "mediaType: %o", e), this._checkMediaType(e), this._assertNotInRoom();
    try {
      videoInMediaType(e) && !this._localScreenVideoTrack && this._localImgScreenTrack && (this._localScreenVideoTrack = await createDummyScreenVideoLocalTrack(this._ctx, this._localImgScreenTrack)), await this._updateScreenPublish({ mediaType: e, pubState: PubState.PUB });
    } catch (e2) {
      throw e2 instanceof SDKError ? e2 : new SDKError(ErrorCode.UNEXPECTED_ERROR, "unexpected error", e2);
    }
  }
  async unpublishScreen(e) {
    this.logger.info("unpublishScreen()", "mediaType: %o", e), this._checkMediaType(e), this._assertNotInRoom(), await this._updateScreenPublish({ mediaType: e, pubState: PubState.UNPUB });
  }
  async subscribeStream(e, t) {
    return this.logger.info("subscribeStream()", "userId: %o, mediaType: %o", e, t), this._subscribe(false, e, t);
  }
  async _subscribe(e, t, i) {
    var r;
    const o = i;
    if (i === MediaType$1.AUDIO && null !== (r = this._room) && void 0 !== r && r.config.isMultiChatMode()) return void this.logger.warn("subscribeStream()", "due to multiChatMode return");
    const n = this._room.remoteStreams.get(t), s = null == n ? void 0 : n.find((t2) => t2.isScreen === e);
    if (!s) throw new SDKError(ErrorCode.STREAM_NOT_EXIST, "stream not exist");
    const a = this._pauseAllSubscribeState.audio, d = this._pauseAllSubscribeState.video;
    this._pauseAllSubscribeState.audio && (i -= i & MediaType$1.AUDIO), this._pauseAllSubscribeState.video && (i -= i & MediaType$1.VIDEO), this.logger.warn("subscribeStream()", "due to pauseAll mediaType: %o", i);
    const { hasSubscribed: c2 } = s;
    s.originalMediaType = i;
    try {
      var l;
      await this._room.subscribe(s, i), audioInMediaType(i) && this._updateAudioPlayerState(s), videoInMediaType(i) && this._updateVideoPlayerState(s);
      let r2 = 0, n2 = 0;
      if (a !== this._pauseAllSubscribeState.audio && (this._pauseAllSubscribeState.audio ? r2 |= MediaType$1.AUDIO : n2 |= MediaType$1.AUDIO), d !== this._pauseAllSubscribeState.video && (this._pauseAllSubscribeState.video ? r2 |= MediaType$1.VIDEO : n2 |= MediaType$1.VIDEO), r2 && this.pauseAllSubscribedStream(r2), n2 && this.resumeAllSubscribedStream(n2), audioInMediaType(o) && (this._pauseAllSubscribeState.resumeAudioStreamIds[s.streamId] = s.streamId), videoInMediaType(o) && (this._pauseAllSubscribeState.resumeVideoStreamIds[s.streamId] = s.streamId), s.audioTrack || s.videoTrack) {
        var u, h;
        const i2 = !(e || !(null !== (u = this._room) && void 0 !== u && u.config.isAutoSubscribeAudio || null !== (h = this._room) && void 0 !== h && h.config.isAutoSubscribeVideo)), r3 = { userId: t, isScreen: false, state: SubscribeState.SUBSCRIBE_SUCC };
        i2 && this.safeEmit(EngineEventsTypes.onAutoSubscribeResult, r3), this.safeEmit(EngineEventsTypes.onSubscribeResult, { userId: t, isScreen: e, isAutoSubscribe: i2 });
      }
      var _, p;
      if ((null === (l = this._room) || void 0 === l || !l.config.isMultiChatMode()) && !c2 && audioInMediaType(i) && s.hasAudio) null === (_ = s.observer) || void 0 === _ || _.setSubscribeAudio(true);
      if (!c2 && videoInMediaType(i) && s.hasVideo) null === (p = s.observer) || void 0 === p || p.setSubscribeVideo(true);
    } catch (e2) {
      throw e2 instanceof SDKError && e2.code === ErrorCode.TOKEN_NO_SUBSCRIBE_PERMISSION && this._handleLoseSubscribePrivilege(), e2;
    }
  }
  async _handleLoseSubscribePrivilege() {
    var e;
    null === (e = this._room) || void 0 === e || e.config.setTokenSubscribePrivilegeExpired(true);
    try {
      await this._unSubscribeAllRemoteStreams();
    } catch (e2) {
    }
  }
  async unsubscribeStream(e, t) {
    return this.logger.info("unsubscribeStream()", "userId: %o, mediaType: %o", e, t), this._unsubscribe(false, e, t);
  }
  async subscribeScreen(e, t) {
    return this.logger.info("subscribeScreen() userId: %o, mediaType: %o", e, t), this._subscribe(true, e, t);
  }
  async unsubscribeScreen(e, t) {
    return this.logger.info("unsubscribeScreen() userId: %o, mediaType: %o", e, t), this._unsubscribe(true, e, t);
  }
  _unsubscribe(e, t, i, r) {
    var o;
    if (i === MediaType$1.AUDIO && null !== (o = this._room) && void 0 !== o && o.config.isMultiChatMode()) return void this.logger.warn("subscribeStream()", "due to multiChatMode return");
    const n = this._room.remoteStreams.get(t), s = null == n ? void 0 : n.find((t2) => t2.isScreen === e);
    if (!s) throw new SDKError(ErrorCode.STREAM_NOT_EXIST, "stream not exist");
    var a;
    isAndroid && chromeVersion && chromeVersion >= 85 && chromeVersion <= 91 && i !== MediaType$1.AUDIO && (null === (a = s.videoTrack) || void 0 === a || a.stopAll());
    return this._room.unsubscribe(s, i).then(() => {
      r || (audioInMediaType(i) && delete this._pauseAllSubscribeState.resumeAudioStreamIds[s.streamId], videoInMediaType(i) && delete this._pauseAllSubscribeState.resumeVideoStreamIds[s.streamId]);
    });
  }
  async setRemoteVideoConfig(e, t) {
    var i;
    return this.logger.info("setRemoteVideoConfig() userId: %o, remoteVideoConfig: %o", e, t), this._ctx.videoProfile.checkSimulcastApiVersion("old"), checkUserId(e), checkRemoteConfig(t), this._ctx.videoProfile.setRemoteUserVideoConfig(e, t), null === (i = this._room) || void 0 === i ? void 0 : i.updateSubVideoConfig(e).then(() => {
    });
  }
  async setRemoteSimulcastStreamType(e, t) {
    var i;
    this.logger.info("setRemoteSimulcastStreamType()", "userId: %s, streamType: %s", e, t), this._ctx.videoProfile.checkSimulcastApiVersion("new"), checkUserId(e), checkEnum(t, "SimulcastStreamType", [SimulcastStreamType.VIDEO_STREAM_HIGH, SimulcastStreamType.VIDEO_STREAM_MID, SimulcastStreamType.VIDEO_STREAM_LOW]), this._ctx.videoProfile.setRemoteUserVideoConfig(e, t), await (null === (i = this._room) || void 0 === i ? void 0 : i.updateSubVideoConfig(e));
  }
  async startVideoCapture(e) {
    var t, i;
    if (this.logger.info("startVideoCapture()", "deviceId: %s", e), isEmpty(e) || checkString(e, "deviceId"), e && this._ctx.videoProfile.setCaptureDeviceId(e), this._trackSourceType.video === VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, "setVideoSourceType as internal first");
    if (this._localVideoTrack && !this._localVideoTrack.dummy) throw new SDKError(ErrorCode.REPEAT_CAPTURE, "Has already capture");
    let r = {};
    const o = await createCameraVideoTrack(this._ctx), n = this._ctx.videoProfile.getContentHint();
    n && o.setContentHint(n), this._initLocalTrackEvents(o), this._localVideoTrack = o;
    this._localVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].forEach((e2) => {
      var t2, i2;
      null === (t2 = this._localVideoTrack) || void 0 === t2 || t2.setPlayer(e2, this._mirrorType, null === (i2 = this._config) || void 0 === i2 ? void 0 : i2.autoPlayPolicy, this._initPlayerEvents.bind(this));
    });
    r = o.originTrack.getSettings();
    const s = { width: r.width, height: r.height };
    if (this._localVideoTrack.resolution = s, this._ctx.videoProfile.__autoResetVideoEncoderConfig(r), setTimeout(() => this.safeEmit(EngineEventsTypes.onLocalVideoSizeChanged, { streamIndex: StreamIndex$1.STREAM_INDEX_MAIN, info: s })), this._ctx.engineDestroyed) return this._destroyLocalTrack(), r;
    if (this._wtnStreamManager._updatePushTrack(), !this._room) return r;
    const { isAutoPublish: a } = this._room.config;
    return (null !== (t = this._room.localStream) && void 0 !== t && t.pubVideo || a) && this._ctx.visibility && this._updatePublish(), null === (i = this._room.localStream) || void 0 === i || null === (i = i.observer) || void 0 === i || i.setEnableVideo(true), r;
  }
  async getLocalStreamStats() {
    var e;
    return await (null === (e = this._room) || void 0 === e ? void 0 : e.getLocalStreamStats());
  }
  async stopVideoCapture() {
    var e, t;
    if (this.logger.info("stopVideoCapture()"), this._trackSourceType.video === VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, "setVideoSourceType as internal first");
    if (this._localVideoTrack && !this._localVideoTrack.dummy) {
      const e2 = this._ctx.extensionManager.getPluginByName(RTCExtensionType.PRE_PROCESSING, "RTCBeautyExtension");
      e2 && e2.emit("stop"), this._removeLocalTrackEvents(this._localVideoTrack), this._localVideoTrack.destroy(), this._localImgVideoTrack ? this._localVideoTrack.setTrack(this._localImgVideoTrack, { isDummy: true }) : this._localVideoTrack = void 0;
    }
    this._wtnStreamManager._updatePushTrack(), this._room && (null !== (e = this._room.localStream) && void 0 !== e && e.pubVideo && await this._updatePublish(), null === (t = this._room.localStream) || void 0 === t || null === (t = t.observer) || void 0 === t || t.setEnableVideo(false));
  }
  async startAudioCapture(e) {
    var t, i;
    if (this.logger.info("startAudioCapture()", "deviceId: $o", e), isEmpty(e) || checkString(e, "deviceId"), e && this._ctx.audioProfileManager.updateConstraints({ deviceId: { exact: e } }), this._trackSourceType.audio === AudioSourceType.AUDIO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, "setAudioSourceType as internal first");
    if (this._localAudioTrack) throw new SDKError(ErrorCode.REPEAT_CAPTURE, "Has already capture");
    let r = {};
    const o = await createMicrophoneAudioTrack(this._ctx, this._ctx.audioProfileManager.getConstraints());
    r = o.originTrack.getSettings(), this._initLocalTrackEvents(o), this._localAudioTrack = o, this._localAudioTrack.setVolume(this._localAudioVolume);
    const { frameSize: n, callback: s } = this._ctx._localAudioTrackDumpConfig[StreamIndex$1.STREAM_INDEX_MAIN];
    n && s && this._localAudioTrack.setDataFetcher(n, s);
    const { position: a, volume: d } = this._ctx.earMonitorSettings[StreamIndex$1.STREAM_INDEX_MAIN];
    if (a !== EarMonitorPosition.NONE && (this._localAudioTrack.play(a), this._localAudioTrack.setPlaybackVolume(d)), this._tempMixingAudioTrack && (this._localAudioTrack.mixType = this._tempMixingAudioTrack.type, this._localAudioTrack.mixedAudioTrack = this._tempMixingAudioTrack.track, delete this._tempMixingAudioTrack), this._ctx.engineDestroyed) return this._destroyLocalTrack(), r;
    if (this._wtnStreamManager._updatePushTrack(), !this._room) return r;
    const { isAutoPublish: c2 } = this._room.config;
    return (null !== (t = this._room.localStream) && void 0 !== t && t.pubAudio || c2) && this._ctx.visibility && this._updatePublish(), null === (i = this._room.localStream) || void 0 === i || null === (i = i.observer) || void 0 === i || i.setEnableAudio(true), r;
  }
  async stopAudioCapture() {
    var e, t, i;
    if (this.logger.info("stopAudioCapture()"), this._trackSourceType.audio === AudioSourceType.AUDIO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, "setAudioSourceType as internal first");
    this._localAudioTrack && (this._removeLocalTrackEvents(this._localAudioTrack), this._localAudioTrack.destroy()), this._localAudioTrack = void 0, null === (e = this._audioMixingManager) || void 0 === e || e.stopAll(), this._wtnStreamManager._updatePushTrack(), this._room && (null !== (t = this._room.localStream) && void 0 !== t && t.pubAudio && await this._updatePublish(), null === (i = this._room.localStream) || void 0 === i || null === (i = i.observer) || void 0 === i || i.setEnableAudio(false));
  }
  async startAudioAndVideoCapture(e, t) {
    var i, r, o, n;
    this.logger.print("startAudioAndVideoCapture", "optionsOrAudioDeviceId: $o", e, "videoDeviceId: $o", t);
    const { audioDeviceId: s, videoDeviceId: a } = checkAudioAndVideoDeviceId(e, t);
    if (s && this._ctx.audioProfileManager.updateConstraints({ deviceId: { exact: s } }), this._trackSourceType.video === VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL || this._trackSourceType.audio === AudioSourceType.AUDIO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, this._trackSourceType.video === VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL ? "setVideoSourceType as internal first" : "setAudioSourceType as internal first");
    if (this._localVideoTrack && !this._localVideoTrack.dummy) throw new SDKError(ErrorCode.REPEAT_CAPTURE, "video has already capture");
    if (this._localAudioTrack) throw new SDKError(ErrorCode.REPEAT_CAPTURE, "audio has already capture");
    const d = this._ctx.videoProfile.getCaptureConfig(a);
    let c2 = {}, l = {};
    const { audioTrack: u, videoTrack: h } = await createMicrophoneAndCameraTrack(this._ctx, this._ctx.audioProfileManager.getConstraints(), d), _ = this._ctx.videoProfile.getContentHint();
    _ && h.setContentHint(_), a && this._ctx.videoProfile.setCaptureDeviceId(a), this._initLocalTrackEvents(h), this._localVideoTrack = h;
    this._localVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].forEach((e2) => {
      var t2, i2;
      null === (t2 = this._localVideoTrack) || void 0 === t2 || t2.setPlayer(e2, this._mirrorType, null === (i2 = this._config) || void 0 === i2 ? void 0 : i2.autoPlayPolicy, this._initPlayerEvents.bind(this));
    }), this._initLocalTrackEvents(u), this._localAudioTrack = u, this._localAudioTrack.setVolume(this._localAudioVolume);
    const { frameSize: p, callback: m } = this._ctx._localAudioTrackDumpConfig[StreamIndex$1.STREAM_INDEX_MAIN];
    p && m && this._localAudioTrack.setDataFetcher(p, m), this._tempMixingAudioTrack && (this._localAudioTrack.mixType = this._tempMixingAudioTrack.type, this._localAudioTrack.mixedAudioTrack = this._tempMixingAudioTrack.track, delete this._tempMixingAudioTrack);
    let S = h.originTrack;
    c2 = S.getSettings();
    const g = { width: c2.width || 0, height: c2.height || 0 };
    if (this._localVideoTrack.resolution = g, this._ctx.videoProfile.__autoResetVideoEncoderConfig(c2), setTimeout(() => this.safeEmit(EngineEventsTypes.onLocalVideoSizeChanged, { streamIndex: StreamIndex$1.STREAM_INDEX_MAIN, info: g })), S = u.originTrack, l = S.getSettings(), this._ctx.engineDestroyed) return this._destroyLocalTrack(), { audioTrackSettings: l, videoTrackSettings: c2 };
    if (this._wtnStreamManager._updatePushTrack(), !this._room) return { audioTrackSettings: l, videoTrackSettings: c2 };
    const { isAutoPublish: v3 } = this._room.config;
    return (null !== (i = this._room.localStream) && void 0 !== i && i.pubVideo || null !== (r = this._room.localStream) && void 0 !== r && r.pubAudio || v3) && this._ctx.visibility && this._updatePublish(), null === (o = this._room.localStream) || void 0 === o || null === (o = o.observer) || void 0 === o || o.setEnableVideo(true), null === (n = this._room.localStream) || void 0 === n || null === (n = n.observer) || void 0 === n || n.setEnableAudio(true), { audioTrackSettings: l, videoTrackSettings: c2 };
  }
  async startVideoAndAudioCapture(e, t) {
    return this.startAudioAndVideoCapture(t, e);
  }
  getAudioMixingManager() {
    return this.logger.info("getAudioMixingManager()", "invoke"), this._audioMixingManager || (this._audioMixingManager = new AudioMixingManager({ getLocalAudioTrack: () => this._localAudioTrack, updateLocalAudioTrack: this._updateMixAudioTrack, emitMessage: this._onAudioMixingMessage, onAutoPlayFailed: this._onAudioMixingAutoplayFailed }, this.id)), this._audioMixingManager;
  }
  getWTNStreamManager() {
    return this._wtnStreamManager;
  }
  getCallId() {
    var e;
    return null === (e = this._ctx) || void 0 === e ? void 0 : e.callId;
  }
  async startScreenCapture() {
    var e, t, i;
    let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (this.logger.info("startScreenCapture()", "config: %o", r), this._trackSourceType.screenVideo === VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, "setVideoSourceType as internal first");
    if (this._trackSourceType.screenAudio === AudioSourceType.AUDIO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, "setAudioSourceType as internal first");
    const [o, n] = await createScreenTracks(this._ctx, r);
    null == n || n.setVolume(this._localScreenAudioVolume), this._localScreenVideoTrack && !this._localScreenVideoTrack.dummy && (this._removeLocalTrackEvents(this._localScreenVideoTrack), this._localScreenVideoTrack.destroy()), null === (e = this._localScreenAudioTrack) || void 0 === e || e.destroy(), delete this._localScreenAudioTrack, this._localScreenVideoTrack = o;
    const { contentHint: s } = this._ctx.videoProfile.getScreenEncodeConfig();
    s && o.setContentHint(s);
    const a = o.originTrack;
    setTimeout(() => {
      const e2 = a.getSettings(), t2 = { width: e2.width, height: e2.height };
      o.resolution = t2, this.safeEmit(EngineEventsTypes.onLocalVideoSizeChanged, { streamIndex: StreamIndex$1.STREAM_INDEX_SCREEN, info: { width: e2.width, height: e2.height } });
    }, 500), n && (this._localScreenAudioTrack = n, this._initLocalTrackEvents(n));
    this._localVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_SCREEN].forEach((e2) => {
      var t2, i2;
      null === (t2 = this._localScreenVideoTrack) || void 0 === t2 || t2.setPlayer(e2, MirrorType.MIRROR_TYPE_NONE, null === (i2 = this._config) || void 0 === i2 ? void 0 : i2.autoPlayPolicy, this._initPlayerEvents.bind(this));
    }), this._initLocalTrackEvents(this._localScreenVideoTrack, true), (null !== (t = this._room) && void 0 !== t && null !== (t = t.localScreenStream) && void 0 !== t && t.pubAudio || null !== (i = this._room) && void 0 !== i && null !== (i = i.localScreenStream) && void 0 !== i && i.pubVideo) && await this._updateScreenPublish();
  }
  async stopScreenCapture() {
    var e, t, i, r;
    this.logger.info("stopScreenCapture()"), null === (e = this._localScreenVideoTrack) || void 0 === e || e.stopAll(), this._localScreenVideoTrack && (this._localScreenVideoTrack.dummy || (this._removeLocalTrackEvents(this._localScreenVideoTrack), this._localScreenVideoTrack.destroy(), this._localImgScreenTrack && this._localScreenVideoTrack.setTrack(this._localImgScreenTrack, { isDummy: true }))), this._localScreenAudioTrack && (this._removeLocalTrackEvents(this._localScreenAudioTrack), this._localScreenAudioTrack.destroy()), this._localScreenAudioTrack = void 0, null !== (t = this._localScreenVideoTrack) && void 0 !== t && t.dummy || (this._localScreenVideoTrack = void 0), (null !== (i = this._room) && void 0 !== i && null !== (i = i.localScreenStream) && void 0 !== i && i.pubAudio || null !== (r = this._room) && void 0 !== r && null !== (r = r.localScreenStream) && void 0 !== r && r.pubVideo) && await this._updateScreenPublish();
  }
  setLocalVideoPlayer(e, t) {
    var i;
    this.logger.info("setLocalVideoPlayer()", "streamIndex: %o, videoPlayerOption: %o", e, t), checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]);
    const r = e === StreamIndex$1.STREAM_INDEX_MAIN ? this._localVideoTrack : this._localScreenVideoTrack, o = null !== (i = null == t ? void 0 : t.playerId) && void 0 !== i ? i : DEFAULT_PLAYER_ID;
    if (null == t || !t.renderDom) {
      var n, s;
      null === (n = this._localVideoPlayerConfig[e].get(o)) || void 0 === n || null === (n = n.player) || void 0 === n || n.destroy(), null == r || r.removePlayer(o);
      const t2 = null === (s = this._localVideoPlayerConfig[e].get(o)) || void 0 === s ? void 0 : s.renderDom;
      return this._containerCollisionDetector.unregisterContainer(t2), void this._localVideoPlayerConfig[e].delete(o);
    }
    checkVideoPlayerOption(t);
    const a = this._localVideoPlayerConfig[e].get(o);
    if (!a) {
      var d, c2, l;
      const { renderDom: i2 } = t;
      if (!this._containerCollisionDetector.registerContainer(i2)) return this.monitor.report("rtc_error", { message: "RenderDom is not empty", error_code: RtcErrorCode.DUPLICATE_DOM }), void warnDevelopers("renderDom is not empty");
      const n2 = new VideoPlayer(this._ctx.id, o, _objectSpread2(_objectSpread2({}, t), {}, { isLocal: true, isScreen: e === StreamIndex$1.STREAM_INDEX_SCREEN, userId: null !== (d = t.userId) && void 0 !== d ? d : "_local_" })), s2 = _objectSpread2(_objectSpread2({}, t), {}, { player: n2 });
      return this._localVideoPlayerConfig[e].set(o, s2), null == r || r.setPlayer(s2, e === StreamIndex$1.STREAM_INDEX_MAIN ? this._mirrorType : MirrorType.MIRROR_TYPE_NONE, null === (c2 = this._config) || void 0 === c2 ? void 0 : c2.autoPlayPolicy, this._initPlayerEvents.bind(this)), null === (l = s2.player) || void 0 === l ? void 0 : l.domElement;
    }
    void 0 !== t.renderMode && (null == r || r.setRenderMode(o, t.renderMode), a.renderMode = t.renderMode);
  }
  async startLiveTranscoding(e) {
    var t;
    this.logger.info("startLiveTranscoding()", "transcode: %o", e), LiveTranscoding.checkStartParams(e), this._liveTranscodeConfig = e;
    const i = null === (t = this._room) || void 0 === t ? void 0 : t.config;
    if (i && i.roomId.length + i.userId.length > 126) throw new SDKError(ErrorCode.INVALID_PARAMS, "The roomId+userId must be within 126 bytes");
    try {
      this.safeEmit(EngineEventsTypes.onStreamMixingEvent, { event: StreamMixingEventType.START, error: 0, message: "" }), this._room && this._ctx.signalingManager.isConnected() && await this._room.liveControlMessage(LiveTranscoding.getStartParams(this._liveTranscodeConfig));
    } catch (e2) {
      throw e2 instanceof SDKError ? e2 : new SDKError(ErrorCode.UNEXPECTED_ERROR, "unexpected error", e2);
    }
  }
  async updateLiveTranscoding(e) {
    var t, i;
    if (this.logger.info("updateLiveTranscoding()", "transcode: %o", e), !this._liveTranscodeConfig) return;
    const r = assignIn({}, e);
    delete r.audio, null === (t = r.video) || void 0 === t || delete t.codec, null === (i = r.video) || void 0 === i || delete i.gop, LiveTranscoding.checkUpdateParams(r), this._liveTranscodeConfig = assignIn(this._liveTranscodeConfig, r);
    try {
      var o;
      this.safeEmit(EngineEventsTypes.onStreamMixingEvent, { event: StreamMixingEventType.UPDATE, error: 0, message: "" }), await (null === (o = this._room) || void 0 === o ? void 0 : o.liveControlMessage(LiveTranscoding.getUpdateParams(this._liveTranscodeConfig)));
    } catch (e2) {
      throw e2 instanceof SDKError ? e2 : new SDKError(ErrorCode.UNEXPECTED_ERROR, "unexpected error", e2);
    }
  }
  async stopLiveTranscoding() {
    if (this.logger.info("stopLiveTranscoding()"), this._liveTranscodeConfig) {
      delete this._liveTranscodeConfig;
      try {
        var e;
        this.safeEmit(EngineEventsTypes.onStreamMixingEvent, { event: StreamMixingEventType.STOP, error: 0, message: "" }), await (null === (e = this._room) || void 0 === e ? void 0 : e.liveControlMessage({ action: "stopped", type: "transcode" }));
      } catch (e2) {
        throw e2 instanceof SDKError ? e2 : new SDKError(ErrorCode.UNEXPECTED_ERROR, "unexpected error", e2);
      }
    }
  }
  async startSubtitle(e) {
    var t;
    this.logger.info("startSubtitle()", "config: %o", e), this._assertNotInRoom(), await (null === (t = this._room) || void 0 === t ? void 0 : t.startSubtitle(e));
  }
  async updateSubtitleConfig(e) {
    var t;
    this.logger.info("updateSubtitleConfig()", "config: %o", e), this._assertNotInRoom(), await (null === (t = this._room) || void 0 === t ? void 0 : t.updateSubtitleConfig(e));
  }
  stopSubtitle() {
    var e;
    this.logger.info("stopSubtitle()", "invoke"), null === (e = this._room) || void 0 === e || e.stopSubtitle();
  }
  setBusinessId(e) {
    return this.logger.info("setBusinessId()", "businessId: %s", e), !illegalBusinessId(e) && !this._room && (this._ctx.businessId = e, true);
  }
  async setUserVisibility(e) {
    var t;
    if (this.logger.info("setUserVisibility()", "enable: %o", e), e = !!e, this._ctx.visibility !== e) if (this._room) {
      var i;
      if (this._assertNotInRoom(), this._room.localStream) null === (i = this._room.localStream.observer) || void 0 === i || i.setPublisher(e);
      if (!e) {
        const e2 = await this._pubLock.lock();
        try {
          this._room.unpublish(), this._room.unpublishScreen();
        } finally {
          e2();
        }
      }
      this._ctx.visibility = e;
      try {
        await this._room.updateUserAttributes();
      } catch (t2) {
        throw this._ctx.visibility = !e, t2;
      }
      e && null !== (t = this._room) && void 0 !== t && t.config.isAutoPublish && this._updatePublish({ mediaType: MediaType$1.AUDIO_AND_VIDEO });
    } else this._ctx.visibility = e;
  }
  _initPlayerEvents(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const i = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : StreamIndex$1.STREAM_INDEX_MAIN) === StreamIndex$1.STREAM_INDEX_SCREEN;
    e.on("playback_event", (r) => {
      switch (r.eventName) {
        case "timeupdate":
          if (!e.hasStartPlaying && e instanceof AudioPlayer) {
            var o;
            e.hasStartPlaying = true;
            const t2 = e.userId.replace("_screen", ""), r2 = null === (o = this._room) || void 0 === o || null === (o = o.remoteStreams.get(t2)) || void 0 === o ? void 0 : o.find((e2) => e2.isScreen === i);
            setTimeout(() => {
              var e2;
              const t3 = { is_screen: i, media_type: "audio", codec: null == r2 || null === (e2 = r2.getRemoteStreamStats()) || void 0 === e2 || null === (e2 = e2.audioStats) || void 0 === e2 ? void 0 : e2.codecType };
              this.logger.info("remote_audio_playing", JSON.stringify(t3)), this.monitor.report("remote_audio_playing", t3);
            }, 8e3);
          }
          return;
        case "loadeddata":
          if ("audio" === r.type) {
            var n;
            const r2 = e.userId.replace("_screen", ""), o2 = null === (n = this._room) || void 0 === n || null === (n = n.remoteStreams.get(r2)) || void 0 === n ? void 0 : n.find((e2) => e2.isScreen === i), s2 = () => {
              t ? this.safeEmit(EngineEventsTypes.onFirstPublicStreamAudioFrameDecoded, { publicStreamId: r2 }) : (this.safeEmit(EngineEventsTypes.onAudioFirstFrameDecoded, { userId: r2, isScreen: i }), this.safeEmit(EngineEventsTypes.onRemoteAudioFirstFrame, { userId: r2, isScreen: i })), this.monitor.report("first_remote_audio_render", { stream_id: "", stream_user_id: r2 || "" }, { isScreen: i });
            };
            null == o2 || !o2.observer || o2.observer.audioFirstFrameReceived ? s2() : o2.observer.once("recvAudioFirstFrame", s2);
          } else {
            var s, a;
            const o2 = { userId: e.userId, height: (null === (s = e.domElement) || void 0 === s ? void 0 : s.videoHeight) || 0, width: (null === (a = e.domElement) || void 0 === a ? void 0 : a.videoWidth) || 0, isScreen: i, playerId: e.playerId };
            t ? (o2.publicStreamId = o2.userId, delete o2.userId, delete o2.isScreen, this.safeEmit(EngineEventsTypes.onFirstPublicStreamVideoFrameRendered, o2), this.safeEmit(EngineEventsTypes.onFirstPublicStreamVideoFrameDecoded, o2)) : e.isLocal || (this.safeEmit(EngineEventsTypes.onVideoFirstFrameRendered, o2), this.safeEmit(EngineEventsTypes.onVideoFirstFrameDecoded, o2), this.safeEmit(EngineEventsTypes.onRemoteVideoFirstFrame, o2)), this.monitor.report("first_remote_video_render", { stream_id: "", stream_user_id: r.userId || "" }, { isScreen: i });
          }
          break;
        case "autoplay-error": {
          t && (r.publicStreamId = r.userId), reportRtcInvokeStatus(this.id, "autoplay-error", e instanceof VideoPlayer ? "video" : "audio", 0, r.userId || "");
          const i2 = { userId: r.userId, kind: e instanceof VideoPlayer ? "video" : "audio", mediaType: e instanceof VideoPlayer ? MediaType$1.VIDEO : MediaType$1.AUDIO, streamIndex: e.isScreen ? StreamIndex$1.STREAM_INDEX_SCREEN : StreamIndex$1.STREAM_INDEX_MAIN };
          return e instanceof VideoPlayer && (i2.playerId = e.playerId === DEFAULT_PLAYER_ID ? void 0 : e.playerId), void this.safeEmit(EngineEventsTypes.onAutoplayFailed, i2);
        }
        case "playing": {
          var d;
          const t2 = e.userId.replace("_screen", ""), o2 = null === (d = this._room) || void 0 === d || null === (d = d.remoteStreams.get(t2)) || void 0 === d ? void 0 : d.find((e2) => e2.isScreen === i);
          "video" === r.type && setTimeout(() => {
            var e2, t3, r2, n2, s2, a2, d2, c2, l, u;
            const h = { is_screen: i, media_type: "video", codec: null == o2 || null === (e2 = o2.getRemoteStreamStats()) || void 0 === e2 || null === (e2 = e2.videoStats) || void 0 === e2 ? void 0 : e2.codecType, stats_frame_size_width: null == o2 || null === (t3 = o2.getRemoteStreamStats()) || void 0 === t3 || null === (t3 = t3.videoStats) || void 0 === t3 ? void 0 : t3.frameSizeWidth, stats_frame_size_height: null == o2 || null === (r2 = o2.getRemoteStreamStats()) || void 0 === r2 || null === (r2 = r2.videoStats) || void 0 === r2 ? void 0 : r2.frameSizeHeight, stats_frame_rate_decode: null == o2 || null === (n2 = o2.getRemoteStreamStats()) || void 0 === n2 || null === (n2 = n2.videoStats) || void 0 === n2 ? void 0 : n2.decoderOutputFrameRate, stats_frame_rate_receive: null == o2 || null === (s2 = o2.getRemoteStreamStats()) || void 0 === s2 || null === (s2 = s2.videoStats) || void 0 === s2 ? void 0 : s2.receivedFrameRate, stats_frame_decoder_name: null == o2 || null === (a2 = o2.getRemoteStreamStats()) || void 0 === a2 || null === (a2 = a2.videoStats) || void 0 === a2 ? void 0 : a2.decoderName, stats_gpu_url: Config2.GPU_URL || (null === (d2 = getGpuInfo()) || void 0 === d2 ? void 0 : d2.renderer), track_frame_size_width: null == o2 || null === (c2 = o2.videoTrack) || void 0 === c2 || null === (c2 = c2.originTrack) || void 0 === c2 ? void 0 : c2.getSettings().width, track_frame_size_height: null == o2 || null === (l = o2.videoTrack) || void 0 === l || null === (l = l.originTrack) || void 0 === l ? void 0 : l.getSettings().height, track_frame_rate: null == o2 || null === (u = o2.videoTrack) || void 0 === u || null === (u = u.originTrack) || void 0 === u ? void 0 : u.getSettings().frameRate };
            this.logger.info("remote_video_playing", JSON.stringify(h)), this.monitor.report("remote_video_playing", h);
          }, 8e3);
          break;
        }
      }
      e instanceof VideoPlayer && (r.playerId = e.playerId === DEFAULT_PLAYER_ID ? void 0 : e.playerId), this.safeEmit(EngineEventsTypes.onPlayerEvent, r);
    });
  }
  _initLocalTrackEvents(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    ["track-ended", "track-mute", "track-unmute"].forEach((t2) => {
      e.on(t2, async (e2) => {
        this.monitor.report("rtc_error", { message: "track-".concat(t2, " mediaType: ").concat(e2.originTrack.kind), error_code: RtcErrorCode.TRACK_ERROR, capture_session_id: e2.captureSessionId, media_type: t2, reason: t2 });
        let i = false;
        e2 !== this._localScreenAudioTrack && e2 !== this._localScreenVideoTrack || (i = true);
        const { kind: r } = e2.originTrack, o = e2.sourceType;
        this.safeEmit({ "track-ended": EngineEventsTypes.onTrackEnded, "track-mute": EngineEventsTypes.onTrackMute, "track-unmute": EngineEventsTypes.onTrackUnmute }[t2], { kind: r, isScreen: i }), Config2.DISABLE_IOS_MUTE_WORKAROUND || !isIOS && !isIPad || ("track-mute" === t2 && (internalEventBus.emit(InternalEvent.ON_IOS_LOCAL_TRACK_MUTE, r), "audio" === r && o === SourceType.INTERNAL && (await this.stopAudioCapture(), this.startAudioCapture())), "track-unmute" === t2 && internalEventBus.emit(InternalEvent.ON_IOS_LOCAL_TRACK_UNMUTE, r));
      });
    }), e.on("resolution-change", (e2) => {
      this._ctx.extensionManager.getPluginsByType(RTCExtensionType.PRE_PROCESSING).forEach((i) => {
        var r;
        null == i || null === (r = i.applyConstraints) || void 0 === r || r.call(i, t ? StreamIndex$1.STREAM_INDEX_SCREEN : StreamIndex$1.STREAM_INDEX_MAIN, e2);
      }), this.safeEmit(EngineEventsTypes.onLocalVideoSizeChanged, { streamIndex: t ? StreamIndex$1.STREAM_INDEX_SCREEN : StreamIndex$1.STREAM_INDEX_MAIN, info: e2 });
    }), e.on("needReplaceTrack", () => {
      if (e instanceof LocalAudioTrack) {
        var t2, i;
        e.stopDataFetcher();
        const n = this._ctx._localAudioTrackDumpConfig[null !== (t2 = e.streamIndex) && void 0 !== t2 ? t2 : StreamIndex$1.STREAM_INDEX_MAIN];
        null != n && n.frameSize && null != n && n.callback && e.setDataFetcher(n.frameSize, n.callback);
        const { position: s, volume: a } = this._ctx.earMonitorSettings[null !== (i = e.streamIndex) && void 0 !== i ? i : StreamIndex$1.STREAM_INDEX_MAIN];
        if (s !== EarMonitorPosition.NONE && (e.play(s), e.setPlaybackVolume(a)), this._room) {
          const { streamIndex: t3 } = e;
          var r, o;
          if (t3 === StreamIndex$1.STREAM_INDEX_MAIN) null !== (r = this._room.localStream) && void 0 !== r && r.pubAudio && this._ctx.visibility && this._updatePublish();
          else null !== (o = this._room.localStream) && void 0 !== o && o.pubAudio && this._ctx.visibility && this._updateScreenPublish();
        }
      }
    }), e.on("autoplay-error", (e2) => {
      this.safeEmit(EngineEventsTypes.onAutoplayFailed, e2);
    });
  }
  _removeLocalTrackEvents(e) {
    e.removeAllListeners("track-ended"), e.removeAllListeners("track-mute"), e.removeAllListeners("track-unmute"), e.removeAllListeners("resolution-change");
  }
  setRemoteVideoPlayer(e, t) {
    var i, r, o, n, s, a;
    this.logger.info("setRemoteVideoPlayer()", "streamIndex: %o, videoPlayerOption: %o", e, t), checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), checkVideoPlayerOption(t);
    const { userId: d } = t, c2 = e === StreamIndex$1.STREAM_INDEX_SCREEN, l = null === (i = this._room) || void 0 === i || null === (i = i.remoteStreams.get(d)) || void 0 === i ? void 0 : i.find((e2) => e2.isScreen === c2), u = null == l ? void 0 : l.videoTrack, h = null !== (r = t.playerId) && void 0 !== r ? r : DEFAULT_PLAYER_ID;
    null === (o = this._getRemoteVideoPlayerConfig(e, d, h)) || void 0 === o || null === (o = o.player) || void 0 === o || o.destroy();
    const _ = null === (n = this._getRemoteVideoPlayerConfig(e, d, h)) || void 0 === n ? void 0 : n.renderDom;
    var p;
    if (this._containerCollisionDetector.unregisterContainer(_), !t.renderDom) return null === (p = this._remoteVideoPlayerConfig[e].get(d)) || void 0 === p || p.delete(h), void (null == u || u.removePlayer(h));
    const { renderDom: m } = t;
    if (!this._containerCollisionDetector.registerContainer(m)) return this.monitor.report("rtc_error", { message: "RenderDom is not empty", error_code: RtcErrorCode.DUPLICATE_DOM }), void warnDevelopers("renderDom is not empty");
    const S = new VideoPlayer(this.id, h, _objectSpread2(_objectSpread2({}, t), {}, { isLocal: false, isScreen: c2, userId: d })), g = _objectSpread2(_objectSpread2({}, t), {}, { player: S });
    return this._setRemoteVideoPlayerConfig(e, d, h, g), null == u || u.setPlayer(this.id, g, null === (s = this._config) || void 0 === s ? void 0 : s.autoPlayPolicy, this._initPlayerEvents.bind(this)), l && this._updateVideoPlayerState(l), null === (a = g.player) || void 0 === a ? void 0 : a.domElement;
  }
  setLocalVideoMirrorType(e) {
    var t;
    this.logger.info("setLocalVideoMirrorType()", "mirrorType: %o", e), checkEnum(e, "mirrorType", [MirrorType.MIRROR_TYPE_NONE, MirrorType.MIRROR_TYPE_RENDER]), this._mirrorType = e, null === (t = this.localVideoTrack) || void 0 === t || t.mirror(!!e);
  }
  setRemoteVideoMirrorType(e, t, i) {
    var r;
    this.logger.info("setRemoteVideoMirrorType()", "userId: %s, streamIndex: %o, mirrorType: %o", e, t, i), checkUserId(e), checkEnum(t, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), checkEnum(i, "mirrorType", [MirrorType.MIRROR_TYPE_NONE, MirrorType.MIRROR_TYPE_RENDER]), this._ctx.setUserStreamConf(e, t, { mirrorType: i }), null === (r = this._room) || void 0 === r || null === (r = r.remoteStreams.get(e)) || void 0 === r || null === (r = r.find((e2) => e2.isScreen === (t === StreamIndex$1.STREAM_INDEX_SCREEN))) || void 0 === r || null === (r = r.videoTrack) || void 0 === r || r.mirror(!!i);
  }
  async setAudioPlaybackDevice(e) {
    var t;
    this.logger.info("setAudioPlaybackDevice()", "deviceId: %s", e), checkString(e, "deviceId");
    const i = await this._audioDeviceManager.setSinkId(e);
    null === (t = this._room) || void 0 === t || t.remoteStreams.forEach((t2) => {
      t2.forEach((t3) => {
        var i2;
        null === (i2 = t3.audioTrack) || void 0 === i2 || i2.setPlaybackDevice(e);
      });
    }), this.safeEmit(EngineEventsTypes.onAudioPlaybackDeviceChanged, i), this.monitor.report("rtc_audio_device", { audio_event: "playout_device_switch", message: JSON.stringify(i), error_code: 0 });
  }
  async play(e) {
    var t;
    let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : MediaType$1.AUDIO_AND_VIDEO, r = arguments.length > 2 ? arguments[2] : void 0, o = arguments.length > 3 ? arguments[3] : void 0;
    this.logger.info("play()", "userId: %s, mediaType: %s, streamIndex: %s", e, i, r);
    const n = null != o ? o : DEFAULT_PLAYER_ID, s = !e || e === this._getUserId() || "local_user" === e, a = void 0 === r || r === StreamIndex$1.STREAM_INDEX_MAIN, d = void 0 === r || r === StreamIndex$1.STREAM_INDEX_SCREEN, c2 = i !== MediaType$1.VIDEO, l = i !== MediaType$1.AUDIO, u = [];
    if (s && l) {
      if (a && this._localVideoTrack) {
        this._localVideoTrack.mirror(!!this._mirrorType);
        const e2 = this._localVideoTrack.play(n);
        e2 && u.push(e2);
      }
      if (d && this._localScreenVideoTrack) {
        var h;
        (null === (h = this._localScreenVideoTrack) || void 0 === h ? void 0 : h.manuallyPlay(n)) && u.push();
      }
    }
    this._audioMixingManager && e === this._audioMixingManager.id && u.push(this._audioMixingManager.resumeLocalPlay());
    let _ = [];
    var p;
    (null === (t = this._room) || void 0 === t || t.remoteStreams.forEach((t2, i2) => {
      e && e !== i2 || t2.forEach((e2) => {
        e2.audioTrack && _.push(e2.audioTrack), e2.videoTrack && _.push(e2.videoTrack);
      });
    }), this._wtnStreamManager.__getRemoteStreams().forEach((t2, i2) => {
      e && e !== i2 || (t2.audioTrack && _.push(t2.audioTrack), t2.videoTrack && _.push(t2.videoTrack));
    }), a || (_ = _.filter((e2) => !!e2.isScreen)), d || (_ = _.filter((e2) => !e2.isScreen)), c2 || (_ = _.filter((e2) => "audio" !== e2.mediaType)), l || (_ = _.filter((e2) => "video" !== e2.mediaType)), c2) && (null === (p = this._room) || void 0 === p || p.virtualStreams.forEach((e2) => {
      e2.audioTrack && _.push(e2.audioTrack);
    }));
    return _.forEach((e2) => {
      const t2 = e2.manuallyPlay(n);
      t2 && u.push(t2);
    }), Promise.all(u).then(() => {
    });
  }
  async stop(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : MediaType$1.AUDIO_AND_VIDEO, i = arguments.length > 2 ? arguments[2] : void 0, r = arguments.length > 3 ? arguments[3] : void 0;
    this.logger.info("stop()", "userId: %s, mediaType: %s, streamIndex: %s, playerId: %s", e, t, i, r);
    const o = null != r ? r : DEFAULT_PLAYER_ID, n = !e || e === this._getUserId() || "local_user" === e, s = void 0 === i || i === StreamIndex$1.STREAM_INDEX_MAIN, a = void 0 === i || i === StreamIndex$1.STREAM_INDEX_SCREEN, d = t !== MediaType$1.VIDEO, c2 = t !== MediaType$1.AUDIO;
    if (n && c2 && (s && this._localVideoTrack && this._localVideoTrack.pause(o), a && this._localScreenVideoTrack && this._localScreenVideoTrack.pause(o)), e) {
      var l;
      let t2 = [];
      null === (l = this._room) || void 0 === l || null === (l = l.remoteStreams.get(e)) || void 0 === l || l.forEach((e2) => {
        e2.audioTrack && t2.push(e2.audioTrack), e2.videoTrack && t2.push(e2.videoTrack);
      });
      const i2 = this._wtnStreamManager.__getPublicStreamTrack(e, "audio"), r2 = this._wtnStreamManager.__getPublicStreamTrack(e, "video");
      i2 && t2.push(i2), r2 && t2.push(r2), s || (t2 = t2.filter((e2) => !!e2.isScreen)), a || (t2 = t2.filter((e2) => !e2.isScreen)), d || (t2 = t2.filter((e2) => "audio" !== e2.mediaType)), c2 || (t2 = t2.filter((e2) => "video" !== e2.mediaType)), t2.forEach((e2) => {
        e2.pause(o);
      });
    }
  }
  getAudioVolume(e, t) {
    checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]);
    let i = 0;
    if (t) {
      var r;
      const o = null === (r = this._room) || void 0 === r || null === (r = r.remoteStreams.get(t)) || void 0 === r || null === (r = r.find((t2) => t2.isScreen === (e === StreamIndex$1.STREAM_INDEX_SCREEN))) || void 0 === r ? void 0 : r.audioTrack;
      o && (i = o.getAudioLevel());
    } else {
      const t2 = e === StreamIndex$1.STREAM_INDEX_MAIN ? this._localAudioTrack : this._localScreenAudioTrack;
      t2 && (i = t2.getAudioLevel());
    }
    return { linearVolume: i, nonlinearVolume: getNonlinearVolume(i) };
  }
  setAudioFrameCallback(e, t, i) {
    var r;
    let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 4096;
    if (this.logger.info("setAudioFrameCallback()", "streamIndex: %s, userId: %s, callback: %s, frameSize: %s", e, t, i ? "true" : "false", o), checkEnum(o, "frameSize", [256, 512, 1024, 2048, 4096, 8192, 16384]), void 0 === audioContextManager.isWorkletReady && audioContextManager.getAudioContextInstance(), null === audioContextManager.isWorkletReady) throw this.logger.error("setAudioFrameCallback()", "Not support AudioWorklet"), new SDKError(ErrorCode.NOT_SUPPORTED, "Not support AudioWorklet");
    t ? i ? this._ctx._remoteAudioTrackDumpConfig[e].set(t, { callback: i, frameSize: o }) : this._ctx._remoteAudioTrackDumpConfig[e].delete(t) : this._ctx._localAudioTrackDumpConfig[e] = { callback: i, frameSize: i ? o : void 0 };
    const n = t ? null === (r = this._room) || void 0 === r || null === (r = r.remoteStreams.get(t)) || void 0 === r || null === (r = r.find((t2) => t2.isScreen === (e === StreamIndex$1.STREAM_INDEX_SCREEN))) || void 0 === r ? void 0 : r.audioTrack : e === StreamIndex$1.STREAM_INDEX_MAIN ? this._localAudioTrack : this._localScreenAudioTrack;
    n ? i ? n.setDataFetcher(o, i) : n.stopDataFetcher() : this.logger.warn("setAudioFrameCallback()", "track not found");
  }
  async pauseAllSubscribedStream(e) {
    this.logger.info("pauseAllSubscribedStream()", "mediaType: %o", e), this._checkMediaType(e);
    return (() => {
      audioInMediaType(e) && (this._pauseAllSubscribeState.audio = true), videoInMediaType(e) && (this._pauseAllSubscribeState.video = true);
    })(), this._room ? this._pauseAllRemoteStreams(e) : Promise.resolve();
  }
  async _pauseAllRemoteStreams(e) {
    if (!this._room) return Promise.resolve();
    const t = [];
    return this._room.remoteStreams.forEach((i) => {
      Array.isArray(i) && i.forEach((i2) => {
        if (i2.hasSubscribed) {
          i2.attributes.audiostream && audioInMediaType(e) && (this._pauseAllSubscribeState.resumeAudioStreamIds[i2.streamId] = i2.streamId), i2.attributes.videostream && videoInMediaType(e) && (this._pauseAllSubscribeState.resumeVideoStreamIds[i2.streamId] = i2.streamId);
          const r = this._unsubscribe(i2.isScreen, i2.userId, e, true);
          r && t.push(r);
        }
      });
    }), Promise.all(t).then(() => {
    });
  }
  async resumeAllSubscribedStream(e) {
    this.logger.info("resumeAllSubscribedStream()", "mediaType: %o", e), this._checkMediaType(e);
    if ((() => {
      audioInMediaType(e) && (this._pauseAllSubscribeState.audio = false), videoInMediaType(e) && (this._pauseAllSubscribeState.video = false);
    })(), !this._room) return Promise.resolve();
    await this._triedResumeAllRemoteStreams(e, false);
  }
  async _triedResumeAllRemoteStreams(e, t) {
    if (!this._room) return Promise.resolve();
    if (this._pauseAllSubscribeState.audio && e === MediaType$1.AUDIO) return Promise.resolve();
    if (this._pauseAllSubscribeState.video && e === MediaType$1.VIDEO) return Promise.resolve();
    if (this._pauseAllSubscribeState.video && this._pauseAllSubscribeState.audio && e === MediaType$1.AUDIO_AND_VIDEO) return Promise.resolve();
    const i = [], r = [...Object.keys(this._pauseAllSubscribeState.resumeAudioStreamIds)], o = [...Object.keys(this._pauseAllSubscribeState.resumeVideoStreamIds)];
    return this._room.remoteStreams.forEach((r2) => {
      Array.isArray(r2) && r2.forEach((r3) => {
        if (t && r3.isScreen) return;
        const o2 = this._pauseAllSubscribeState.resumeAudioStreamIds[r3.streamId], n = this._pauseAllSubscribeState.resumeVideoStreamIds[r3.streamId];
        if (o2 && audioInMediaType(e) || n && videoInMediaType(e)) {
          const t2 = this._subscribe(r3.isScreen, r3.userId, e).then(() => {
            o2 && audioInMediaType(e) && delete this._pauseAllSubscribeState.resumeAudioStreamIds[r3.streamId], n && videoInMediaType(e) && delete this._pauseAllSubscribeState.resumeVideoStreamIds[r3.streamId];
          });
          t2 && i.push(t2);
        }
      });
    }), Promise.all(i).then(() => {
      var e2;
      return null === (e2 = this._room) || void 0 === e2 || e2.remoteStreams.forEach((e3) => {
        Array.isArray(e3) && e3.forEach((e4) => {
          this._updateAudioPlayerState(e4), this._updateVideoPlayerState(e4);
        });
      }), Promise.resolve();
    }).finally(() => {
      var e2;
      return null !== (e2 = this._room) && void 0 !== e2 && e2.config.tokenSubscribePrivilegeExpired && (r.forEach((e3) => {
        this._pauseAllSubscribeState.resumeAudioStreamIds[e3] = e3;
      }), o.forEach((e3) => {
        this._pauseAllSubscribeState.resumeVideoStreamIds[e3] = e3;
      })), Promise.resolve();
    });
  }
  async sendUserMessage(e, t) {
    var i;
    checkUserId(e), this._assertNotInRoom();
    const r = Date.now();
    return null === (i = this._room) || void 0 === i || null === (i = i.sendUserMessage(e, t)) || void 0 === i ? void 0 : i.then((t2) => (this._messageStatisticsObserver.countP2PMessage(true, e, false, r, t2), t2.id)).catch((t2) => {
      throw this._messageStatisticsObserver.countP2PMessage(false, e, false, r, t2), t2;
    });
  }
  async sendUserBinaryMessage(e, t) {
    var i;
    checkUserId(e), checkArrayBuffer(t, "message"), this._assertNotInRoom();
    const r = Date.now();
    return null === (i = this._room) || void 0 === i || null === (i = i.sendUserMessage(e, t)) || void 0 === i ? void 0 : i.then((t2) => (this._messageStatisticsObserver.countP2PMessage(true, e, true, r, t2), t2.id)).catch((t2) => {
      throw this._messageStatisticsObserver.countP2PMessage(false, e, true, r, t2), t2;
    });
  }
  async sendRoomMessage(e) {
    var t, i;
    this._assertNotInRoom();
    const r = null === (t = this._room) || void 0 === t ? void 0 : t.config.roomId, o = Date.now();
    return null === (i = this._room) || void 0 === i || null === (i = i.sendRoomMessage(e)) || void 0 === i ? void 0 : i.then((e2) => (this._messageStatisticsObserver.countRoomMessage(true, r, false, o), e2)).catch((e2) => {
      throw this._messageStatisticsObserver.countRoomMessage(false, r, false, o), e2;
    });
  }
  async sendRoomBinaryMessage(e) {
    var t, i;
    this._assertNotInRoom();
    const r = null === (t = this._room) || void 0 === t ? void 0 : t.config.roomId, o = Date.now();
    return null === (i = this._room) || void 0 === i || null === (i = i.sendRoomMessage(e, true)) || void 0 === i ? void 0 : i.then((e2) => (this._messageStatisticsObserver.countRoomMessage(true, r, true, o), e2)).catch((e2) => {
      throw this._messageStatisticsObserver.countRoomMessage(false, r, true, o), e2;
    });
  }
  async setAudioCaptureConfig() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.logger.info("setAudioCaptureConfig()", "config: %o", e), delete e.deviceId, checkSupportedConstraints(e);
    await this._shouldUpdateAudioConf("setAudioCaptureConfig") && this._ctx.audioProfileManager.updateConstraints(e);
  }
  async setVideoCaptureConfig() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return this.logger.info("setVideoCaptureConfig()", "config: %o", e), this._setVideoCaptureConfig(e);
  }
  async _setVideoCaptureConfig() {
    var e;
    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    delete t.deviceId, checkSupportedConstraints(t);
    const i = _objectSpread2(_objectSpread2({}, this._ctx.videoProfile.getCaptureConfig()), t);
    return this._localVideoTrack && await this._localVideoTrack.updateVideoCaptureConfig(i), this._ctx.videoProfile.setCaptureConfig(i), (null === (e = this._localVideoTrack) || void 0 === e ? void 0 : e.originTrack.getSettings()) || {};
  }
  enableSimulcastMode(e) {
    this.logger.info("enableSimulcastMode()", "enabled: %o", e), this._ctx.videoProfile.checkSimulcastApiVersion("old");
    try {
      return this._ctx.videoProfile.setSimulcastMode(e ? VideoSimulcastMode.VIDEO_ON_DEMAND : VideoSimulcastMode.VIDEO_ONLY_ONE, this._room), true;
    } catch (e2) {
      return false;
    }
  }
  async setLocalSimulcastMode(e, t) {
    var i;
    this.logger.info("setLocalSimulcastMode()", "mode: %o, config: %o", e, t), this._ctx.videoProfile.checkSimulcastApiVersion("new"), await this._ctx.videoProfile.setSimulcastMode(e, this._room), await this._ctx.videoProfile.setSubVideoEncodeConfig(t, this._room, this._localVideoTrack);
    await (null === (i = this._room) || void 0 === i ? void 0 : i.hasPublished()) && this._updatePublish();
  }
  async setVideoEncoderConfig(e) {
    var t;
    if (this.logger.info("setVideoEncoderConfig()", "descriptions: %o", e), await this._ctx.videoProfile.setVideoEncodeConfigPolyfill(e), this._localVideoTrack) {
      const e2 = this._ctx.videoProfile.getContentHint();
      e2 && this._localVideoTrack.setContentHint(e2), await this._localVideoTrack.updateVideoCaptureConfig(this._ctx.videoProfile.getCaptureConfig());
    }
    this._updateDummyCaptureImage(StreamIndex$1.STREAM_INDEX_MAIN);
    await (null === (t = this._room) || void 0 === t ? void 0 : t.hasPublished()) && this._updatePublish();
  }
  setVideoEncoderAutoConfigList(e) {
    if (Array.isArray(e)) return _sortInstanceProperty(e).call(e, (e2, t) => e2.maxKbps - t.maxKbps), setVideoEncoderAutoConfigList(e);
  }
  async setScreenEncoderConfig(e) {
    var t;
    this.logger.info("setScreenEncoderConfig()", "description: %o", e), this._ctx.videoProfile.setScreenEncodeConfig(e), this._localScreenVideoTrack && ("16.1" !== safariMinorVersion && await this._localScreenVideoTrack.updateVideoCaptureConfig(e), e.contentHint && this._localScreenVideoTrack.setContentHint(e.contentHint)), this._updateDummyCaptureImage(StreamIndex$1.STREAM_INDEX_SCREEN);
    await (null === (t = this._room) || void 0 === t ? void 0 : t.hasScreenPublished()) && this._updateScreenPublish();
  }
  sendSEIMessage(e, t, i) {
    if (this.logger.info("sendSEIMessage()", "streamIdex: %o, message: %o, repeatCount: %o", e, t, i), !isLegacyEncodedTransformSupported() && !isEncodedTransformSupported()) return warnDevelopers("Your browser does not support sending SEI"), false;
    checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), checkNumber(i, "repeatCount", 0, 30);
    const r = "string" == typeof t ? new Uint8Array(Utils.str2ab(t)) : t;
    if (!t.length) return this.logger.warn("sei message must not be empty"), false;
    let o;
    if (e === StreamIndex$1.STREAM_INDEX_MAIN) {
      var n, s;
      if (!(null !== (n = this._room) && void 0 !== n && null !== (n = n.localStream) && void 0 !== n && n.pubAudio || null !== (s = this._room) && void 0 !== s && null !== (s = s.localStream) && void 0 !== s && s.pubVideo)) return;
      o = this._room.localStream;
    } else {
      var a, d;
      if (!(null !== (a = this._room) && void 0 !== a && null !== (a = a.localScreenStream) && void 0 !== a && a.pubAudio || null !== (d = this._room) && void 0 !== d && null !== (d = d.localScreenStream) && void 0 !== d && d.pubVideo)) return;
      o = this._room.localScreenStream;
    }
    if (r.byteLength > 4096) return void this.logger.warn("sei size must not bigger than 4KB");
    var c2;
    isAndroid || (null === (c2 = this._room) || void 0 === c2 || c2.maybeFillBackFrame2Stream(o));
    const l = genUuid();
    return o.sendSEIMessage({ content: r, uuid: l, repeatCount: i + 1 }), setTimeout(async () => {
      if (!o) return;
      if (await o.revokeSEIMessage(l)) {
        const e2 = "timeout for sei message(id: ".concat(l, ")");
        console.error("[RTC WebSDK] ".concat(e2)), this.monitor.report("rtc_sdk_callback", { sdk_callback_name: "sendSEIMessageTimeout", message: e2, error_code: 400 });
      }
    }, getParameter("SEI_TIME_OUT")), l;
  }
  setAudioVolumeIndicationInterval(e) {
    this.logger.info("setAudioVolumeIndicationInterval()", "interval %o: ", e), ("number" != typeof e || e < 200) && (e = 200);
    let t = [];
    this._audioVolumeIndicationTimer && clearInterval(this._audioVolumeIndicationTimer), this._audioVolumeIndicationTimer = setInterval(() => {
      var e2, i;
      t = [], null === (e2 = this._room) || void 0 === e2 || e2.remoteStreams.forEach((e3, i2) => {
        var r2;
        if (0 === e3.length) return;
        const o = e3.find((e4) => !e4.isScreen), n = null == o || null === (r2 = o.audioTrack) || void 0 === r2 ? void 0 : r2.getAudioLevel();
        t.push({ userId: i2, volume: n || 0 });
      });
      const r = null === (i = this._localAudioTrack) || void 0 === i ? void 0 : i.getAudioLevel();
      t.push({ userId: this._getUserId(), volume: r || 0 }), this.safeEmit(EngineEventsTypes.onAudioVolumeIndication, { speakers: t });
    }, e);
  }
  _sendActiveSpeaker(e, t) {
    if (this._room && this._room.remoteUsers.size >= 1) {
      const i = e[0], r = t.reduce((e2, t2) => e2 && e2.audioPropertiesInfo.nonlinearVolume > t2.audioPropertiesInfo.nonlinearVolume ? e2 : t2, void 0);
      let o;
      if (o = i ? r ? i.audioPropertiesInfo.nonlinearVolume > r.audioPropertiesInfo.nonlinearVolume ? i : r : i : r, o && o.audioPropertiesInfo.nonlinearVolume > -35) {
        let e2;
        e2 = o.streamKey ? this._room.remoteUsers.get(o.streamKey.userId) : this._room.config.userInfo, e2 && this.safeEmit(EngineEventsTypes.onActiveSpeaker, { userId: e2.userId, extraInfo: e2.extraInfo });
      }
    }
  }
  enableAudioPropertiesReport() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.logger.info("enableAudioPropertiesReport()", "config %o: ", e);
    const { enableInBackground: t = true, localMainReportMode: i = LocalMainReportMode.NORMAL, audioReportMode: r = AudioReportMode.MICROPHONE } = e;
    let { interval: o = 100 } = e;
    this._stopAudioPropertiesReport(), o <= 0 || (o = Math.max(100, o), this._audioPropertiesReportTimer = self.setInterval(() => {
      if (!t && "hidden" === document.visibilityState) return;
      const e2 = [], o2 = this._audioDeviceManager.getRecordTrack() || this._localAudioTrack;
      if (o2) {
        var n;
        const t2 = null === (n = this._room) || void 0 === n || null === (n = n.localStream) || void 0 === n ? void 0 : n.audioHasPublish, s = !!this._audioDeviceManager.getRecordTrack(), a = o2.getAudioLevel(r), d = getNonlinearVolume(a), c2 = { streamIndex: StreamIndex$1.STREAM_INDEX_MAIN, audioPropertiesInfo: { linearVolume: a, nonlinearVolume: d } };
        if (t2 || s) e2.push(c2);
        else switch (i) {
          case LocalMainReportMode.DISCONNECT:
            break;
          case LocalMainReportMode.RESET:
            c2.audioPropertiesInfo.linearVolume = 0, c2.audioPropertiesInfo.nonlinearVolume = -127, e2.push(c2);
            break;
          case LocalMainReportMode.NORMAL:
            e2.push(c2);
            break;
          default:
            throw new SDKError(ErrorCode.INVALID_PARAMS, "invalid localMainReportMode: ".concat(i, " in config"));
        }
      }
      if (this._localScreenAudioTrack) {
        const t2 = this._localScreenAudioTrack.getAudioLevel();
        e2.push({ streamIndex: StreamIndex$1.STREAM_INDEX_SCREEN, audioPropertiesInfo: { linearVolume: t2, nonlinearVolume: getNonlinearVolume(t2) } });
      }
      if (this.safeEmit(EngineEventsTypes.onLocalAudioPropertiesReport, e2), this._room) {
        const t2 = [];
        if (this._room.config.isMultiChatMode()) {
          this._room.getActiveSpeakerInMultiChatMode().forEach((e3) => {
            var i2, r2;
            const o3 = 255 * e3.audioLevel;
            t2.push({ streamKey: { userId: e3.userId, streamIndex: StreamIndex$1.STREAM_INDEX_MAIN, roomId: null !== (i2 = null === (r2 = this._room) || void 0 === r2 ? void 0 : r2.config.roomId) && void 0 !== i2 ? i2 : "" }, audioPropertiesInfo: { linearVolume: o3, nonlinearVolume: getNonlinearVolume(o3) } });
          });
        } else this._room.remoteStreams.forEach((e3, i2) => {
          e3.forEach((e4) => {
            if (e4.audioTrack) {
              var r2, o3;
              const n2 = e4.audioTrack.getAudioLevel();
              t2.push({ streamKey: { userId: i2, streamIndex: e4.isScreen ? StreamIndex$1.STREAM_INDEX_SCREEN : StreamIndex$1.STREAM_INDEX_MAIN, roomId: null !== (r2 = null === (o3 = this._room) || void 0 === o3 ? void 0 : o3.config.roomId) && void 0 !== r2 ? r2 : "" }, audioPropertiesInfo: { linearVolume: n2, nonlinearVolume: getNonlinearVolume(n2) } });
            }
          });
        });
        this.safeEmit(EngineEventsTypes.onRemoteAudioPropertiesReport, t2), this._sendActiveSpeaker(e2, t2.filter((e3) => e3.streamKey.streamIndex !== StreamIndex$1.STREAM_INDEX_SCREEN));
      }
    }, o));
  }
  async setVideoSourceType(e, t) {
    this.logger.print("setVideoSourceType()", "index: %o, videoSourceType: %o", e, t), checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), checkEnum(t, "VideoSourceType", [VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL, VideoSourceType.VIDEO_SOURCE_TYPE_INTERNAL]);
    const i = e === StreamIndex$1.STREAM_INDEX_MAIN ? "video" : "screenVideo";
    if (this._trackSourceType[i] !== t) {
      if (this._trackSourceType[i] = t, this.logger.print("setVideoSourceType", "set ".concat(i, " source type to ").concat(t)), this._localVideoTrack && e === StreamIndex$1.STREAM_INDEX_MAIN) {
        var r, o, n;
        let e2 = false;
        if (t === VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL) {
          e2 = true;
          const t2 = this._ctx.extensionManager.getPluginByName(RTCExtensionType.PRE_PROCESSING, "RTCBeautyExtension");
          t2 && t2.emit("stop"), this._removeLocalTrackEvents(this._localVideoTrack), this._localVideoTrack.destroy();
        }
        null === (r = this._localVideoTrack) || void 0 === r || r.destroy(), this._localVideoTrack = void 0;
        const i2 = null === (o = this._room) || void 0 === o ? void 0 : o.config.isAutoPublish;
        var s, a;
        if (e2) null === (s = this._room) || void 0 === s || null === (s = s.localStream) || void 0 === s || null === (s = s.observer) || void 0 === s || s.setEnableVideo(false);
        else null === (a = this._room) || void 0 === a || null === (a = a.localStream) || void 0 === a || null === (a = a.observer) || void 0 === a || a.setPushVideo(false);
        (null !== (n = this._room) && void 0 !== n && null !== (n = n.localStream) && void 0 !== n && n.pubVideo || i2) && await this._updatePublish();
      }
      if (this._localScreenVideoTrack && e === StreamIndex$1.STREAM_INDEX_SCREEN) {
        var d, c2;
        let e2 = false;
        var l, u;
        if (t === VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL && (e2 = true, this._removeLocalTrackEvents(this._localScreenVideoTrack), this._localScreenVideoTrack.destroy()), null === (d = this._localScreenVideoTrack) || void 0 === d || d.destroy(), this._localScreenVideoTrack = void 0, e2) null === (l = this._room) || void 0 === l || null === (l = l.localScreenStream) || void 0 === l || null === (l = l.observer) || void 0 === l || l.setEnableVideo(false);
        else null === (u = this._room) || void 0 === u || null === (u = u.localScreenStream) || void 0 === u || null === (u = u.observer) || void 0 === u || u.setPushVideo(false);
        null !== (c2 = this._room) && void 0 !== c2 && null !== (c2 = c2.localScreenStream) && void 0 !== c2 && c2.pubVideo && await this._updateScreenPublish();
      }
    }
  }
  async setExternalVideoTrack(e, t) {
    if (this.logger.print("setExternalVideoTrack()", "index: %o, track: %o", e, t), checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), checkMediaStreamTrack(t), e === StreamIndex$1.STREAM_INDEX_MAIN) {
      var i, r;
      if (this._trackSourceType.video !== VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, "setVideoSourceType as external first");
      this._localVideoTrack = await createCustomVideoLocalTrack(this._ctx, t);
      const e2 = this._ctx.videoProfile.getContentHint();
      !t.contentHint && e2 && this._localVideoTrack.setContentHint(e2), this._initLocalTrackEvents(this._localVideoTrack), this._localVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].forEach((e3) => {
        var t2, i2;
        null === (t2 = this._localVideoTrack) || void 0 === t2 || t2.setPlayer(e3, this._mirrorType, null === (i2 = this._config) || void 0 === i2 ? void 0 : i2.autoPlayPolicy, this._initPlayerEvents.bind(this));
      });
      const o2 = null === (i = this._room) || void 0 === i ? void 0 : i.config.isAutoPublish;
      (null !== (r = this._room) && void 0 !== r && null !== (r = r.localStream) && void 0 !== r && r.pubVideo || o2) && await this._updatePublish();
    }
    if (e === StreamIndex$1.STREAM_INDEX_SCREEN) {
      var o, n;
      if (this._trackSourceType.screenVideo !== VideoSourceType.VIDEO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, "setVideoSourceType as external first");
      this._localScreenVideoTrack = await createCustomScreenVideoLocalTrack(this._ctx, t), this._initLocalTrackEvents(this._localScreenVideoTrack, true), this._localVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_SCREEN].forEach((e2) => {
        var t2, i2;
        null === (t2 = this._localScreenVideoTrack) || void 0 === t2 || t2.setPlayer(e2, this._mirrorType, null === (i2 = this._config) || void 0 === i2 ? void 0 : i2.autoPlayPolicy, this._initPlayerEvents.bind(this));
      }), null === (o = this._room) || void 0 === o || null === (o = o.localScreenStream) || void 0 === o || null === (o = o.observer) || void 0 === o || o.setPushVideo(true), null !== (n = this._room) && void 0 !== n && null !== (n = n.localScreenStream) && void 0 !== n && n.pubVideo && await this._updateScreenPublish();
    }
  }
  async setAudioSourceType(e, t) {
    this.logger.print("setAudioSourceType()", "index: %o, audioSourceType: %o", e, t), checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), checkEnum(t, "audioSourceType", [AudioSourceType.AUDIO_SOURCE_TYPE_EXTERNAL, AudioSourceType.AUDIO_SOURCE_TYPE_INTERNAL]);
    const i = e === StreamIndex$1.STREAM_INDEX_MAIN ? "audio" : "screenAudio";
    if (this._trackSourceType[i] !== t) {
      if (this._trackSourceType[i] = t, this.logger.print("setVideoSourceType", "set ".concat(i, " source type to ").concat(t)), this._localAudioTrack && e === StreamIndex$1.STREAM_INDEX_MAIN) {
        var r, o;
        let e2 = false;
        this._trackSourceType.audio === AudioSourceType.AUDIO_SOURCE_TYPE_EXTERNAL && (e2 = true, this._removeLocalTrackEvents(this._localAudioTrack), this._localAudioTrack.destroy()), this._localAudioTrack = void 0;
        const t2 = null === (r = this._room) || void 0 === r ? void 0 : r.config.isAutoPublish;
        var n, s;
        if (e2) null === (n = this._room) || void 0 === n || null === (n = n.localStream) || void 0 === n || null === (n = n.observer) || void 0 === n || n.setEnableAudio(false);
        else null === (s = this._room) || void 0 === s || null === (s = s.localStream) || void 0 === s || null === (s = s.observer) || void 0 === s || s.setPushAudio(false);
        (null !== (o = this._room) && void 0 !== o && null !== (o = o.localStream) && void 0 !== o && o.pubAudio || t2) && await this._updatePublish();
      }
      if (this._localScreenAudioTrack && e === StreamIndex$1.STREAM_INDEX_SCREEN) {
        var a;
        let e2 = false;
        var d, c2;
        if (this._trackSourceType.audio === AudioSourceType.AUDIO_SOURCE_TYPE_EXTERNAL && (e2 = true, this._removeLocalTrackEvents(this._localScreenAudioTrack), this._localScreenAudioTrack.destroy()), this._localScreenAudioTrack = void 0, e2) null === (d = this._room) || void 0 === d || null === (d = d.localScreenStream) || void 0 === d || null === (d = d.observer) || void 0 === d || d.setEnableAudio(false);
        else null === (c2 = this._room) || void 0 === c2 || null === (c2 = c2.localScreenStream) || void 0 === c2 || null === (c2 = c2.observer) || void 0 === c2 || c2.setPushAudio(false);
        null !== (a = this._room) && void 0 !== a && null !== (a = a.localScreenStream) && void 0 !== a && a.pubAudio && await this._updateScreenPublish();
      }
    }
  }
  async setExternalAudioTrack(e, t) {
    if (this.logger.print("setExternalAudioTrack()", "index: %o, track: %o", e, t), checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), checkMediaStreamTrack(t), e === StreamIndex$1.STREAM_INDEX_MAIN) {
      var i, r, o;
      if (this._trackSourceType.audio !== AudioSourceType.AUDIO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, "setAudioSourceType as external first");
      this._localAudioTrack = await createCustomAudioLocalTrack(this._ctx, t), this._localAudioTrack.setVolume(this._localAudioVolume), this._initLocalTrackEvents(this._localAudioTrack);
      const e2 = this._ctx._localAudioTrackDumpConfig[StreamIndex$1.STREAM_INDEX_MAIN];
      e2.frameSize && e2.callback && this._localAudioTrack.setDataFetcher(e2.frameSize, e2.callback);
      const { position: n2, volume: s2 } = this._ctx.earMonitorSettings[StreamIndex$1.STREAM_INDEX_MAIN];
      n2 !== EarMonitorPosition.NONE && (this.setEarMonitorMode(StreamIndex$1.STREAM_INDEX_MAIN, n2), this.setEarMonitorVolume(StreamIndex$1.STREAM_INDEX_MAIN, s2));
      const a = null === (i = this._room) || void 0 === i ? void 0 : i.config.isAutoPublish;
      null === (r = this._room) || void 0 === r || null === (r = r.localStream) || void 0 === r || null === (r = r.observer) || void 0 === r || r.setPushAudio(true), (null !== (o = this._room) && void 0 !== o && null !== (o = o.localStream) && void 0 !== o && o.pubAudio || a) && await this._updatePublish();
    }
    if (e === StreamIndex$1.STREAM_INDEX_SCREEN) {
      var n, s;
      if (this._trackSourceType.screenAudio !== AudioSourceType.AUDIO_SOURCE_TYPE_EXTERNAL) throw new SDKError(ErrorCode.STREAM_TYPE_NOT_MATCH, "setAudioSourceType as external first");
      this._localScreenAudioTrack = await createCustomScreenAudioLocalTrack(this._ctx, t), this._localScreenAudioTrack.setVolume(this._localScreenAudioVolume), this._initLocalTrackEvents(this._localScreenAudioTrack);
      const e2 = this._ctx._localAudioTrackDumpConfig[StreamIndex$1.STREAM_INDEX_SCREEN];
      e2.frameSize && e2.callback && this._localScreenAudioTrack.setDataFetcher(e2.frameSize, e2.callback);
      const { position: i2, volume: r2 } = this._ctx.earMonitorSettings[StreamIndex$1.STREAM_INDEX_SCREEN];
      i2 !== EarMonitorPosition.NONE && (this.setEarMonitorMode(StreamIndex$1.STREAM_INDEX_SCREEN, i2), this.setEarMonitorVolume(StreamIndex$1.STREAM_INDEX_SCREEN, r2)), null === (n = this._room) || void 0 === n || null === (n = n.localScreenStream) || void 0 === n || null === (n = n.observer) || void 0 === n || n.setPushAudio(true), null !== (s = this._room) && void 0 !== s && null !== (s = s.localScreenStream) && void 0 !== s && s.pubAudio && await this._updateScreenPublish();
    }
  }
  async login(e, t) {
    return this.logger.info("login()", "token: %o, userInfo: %o", e, t), isEmpty(e) || checkString(e, "token"), checkUserId(t), this._rtmClient.login(e, t);
  }
  async logout() {
    return this.logger.info("logout()"), this._rtmClient.logout();
  }
  async updateLoginToken(e) {
    return this.logger.info("updateLoginToken()", "token: %o", e), isEmpty(e) || checkString(e, "token"), this._rtmClient.updateLoginToken(e);
  }
  async getPeerOnlineStatus(e) {
    return this.logger.info("getPeerOnlineStatus()", "userId: %o", e), checkUserId(e), this._rtmClient.getPeerOnlineStatus(e);
  }
  async sendUserMessageOutsideRoom(e, t) {
    checkUserId(e);
    const i = Date.now();
    return this._rtmClient.sendUserMessageOutsideRoom(e, t).then((t2) => (this._messageStatisticsObserver.countUserMessageOutsideRoom(true, e, false, i, t2), t2.id)).catch((t2) => {
      throw this._messageStatisticsObserver.countUserMessageOutsideRoom(false, e, false, i, t2), t2;
    });
  }
  async sendUserBinaryMessageOutsideRoom(e, t) {
    checkUserId(e), checkArrayBuffer(t, "message");
    const i = Date.now();
    return this._rtmClient.sendUserMessageOutsideRoom(e, t).then((t2) => (this._messageStatisticsObserver.countUserMessageOutsideRoom(true, e, true, i, t2), t2.id)).catch((t2) => {
      throw this._messageStatisticsObserver.countUserMessageOutsideRoom(false, e, true, i, t2), t2;
    });
  }
  async setServerParams(e, t) {
    return this.logger.info("setServerParams()", "signature: %o, url: %0", e, t), this._rtmClient.setServerParams(e, t);
  }
  async sendServerMessage(e) {
    checkString(e, "message");
    const t = Date.now();
    return this._rtmClient.sendServerMessage(e).then((e2) => {
      this._messageStatisticsObserver.countServerMessage(true, false, t, e2);
    }).catch((e2) => {
      throw this._messageStatisticsObserver.countServerMessage(false, false, t, e2), e2;
    });
  }
  async sendServerBinaryMessage(e) {
    checkArrayBuffer(e, "message");
    const t = Date.now();
    return this._rtmClient.sendServerMessage(e).then((e2) => {
      this._messageStatisticsObserver.countServerMessage(true, true, t, e2);
    }).catch((e2) => {
      throw this._messageStatisticsObserver.countServerMessage(false, true, t, e2), e2;
    });
  }
  startCloudProxy(e) {
    if (this._room) throw new SDKError(ErrorCode.START_CLOUD_PROXY_AFTER_JOIN, "[startCloudProxy] should be invoke before join room ");
    if (this.logger.info("startCloudProxy()", e), checkString(e.logProxy, "logProxy"), Array.isArray(e.accessProxy)) for (const t of e.accessProxy) checkString(t, "accessProxy");
    else checkString(e.accessProxy, "accessProxy");
    checkString(e.configProxy, "configProxy"), this._originIceConfigRequestUrls = getParameter("ICE_CONFIG_REQUEST_URLS"), this._originLogServerUrl = getParameter("LOG_SERVER_URL"), this._originConfigServerUrls = getParameter("CONFIG_REQUEST_DOMAINS"), setParameter("ICE_CONFIG_REQUEST_URLS", e.accessProxy), setParameter("LOG_SERVER_URL", getFullLogServerUrl(e.logProxy)), setParameter("CONFIG_REQUEST_DOMAINS", [e.configProxy]), sdkCache.clearAccessNode(this._appId), sdkCache.clearAccessUrls(), this._ctx.useCloudProxy = true;
  }
  stopCloudProxy() {
    var e, t, i;
    if (this._room) throw new SDKError(ErrorCode.STOP_CLOUD_PROXY_BEFORE_LEAVE, "[stopCloudProxy] should be invoke after leave room ");
    this.logger.info("stopCloudProxy()");
    const r = null === (e = this._originIceConfigRequestUrls) || void 0 === e ? void 0 : e.map((e2) => e2.replace("https://", "").replace("/dispatch/v1/AccessInfo?Action=GetAccessInfo", ""));
    setParameter("ICE_CONFIG_REQUEST_URLS", null != r ? r : []), setParameter("LOG_SERVER_URL", null !== (t = this._originLogServerUrl) && void 0 !== t ? t : ""), setParameter("CONFIG_REQUEST_DOMAINS", null !== (i = this._originConfigServerUrls) && void 0 !== i ? i : []), sdkCache.clearAccessNode(this._appId), sdkCache.clearAccessUrls(), this._ctx.useCloudProxy = false, this._startCloudProxyTimestamp = void 0;
  }
  async startPushPublicStream(e, t) {
    var i, r;
    if (this.logger.print("startPushPublicStream()", "publicStreamId: %o, publicStreamParam: %o", e, t), checkPublicStreamId(e), this._assertNotInRoom(), this._publicStreamIds.get(e)) throw new SDKError(ErrorCode.REPEAT_PUSH, "repeat push public media stream");
    this._room && (null === (r = t.layout) || void 0 === r || null === (r = r.regions) || void 0 === r || r.map((e2) => {
      var t2;
      e2.roomId = null === (t2 = this._room) || void 0 === t2 ? void 0 : t2.config.roomId;
    }));
    const o = getPublicStreamControlMessage(e, "started", t);
    return null === (i = this._room) || void 0 === i || null === (i = i.publicStreamControlMessage(o)) || void 0 === i ? void 0 : i.then(() => {
      this._publicStreamIds.set(e, e);
    });
  }
  async updatePublicStreamParam(e, t) {
    var i;
    this.logger.print("startPushPublicStream()", "publicStreamId: %o, publicStreamParam: %o", e, t), checkPublicStreamId(e), this._assertNotInRoom();
    const r = getPublicStreamControlMessage(e, "layoutChanged", t);
    return null === (i = this._room) || void 0 === i ? void 0 : i.publicStreamControlMessage(r);
  }
  async stopPushPublicStream(e) {
    var t;
    return this.logger.print("startPushPublicStream()", "publicStreamId: %o", e), checkPublicStreamId(e), this._assertNotInRoom(), null === (t = this._room) || void 0 === t ? void 0 : t.publicStreamControlMessage({ type: "publicstream", action: "stopped", publicStreamID: e }).then(() => {
      this._publicStreamIds.delete(e);
    });
  }
  async startPlayPublicStream(e) {
    await this._wtnStreamManager.startPlayWTN(null, e, false, false);
  }
  async stopPlayPublicStream(e) {
    await this._wtnStreamManager.stopPlayWTN(e);
  }
  async setAudioProfile(e) {
    this.logger.info("setAudioProfile()", "profile: %o", e);
    await this._shouldUpdateAudioConf("setAudioProfile") && this._ctx.audioProfileManager.setAudioProfile(e);
  }
  async setAudioEncodeMaxBitrate(e) {
    if (this.logger.print("setAudioEncodeMaxBitrate()", e), checkNumber(e, "maxBitrate", 6, 256), this._ctx.audioProfileManager.setCustomMaxBitrate(e), this._ctx.audioProfileManager.customMaxBitrate) {
      var t, i, r, o;
      if (isFirefox && (null !== (t = this._room) && void 0 !== t && null !== (t = t.localStream) && void 0 !== t && t.pubAudio || null !== (i = this._room) && void 0 !== i && null !== (i = i.localScreenStream) && void 0 !== i && i.pubAudio)) throw new SDKError(ErrorCode.NOT_SUPPORTED, "Your browser does not support set audio encode maxBitrate dynamically.");
      await (null === (r = this._room) || void 0 === r ? void 0 : r.setAudioEncodeMaxBitrate(StreamIndex$1.STREAM_INDEX_MAIN, e)), await (null === (o = this._room) || void 0 === o ? void 0 : o.setAudioEncodeMaxBitrate(StreamIndex$1.STREAM_INDEX_SCREEN, e));
    }
  }
  setPublicStreamVideoPlayer(e, t) {
    return this._wtnStreamManager.setWTNRemoteVideoPlayer(e, t);
  }
  async setDummyCaptureImagePath(e, t) {
    return new Promise((i, r) => {
      checkString(t, "filePath");
      const o = new Image();
      o.crossOrigin = "anonymous", o.src = t, o.onload = () => {
        e === StreamIndex$1.STREAM_INDEX_MAIN ? this._dummyMainImage = o : this._dummyScreenImage = o;
        try {
          this._updateDummyCaptureImage(e), i();
        } catch (e2) {
          r(new SDKError(ErrorCode.UNEXPECTED_ERROR, e2.message));
        }
      }, o.onerror = () => {
        r(new SDKError(ErrorCode.UNEXPECTED_ERROR, "Load image error"));
      };
    });
  }
  _updateDummyCaptureImage(e) {
    let t, i;
    if (e === StreamIndex$1.STREAM_INDEX_MAIN ? (t = this._dummyMainImage, i = this._ctx.videoProfile.getVideoEncodeConfig()[0]) : (t = this._dummyScreenImage, i = this._ctx.videoProfile.getScreenEncodeConfig()), !t) return;
    const r = document.createElement("canvas"), o = r.getContext("2d"), n = constraints2number(i.width), s = constraints2number(i.height);
    if (!o) throw new SDKError(ErrorCode.UNEXPECTED_ERROR, "Not support canvas");
    let a, d;
    !n || !s || t.width <= n && t.height <= s ? (a = t.width, d = t.height) : (a = Math.min(n, t.width * s / t.height), d = Math.min(s, t.height * n / t.width)), r.width = a, r.height = d, o.drawImage(t, 0, 0, t.width, t.height, 0, 0, a, d);
    const c2 = window.setInterval(() => {
      t && o.drawImage(t, 0, 0, t.width, t.height, 0, 0, a, d);
    }, 200);
    e === StreamIndex$1.STREAM_INDEX_MAIN ? (clearInterval(this._dummyMainTimer), this._dummyMainTimer = c2) : (clearInterval(this._dummyScreenTimer), this._dummyScreenTimer = c2);
    const l = r.captureStream(5).getVideoTracks()[0];
    var u, h;
    e === StreamIndex$1.STREAM_INDEX_MAIN ? (this._localImgVideoTrack = l, null !== (u = this._localVideoTrack) && void 0 !== u && u.dummy && this._localVideoTrack.setTrack(this._localImgVideoTrack)) : (this._localImgScreenTrack = l, null !== (h = this._localScreenVideoTrack) && void 0 !== h && h.dummy && this._localScreenVideoTrack.setTrack(this._localImgScreenTrack));
  }
  _addListenExtensionEvent(e) {
    e.on("re-capture-audio", () => {
      this._localAudioTrack && this.stopAudioCapture().then(() => {
        this.startAudioCapture();
      });
    }), e.on("re-capture-video", () => {
      this._localVideoTrack && !this._localVideoTrack.dummy && this.stopVideoCapture().then(() => {
        this.startVideoCapture();
      });
    }), e.on("reset-video-effect", async (e2, t) => {
      if (this._localVideoTrack && !this._localVideoTrack.dummy) {
        var i;
        this._localVideoTrack && this._removeLocalTrackEvents(this._localVideoTrack);
        try {
          await this._localVideoTrack.generatePreProcessingTrack();
        } catch (e3) {
          t(e3);
        }
        this._initLocalTrackEvents(this._localVideoTrack), this._localVideoTrack.stopAll(), this._localVideoTrack.playAll(), this.safeEmit(EngineEventsTypes.onLocalStreamTrackChangedByExtension, { streamIndex: StreamIndex$1.STREAM_INDEX_MAIN, type: "video" }), e2(), null !== (i = this._room) && void 0 !== i && null !== (i = i.localStream) && void 0 !== i && i.pubVideo && await this._updatePublish(), this._wtnStreamManager._updatePushTrack();
      }
      e2();
    });
  }
  async registerExtension(e) {
    var t, i, r;
    e.monitor = this.monitor, e.logger = new Logger$1(e.name, 0, this.id);
    try {
      if (!await e.isSupported()) throw new Error("This extension is not supported.");
    } catch (e2) {
      throw new Error("This extension is not supported.");
    }
    getParameter("VERSION") !== e.version && (warnDevelopers("This extension version is ".concat(e.version, ", but the sdk version is ").concat(getParameter("VERSION"), ".")), this.monitor.report("rtc_error", { message: "This extension version is ".concat(e.version, ", but the sdk version is ").concat(getParameter("VERSION"), "."), error_code: -1 }));
    let o = {};
    if ("RTCAIAnsExtension" === e.name) {
      o = { overloadThreshold: getParameter("AINR_OVERLOAD_THRESHOLD"), enableCache: getParameter("AINR_ENABLE_DUMP"), urls: getParameter("AINR_URLS"), cacheTime: getParameter("AINR_CACHE_TIME"), dumpTime: getParameter("AINR_DUMP_TIME") };
    }
    o = filterUndefined(o), await e.init(o), this._ctx.extensionManager.register(e), this._addListenExtensionEvent(e), null === (t = this._localAudioTrack) || void 0 === t || t.generatePreProcessingTrack(), null === (i = this._localVideoTrack) || void 0 === i || i.generatePreProcessingTrack(), null === (r = this._localScreenAudioTrack) || void 0 === r || r.generatePreProcessingTrack();
  }
  defaultTranscoding() {
    return JSON.parse(JSON.stringify(LiveTranscoding.getDefaultValue()));
  }
  async _updatePublish() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.logger.info("_updatePublish()", "config: %o", e);
    if (e = _objectSpread2(_objectSpread2({}, { mediaType: void 0, invokeByJoinRoom: false, pubState: PubState.PUB }), e), !this._ctx.visibility) throw new SDKError(ErrorCode.NO_PUBLISH_PERMISSION, "no publish permission");
    const i = await this._pubLock.lock();
    if (this._room && this._ctx.signalingManager.isConnected()) try {
      await this._room.publish(this._localVideoTrack, this._localAudioTrack, e.mediaType, e.pubState, e.invokeByJoinRoom);
    } catch (e2) {
      throw e2 instanceof SDKError ? (e2.code === ErrorCode.TOKEN_NO_PUBLISH_PERMISSION && this._room.config.setTokenPublishPrivilegeExpired(true), e2) : new SDKError(ErrorCode.UNEXPECTED_ERROR, "unexpected error", e2);
    } finally {
      i();
    }
    else if (i(), t) throw new SDKError(ErrorCode.NOT_CONNECTED_YET, "not connected");
  }
  async startAudioPlaybackDeviceTest(e, t) {
    return this.logger.print("startAudioPlaybackDeviceTest()", "filePath: %o, indicationInterval: %o", e, t), checkString(e, "filePath"), checkNumber(t, "indicationInterval"), await this._audioDeviceManager.startAudioPlaybackDeviceTest(e, t);
  }
  stopAudioPlaybackDeviceTest() {
    this.logger.info("stopAudioPlaybackDeviceTest()"), this._audioDeviceManager.stopAudioPlaybackDeviceTest();
  }
  async startAudioDeviceRecordTest(e, t) {
    this.logger.print("startAudioDeviceRecordTest()", "indicationInterval: %o", e), checkNumber(e, "indicationInterval"), await this._audioDeviceManager.startAudioDeviceRecordTest(e, t, this._localAudioVolume);
  }
  stopAudioDeviceRecordAndPlayTest() {
    this.logger.info("stopAudioDeviceRecordAndPlayTest()"), this._audioDeviceManager.stopAudioDeviceRecordAndPlayTest();
  }
  stopAudioDevicePlayTest() {
    this.logger.info("stopAudioDevicePlayTest()"), this._audioDeviceManager.stopAudioDevicePlayTest();
  }
  setRemoteUserPriority(e, t) {
    var i;
    this.logger.print("setRemoteUserPriority()", "userId: %o, priority: %o", e, t);
    try {
      checkUserId(e), checkEnum(t, "priority", [RemoteUserPriority.HIGH, RemoteUserPriority.MEDIUM, RemoteUserPriority.LOW]);
    } catch (e2) {
      return console.warn(e2), false;
    }
    return this._ctx.userPriority.set(e, t), null === (i = this._room) || void 0 === i || i.updateRemoteUserPriority(e), true;
  }
  async takeLocalSnapshot(e) {
    this.logger.print("takeLocalSnapshot()", "streamIndex: %o", e), checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]);
    const t = e === StreamIndex$1.STREAM_INDEX_MAIN ? this.localVideoTrack : this.localScreenVideoTrack;
    if (!t) throw new SDKError(ErrorCode.INVOKED_BEFORE_CAPTURE, "capture first");
    return t.snapshot();
  }
  async takeRemoteSnapshot(e, t) {
    var i;
    this.logger.print("takeRemoteSnapshot()", "id: %o, streamIndex: %o", e, t), checkString(e, "id"), checkEnum(t, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]);
    const r = (null === (i = this._room) || void 0 === i || null === (i = i.remoteStreams.get(e)) || void 0 === i || null === (i = i.find((e2) => e2.isScreen === (t === StreamIndex$1.STREAM_INDEX_SCREEN))) || void 0 === i ? void 0 : i.videoTrack) || this._wtnStreamManager.__getPublicStreamTrack(e, "video");
    if (!r) throw new SDKError(ErrorCode.STREAM_NOT_EXIST, "stream not exist");
    return r.snapshot();
  }
  setSubscribeFallbackOption(e) {
    this.logger.info("setSubscribeFallbackOption()", "option: %o", e);
    try {
      checkEnum(e, "option", [SubscribeFallbackOption.DISABLE, SubscribeFallbackOption.VIDEO_STREAM_LOW, SubscribeFallbackOption.AUDIO_ONLY]);
    } catch (e2) {
      return console.warn(e2), false;
    }
    return !this._room && (this._ctx.subscribeFallbackOption = e, true);
  }
  getLocalStreamTrack(e, t) {
    let i, r;
    if (e === StreamIndex$1.STREAM_INDEX_MAIN ? (i = "video" === t ? this.localVideoTrack : this.localAudioTrack, r = () => {
      var e2;
      return null === (e2 = this._room) || void 0 === e2 ? void 0 : e2.localStream;
    }) : (i = "video" === t ? this.localScreenVideoTrack : this.localScreenAudioTrack, r = () => {
      var e2;
      return null === (e2 = this._room) || void 0 === e2 ? void 0 : e2.localScreenStream;
    }), !i) return;
    const o = i instanceof LocalAudioTrack && i.mixedAudioTrack ? i.mixedAudioTrack : i.preprocessingTrack;
    if (!o) return;
    const n = r();
    return this._reportMsTrackEvent(o, (null == n ? void 0 : n.stream.id) || "local"), o;
  }
  getRemoteStreamTrack(e, t, i) {
    var r;
    let o;
    const n = (null === (r = this._room) || void 0 === r ? void 0 : r.remoteStreams.get(e)) || [];
    if (null == n || !n.length) return;
    let s;
    var a, d, c2, l;
    t === StreamIndex$1.STREAM_INDEX_MAIN ? (s = n.find((e2) => !e2.isScreen), o = "video" === i ? null === (a = s) || void 0 === a ? void 0 : a.videoTrack : null === (d = s) || void 0 === d ? void 0 : d.audioTrack) : (s = n.find((e2) => e2.isScreen), o = "video" === i ? null === (c2 = s) || void 0 === c2 ? void 0 : c2.videoTrack : null === (l = s) || void 0 === l ? void 0 : l.audioTrack);
    if (!o) return;
    const u = o.preprocessingTrack;
    if (!u || !s) return;
    const { streamId: h } = s;
    return this._reportMsTrackEvent(u, h), u;
  }
  getPublicStreamTrack(e, t) {
    const i = this._wtnStreamManager.__getPublicStreamTrack(e, t), r = null == i ? void 0 : i.preprocessingTrack;
    if (r) return r ? (this._reportMsTrackEvent(r, e), r) : void 0;
  }
  setRemoteStreamRenderSync(e) {
    return !this._room && (this._ctx.avSync = !!e, true);
  }
  setJoinRoomParams(e) {
    e && (this._ctx.joinRoomParams = e);
  }
  async setAudioSelectionConfig(e) {
    checkEnum(e, "audioSelectionPriority", [AudioSelectionPriority.DEFAULT, AudioSelectionPriority.HIGH]), this._ctx.mediaParams || (this._ctx.mediaParams = {}), this._ctx.mediaParams.audioSelectionConfig = { isHighPriority: e === AudioSelectionPriority.HIGH }, this._room && await this._room.updateMediaParams(this._ctx.mediaParams);
  }
  setCaptureVolume(e, t) {
    checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), t = numberRangeGuide(t, "volume", 0, 400);
    var i, r, o, n, s;
    e === StreamIndex$1.STREAM_INDEX_SCREEN ? (null === (i = this._localScreenAudioTrack) || void 0 === i || i.once("needReplaceTrack", () => {
      var e2;
      null === (e2 = this._room) || void 0 === e2 || e2.updatePubScreenTrack();
    }), null === (r = this._localScreenAudioTrack) || void 0 === r || r.setVolume(t), this._localScreenAudioVolume = t) : (null === (o = this._localAudioTrack) || void 0 === o || o.once("needReplaceTrack", () => {
      var e2;
      null === (e2 = this._room) || void 0 === e2 || e2.updatePubTrack();
    }), null === (n = this._localAudioTrack) || void 0 === n || n.setVolume(t), null === (s = this._audioDeviceManager.audioTrack) || void 0 === s || s.setVolume(t), this._localAudioVolume = t);
  }
  setPlaybackVolume(e, t, i) {
    var r, o, n;
    if (checkUserId(e), checkEnum(t, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), i = numberRangeGuide(i, "volume", 0, 400), null !== (r = this._room) && void 0 !== r && r.config.isMultiChatMode()) return void warnDevelopers("setPlaybackVolume is not supported in Conference mode");
    const s = t === StreamIndex$1.STREAM_INDEX_SCREEN;
    s ? this._remoteScreenAudioVolume.set(e, i) : this._remoteAudioVolume.set(e, i);
    const a = null === (o = this._room) || void 0 === o || null === (o = o.remoteStreams.get(e)) || void 0 === o ? void 0 : o.find((e2) => e2.isScreen === s);
    null == a || null === (n = a.audioTrack) || void 0 === n || n.setVolume(i);
  }
  setPublicStreamVolume(e, t) {
    this._wtnStreamManager.setWTNRemoteAudioPlaybackVolume(e, t);
  }
  async startForwardStreamToRooms(e) {
    e.forEach((e2) => {
      checkRoomId(e2.roomId);
    }), this._assertNotInRoom();
    return await this._room.startForwardStream2Rooms(e);
  }
  async updateForwardStreamToRooms(e) {
    e.forEach((e2) => {
      checkRoomId(e2.roomId);
    }), this._assertNotInRoom();
    return await this._room.updateForwardStream2Rooms(e);
  }
  async stopForwardStreamToRooms() {
    this._assertNotInRoom();
    return await this._room.stopForwardStream2Rooms();
  }
  async pauseForwardStreamToAllRooms() {
    this._assertNotInRoom();
    return await this._room.pauseForwardStream2AllRooms();
  }
  async resumeForwardStreamToAllRooms() {
    this._assertNotInRoom();
    return await this._room.resumeForwardStream2AllRooms();
  }
  async ambulance() {
    const e = await ambulance(this), t = JSON.stringify(e);
    return this.monitor.reportLongString("ambulance", t), e;
  }
  async setEarMonitorMode(e, t) {
    this.logger.info("setEarMonitorMode()", "streamIndex: %s, position: %s", e, t), checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), checkEnum(t, "position", [EarMonitorPosition.NONE, EarMonitorPosition.AFTER_CAPTURE, EarMonitorPosition.AFTER_PROCESS]), this._ctx.earMonitorSettings[e].position = t;
    const i = e === StreamIndex$1.STREAM_INDEX_MAIN ? this.localAudioTrack : e === StreamIndex$1.STREAM_INDEX_SCREEN ? this.localScreenAudioTrack : void 0;
    if (i) return t !== EarMonitorPosition.NONE ? i.play(t) : i.stop();
    this.logger.warn("setEarMonitorMode()", "local audio track not exist");
  }
  setEarMonitorVolume(e, t) {
    this.logger.info("setEarMonitorVolume()", "streamIndex: %s, volume: %s", e, t), checkEnum(e, "streamIndex", [StreamIndex$1.STREAM_INDEX_MAIN, StreamIndex$1.STREAM_INDEX_SCREEN]), t = numberRangeGuide(t, "volume", 0, 400), this._ctx.earMonitorSettings[e].volume = t;
    const i = e === StreamIndex$1.STREAM_INDEX_MAIN ? this.localAudioTrack : e === StreamIndex$1.STREAM_INDEX_SCREEN ? this.localScreenAudioTrack : void 0;
    if (i) return i.setPlaybackVolume(t);
    this.logger.warn("setEarMonitorVolume()", "local audio track not exist");
  }
  setUserInfo(e, t) {
    checkRoomId(e), checkUserId(t), this.monitor.set({ room_id: e, user_id: t });
  }
  _reportMsTrackEvent(e, t) {
    if (!e.hookStop) {
      e.hookStop = true;
      const i = e.stop;
      e.stop = () => {
        reportRtcInvokeStatus(this.id, "stop", t, 0, t), i.call(e);
      };
    }
  }
  async _updateScreenPublish() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.logger.info("_updateScreenPublish()");
    if (e = _objectSpread2(_objectSpread2({}, { mediaType: void 0, pubState: PubState.PUB }), e), !this._ctx.visibility) throw new SDKError(ErrorCode.NO_PUBLISH_PERMISSION, "no publish permission");
    const t = await this._pubLock.lock();
    if (this._room && this._ctx.signalingManager.isConnected()) try {
      await this._room.publishScreen(this._localScreenVideoTrack, this._localScreenAudioTrack, e.mediaType, e.pubState);
    } catch (e2) {
      throw e2 instanceof SDKError ? e2 : new SDKError(ErrorCode.UNEXPECTED_ERROR, "unexpected error", e2);
    } finally {
      t();
    }
    else t();
  }
  _updateAudioPlayerState(e) {
    this.logger.info("_updateAudioPlayerState()");
    const { userId: t, isScreen: i, isPublic: r } = e;
    if (e.audioTrack && e.attributes.audiostream && e.subAudio) {
      var o, n, s;
      if (!e.audioTrack.havePlayer()) {
        var a, d;
        const o2 = new AudioPlayer(this.id, t, { muted: (null === (a = this._config) || void 0 === a ? void 0 : a.autoPlayPolicy) === RTCAutoPlayPolicy.VIDEO_ONLY || (null === (d = this._config) || void 0 === d ? void 0 : d.autoPlayPolicy) === RTCAutoPlayPolicy.PLAY_MANUALLY, isScreen: !r && i });
        e.audioTrack.setPlayer(o2), e.audioTrack.bindPlayerEvent(this._initPlayerEvents.bind(this));
        const n2 = this._audioDeviceManager.getSinkId();
        n2 && e.audioTrack.setPlaybackDevice(n2);
      }
      e.audioTrack.play();
      const u2 = r ? null !== (o = this._ctx.publicAudioVolume.get(t)) && void 0 !== o ? o : 100 : i ? null !== (n = this._remoteScreenAudioVolume.get(t)) && void 0 !== n ? n : 100 : null !== (s = this._remoteAudioVolume.get(t)) && void 0 !== s ? s : 100;
      if (e.audioTrack.setVolume(u2), isSafari && isIPad) {
        var c2, l;
        const e2 = null !== (c2 = null === (l = this._room) || void 0 === l ? void 0 : l.remoteStreams) && void 0 !== c2 ? c2 : /* @__PURE__ */ new Map();
        replayRemoteAudioWorkaround(e2);
      }
    } else {
      var u;
      null === (u = e.audioTrack) || void 0 === u || u.stop();
    }
  }
  _updateVideoPlayerState(e) {
    if (this.logger.info("_updateVideoPlayerState()"), e.videoTrack) {
      const i = e.isPublic ? this._wtnStreamManager._publicVideoPlayerConfig : this._remoteVideoPlayerConfig[e.isScreen ? StreamIndex$1.STREAM_INDEX_SCREEN : StreamIndex$1.STREAM_INDEX_MAIN].get(e.userId);
      if (i) for (const [, r] of i) {
        var t;
        e.videoTrack.setPlayer(this.id, r, null === (t = this._config) || void 0 === t ? void 0 : t.autoPlayPolicy, this._initPlayerEvents.bind(this));
      }
    }
  }
  get _localVideoTrack() {
    return this._ctx.localVideoTrack;
  }
  get _localAudioTrack() {
    return this._ctx.localAudioTrack;
  }
  set _localVideoTrack(e) {
    this._ctx.localVideoTrack = e;
  }
  set _localAudioTrack(e) {
    this._ctx.localAudioTrack = e;
  }
  async _onAddStream(e) {
    const t = e.stream, { localaudio: i, audiostream: r, localvideo: o, videostream: n } = t.attributes;
    let s = ExtendMediaType.NONE;
    r && (s |= MediaType$1.AUDIO), n && (s |= MediaType$1.VIDEO), s && (await new Promise((e2) => setTimeout(e2)), t.isScreen ? this.safeEmit(EngineEventsTypes.onUserPublishScreen, { userId: t.userId, mediaType: s }) : (this.safeEmit(EngineEventsTypes.onUserPublishStream, { userId: t.userId, mediaType: s, videoStreamDescriptions: t.attributes.videoDescriptions }), this._handleAutoSubscribe(t, true)), this.safeEmit("onAddStream", { userId: t.userId, mediaType: s, isScreen: !!t.isScreen }), t.isScreen || (i && this.safeEmit(EngineEventsTypes.onUserStartAudioCapture, { userId: t.userId }), o && this.safeEmit(EngineEventsTypes.onUserStartVideoCapture, { userId: t.userId })));
  }
  _handleAutoSubscribe(e, t) {
    var i, r;
    let o = ExtendMediaType.NONE;
    if (null !== (i = this._room) && void 0 !== i && i.config.isAutoSubscribeAudio && (o |= MediaType$1.AUDIO), null !== (r = this._room) && void 0 !== r && r.config.isAutoSubscribeVideo && (o |= MediaType$1.VIDEO), o) {
      var n, s, a;
      if (t && audioInMediaType(o)) null === (s = e.observer) || void 0 === s || s.setAutoSubscribeAudio(true);
      if (t && videoInMediaType(o)) null === (a = e.observer) || void 0 === a || a.setAutoSubscribeVideo(true);
      null !== (n = this._room) && void 0 !== n && n.config.tokenSubscribePrivilegeExpired ? (audioInMediaType(o) && (this._pauseAllSubscribeState.resumeAudioStreamIds[e.streamId] = e.streamId), videoInMediaType(o) && (this._pauseAllSubscribeState.resumeVideoStreamIds[e.streamId] = e.streamId)) : this._subscribe(false, e.userId, o);
    }
  }
  _onRemoveStream(e) {
    var t;
    const i = e.stream, r = null !== (t = StreamRemoveReasonMap[e.reason]) && void 0 !== t ? t : StreamRemoveReason.STREAM_REMOVE_REASON_OTHER, o = i.isScreen ? EngineEventsTypes.onUserUnpublishScreen : EngineEventsTypes.onUserUnpublishStream;
    let n = ExtendMediaType.NONE;
    i.attributes.audiostream && (n |= MediaType$1.AUDIO), i.attributes.videostream && (n |= MediaType$1.VIDEO), n !== ExtendMediaType.NONE && (this.safeEmit(o, { userId: i.userId, mediaType: n, reason: r }), this.safeEmit("onRemoveStream", { userId: i.userId, isScreen: i.isScreen })), delete this._pauseAllSubscribeState.resumeAudioStreamIds[i.streamId], delete this._pauseAllSubscribeState.resumeVideoStreamIds[i.streamId];
  }
  _onUserConnection(e) {
    setTimeout(() => this.safeEmit(EngineEventsTypes.onUserJoined, e));
  }
  _onUserLeave(e) {
    this.safeEmit(EngineEventsTypes.onUserLeave, e);
  }
  _onRoomError(e) {
    var t;
    this.safeEmit(EngineEventsTypes.onError, e), null === (t = this._room) || void 0 === t || t.destroy(), this._room = void 0;
  }
  _onNetworkQuality() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
    this.safeEmit(EngineEventsTypes.onNetworkQuality, ...t);
  }
  _onConnectionStateChange(e) {
    if (void 0 !== this._startCloudProxyTimestamp && this._ctx.useCloudProxy && e.state === ConnectionState.CONNECTION_STATE_CONNECTED && this.safeEmit(EngineEventsTypes.onCloudProxyConnected, { interval: Date.now() - this._startCloudProxyTimestamp }), (this._ctx.isPreConnection || e.state !== ConnectionState.CONNECTION_STATE_CONNECTED && e.state !== ConnectionState.CONNECTION_STATE_RECONNECTED) && this.safeEmit(EngineEventsTypes.onConnectionStateChanged, e), e.state === ConnectionState.CONNECTION_STATE_RECONNECTING) for (const [e2, r] of null !== (t = null === (i = this._room) || void 0 === i ? void 0 : i.remoteStreams) && void 0 !== t ? t : /* @__PURE__ */ new Map()) {
      var t, i;
      e2.startsWith("mux") && r.forEach((e3) => {
        var t2;
        return null === (t2 = e3.audioTrack) || void 0 === t2 ? void 0 : t2.stop();
      });
    }
    else e.state === ConnectionState.CONNECTION_STATE_CONNECTED && this._rtmClient.setRTSMessageLimit(this._ctx.rtsLimiter.conf);
  }
  _stopAudioPropertiesReport() {
    null !== this._audioPropertiesReportTimer && (clearInterval(this._audioPropertiesReportTimer), this._audioPropertiesReportTimer = null);
  }
  _onResubscribe(e) {
    var t, i;
    e.stream && (null === (t = e.stream.videoTrack) || void 0 === t || t.stopAll(), null === (i = e.stream.audioTrack) || void 0 === i || i.stop(), this._updateAudioPlayerState(e.stream), this._updateVideoPlayerState(e.stream));
  }
  _onSubscribePushTrack(e) {
    e.stream && this._updateAudioPlayerState(e.stream);
  }
  _onRemovePushTrack(e) {
    e.stream && this._updateAudioPlayerState(e.stream);
  }
  _onUserPublishStateChange(e) {
    let { userId: t, isScreen: i, mediaType: r, pubState: o, remoteStream: n } = e;
    const s = { userId: t, mediaType: r };
    r & MediaType$1.AUDIO && setTimeout(() => {
      this._updateAudioPlayerState(n);
    }), i ? o === PubState.PUB ? this.safeEmit(EngineEventsTypes.onUserPublishScreen, s) : this.safeEmit(EngineEventsTypes.onUserUnpublishScreen, _objectSpread2(_objectSpread2({}, s), {}, { reason: StreamRemoveReason.STREAM_REMOVE_REASON_UNPUBLISH })) : o === PubState.PUB ? (s.videoStreamDescriptions = n.attributes.videoDescriptions, this.safeEmit(EngineEventsTypes.onUserPublishStream, s), this._handleAutoSubscribe(n, true)) : this.safeEmit(EngineEventsTypes.onUserUnpublishStream, _objectSpread2(_objectSpread2({}, s), {}, { reason: StreamRemoveReason.STREAM_REMOVE_REASON_UNPUBLISH }));
  }
  _onCustomMessage(e) {
    const { message: t } = e;
    e.binary ? this.safeEmit(EngineEventsTypes.onRoomBinaryMessageReceived, { userId: e.clientId, message: t }) : this.safeEmit(EngineEventsTypes.onRoomMessageReceived, { userId: e.clientId, message: t });
  }
  _onUserMessageReceived(e) {
    this._messageStatisticsObserver.recvP2PMessage(e.userId), this.safeEmit(EngineEventsTypes.onUserMessageReceived, e);
  }
  _onUserBinaryMessageReceived(e) {
    this._messageStatisticsObserver.recvP2PMessage(e.userId), this.safeEmit(EngineEventsTypes.onUserBinaryMessageReceived, e);
  }
  _onLiveTranscodingResult(e) {
    this.safeEmit(EngineEventsTypes.onLiveTranscodingResult, e);
  }
  _onStreamMixingEvent(e) {
    this.safeEmit(EngineEventsTypes.onStreamMixingEvent, e);
  }
  _onUserTokenWillExpire() {
    this.safeEmit(EngineEventsTypes.onTokenWillExpire);
  }
  _onUserTokenPublishPrivilegeWillExpire() {
    this.safeEmit(EngineEventsTypes.onTokenPublishPrivilegeWillExpire);
  }
  async _onUserTokenPublishPrivilegeDidExpired() {
    var e, t, i;
    await (null === (e = this._room) || void 0 === e ? void 0 : e.unpublish()), await (null === (t = this._room) || void 0 === t ? void 0 : t.unpublishScreen()), null === (i = this._room) || void 0 === i || i.config.setTokenPublishPrivilegeExpired(true), this.safeEmit(EngineEventsTypes.onTokenPublishPrivilegeDidExpired, { errorCode: ErrorCode.TOKEN_NO_PUBLISH_PERMISSION, message: "Token no longer has publish privilege" });
  }
  _onUserTokenSubscribePrivilegeWillExpire() {
    this.safeEmit(EngineEventsTypes.onTokenSubscribePrivilegeWillExpire);
  }
  async _onUserTokenSubscribePrivilegeDidExpired() {
    this._handleLoseSubscribePrivilege(), this.safeEmit(EngineEventsTypes.onTokenSubscribePrivilegeDidExpired, { errorCode: ErrorCode.TOKEN_NO_SUBSCRIBE_PERMISSION, message: "Token no longer has subscribe privilege" });
  }
  async _unSubscribeAllRemoteStreams() {
    return this._room ? this._pauseAllRemoteStreams(MediaType$1.AUDIO_AND_VIDEO) : Promise.resolve();
  }
  _onPushPublicStreamResult(e) {
    this.safeEmit(EngineEventsTypes.onPushPublicStreamResult, e);
  }
  _handleRTMClient(e) {
    e.on("onUserMessageReceivedOutsideRoom", (e2) => {
      this._messageStatisticsObserver.recvP2POutRoomMessage(e2.userId), this.safeEmit(EngineEventsTypes.onUserMessageReceivedOutsideRoom, e2);
    }), e.on("onUserBinaryMessageReceivedOutsideRoom", (e2) => {
      this._messageStatisticsObserver.recvP2POutRoomMessage(e2.userId), this.safeEmit(EngineEventsTypes.onUserBinaryMessageReceivedOutsideRoom, e2);
    }), e.on("onUserDisconnection", () => {
      this.safeEmit(EngineEventsTypes.onError, { errorCode: ErrorCode.RTM_DUPLICATE_LOGIN });
    }), e.on("onRTMTokenError", () => {
      this.safeEmit(EngineEventsTypes.onError, { errorCode: ErrorCode.RTM_TOKEN_ERROR });
    }), e.on("onServerParamsSetResult", (e2) => {
      this.safeEmit(EngineEventsTypes.onServerParamsSetResult, null == e2 ? void 0 : e2.code);
    });
  }
  getSubLock(e, t) {
    const i = e ? this._subScreenLocks : this._subLocks;
    let r = i.get(t);
    return r || (r = new PromiseLock2("sub_".concat(e ? 1 : 0, "_").concat(t)), i.set(t, r)), r;
  }
  get localAudioTrack() {
    return this._localAudioTrack;
  }
  get localVideoTrack() {
    return this._localVideoTrack;
  }
  get localScreenAudioTrack() {
    return this._localScreenAudioTrack;
  }
  get localScreenVideoTrack() {
    return this._localScreenVideoTrack;
  }
  get remoteStreams() {
    var e;
    const t = [];
    return null !== (e = this._room) && void 0 !== e && e.remoteStreams && this._room.remoteStreams.forEach((e2) => {
      Array.isArray(e2) && e2.forEach((e3) => {
        t.push({ userId: e3.userId, isScreen: e3.isScreen, hasVideo: e3.hasVideo, hasAudio: e3.hasAudio, videoStreamDescriptions: e3.attributes.videoDescriptions });
      });
    }), t;
  }
  get iceState() {
    var e;
    return null === (e = this._ctx.peerConnection) || void 0 === e ? void 0 : e.getIceConnectionState();
  }
  get remoteUsers() {
    var e;
    const t = [];
    return null !== (e = this._room) && void 0 !== e && e.remoteUsers && this._room.remoteUsers.forEach((e2) => {
      t.push({ userId: e2.userId });
    }), t;
  }
  get multiChatMode() {
    var e;
    return !(null === (e = this._room) || void 0 === e || !e.config.isMultiChatMode());
  }
  get checkMediaType() {
    return this._checkMediaType;
  }
  get assertNotInRoom() {
    return this._assertNotInRoom;
  }
  get peerConnection() {
    var e;
    return null === (e = this._ctx.peerConnection) || void 0 === e ? void 0 : e.getOriginRTCPeerConnection();
  }
  _handleAudioDeviceManager() {
    this._audioDeviceManager.on("onAudioPlaybackDeviceTestVolume", (e) => {
      this.safeEmit(EngineEventsTypes.onAudioPlaybackDeviceTestVolume, e);
    });
  }
  _assertNotInRoom() {
    if (!this._room || !this._ctx.signalingManager.isConnected()) throw new SDKError(ErrorCode.NOT_CONNECTED_YET, "server not connected");
  }
  _checkMediaType(e) {
    checkEnum(e, "mediaType", [MediaType$1.AUDIO, MediaType$1.VIDEO, MediaType$1.AUDIO_AND_VIDEO]);
  }
  _getUserId() {
    var e;
    return (null === (e = this._room) || void 0 === e ? void 0 : e.config.userInfo.userId) || "local_user";
  }
  async _switchTrack(e) {
    var t;
    this._initLocalTrackEvents(e), this._localVideoTrack = e, this._localVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].forEach((t2) => {
      var i;
      e.setPlayer(t2, this._mirrorType, null === (i = this._config) || void 0 === i ? void 0 : i.autoPlayPolicy, this._initPlayerEvents.bind(this));
    }), null !== (t = this._room) && void 0 !== t && null !== (t = t.localStream) && void 0 !== t && t.pubVideo && await this._updatePublish(), this._wtnStreamManager._updatePushTrack();
  }
  async _shouldUpdateAudioConf(e) {
    var t, i;
    const r = await (null === (t = this._room) || void 0 === t ? void 0 : t.hasPublished()) || (null === (i = this._room) || void 0 === i || null === (i = i.localStream) || void 0 === i ? void 0 : i.pubAudio) || this._localAudioTrack && this._localAudioTrack.sourceType === SourceType.INTERNAL;
    if (r) {
      const t2 = "engine.".concat(e, " should be called before publishing or capturing.");
      console.warn("[RTC WebSDK]: ".concat(t2)), reportRtcInvokeStatus(this.id, e, t2);
    }
    return !r;
  }
  _getRemoteVideoPlayerConfig(e, t, i) {
    var r;
    return null === (r = this._remoteVideoPlayerConfig[e].get(t)) || void 0 === r ? void 0 : r.get(i);
  }
  _setRemoteVideoPlayerConfig(e, t, i, r) {
    const o = this._remoteVideoPlayerConfig[e].get(t) || /* @__PURE__ */ new Map();
    o.set(i, r), this._remoteVideoPlayerConfig[e].set(t, o);
  }
  getRemoteVideoStats() {
    var e;
    const t = null === (e = this._room) || void 0 === e ? void 0 : e.remoteStreams;
    if (!t || 0 === t.size) return {};
    const i = {};
    return t.forEach((e2, t2) => {
      var r, o, n;
      let s, a;
      null !== (r = e2[0]) && void 0 !== r && r.isScreen ? (a = e2[0], s = e2[1]) : (a = e2[1], s = e2[0]);
      const d = { mainVideoStats: getPublicStats((null === (o = s) || void 0 === o ? void 0 : o.getRemoteStreamStats().videoStats) || {}), screenVideoStats: getPublicStats((null === (n = a) || void 0 === n ? void 0 : n.getRemoteStreamStats().videoStats) || {}) };
      i[t2] = d;
    }), i;
  }
  getRemoteAudioStats() {
    var e;
    const t = null === (e = this._room) || void 0 === e ? void 0 : e.remoteStreams;
    if (!t || 0 === t.size) return {};
    const i = {};
    return t.forEach((e2, t2) => {
      var r, o, n;
      let s, a;
      null !== (r = e2[0]) && void 0 !== r && r.isScreen ? (a = e2[0], s = e2[1]) : (a = e2[1], s = e2[0]);
      const d = { mainAudioStats: getPublicStats((null === (o = s) || void 0 === o ? void 0 : o.getRemoteStreamStats().audioStats) || {}), screenAudioStats: getPublicStats((null === (n = a) || void 0 === n ? void 0 : n.getRemoteStreamStats().audioStats) || {}) };
      i[t2] = d;
    }), i;
  }
  getLocalVideoStats() {
    var e, t;
    return { mainVideoStats: getPublicStats((null === (e = this._room) || void 0 === e || null === (e = e.localStream) || void 0 === e ? void 0 : e.getLocalStreamStats().videoStats) || {}), screenVideoStats: getPublicStats((null === (t = this._room) || void 0 === t || null === (t = t.localScreenStream) || void 0 === t ? void 0 : t.getLocalStreamStats().videoStats) || {}) };
  }
  getLocalAudioStats() {
    var e, t;
    return { mainAudioStats: getPublicStats((null === (e = this._room) || void 0 === e || null === (e = e.localStream) || void 0 === e ? void 0 : e.getLocalStreamStats().audioStats) || {}), screenAudioStats: getPublicStats((null === (t = this._room) || void 0 === t || null === (t = t.localScreenStream) || void 0 === t ? void 0 : t.getLocalStreamStats().audioStats) || {}) };
  }
  getPublicVideoStats() {
    const e = this._wtnStreamManager.__getRemoteStreams();
    if (!e || 0 === e.size) return {};
    const t = {};
    return e.forEach((e2, i) => {
      const r = getPublicStats(e2.getRemoteStreamStats().videoStats || {});
      delete r.isScreen, t[i] = r;
    }), t;
  }
  getPublicAudioStats() {
    const e = this._wtnStreamManager.__getRemoteStreams();
    if (!e || 0 === e.size) return {};
    const t = {};
    return e.forEach((e2, i) => {
      const r = getPublicStats(e2.getRemoteStreamStats().audioStats || {});
      delete r.isScreen, t[i] = r;
    }), t;
  }
  _initAutoplayFailedWorkaround() {
    if (Config2.AUTOPLAY_WORKAROUND && (Config2.ENABLE_PLAY_AFTER_CLICK || isWeChat)) {
      let e = [];
      this.on(EngineEventsTypes.onAutoplayFailed, (t2) => {
        e.push(t2), r();
      });
      const t = () => {
        e.length > 0 && (reportRtcInvokeStatus(this.id, "resumePlay", JSON.stringify(e)), Promise.all(e.map((e2) => this.play(e2.userId, e2.mediaType, e2.streamIndex, e2.playerId))).then(() => {
          e = [], reportRtcInvokeStatus(this.id, "resumePlaySuccess", JSON.stringify(e));
        }).catch(() => {
          reportRtcInvokeStatus(this.id, "resumePlayFailed", JSON.stringify(e));
        }));
      };
      let i;
      Config2.ENABLE_PLAY_AFTER_CLICK && (document.addEventListener("click", t), i = () => {
        document.removeEventListener("click", t);
      });
      const r = () => {
        var i2, r2;
        window.WeixinJSBridge && (reportRtcInvokeStatus(this.id, "resumePlayInWxBridge", JSON.stringify(e)), null === (i2 = (r2 = window.WeixinJSBridge).invoke) || void 0 === i2 || i2.call(r2, "getNetworkType", {}, t));
      };
      let o;
      isWeChat && !window.WeixinJSBridge && (document.addEventListener("WeixinJSBridgeReady", r, false), o = () => {
        document.removeEventListener("WeixinJSBridgeReady", r);
      }), this._revokeAutoplayFailedWorkaround = () => {
        var e2, t2;
        null === (e2 = i) || void 0 === e2 || e2(), null === (t2 = o) || void 0 === t2 || t2();
      };
    }
  }
}, _defineProperty(_Class, "hasReportNativeDetector", false), _Class);
var RTCEngine = _RTCEngine2;
__decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "updateToken", 1), __decorateClass$1([reportRtcSdkApi(), captureLock("video")], RTCEngine.prototype, "setVideoCaptureDevice", 1), __decorateClass$1([reportRtcSdkApi(), captureLock("audio")], RTCEngine.prototype, "setAudioCaptureDevice", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "connect", 1), __decorateClass$1([setJoinRoomInfo, reportRtcSdkApi()], RTCEngine.prototype, "joinRoom", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "leaveRoom", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "destroy", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "publishStream", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "unpublishStream", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "publishScreen", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "unpublishScreen", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "subscribeStream", 1), __decorateClass$1([subLock], RTCEngine.prototype, "_subscribe", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "unsubscribeStream", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "subscribeScreen", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "unsubscribeScreen", 1), __decorateClass$1([subLock], RTCEngine.prototype, "_unsubscribe", 1), __decorateClass$1([reportRtcSdkApi(), subLock2], RTCEngine.prototype, "setRemoteVideoConfig", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setRemoteSimulcastStreamType", 1), __decorateClass$1([reportRtcSdkApi(), captureLock("video")], RTCEngine.prototype, "startVideoCapture", 1), __decorateClass$1([reportRtcSdkApi(), captureLock("video")], RTCEngine.prototype, "stopVideoCapture", 1), __decorateClass$1([reportRtcSdkApi(), captureLock("audio")], RTCEngine.prototype, "startAudioCapture", 1), __decorateClass$1([reportRtcSdkApi(), captureLock("audio")], RTCEngine.prototype, "stopAudioCapture", 1), __decorateClass$1([reportRtcSdkApi(), captureLock("all")], RTCEngine.prototype, "startAudioAndVideoCapture", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "startVideoAndAudioCapture", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "getAudioMixingManager", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "getWTNStreamManager", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "getCallId", 1), __decorateClass$1([reportRtcSdkApi(), screenCaptureLock], RTCEngine.prototype, "startScreenCapture", 1), __decorateClass$1([reportRtcSdkApi(), screenCaptureLock], RTCEngine.prototype, "stopScreenCapture", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setLocalVideoPlayer", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "startLiveTranscoding", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "updateLiveTranscoding", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "stopLiveTranscoding", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "startSubtitle", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "updateSubtitleConfig", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "stopSubtitle", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setBusinessId", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "setUserVisibility", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setRemoteVideoPlayer", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setLocalVideoMirrorType", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setRemoteVideoMirrorType", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setAudioPlaybackDevice", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "play", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "stop", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "getAudioVolume", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setAudioFrameCallback", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "pauseAllSubscribedStream", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "resumeAllSubscribedStream", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "sendUserMessage", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "sendUserBinaryMessage", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "sendRoomMessage", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "sendRoomBinaryMessage", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setAudioCaptureConfig", 1), __decorateClass$1([warnDeprecatedApi("4.51"), reportRtcSdkApi()], RTCEngine.prototype, "setVideoCaptureConfig", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "enableSimulcastMode", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setLocalSimulcastMode", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setVideoEncoderConfig", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setScreenEncoderConfig", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "sendSEIMessage", 1), __decorateClass$1([warnDeprecatedApi("4.42"), reportRtcSdkApi()], RTCEngine.prototype, "setAudioVolumeIndicationInterval", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "enableAudioPropertiesReport", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setVideoSourceType", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setExternalVideoTrack", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setAudioSourceType", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setExternalAudioTrack", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "login", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "logout", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "updateLoginToken", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "getPeerOnlineStatus", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "sendUserMessageOutsideRoom", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "sendUserBinaryMessageOutsideRoom", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setServerParams", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "sendServerMessage", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "sendServerBinaryMessage", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "startCloudProxy", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "stopCloudProxy", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "startPushPublicStream", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "updatePublicStreamParam", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "stopPushPublicStream", 1), __decorateClass$1([reportRtcSdkApi(["streamId"])], RTCEngine.prototype, "startPlayPublicStream", 1), __decorateClass$1([reportRtcSdkApi(["streamId"])], RTCEngine.prototype, "stopPlayPublicStream", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setAudioProfile", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setAudioEncodeMaxBitrate", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setPublicStreamVideoPlayer", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setDummyCaptureImagePath", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "registerExtension", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "startAudioPlaybackDeviceTest", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "stopAudioPlaybackDeviceTest", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "startAudioDeviceRecordTest", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "stopAudioDeviceRecordAndPlayTest", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "stopAudioDevicePlayTest", 1), __decorateClass$1([reportRtcSdkApi(), subLock2], RTCEngine.prototype, "setRemoteUserPriority", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "takeLocalSnapshot", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "takeRemoteSnapshot", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setSubscribeFallbackOption", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "getLocalStreamTrack", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "getRemoteStreamTrack", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "getPublicStreamTrack", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setRemoteStreamRenderSync", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setJoinRoomParams", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "setAudioSelectionConfig", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "startForwardStreamToRooms", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "updateForwardStreamToRooms", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "stopForwardStreamToRooms", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "pauseForwardStreamToAllRooms", 1), __decorateClass$1([reportRtcSdkApi(), checkNotInRTSRoom], RTCEngine.prototype, "resumeForwardStreamToAllRooms", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setEarMonitorMode", 1), __decorateClass$1([reportRtcSdkApi([], { debounce: 2e3, debounceTag: function(e) {
  return "".concat(e);
} })], RTCEngine.prototype, "setEarMonitorVolume", 1), __decorateClass$1([reportRtcSdkApi()], RTCEngine.prototype, "setUserInfo", 1);
var StreamRemoveReasonMap = { "client unpublished": StreamRemoveReason.STREAM_REMOVE_REASON_UNPUBLISH, "publish failed": StreamRemoveReason.STREAM_REMOVE_REASON_PUBLISH_FAILED, "stream removed": StreamRemoveReason.STREAM_REMOVE_REASON_KEEP_LIVE_FAILED, "client disconnected": StreamRemoveReason.STREAM_REMOVE_REASON_CLIENT_DISCONNECTED, "client republish": StreamRemoveReason.STREAM_REMOVE_REASON_REPUBLISH, "token publish privilege expired": StreamRemoveReason.STREAM_REMOVE_REASON_TOKEN_PRIVILEGE_EXPIRED };
function subLock(e, t, i) {
  const r = i.value;
  return i.value = async function() {
    for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
    const [o, n, s] = t2;
    this.checkMediaType(s), this.assertNotInRoom();
    const a = await this.getSubLock(o, n).lock();
    try {
      return await r.apply(this, t2);
    } finally {
      a();
    }
  }, i;
}
function subLock2(e, t, i) {
  const r = i.value;
  return i.value = async function() {
    for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++) t2[i2] = arguments[i2];
    const [o] = t2, n = await this.getSubLock(false, o).lock();
    try {
      return await r.apply(this, t2);
    } finally {
      n();
    }
  }, i;
}
function captureLock(e) {
  return function(t, i, r) {
    const o = r.value;
    return r.value = async function() {
      const t2 = [];
      "video" !== e && t2.push(this._audioCaptureLock.lock()), "audio" !== e && t2.push(this._videoCaptureLock.lock());
      const i2 = await Promise.all(t2);
      try {
        for (var r2 = arguments.length, n = new Array(r2), s = 0; s < r2; s++) n[s] = arguments[s];
        return await o.apply(this, n);
      } finally {
        i2.forEach((e2) => e2());
      }
    }, r;
  };
}
function screenCaptureLock(e, t, i) {
  const r = i.value;
  return i.value = async function() {
    const e2 = await this._screenCaptureLock.lock();
    try {
      for (var t2 = arguments.length, i2 = new Array(t2), o = 0; o < t2; o++) i2[o] = arguments[o];
      return await r.apply(this, i2);
    } finally {
      e2();
    }
  }, i;
}
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (e, t, i, r) => {
  for (var o, n = r > 1 ? void 0 : r ? __getOwnPropDesc(t, i) : t, s = e.length - 1; s >= 0; s--) (o = e[s]) && (n = (r ? o(t, i, n) : o(n)) || n);
  return r && n && __defProp(t, i, n), n;
};
var BLWRTCEngine = class extends RTCEngine {
  constructor(e, t, i) {
    super(e, t, i), _defineProperty(this, "singleStreamRenderMode", false), this.id = t, this.logger = new Logger$1("BLWEngine", 0, t), setVideoEncoderAutoConfigList([{ width: 192, height: 108, frameRate: 15, maxKbps: 100 }, { width: 320, height: 180, frameRate: 15, maxKbps: 140 }, { width: 640, height: 360, frameRate: 15, maxKbps: 400 }, { width: 1280, height: 720, frameRate: 15, maxKbps: 1e3 }, { width: 1920, height: 1080, frameRate: 15, maxKbps: 2e3 }]), this._handleEngineEvents();
  }
  async subscribeStream(e, t) {
    return this.logger.print("subscribeStream()", "userId: %o, mediaType: %o", e, t), this.singleStreamRenderMode && videoInMediaType(t) && super.subscribeScreen(e, MediaType$1.VIDEO).catch((e2) => {
      this.logger.error("singleStreamRenderMode subscribeScreen()", e2);
    }), super.subscribeStream(e, t);
  }
  async unsubscribeStream(e, t) {
    return this.logger.print("unsubscribeStream()", "userId: %o, mediaType: %o", e, t), this.singleStreamRenderMode && videoInMediaType(t) && super.unsubscribeScreen(e, MediaType$1.VIDEO).catch((e2) => {
      this.logger.error("singleStreamRenderMode unsubscribeScreen()", e2);
    }), super.unsubscribeStream(e, t);
  }
  setRemoteScreenVideoStreamIndex(e) {
    return this.logger.print("setRemoteScreenVideoStreamIndex()", "streamIndex: %o", e), !this._room && (this.singleStreamRenderMode = e === StreamIndex$1.STREAM_INDEX_MAIN, true);
  }
  setRemoteVideoPlayer(e, t) {
    if (this.logger.print("setRemoteVideoPlayer()", "streamIndex: %o, videoPlayerOption: %o", e, t), null == t || delete t.playerId, !this.singleStreamRenderMode || e !== StreamIndex$1.STREAM_INDEX_SCREEN) return super.setRemoteVideoPlayer(e, t);
  }
  destroy() {
    this.singleStreamRenderMode = false, super.destroy();
  }
  _updateVideoPlayerState(e) {
    var t, i, r, o;
    if (!this.singleStreamRenderMode) return super._updateVideoPlayerState(e);
    const { userId: n } = e, s = null === (t = this._room) || void 0 === t ? void 0 : t.remoteStreams.get(n);
    let a, d;
    Array.isArray(s) && s.forEach((e2) => {
      e2.isScreen ? a = e2 : d = e2;
    });
    let c2 = null === (i = d) || void 0 === i || null === (i = i.videoTrack) || void 0 === i ? void 0 : i.dangerousGetPlayer(DEFAULT_PLAYER_ID);
    if (!c2) {
      var l;
      const e2 = null === (l = this._remoteVideoPlayerConfig[StreamIndex$1.STREAM_INDEX_MAIN].get(n)) || void 0 === l ? void 0 : l.get(DEFAULT_PLAYER_ID);
      if (!e2) return;
      var u, h, _;
      null === (u = d) || void 0 === u || null === (u = u.videoTrack) || void 0 === u || u.setPlayer(this.id, e2, null === (h = this._config) || void 0 === h ? void 0 : h.autoPlayPolicy, this._initPlayerEvents.bind(this)), c2 = null === (_ = d) || void 0 === _ || null === (_ = _.videoTrack) || void 0 === _ ? void 0 : _.dangerousGetPlayer(DEFAULT_PLAYER_ID);
    }
    var p, m, S;
    if (!e.isScreen && null !== (r = a) && void 0 !== r && r.videoTrack && a.videoHasPublish) return this.logger.print("_updateVideoPlayerState", "prevent play main stream"), void (null === (p = c2) || void 0 === p || p.playVideo(a.videoTrack));
    e.videoTrack ? (null === (m = this._config) || void 0 === m ? void 0 : m.autoPlayPolicy) !== RTCAutoPlayPolicy.PLAY_MANUALLY && (null === (S = c2) || void 0 === S || S.playVideo(e.videoTrack)) : null !== (o = c2) && void 0 !== o && o.played && c2.stop();
  }
  _handleEngineEvents() {
    this.on(EngineEventsTypes.onUserPublishScreen, (e) => {
      if (this.singleStreamRenderMode && videoInMediaType(e.mediaType)) {
        var t, i;
        const r = null === (t = this._room) || void 0 === t ? void 0 : t.remoteStreams.get(e.userId), o = null == r ? void 0 : r.find((e2) => !e2.isScreen), n = null == r ? void 0 : r.find((e2) => e2.isScreen);
        null != n && n.hasSubscribed ? (this.logger.info("onUserPublishScreen", "singleStreamRenderMode screen hasSubscribed"), this._updateVideoPlayerState(n)) : (null !== (i = this._room) && void 0 !== i && i.config.isAutoSubscribeVideo || null != o && o.hasSubscribed && videoInMediaType(o.subMediaType)) && (this.logger.info("onUserPublishScreen", "singleStreamRenderMode subscribeScreen"), this.subscribeScreen(e.userId, MediaType$1.VIDEO));
      }
    }), this.on(EngineEventsTypes.onUserUnpublishScreen, (e) => {
      if (this.singleStreamRenderMode && videoInMediaType(e.mediaType)) {
        var t;
        const i = null === (t = this._room) || void 0 === t ? void 0 : t.remoteStreams.get(e.userId), r = null == i ? void 0 : i.find((e2) => !e2.isScreen);
        r && setTimeout(() => {
          this._updateVideoPlayerState(r);
        });
      }
    });
  }
};
__decorateClass([reportRtcSdkApi()], BLWRTCEngine.prototype, "subscribeStream", 1), __decorateClass([reportRtcSdkApi()], BLWRTCEngine.prototype, "unsubscribeStream", 1), __decorateClass([reportRtcSdkApi()], BLWRTCEngine.prototype, "setRemoteScreenVideoStreamIndex", 1), __decorateClass([reportRtcSdkApi()], BLWRTCEngine.prototype, "setRemoteVideoPlayer", 1), __decorateClass([reportRtcSdkApi()], BLWRTCEngine.prototype, "destroy", 1);
var logger = new Logger$1("VERTC", 0);
iDB.storeKey = "".concat(Date.now(), "-").concat(sdkCache.getDeviceId()), setGlobalStats({ rtc_sdk_version: Config2.VERSION, device_id: sdkCache.getDeviceId(), log_cache_key: iDB.storeKey }), setReportUrl(Config2.LOG_SERVER_URL);
var ENGINE_GUID = 1;
var createEngine = (e, t) => {
  logger.info("createEngine", "Invoke VERTC.createEngine"), checkString(e, "appId");
  const i = (ENGINE_GUID++).toString();
  return createMonitor(i, { rtc_app_id: e, auto_play_policy: null == t ? void 0 : t.autoPlayPolicy }), new RTCEngine(e, i, t);
};
var createBLWEngine = (e, t) => {
  logger.print("createBLWEngine", "Invoke VERTC.createBLWEngine"), checkString(e, "appId");
  const i = (ENGINE_GUID++).toString();
  return createMonitor(i, { rtc_app_id: e, auto_play_policy: null == t ? void 0 : t.autoPlayPolicy }), new BLWRTCEngine(e, i, t);
};
var destroyEngine = (e) => {
  if (logger.info("destroyEngine", "Invoke VERTC.destroyEngine"), !(e instanceof RTCEngine)) throw new SDKError(ErrorCode.INVALID_ENGINE, "Invalid engine object");
  e.destroy(), destroyMonitor(e.monitor);
};
var enumerateDevices = async () => dd.enumerateDevices();
var enableDevices = async function() {
  let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { video: true, audio: true };
  const { video: t, audio: i } = e, r = { video: false, audio: false }, o = [];
  return t && o.push(dd.getPermissions({ video: true, force: true }).then((e2) => {
    r.video = e2.video, e2.video || (r.videoExceptionError = e2.reason);
  })), i && o.push(dd.getPermissions({ audio: true, force: true }).then((e2) => {
    r.audio = e2.audio, e2.audio || (r.audioExceptionError = e2.reason);
  })), await Promise.allSettled(o), r;
};
var enumerateAudioCaptureDevices = async () => dd.enumerateAudioCaptureDevices();
var enumerateVideoCaptureDevices = async () => dd.enumerateVideoCaptureDevices();
var enumerateAudioPlaybackDevices = async () => dd.enumerateAudioPlaybackDevices();
var getSdkVersion = () => Config2.VERSION;
var isSupported2 = () => isSupported();
var getSupportedCodecs2 = () => getSupportedCodecs();
var setLogConfig = (e) => {
  let { logLevel: t, LogfileSize: i } = e;
  t && (iDB.logLevel = t), i && (iDB.LogfileSize = i);
};
var downloadLog = (e) => {
  iDB.download(e);
};
function stringifyParams() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
  return JSON.stringify(t.map((e2) => e2 instanceof RTCEngine ? "[ENGINE]" : e2));
}
function reportVERTCApiCall(e, t) {
  return function() {
    reportGlobalApiCall(t, 0, stringifyParams(...arguments));
    const i = e(...arguments);
    return "function" == typeof (null == i ? void 0 : i.then) ? i.then((e2) => (reportGlobalCallback(t, 0, stringifyParams(e2)), e2)).catch((e2) => {
      throw reportGlobalCallback(t, e2.code, e2.message), e2;
    }) : (reportGlobalCallback(t, 0, stringifyParams(i)), i);
  };
}
var VERTC = class {
  constructor() {
    _defineProperty(this, "getSdkVersion", reportVERTCApiCall(getSdkVersion, "getSdkVersion")), _defineProperty(this, "createEngine", reportVERTCApiCall(createEngine, "createEngine")), _defineProperty(this, "createBLWEngine", reportVERTCApiCall(createBLWEngine, "createBLWEngine")), _defineProperty(this, "destroyEngine", reportVERTCApiCall(destroyEngine, "destroyEngine")), _defineProperty(this, "enumerateDevices", reportVERTCApiCall(enumerateDevices, "enumerateDevices")), _defineProperty(this, "enableDevices", reportVERTCApiCall(enableDevices, "enableDevices")), _defineProperty(this, "enumerateAudioCaptureDevices", reportVERTCApiCall(enumerateAudioCaptureDevices, "enumerateAudioCaptureDevices")), _defineProperty(this, "enumerateVideoCaptureDevices", reportVERTCApiCall(enumerateVideoCaptureDevices, "enumerateVideoCaptureDevices")), _defineProperty(this, "enumerateAudioPlaybackDevices", reportVERTCApiCall(enumerateAudioPlaybackDevices, "enumerateAudioPlaybackDevices")), _defineProperty(this, "getParameter", getParameter), _defineProperty(this, "setParameter", setParameter), _defineProperty(this, "isSupported", reportVERTCApiCall(isSupported2, "isSupported")), _defineProperty(this, "getSupportedCodecs", reportVERTCApiCall(getSupportedCodecs2, "getSupportedCodecs")), _defineProperty(this, "getElectronScreenSources", reportVERTCApiCall(getElectronScreenSources, "getElectronScreenSources")), _defineProperty(this, "events", EngineEventsTypes), _defineProperty(this, "ErrorCode", ErrorCode), _defineProperty(this, "platform", "VolcEngine"), _defineProperty(this, "commitInfo", "HEAD<42dc47c*>"), _defineProperty(this, "downloadLog", reportVERTCApiCall(downloadLog, "downloadLog")), _defineProperty(this, "setLogConfig", reportVERTCApiCall(setLogConfig, "setLogConfig"));
  }
};
var index = new VERTC();
export {
  AAC_PROFILE,
  AudioMixingDualMonoMode,
  AudioMixingType,
  AudioProfileType,
  AudioReportMode,
  AudioSelectionPriority,
  AudioSourceType,
  ChannelProfile,
  ConnectionState,
  EarMonitorPosition,
  FallbackOrRecoverReason,
  ForwardStreamError,
  ForwardStreamState,
  LocalMainReportMode,
  LogChannel,
  MediaType$1 as MediaType,
  MirrorMode,
  MirrorType,
  NetworkQuality,
  PublicInterpolationMode,
  PublicStreamType,
  PublishState,
  RTCAutoPlayPolicy,
  ReconnectReason,
  RemoteUserPriority,
  RoomMode,
  RoomProfileType,
  SUBTITLE_MODE,
  SimulcastStreamType,
  StreamIndex$1 as StreamIndex,
  StreamRemoveReason,
  SubscribeFallbackOption,
  SubscribeMode,
  SubscribeState,
  SubtitleEventType,
  TRANSCODING_VIDEO_CODEC,
  USER_ONLINE_STATUS,
  UserDisconnectionTag$1 as UserDisconnectionTag,
  UserOfflineReason,
  VideoCodecType,
  VideoRenderMode,
  VideoSimulcastMode,
  VideoSourceType,
  WTNPlayState,
  WTNPlayStateChangedReason,
  WTNPushState,
  WTNPushStateChangedReason,
  WTNRemoteAudioState,
  WTNRemoteAudioStateChangeReason,
  WTNRemoteVideoState,
  WTNRemoteVideoStateChangeReason,
  WTNStreamEventsTypes,
  index as default
};
//# sourceMappingURL=@volcengine_rtc.js.map
